/* eslint-disable */

/**
* Types generated by Unity.
* To generate, use the menu action: Typescript > Generate Types
*
* DO NOT EDIT!
*/

declare const enum HideFlags {
    None = 0,
    HideInHierarchy = 1,
    HideInInspector = 2,
    DontSaveInEditor = 4,
    NotEditable = 8,
    DontSaveInBuild = 16,
    DontUnloadUnusedAsset = 32,
    DontSave = 52,
    HideAndDontSave = 61,
}
declare const enum FindObjectsInactive {
    Exclude = 0,
    Include = 1,
}
declare const enum FindObjectsSortMode {
    None = 0,
    InstanceID = 1,
}
declare const enum Space {
    World = 0,
    Self = 1,
}
declare const enum SendMessageOptions {
    RequireReceiver = 0,
    DontRequireReceiver = 1,
}
declare const enum PrimitiveType {
    Sphere = 0,
    Capsule = 1,
    Cylinder = 2,
    Cube = 3,
    Plane = 4,
    Quad = 5,
}
declare const enum RigidbodyConstraints {
    None = 0,
    FreezePositionX = 2,
    FreezePositionY = 4,
    FreezePositionZ = 8,
    FreezePosition = 14,
    FreezeRotationX = 16,
    FreezeRotationY = 32,
    FreezeRotationZ = 64,
    FreezeRotation = 112,
    FreezeAll = 126,
}
declare const enum CollisionDetectionMode {
    Discrete = 0,
    Continuous = 1,
    ContinuousDynamic = 2,
    ContinuousSpeculative = 3,
}
declare const enum RigidbodyInterpolation {
    None = 0,
    Interpolate = 1,
    Extrapolate = 2,
}
declare const enum ForceMode {
    Force = 0,
    Impulse = 1,
    VelocityChange = 2,
    Acceleration = 5,
}
declare const enum QueryTriggerInteraction {
    UseGlobal = 0,
    Ignore = 1,
    Collide = 2,
}
declare const enum ArticulationJointType {
    FixedJoint = 0,
    PrismaticJoint = 1,
    RevoluteJoint = 2,
    SphericalJoint = 3,
}
declare const enum ArticulationDofLock {
    LockedMotion = 0,
    LimitedMotion = 1,
    FreeMotion = 2,
}
declare const enum ArticulationDriveType {
    Force = 0,
    Acceleration = 1,
    Target = 2,
    Velocity = 3,
}
declare const enum ArticulationDriveAxis {
    X = 0,
    Y = 1,
    Z = 2,
}
declare const enum GeometryType {
    Sphere = 0,
    Capsule = 2,
    Box = 3,
    ConvexMesh = 4,
    TriangleMesh = 5,
    Terrain = 6,
    Invalid = -1,
}
declare const enum PhysicMaterialCombine {
    Average = 0,
    Multiply = 1,
    Minimum = 2,
    Maximum = 3,
}
declare const enum SimulationMode {
    FixedUpdate = 0,
    Update = 1,
    Script = 2,
}
declare const enum SimulationStage {
    None = 0,
    PrepareSimulation = 1,
    RunSimulation = 2,
    PublishSimulationResults = 4,
    All = 7,
}
declare const enum SimulationOption {
    None = 0,
    SyncTransforms = 1,
    IgnoreEmptyScenes = 2,
    All = 3,
}
declare const enum MeshColliderCookingOptions {
    None = 0,
    InflateConvexMesh = 1,
    CookForFasterSimulation = 2,
    EnableMeshCleaning = 4,
    WeldColocatedVertices = 8,
    UseFastMidphase = 16,
}
declare const enum CompositeOperation {
    None = 0,
    Merge = 1,
    Intersect = 2,
    Difference = 3,
    Flip = 4,
}
declare const enum GeometryType {
    Outlines = 0,
    Polygons = 1,
}
declare const enum GenerationType {
    Synchronous = 0,
    Manual = 1,
}
declare const enum RigidbodyType2D {
    Dynamic = 0,
    Kinematic = 1,
    Static = 2,
}
declare const enum RigidbodyConstraints2D {
    None = 0,
    FreezePositionX = 1,
    FreezePositionY = 2,
    FreezePosition = 3,
    FreezeRotation = 4,
    FreezeAll = 7,
}
declare const enum RigidbodyInterpolation2D {
    None = 0,
    Interpolate = 1,
    Extrapolate = 2,
}
declare const enum RigidbodySleepMode2D {
    NeverSleep = 0,
    StartAwake = 1,
    StartAsleep = 2,
}
declare const enum CollisionDetectionMode2D {
    None = 0,
    Discrete = 0,
    Continuous = 1,
}
declare const enum ForceMode2D {
    Force = 0,
    Impulse = 1,
}
declare const enum PhysicsShapeType2D {
    Circle = 0,
    Capsule = 1,
    Polygon = 2,
    Edges = 3,
}
declare const enum ColliderErrorState2D {
    None = 0,
    NoShapes = 1,
    RemovedShapes = 2,
}
declare const enum IndexFormat {
    UInt16 = 0,
    UInt32 = 1,
}
declare const enum Target {
    Vertex = 1,
    Index = 2,
    CopySource = 4,
    CopyDestination = 8,
    Structured = 16,
    Raw = 32,
    Append = 64,
    Counter = 128,
    IndirectArguments = 256,
    Constant = 512,
}
declare const enum SkinWeights {
    None = 0,
    OneBone = 1,
    TwoBones = 2,
    FourBones = 4,
    Unlimited = 255,
}
declare const enum UsageFlags {
    None = 0,
    LockBufferForWrite = 1,
}
declare const enum BlendShapeBufferLayout {
    PerShape = 0,
    PerVertex = 1,
}
declare const enum MeshTopology {
    Triangles = 0,
    Quads = 2,
    Lines = 3,
    LineStrip = 4,
    Points = 5,
}
declare const enum VertexAttribute {
    Position = 0,
    Normal = 1,
    Tangent = 2,
    Color = 3,
    TexCoord0 = 4,
    TexCoord1 = 5,
    TexCoord2 = 6,
    TexCoord3 = 7,
    TexCoord4 = 8,
    TexCoord5 = 9,
    TexCoord6 = 10,
    TexCoord7 = 11,
    BlendWeight = 12,
    BlendIndices = 13,
}
declare const enum VertexAttributeFormat {
    Float32 = 0,
    Float16 = 1,
    UNorm8 = 2,
    SNorm8 = 3,
    UNorm16 = 4,
    SNorm16 = 5,
    UInt8 = 6,
    SInt8 = 7,
    UInt16 = 8,
    SInt16 = 9,
    UInt32 = 10,
    SInt32 = 11,
}
declare const enum MeshUpdateFlags {
    Default = 0,
    DontValidateIndices = 1,
    DontResetBoneBounds = 2,
    DontNotifyMeshUsers = 4,
    DontRecalculateBounds = 8,
}
declare const enum CapsuleDirection2D {
    Vertical = 0,
    Horizontal = 1,
}
declare const enum SimulationMode2D {
    FixedUpdate = 0,
    Update = 1,
    Script = 2,
}
declare const enum LogType {
    Error = 0,
    Assert = 1,
    Warning = 2,
    Log = 3,
    Exception = 4,
}
declare const enum LogOption {
    None = 0,
    NoStacktrace = 1,
}
declare const enum GraphicsFormat {
    None = 0,
    R8_SRGB = 1,
    R8G8_SRGB = 2,
    R8G8B8_SRGB = 3,
    R8G8B8A8_SRGB = 4,
    R8_UNorm = 5,
    R8G8_UNorm = 6,
    R8G8B8_UNorm = 7,
    R8G8B8A8_UNorm = 8,
    R8_SNorm = 9,
    R8G8_SNorm = 10,
    R8G8B8_SNorm = 11,
    R8G8B8A8_SNorm = 12,
    R8_UInt = 13,
    R8G8_UInt = 14,
    R8G8B8_UInt = 15,
    R8G8B8A8_UInt = 16,
    R8_SInt = 17,
    R8G8_SInt = 18,
    R8G8B8_SInt = 19,
    R8G8B8A8_SInt = 20,
    R16_UNorm = 21,
    R16G16_UNorm = 22,
    R16G16B16_UNorm = 23,
    R16G16B16A16_UNorm = 24,
    R16_SNorm = 25,
    R16G16_SNorm = 26,
    R16G16B16_SNorm = 27,
    R16G16B16A16_SNorm = 28,
    R16_UInt = 29,
    R16G16_UInt = 30,
    R16G16B16_UInt = 31,
    R16G16B16A16_UInt = 32,
    R16_SInt = 33,
    R16G16_SInt = 34,
    R16G16B16_SInt = 35,
    R16G16B16A16_SInt = 36,
    R32_UInt = 37,
    R32G32_UInt = 38,
    R32G32B32_UInt = 39,
    R32G32B32A32_UInt = 40,
    R32_SInt = 41,
    R32G32_SInt = 42,
    R32G32B32_SInt = 43,
    R32G32B32A32_SInt = 44,
    R16_SFloat = 45,
    R16G16_SFloat = 46,
    R16G16B16_SFloat = 47,
    R16G16B16A16_SFloat = 48,
    R32_SFloat = 49,
    R32G32_SFloat = 50,
    R32G32B32_SFloat = 51,
    R32G32B32A32_SFloat = 52,
    B8G8R8_SRGB = 56,
    B8G8R8A8_SRGB = 57,
    B8G8R8_UNorm = 58,
    B8G8R8A8_UNorm = 59,
    B8G8R8_SNorm = 60,
    B8G8R8A8_SNorm = 61,
    B8G8R8_UInt = 62,
    B8G8R8A8_UInt = 63,
    B8G8R8_SInt = 64,
    B8G8R8A8_SInt = 65,
    R4G4B4A4_UNormPack16 = 66,
    B4G4R4A4_UNormPack16 = 67,
    R5G6B5_UNormPack16 = 68,
    B5G6R5_UNormPack16 = 69,
    R5G5B5A1_UNormPack16 = 70,
    B5G5R5A1_UNormPack16 = 71,
    A1R5G5B5_UNormPack16 = 72,
    E5B9G9R9_UFloatPack32 = 73,
    B10G11R11_UFloatPack32 = 74,
    A2B10G10R10_UNormPack32 = 75,
    A2B10G10R10_UIntPack32 = 76,
    A2B10G10R10_SIntPack32 = 77,
    A2R10G10B10_UNormPack32 = 78,
    A2R10G10B10_UIntPack32 = 79,
    A2R10G10B10_SIntPack32 = 80,
    A2R10G10B10_XRSRGBPack32 = 81,
    A2R10G10B10_XRUNormPack32 = 82,
    R10G10B10_XRSRGBPack32 = 83,
    R10G10B10_XRUNormPack32 = 84,
    A10R10G10B10_XRSRGBPack32 = 85,
    A10R10G10B10_XRUNormPack32 = 86,
    D16_UNorm = 90,
    D24_UNorm = 91,
    D24_UNorm_S8_UInt = 92,
    D32_SFloat = 93,
    D32_SFloat_S8_UInt = 94,
    S8_UInt = 95,
    RGB_DXT1_SRGB = 96,
    RGBA_DXT1_SRGB = 96,
    RGB_DXT1_UNorm = 97,
    RGBA_DXT1_UNorm = 97,
    RGBA_DXT3_SRGB = 98,
    RGBA_DXT3_UNorm = 99,
    RGBA_DXT5_SRGB = 100,
    RGBA_DXT5_UNorm = 101,
    R_BC4_UNorm = 102,
    R_BC4_SNorm = 103,
    RG_BC5_UNorm = 104,
    RG_BC5_SNorm = 105,
    RGB_BC6H_UFloat = 106,
    RGB_BC6H_SFloat = 107,
    RGBA_BC7_SRGB = 108,
    RGBA_BC7_UNorm = 109,
    RGB_PVRTC_2Bpp_SRGB = 110,
    RGB_PVRTC_2Bpp_UNorm = 111,
    RGB_PVRTC_4Bpp_SRGB = 112,
    RGB_PVRTC_4Bpp_UNorm = 113,
    RGBA_PVRTC_2Bpp_SRGB = 114,
    RGBA_PVRTC_2Bpp_UNorm = 115,
    RGBA_PVRTC_4Bpp_SRGB = 116,
    RGBA_PVRTC_4Bpp_UNorm = 117,
    RGB_ETC_UNorm = 118,
    RGB_ETC2_SRGB = 119,
    RGB_ETC2_UNorm = 120,
    RGB_A1_ETC2_SRGB = 121,
    RGB_A1_ETC2_UNorm = 122,
    RGBA_ETC2_SRGB = 123,
    RGBA_ETC2_UNorm = 124,
    R_EAC_UNorm = 125,
    R_EAC_SNorm = 126,
    RG_EAC_UNorm = 127,
    RG_EAC_SNorm = 128,
    RGBA_ASTC4X4_SRGB = 129,
    RGBA_ASTC4X4_UNorm = 130,
    RGBA_ASTC5X5_SRGB = 131,
    RGBA_ASTC5X5_UNorm = 132,
    RGBA_ASTC6X6_SRGB = 133,
    RGBA_ASTC6X6_UNorm = 134,
    RGBA_ASTC8X8_SRGB = 135,
    RGBA_ASTC8X8_UNorm = 136,
    RGBA_ASTC10X10_SRGB = 137,
    RGBA_ASTC10X10_UNorm = 138,
    RGBA_ASTC12X12_SRGB = 139,
    RGBA_ASTC12X12_UNorm = 140,
    YUV2 = 141,
    DepthAuto = 142,
    ShadowAuto = 143,
    VideoAuto = 144,
    RGBA_ASTC4X4_UFloat = 145,
    RGBA_ASTC5X5_UFloat = 146,
    RGBA_ASTC6X6_UFloat = 147,
    RGBA_ASTC8X8_UFloat = 148,
    RGBA_ASTC10X10_UFloat = 149,
    RGBA_ASTC12X12_UFloat = 150,
    D16_UNorm_S8_UInt = 151,
}
declare const enum TextureDimension {
    None = 0,
    Any = 1,
    Tex2D = 2,
    Tex3D = 3,
    Cube = 4,
    Tex2DArray = 5,
    CubeArray = 6,
    Unknown = -1,
}
declare const enum TextureWrapMode {
    Repeat = 0,
    Clamp = 1,
    Mirror = 2,
    MirrorOnce = 3,
}
declare const enum FilterMode {
    Point = 0,
    Bilinear = 1,
    Trilinear = 2,
}
declare const enum GraphicsTextureDescriptorFlags {
    None = 0,
    RenderTarget = 1,
    RandomWriteTarget = 2,
}
declare const enum GraphicsTextureState {
    Constructed = 0,
    Initializing = 1,
    InitializedOnRenderThread = 2,
    DestroyQueued = 3,
    Destroyed = 4,
}
declare const enum AnisotropicFiltering {
    Disable = 0,
    Enable = 1,
    ForceEnable = 2,
}
declare const enum TextureFormat {
    Alpha8 = 1,
    ARGB4444 = 2,
    RGB24 = 3,
    RGBA32 = 4,
    ARGB32 = 5,
    RGB565 = 7,
    R16 = 9,
    DXT1 = 10,
    DXT5 = 12,
    RGBA4444 = 13,
    BGRA32 = 14,
    RHalf = 15,
    RGHalf = 16,
    RGBAHalf = 17,
    RFloat = 18,
    RGFloat = 19,
    RGBAFloat = 20,
    YUY2 = 21,
    RGB9e5Float = 22,
    BC6H = 24,
    BC7 = 25,
    BC4 = 26,
    BC5 = 27,
    DXT1Crunched = 28,
    DXT5Crunched = 29,
    PVRTC_RGB2 = 30,
    PVRTC_RGBA2 = 31,
    PVRTC_RGB4 = 32,
    PVRTC_RGBA4 = 33,
    ETC_RGB4 = 34,
    EAC_R = 41,
    EAC_R_SIGNED = 42,
    EAC_RG = 43,
    EAC_RG_SIGNED = 44,
    ETC2_RGB = 45,
    ETC2_RGBA1 = 46,
    ETC2_RGBA8 = 47,
    ASTC_4x4 = 48,
    ASTC_5x5 = 49,
    ASTC_6x6 = 50,
    ASTC_8x8 = 51,
    ASTC_10x10 = 52,
    ASTC_12x12 = 53,
    RG16 = 62,
    R8 = 63,
    ETC_RGB4Crunched = 64,
    ETC2_RGBA8Crunched = 65,
    ASTC_HDR_4x4 = 66,
    ASTC_HDR_5x5 = 67,
    ASTC_HDR_6x6 = 68,
    ASTC_HDR_8x8 = 69,
    ASTC_HDR_10x10 = 70,
    ASTC_HDR_12x12 = 71,
    RG32 = 72,
    RGB48 = 73,
    RGBA64 = 74,
    R8_SIGNED = 75,
    RG16_SIGNED = 76,
    RGB24_SIGNED = 77,
    RGBA32_SIGNED = 78,
    R16_SIGNED = 79,
    RG32_SIGNED = 80,
    RGB48_SIGNED = 81,
    RGBA64_SIGNED = 82,
    ETC_RGBA8_3DS = -61,
    ETC_RGB4_3DS = -60,
    ASTC_RGBA_12x12 = -59,
    ASTC_RGBA_10x10 = -58,
    ASTC_RGBA_8x8 = -57,
    ASTC_RGBA_6x6 = -56,
    ASTC_RGBA_5x5 = -55,
    ASTC_RGBA_4x4 = -54,
    ASTC_RGB_12x12 = -53,
    ASTC_RGB_10x10 = -52,
    ASTC_RGB_8x8 = -51,
    ASTC_RGB_6x6 = -50,
    ASTC_RGB_5x5 = -49,
    ASTC_RGB_4x4 = -48,
}
declare const enum SpritePackingMode {
    Tight = 0,
    Rectangle = 1,
}
declare const enum SpritePackingRotation {
    None = 0,
    FlipHorizontal = 1,
    FlipVertical = 2,
    Rotate180 = 3,
    Any = 15,
}
declare const enum SpriteMeshType {
    FullRect = 0,
    Tight = 1,
}
declare const enum DefaultFormat {
    LDR = 0,
    HDR = 1,
    DepthStencil = 2,
    Shadow = 3,
    Video = 4,
}
declare const enum TextureCreationFlags {
    None = 0,
    MipChain = 1,
    DontInitializePixels = 4,
    Crunch = 64,
    DontUploadUponCreate = 1024,
    IgnoreMipmapLimit = 2048,
}
declare const enum ConditionOverrideType {
    AddMissing = 1,
    UseManager = 2,
    IgnoreManager = 3,
}
declare const enum ObserverConditionType {
    Normal = 1,
    Timed = 2,
}
declare const enum Channel {
    Reliable = 0,
    Unreliable = 1,
}
declare const enum AutoPackType {
    Unpacked = 0,
    Packed = 1,
    PackedLess = 2,
}
declare const enum RotationOrder {
    XYZ = 0,
    XZY = 1,
    YXZ = 2,
    YZX = 3,
    ZXY = 4,
    Default = 4,
    ZYX = 5,
}
declare const enum RemoteTimeoutType {
    Disabled = 0,
    Release = 1,
    Development = 2,
}
declare const enum HostVisibilityUpdateTypes {
    Manager = 1,
    Spawned = 2,
}
declare const enum LocalConnectionState {
    Stopped = 0,
    Starting = 1,
    Started = 2,
    Stopping = 3,
}
declare const enum RemoteConnectionState {
    Stopped = 0,
    Started = 2,
}
declare const enum IPAddressType {
    IPv4 = 0,
    IPv6 = 1,
}
declare const enum OldTickOption {
    Discard = 0,
    SetLastRemoteTick = 1,
    SetRemoteTick = 2,
}
declare const enum PhysicsMode {
    Unity = 0,
    TimeManager = 1,
    Disabled = 2,
}
declare const enum TickType {
    Tick = 0,
    LocalTick = 1,
    LastPacketTick = 2,
}
declare const enum TickRounding {
    RoundUp = 0,
    RoundDown = 1,
    RoundNearest = 2,
}
declare const enum LoadSceneMode {
    Single = 0,
    Additive = 1,
}
declare const enum LocalPhysicsMode {
    None = 0,
    Physics2D = 1,
    Physics3D = 2,
}
declare const enum SceneScopeType {
    Global = 0,
    Connections = 1,
}
declare const enum ReplaceOption {
    All = 0,
    OnlineOnly = 1,
    None = 2,
}
declare const enum ServerUnloadMode {
    UnloadUnused = 0,
    KeepUnused = 1,
}
declare const enum RollbackPhysicsType {
    Physics = 1,
    Physics2D = 2,
}
declare const enum LoggingType {
    Off = 0,
    Error = 1,
    Warning = 2,
    Common = 3,
}
declare const enum DataSource {
    Unset = 0,
    Server = 1,
    Client = 2,
}
declare const enum DataOrderType {
    Default = 0,
    Last = 1,
}
declare const enum TransformPropertiesFlag {
    Unset = 0,
    Position = 1,
    Rotation = 2,
    LocalScale = 4,
    Everything = 255,
}
declare const enum AdaptiveInterpolationType {
    Off = 0,
    VeryLow = 1,
    Low = 2,
    Medium = 3,
    High = 4,
    VeryHigh = 5,
}
declare const enum RigidbodyType {
    Rigidbody = 0,
    Rigidbody2D = 1,
}
declare const enum DespawnType {
    Destroy = 0,
    Pool = 1,
}
declare const enum KickReason {
    Unset = 0,
    ExploitAttempt = 1,
    MalformedData = 2,
    ExploitExcessiveData = 3,
    ExcessiveData = 4,
    UnexpectedProblem = 5,
    UnusualActivity = 6,
}
declare const enum RenderingPath {
    VertexLit = 0,
    Forward = 1,
    DeferredLighting = 2,
    DeferredShading = 3,
    UsePlayerSettings = -1,
}
declare const enum OpaqueSortMode {
    Default = 0,
    FrontToBack = 1,
    NoDistanceSort = 2,
}
declare const enum TransparencySortMode {
    Default = 0,
    Perspective = 1,
    Orthographic = 2,
    CustomAxis = 3,
}
declare const enum CameraType {
    Game = 1,
    SceneView = 2,
    Preview = 4,
    VR = 8,
    Reflection = 16,
}
declare const enum CameraClearFlags {
    Skybox = 1,
    Color = 2,
    SolidColor = 2,
    Depth = 3,
    Nothing = 4,
}
declare const enum DepthTextureMode {
    None = 0,
    Depth = 1,
    DepthNormals = 2,
    MotionVectors = 4,
}
declare const enum GateFitMode {
    None = 0,
    Vertical = 1,
    Horizontal = 2,
    Fill = 3,
    Overscan = 4,
}
declare const enum VRTextureUsage {
    None = 0,
    OneEye = 1,
    TwoEyes = 2,
    DeviceSpecific = 3,
}
declare const enum RenderTextureMemoryless {
    None = 0,
    Color = 1,
    Depth = 2,
    MSAA = 4,
}
declare const enum RenderTextureFormat {
    ARGB32 = 0,
    Depth = 1,
    ARGBHalf = 2,
    Shadowmap = 3,
    RGB565 = 4,
    ARGB4444 = 5,
    ARGB1555 = 6,
    Default = 7,
    ARGB2101010 = 8,
    DefaultHDR = 9,
    ARGB64 = 10,
    ARGBFloat = 11,
    RGFloat = 12,
    RGHalf = 13,
    RFloat = 14,
    RHalf = 15,
    R8 = 16,
    ARGBInt = 17,
    RGInt = 18,
    RInt = 19,
    BGRA32 = 20,
    RGB111110Float = 22,
    RG32 = 23,
    RGBAUShort = 24,
    RG16 = 25,
    BGRA10101010_XR = 26,
    BGR101010_XR = 27,
    R16 = 28,
}
declare const enum ShadowSamplingMode {
    CompareDepths = 0,
    RawDepth = 1,
    None = 2,
}
declare const enum RenderTextureCreationFlags {
    MipMap = 1,
    AutoGenerateMips = 2,
    SRGB = 4,
    EyeTexture = 8,
    EnableRandomWrite = 16,
    CreatedFromScript = 32,
    AllowVerticalFlip = 128,
    NoResolvedColorSurface = 256,
    DynamicallyScalable = 1024,
    BindMS = 2048,
    DynamicallyScalableExplicit = 65536,
}
declare const enum MonoOrStereoscopicEye {
    Left = 0,
    Right = 1,
    Mono = 2,
}
declare const enum RenderTextureReadWrite {
    Default = 0,
    Linear = 1,
    sRGB = 2,
}
declare const enum StereoTargetEyeMask {
    None = 0,
    Left = 1,
    Right = 2,
    Both = 3,
}
declare const enum SceneViewFilterMode {
    Off = 0,
    ShowFiltered = 1,
}
declare const enum CameraEvent {
    BeforeDepthTexture = 0,
    AfterDepthTexture = 1,
    BeforeDepthNormalsTexture = 2,
    AfterDepthNormalsTexture = 3,
    BeforeGBuffer = 4,
    AfterGBuffer = 5,
    BeforeLighting = 6,
    AfterLighting = 7,
    BeforeFinalPass = 8,
    AfterFinalPass = 9,
    BeforeForwardOpaque = 10,
    AfterForwardOpaque = 11,
    BeforeImageEffectsOpaque = 12,
    AfterImageEffectsOpaque = 13,
    BeforeSkybox = 14,
    AfterSkybox = 15,
    BeforeForwardAlpha = 16,
    AfterForwardAlpha = 17,
    BeforeImageEffects = 18,
    AfterImageEffects = 19,
    AfterEverything = 20,
    BeforeReflections = 21,
    AfterReflections = 22,
    BeforeHaloAndLensFlares = 23,
    AfterHaloAndLensFlares = 24,
}
declare const enum RenderBufferLoadAction {
    Load = 0,
    Clear = 1,
    DontCare = 2,
}
declare const enum RenderBufferStoreAction {
    Store = 0,
    Resolve = 1,
    StoreAndResolve = 2,
    DontCare = 3,
}
declare const enum SubPassFlags {
    None = 0,
    ReadOnlyDepth = 2,
    ReadOnlyStencil = 4,
    ReadOnlyDepthStencil = 6,
}
declare const enum ShaderKeywordType {
    None = 0,
    BuiltinDefault = 2,
    BuiltinExtra = 6,
    BuiltinAutoStripped = 10,
    UserDefined = 16,
    Plugin = 32,
}
declare const enum ShaderPropertyFlags {
    None = 0,
    HideInInspector = 1,
    PerRendererData = 2,
    NoScaleOffset = 4,
    Normal = 8,
    HDR = 16,
    Gamma = 32,
    NonModifiableTextureData = 64,
    MainTexture = 128,
    MainColor = 256,
}
declare const enum ShaderPropertyType {
    Color = 0,
    Vector = 1,
    Float = 2,
    Range = 3,
    Texture = 4,
    Int = 5,
}
declare const enum ShaderHardwareTier {
    Tier1 = 0,
    Tier2 = 1,
    Tier3 = 2,
}
declare const enum ShadowCastingMode {
    Off = 0,
    On = 1,
    TwoSided = 2,
    ShadowsOnly = 3,
}
declare const enum MotionVectorGenerationMode {
    Camera = 0,
    Object = 1,
    ForceNoMotion = 2,
}
declare const enum LightProbeUsage {
    Off = 0,
    BlendProbes = 1,
    UseProxyVolume = 2,
    CustomProvided = 4,
}
declare const enum ReflectionProbeUsage {
    Off = 0,
    BlendProbes = 1,
    BlendProbesAndSkybox = 2,
    Simple = 3,
}
declare const enum RayTracingMode {
    Off = 0,
    Static = 1,
    DynamicTransform = 2,
    DynamicGeometry = 3,
}
declare const enum RayTracingAccelerationStructureBuildFlags {
    None = 0,
    PreferFastTrace = 1,
    PreferFastBuild = 2,
    MinimizeMemory = 4,
}
declare const enum ReflectionProbeType {
    Cube = 0,
    Card = 1,
}
declare const enum ReflectionProbeClearFlags {
    Skybox = 1,
    SolidColor = 2,
}
declare const enum ReflectionProbeMode {
    Baked = 0,
    Realtime = 1,
    Custom = 2,
}
declare const enum ReflectionProbeRefreshMode {
    OnAwake = 0,
    EveryFrame = 1,
    ViaScripting = 2,
}
declare const enum ReflectionProbeTimeSlicingMode {
    AllFacesAtOnce = 0,
    IndividualFaces = 1,
    NoTimeSlicing = 2,
}
declare const enum RenderTextureSubElement {
    Color = 0,
    Depth = 1,
    Stencil = 2,
    Default = 3,
}
declare const enum TexGenMode {
    None = 0,
    SphereMap = 1,
    Object = 2,
    EyeLinear = 3,
    CubeReflect = 4,
    CubeNormal = 5,
}
declare const enum MaterialGlobalIlluminationFlags {
    None = 0,
    RealtimeEmissive = 1,
    BakedEmissive = 2,
    AnyEmissive = 3,
    EmissiveIsBlack = 4,
}
declare const enum MaterialPropertyType {
    Float = 0,
    Int = 1,
    Vector = 2,
    Matrix = 3,
    Texture = 4,
    ConstantBuffer = 5,
    ComputeBuffer = 6,
}
declare const enum RTClearFlags {
    None = 0,
    Color = 1,
    Depth = 2,
    ColorDepth = 3,
    Stencil = 4,
    ColorStencil = 5,
    DepthStencil = 6,
    All = 7,
}
declare const enum SynchronisationStage {
    VertexProcessing = 0,
    PixelProcessing = 1,
}
declare const enum GraphicsFenceType {
    AsyncQueueSynchronisation = 0,
    CPUSynchronisation = 1,
}
declare const enum SynchronisationStageFlags {
    VertexProcessing = 1,
    PixelProcessing = 2,
    ComputeProcessing = 4,
    AllGPUOperations = 7,
}
declare const enum CustomMarkerCallbackFlags {
    CustomMarkerCallbackDefault = 0,
    CustomMarkerCallbackForceInvalidateStateTracking = 4,
}
declare const enum CameraLateLatchMatrixType {
    View = 0,
    InverseView = 1,
    ViewProjection = 2,
    InverseViewProjection = 3,
}
declare const enum CommandBufferExecutionFlags {
    None = 0,
    AsyncCompute = 2,
}
declare const enum FoveatedRenderingMode {
    Disabled = 0,
    Enabled = 1,
}
declare const enum CubemapFace {
    PositiveX = 0,
    NegativeX = 1,
    PositiveY = 2,
    NegativeY = 3,
    PositiveZ = 4,
    NegativeZ = 5,
    Unknown = -1,
}
declare const enum RenderTargetFlags {
    None = 0,
    ReadOnlyDepth = 1,
    ReadOnlyStencil = 2,
    ReadOnlyDepthStencil = 3,
}
declare const enum SinglePassStereoMode {
    None = 0,
    SideBySide = 1,
    Instancing = 2,
    Multiview = 3,
}
declare const enum ComputeQueueType {
    Default = 0,
    Background = 1,
    Urgent = 2,
}
declare const enum StereoscopicEye {
    Left = 0,
    Right = 1,
}
declare const enum RenderRequestMode {
    None = 0,
    ObjectId = 1,
    Depth = 2,
    VertexNormal = 3,
    WorldPosition = 4,
    EntityId = 5,
    BaseColor = 6,
    SpecularColor = 7,
    Metallic = 8,
    Emission = 9,
    Normal = 10,
    Smoothness = 11,
    Occlusion = 12,
    DiffuseColor = 13,
}
declare const enum RenderRequestOutputSpace {
    UV0 = 0,
    UV1 = 1,
    UV2 = 2,
    UV3 = 3,
    UV4 = 4,
    UV5 = 5,
    UV6 = 6,
    UV7 = 7,
    UV8 = 8,
    ScreenSpace = -1,
}
declare const enum IMECompositionMode {
    Auto = 0,
    On = 1,
    Off = 2,
}
declare const enum DeviceOrientation {
    Unknown = 0,
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeLeft = 3,
    LandscapeRight = 4,
    FaceUp = 5,
    FaceDown = 6,
}
declare const enum LocationServiceStatus {
    Stopped = 0,
    Initializing = 1,
    Running = 2,
    Failed = 3,
}
declare const enum TouchPhase {
    Began = 0,
    Moved = 1,
    Stationary = 2,
    Ended = 3,
    Canceled = 4,
}
declare const enum TouchType {
    Direct = 0,
    Indirect = 1,
    Stylus = 2,
}
declare const enum KeyCode {
    None = 0,
    Backspace = 8,
    Tab = 9,
    Clear = 12,
    Return = 13,
    Pause = 19,
    Escape = 27,
    Space = 32,
    Exclaim = 33,
    DoubleQuote = 34,
    Hash = 35,
    Dollar = 36,
    Percent = 37,
    Ampersand = 38,
    Quote = 39,
    LeftParen = 40,
    RightParen = 41,
    Asterisk = 42,
    Plus = 43,
    Comma = 44,
    Minus = 45,
    Period = 46,
    Slash = 47,
    Alpha0 = 48,
    Alpha1 = 49,
    Alpha2 = 50,
    Alpha3 = 51,
    Alpha4 = 52,
    Alpha5 = 53,
    Alpha6 = 54,
    Alpha7 = 55,
    Alpha8 = 56,
    Alpha9 = 57,
    Colon = 58,
    Semicolon = 59,
    Less = 60,
    Equals = 61,
    Greater = 62,
    Question = 63,
    At = 64,
    LeftBracket = 91,
    Backslash = 92,
    RightBracket = 93,
    Caret = 94,
    Underscore = 95,
    BackQuote = 96,
    A = 97,
    B = 98,
    C = 99,
    D = 100,
    E = 101,
    F = 102,
    G = 103,
    H = 104,
    I = 105,
    J = 106,
    K = 107,
    L = 108,
    M = 109,
    N = 110,
    O = 111,
    P = 112,
    Q = 113,
    R = 114,
    S = 115,
    T = 116,
    U = 117,
    V = 118,
    W = 119,
    X = 120,
    Y = 121,
    Z = 122,
    LeftCurlyBracket = 123,
    Pipe = 124,
    RightCurlyBracket = 125,
    Tilde = 126,
    Delete = 127,
    Keypad0 = 256,
    Keypad1 = 257,
    Keypad2 = 258,
    Keypad3 = 259,
    Keypad4 = 260,
    Keypad5 = 261,
    Keypad6 = 262,
    Keypad7 = 263,
    Keypad8 = 264,
    Keypad9 = 265,
    KeypadPeriod = 266,
    KeypadDivide = 267,
    KeypadMultiply = 268,
    KeypadMinus = 269,
    KeypadPlus = 270,
    KeypadEnter = 271,
    KeypadEquals = 272,
    UpArrow = 273,
    DownArrow = 274,
    RightArrow = 275,
    LeftArrow = 276,
    Insert = 277,
    Home = 278,
    End = 279,
    PageUp = 280,
    PageDown = 281,
    F1 = 282,
    F2 = 283,
    F3 = 284,
    F4 = 285,
    F5 = 286,
    F6 = 287,
    F7 = 288,
    F8 = 289,
    F9 = 290,
    F10 = 291,
    F11 = 292,
    F12 = 293,
    F13 = 294,
    F14 = 295,
    F15 = 296,
    Numlock = 300,
    CapsLock = 301,
    ScrollLock = 302,
    RightShift = 303,
    LeftShift = 304,
    RightControl = 305,
    LeftControl = 306,
    RightAlt = 307,
    LeftAlt = 308,
    RightMeta = 309,
    RightCommand = 309,
    RightApple = 309,
    LeftMeta = 310,
    LeftCommand = 310,
    LeftApple = 310,
    LeftWindows = 311,
    RightWindows = 312,
    AltGr = 313,
    Help = 315,
    Print = 316,
    SysReq = 317,
    Break = 318,
    Menu = 319,
    WheelUp = 321,
    WheelDown = 322,
    Mouse0 = 323,
    Mouse1 = 324,
    Mouse2 = 325,
    Mouse3 = 326,
    Mouse4 = 327,
    Mouse5 = 328,
    Mouse6 = 329,
    JoystickButton0 = 330,
    JoystickButton1 = 331,
    JoystickButton2 = 332,
    JoystickButton3 = 333,
    JoystickButton4 = 334,
    JoystickButton5 = 335,
    JoystickButton6 = 336,
    JoystickButton7 = 337,
    JoystickButton8 = 338,
    JoystickButton9 = 339,
    JoystickButton10 = 340,
    JoystickButton11 = 341,
    JoystickButton12 = 342,
    JoystickButton13 = 343,
    JoystickButton14 = 344,
    JoystickButton15 = 345,
    JoystickButton16 = 346,
    JoystickButton17 = 347,
    JoystickButton18 = 348,
    JoystickButton19 = 349,
    Joystick1Button0 = 350,
    Joystick1Button1 = 351,
    Joystick1Button2 = 352,
    Joystick1Button3 = 353,
    Joystick1Button4 = 354,
    Joystick1Button5 = 355,
    Joystick1Button6 = 356,
    Joystick1Button7 = 357,
    Joystick1Button8 = 358,
    Joystick1Button9 = 359,
    Joystick1Button10 = 360,
    Joystick1Button11 = 361,
    Joystick1Button12 = 362,
    Joystick1Button13 = 363,
    Joystick1Button14 = 364,
    Joystick1Button15 = 365,
    Joystick1Button16 = 366,
    Joystick1Button17 = 367,
    Joystick1Button18 = 368,
    Joystick1Button19 = 369,
    Joystick2Button0 = 370,
    Joystick2Button1 = 371,
    Joystick2Button2 = 372,
    Joystick2Button3 = 373,
    Joystick2Button4 = 374,
    Joystick2Button5 = 375,
    Joystick2Button6 = 376,
    Joystick2Button7 = 377,
    Joystick2Button8 = 378,
    Joystick2Button9 = 379,
    Joystick2Button10 = 380,
    Joystick2Button11 = 381,
    Joystick2Button12 = 382,
    Joystick2Button13 = 383,
    Joystick2Button14 = 384,
    Joystick2Button15 = 385,
    Joystick2Button16 = 386,
    Joystick2Button17 = 387,
    Joystick2Button18 = 388,
    Joystick2Button19 = 389,
    Joystick3Button0 = 390,
    Joystick3Button1 = 391,
    Joystick3Button2 = 392,
    Joystick3Button3 = 393,
    Joystick3Button4 = 394,
    Joystick3Button5 = 395,
    Joystick3Button6 = 396,
    Joystick3Button7 = 397,
    Joystick3Button8 = 398,
    Joystick3Button9 = 399,
    Joystick3Button10 = 400,
    Joystick3Button11 = 401,
    Joystick3Button12 = 402,
    Joystick3Button13 = 403,
    Joystick3Button14 = 404,
    Joystick3Button15 = 405,
    Joystick3Button16 = 406,
    Joystick3Button17 = 407,
    Joystick3Button18 = 408,
    Joystick3Button19 = 409,
    Joystick4Button0 = 410,
    Joystick4Button1 = 411,
    Joystick4Button2 = 412,
    Joystick4Button3 = 413,
    Joystick4Button4 = 414,
    Joystick4Button5 = 415,
    Joystick4Button6 = 416,
    Joystick4Button7 = 417,
    Joystick4Button8 = 418,
    Joystick4Button9 = 419,
    Joystick4Button10 = 420,
    Joystick4Button11 = 421,
    Joystick4Button12 = 422,
    Joystick4Button13 = 423,
    Joystick4Button14 = 424,
    Joystick4Button15 = 425,
    Joystick4Button16 = 426,
    Joystick4Button17 = 427,
    Joystick4Button18 = 428,
    Joystick4Button19 = 429,
    Joystick5Button0 = 430,
    Joystick5Button1 = 431,
    Joystick5Button2 = 432,
    Joystick5Button3 = 433,
    Joystick5Button4 = 434,
    Joystick5Button5 = 435,
    Joystick5Button6 = 436,
    Joystick5Button7 = 437,
    Joystick5Button8 = 438,
    Joystick5Button9 = 439,
    Joystick5Button10 = 440,
    Joystick5Button11 = 441,
    Joystick5Button12 = 442,
    Joystick5Button13 = 443,
    Joystick5Button14 = 444,
    Joystick5Button15 = 445,
    Joystick5Button16 = 446,
    Joystick5Button17 = 447,
    Joystick5Button18 = 448,
    Joystick5Button19 = 449,
    Joystick6Button0 = 450,
    Joystick6Button1 = 451,
    Joystick6Button2 = 452,
    Joystick6Button3 = 453,
    Joystick6Button4 = 454,
    Joystick6Button5 = 455,
    Joystick6Button6 = 456,
    Joystick6Button7 = 457,
    Joystick6Button8 = 458,
    Joystick6Button9 = 459,
    Joystick6Button10 = 460,
    Joystick6Button11 = 461,
    Joystick6Button12 = 462,
    Joystick6Button13 = 463,
    Joystick6Button14 = 464,
    Joystick6Button15 = 465,
    Joystick6Button16 = 466,
    Joystick6Button17 = 467,
    Joystick6Button18 = 468,
    Joystick6Button19 = 469,
    Joystick7Button0 = 470,
    Joystick7Button1 = 471,
    Joystick7Button2 = 472,
    Joystick7Button3 = 473,
    Joystick7Button4 = 474,
    Joystick7Button5 = 475,
    Joystick7Button6 = 476,
    Joystick7Button7 = 477,
    Joystick7Button8 = 478,
    Joystick7Button9 = 479,
    Joystick7Button10 = 480,
    Joystick7Button11 = 481,
    Joystick7Button12 = 482,
    Joystick7Button13 = 483,
    Joystick7Button14 = 484,
    Joystick7Button15 = 485,
    Joystick7Button16 = 486,
    Joystick7Button17 = 487,
    Joystick7Button18 = 488,
    Joystick7Button19 = 489,
    Joystick8Button0 = 490,
    Joystick8Button1 = 491,
    Joystick8Button2 = 492,
    Joystick8Button3 = 493,
    Joystick8Button4 = 494,
    Joystick8Button5 = 495,
    Joystick8Button6 = 496,
    Joystick8Button7 = 497,
    Joystick8Button8 = 498,
    Joystick8Button9 = 499,
    Joystick8Button10 = 500,
    Joystick8Button11 = 501,
    Joystick8Button12 = 502,
    Joystick8Button13 = 503,
    Joystick8Button14 = 504,
    Joystick8Button15 = 505,
    Joystick8Button16 = 506,
    Joystick8Button17 = 507,
    Joystick8Button18 = 508,
    Joystick8Button19 = 509,
}
declare const enum PenStatus {
    None = 0,
    Contact = 1,
    Barrel = 2,
    Inverted = 4,
    Eraser = 8,
}
declare const enum PenEventType {
    NoContact = 0,
    PenDown = 1,
    PenUp = 2,
}
declare const enum InputButton {
    Left = 0,
    Right = 1,
    Middle = 2,
}
declare const enum MoveDirection {
    Left = 0,
    Up = 1,
    Right = 2,
    Down = 3,
    None = 4,
}
declare const enum Mode {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
    Automatic = 3,
    Explicit = 4,
}
declare const enum Transition {
    None = 0,
    ColorTint = 1,
    SpriteSwap = 2,
    Animation = 3,
}
declare const enum CanvasUpdate {
    Prelayout = 0,
    Layout = 1,
    PostLayout = 2,
    PreRender = 3,
    LatePreRender = 4,
    MaxUpdateValue = 5,
}
declare const enum Edge {
    Left = 0,
    Right = 1,
    Top = 2,
    Bottom = 3,
}
declare const enum Axis {
    Horizontal = 0,
    Vertical = 1,
}
declare const enum RenderMode {
    ScreenSpaceOverlay = 0,
    ScreenSpaceCamera = 1,
    WorldSpace = 2,
}
declare const enum AdditionalCanvasShaderChannels {
    None = 0,
    TexCoord1 = 1,
    TexCoord2 = 2,
    TexCoord3 = 4,
    Normal = 8,
    Tangent = 16,
}
declare const enum StandaloneRenderResize {
    Enabled = 0,
    Disabled = 1,
}
declare const enum Type {
    Simple = 0,
    Sliced = 1,
    Tiled = 2,
    Filled = 3,
}
declare const enum FillMethod {
    Horizontal = 0,
    Vertical = 1,
    Radial90 = 2,
    Radial180 = 3,
    Radial360 = 4,
}
declare const enum AnimatorUpdateMode {
    Normal = 0,
    Fixed = 1,
    AnimatePhysics = 1,
    UnscaledTime = 2,
}
declare const enum AnimatorControllerParameterType {
    Float = 1,
    Int = 3,
    Bool = 4,
    Trigger = 9,
}
declare const enum AnimatorCullingMode {
    AlwaysAnimate = 0,
    CullUpdateTransforms = 1,
    BasedOnRenderers = 1,
    CullCompletely = 2,
}
declare const enum AnimatorRecorderMode {
    Offline = 0,
    Playback = 1,
    Record = 2,
}
declare const enum WrapMode {
    Default = 0,
    Once = 1,
    Clamp = 1,
    Loop = 2,
    PingPong = 4,
    ClampForever = 8,
}
declare const enum AnimationBlendMode {
    Blend = 0,
    Additive = 1,
}
declare const enum WeightedMode {
    None = 0,
    In = 1,
    Out = 2,
    Both = 3,
}
declare const enum DirectorUpdateMode {
    DSPClock = 0,
    GameTime = 1,
    UnscaledGameTime = 2,
    Manual = 3,
}
declare const enum DurationUnit {
    Fixed = 0,
    Normalized = 1,
}
declare const enum HumanBodyBones {
    Hips = 0,
    LeftUpperLeg = 1,
    RightUpperLeg = 2,
    LeftLowerLeg = 3,
    RightLowerLeg = 4,
    LeftFoot = 5,
    RightFoot = 6,
    Spine = 7,
    Chest = 8,
    Neck = 9,
    Head = 10,
    LeftShoulder = 11,
    RightShoulder = 12,
    LeftUpperArm = 13,
    RightUpperArm = 14,
    LeftLowerArm = 15,
    RightLowerArm = 16,
    LeftHand = 17,
    RightHand = 18,
    LeftToes = 19,
    RightToes = 20,
    LeftEye = 21,
    RightEye = 22,
    Jaw = 23,
    LeftThumbProximal = 24,
    LeftThumbIntermediate = 25,
    LeftThumbDistal = 26,
    LeftIndexProximal = 27,
    LeftIndexIntermediate = 28,
    LeftIndexDistal = 29,
    LeftMiddleProximal = 30,
    LeftMiddleIntermediate = 31,
    LeftMiddleDistal = 32,
    LeftRingProximal = 33,
    LeftRingIntermediate = 34,
    LeftRingDistal = 35,
    LeftLittleProximal = 36,
    LeftLittleIntermediate = 37,
    LeftLittleDistal = 38,
    RightThumbProximal = 39,
    RightThumbIntermediate = 40,
    RightThumbDistal = 41,
    RightIndexProximal = 42,
    RightIndexIntermediate = 43,
    RightIndexDistal = 44,
    RightMiddleProximal = 45,
    RightMiddleIntermediate = 46,
    RightMiddleDistal = 47,
    RightRingProximal = 48,
    RightRingIntermediate = 49,
    RightRingDistal = 50,
    RightLittleProximal = 51,
    RightLittleIntermediate = 52,
    RightLittleDistal = 53,
    UpperChest = 54,
    LastBone = 55,
}
declare const enum AvatarIKHint {
    LeftKnee = 0,
    RightKnee = 1,
    LeftElbow = 2,
    RightElbow = 3,
}
declare const enum AvatarIKGoal {
    LeftFoot = 0,
    RightFoot = 1,
    LeftHand = 2,
    RightHand = 3,
}
declare const enum AvatarTarget {
    Root = 0,
    Body = 1,
    LeftFoot = 2,
    RightFoot = 3,
    LeftHand = 4,
    RightHand = 5,
}
declare const enum UnityEventCallState {
    Off = 0,
    EditorAndRuntime = 1,
    RuntimeOnly = 2,
}
declare const enum ReceiveGI {
    Lightmaps = 1,
    LightProbes = 2,
}
declare const enum FontStyle {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    BoldAndItalic = 3,
}
declare const enum AtlasPopulationMode {
    Static = 0,
    Dynamic = 1,
    DynamicOS = 2,
}
declare const enum GlyphClassDefinitionType {
    Undefined = 0,
    Base = 1,
    Ligature = 2,
    Mark = 3,
    Component = 4,
}
declare const enum TextElementType {
    Character = 1,
    Sprite = 2,
}
declare const enum GlyphRenderMode {
    SMOOTH = 4117,
    RASTER = 4118,
    SMOOTH_HINTED = 4121,
    RASTER_HINTED = 4122,
    SDF = 4134,
    SDFAA = 4165,
    SDFAA_HINTED = 4169,
    SDF8 = 8230,
    SDF16 = 16422,
    SDF32 = 32806,
    COLOR = 69652,
    COLOR_HINTED = 69656,
}
declare const enum FontFeatureLookupFlags {
    None = 0,
    IgnoreLigatures = 4,
    IgnoreSpacingAdjustments = 256,
}
declare const enum ColorMode {
    Single = 0,
    HorizontalGradient = 1,
    VerticalGradient = 2,
    FourCornersGradient = 3,
}
declare const enum FontWeight {
    Thin = 100,
    ExtraLight = 200,
    Light = 300,
    Regular = 400,
    Medium = 500,
    SemiBold = 600,
    Bold = 700,
    Heavy = 800,
    Black = 900,
}
declare const enum FontStyles {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    LowerCase = 8,
    UpperCase = 16,
    SmallCaps = 32,
    Strikethrough = 64,
    Superscript = 128,
    Subscript = 256,
    Highlight = 512,
}
declare const enum HorizontalAlignmentOptions {
    Left = 1,
    Center = 2,
    Right = 4,
    Justified = 8,
    Flush = 16,
    Geometry = 32,
}
declare const enum VerticalAlignmentOptions {
    Top = 256,
    Middle = 512,
    Bottom = 1024,
    Baseline = 2048,
    Geometry = 4096,
    Capline = 8192,
}
declare const enum TextAlignmentOptions {
    TopLeft = 257,
    Top = 258,
    TopRight = 260,
    TopJustified = 264,
    TopFlush = 272,
    TopGeoAligned = 288,
    Left = 513,
    Center = 514,
    Right = 516,
    Justified = 520,
    Flush = 528,
    CenterGeoAligned = 544,
    BottomLeft = 1025,
    Bottom = 1026,
    BottomRight = 1028,
    BottomJustified = 1032,
    BottomFlush = 1040,
    BottomGeoAligned = 1056,
    BaselineLeft = 2049,
    Baseline = 2050,
    BaselineRight = 2052,
    BaselineJustified = 2056,
    BaselineFlush = 2064,
    BaselineGeoAligned = 2080,
    MidlineLeft = 4097,
    Midline = 4098,
    MidlineRight = 4100,
    MidlineJustified = 4104,
    MidlineFlush = 4112,
    MidlineGeoAligned = 4128,
    CaplineLeft = 8193,
    Capline = 8194,
    CaplineRight = 8196,
    CaplineJustified = 8200,
    CaplineFlush = 8208,
    CaplineGeoAligned = 8224,
    Converted = 65535,
}
declare const enum TextWrappingModes {
    NoWrap = 0,
    Normal = 1,
    PreserveWhitespace = 2,
    PreserveWhitespaceNoWrap = 3,
}
declare const enum TextOverflowModes {
    Overflow = 0,
    Ellipsis = 1,
    Masking = 2,
    Truncate = 3,
    ScrollRect = 4,
    Page = 5,
    Linked = 6,
}
declare const enum OTL_FeatureTag {
    kern = 1801810542,
    liga = 1818847073,
    mark = 1835102827,
    mkmk = 1835756907,
}
declare const enum TextureMappingOptions {
    Character = 0,
    Line = 1,
    Paragraph = 2,
    MatchAspect = 3,
}
declare const enum TextRenderFlags {
    DontRender = 0,
    Render = 255,
}
declare const enum VertexSortingOrder {
    Normal = 0,
    Reverse = 1,
}
declare const enum TMP_TextElementType {
    Character = 0,
    Sprite = 1,
}
declare const enum TMP_VertexDataUpdateFlags {
    None = 0,
    Vertices = 1,
    Uv0 = 2,
    Uv2 = 4,
    Uv4 = 8,
    Colors32 = 16,
    All = 255,
}
declare const enum AnimationUpdateMode {
    Normal = 0,
    Fixed = 1,
}
declare const enum AnimationCullingType {
    AlwaysAnimate = 0,
    BasedOnRenderers = 1,
    BasedOnClipBounds = 2,
    BasedOnUserBounds = 3,
}
declare const enum PlayMode {
    StopSameLayer = 0,
    StopAll = 4,
}
declare const enum QueueMode {
    CompleteOthers = 0,
    PlayNow = 2,
}
declare const enum AnimationPlayMode {
    Stop = 0,
    Queue = 1,
    Mix = 2,
}
declare const enum FogMode {
    Linear = 1,
    Exponential = 2,
    ExponentialSquared = 3,
}
declare const enum AmbientMode {
    Skybox = 0,
    Trilight = 1,
    Flat = 3,
    Custom = 4,
}
declare const enum LightType {
    Spot = 0,
    Directional = 1,
    Point = 2,
    Area = 3,
    Rectangle = 3,
    Disc = 4,
    Pyramid = 5,
    Box = 6,
    Tube = 7,
}
declare const enum LightShape {
    Cone = 0,
    Pyramid = 1,
    Box = 2,
}
declare const enum LightmapBakeType {
    Mixed = 1,
    Baked = 2,
    Realtime = 4,
}
declare const enum MixedLightingMode {
    IndirectOnly = 0,
    Subtractive = 1,
    Shadowmask = 2,
}
declare const enum LightShadowCasterMode {
    Default = 0,
    NonLightmappedOnly = 1,
    Everything = 2,
}
declare const enum LightShadows {
    None = 0,
    Hard = 1,
    Soft = 2,
}
declare const enum LightShadowResolution {
    Low = 0,
    Medium = 1,
    High = 2,
    VeryHigh = 3,
    FromQualitySettings = -1,
}
declare const enum LightRenderMode {
    Auto = 0,
    ForcePixel = 1,
    ForceVertex = 2,
}
declare const enum LightmappingMode {
    Mixed = 1,
    Baked = 2,
    Realtime = 4,
}
declare const enum LightEvent {
    BeforeShadowMap = 0,
    AfterShadowMap = 1,
    BeforeScreenspaceMask = 2,
    AfterScreenspaceMask = 3,
    BeforeShadowMapPass = 4,
    AfterShadowMapPass = 5,
}
declare const enum ShadowMapPass {
    PointlightPositiveX = 1,
    PointlightNegativeX = 2,
    PointlightPositiveY = 4,
    PointlightNegativeY = 8,
    PointlightPositiveZ = 16,
    PointlightNegativeZ = 32,
    Pointlight = 63,
    DirectionalCascade0 = 64,
    DirectionalCascade1 = 128,
    DirectionalCascade2 = 256,
    DirectionalCascade3 = 512,
    Directional = 960,
    Spotlight = 1024,
    All = 2047,
    AreaLight = 2048,
}
declare const enum DefaultReflectionMode {
    Skybox = 0,
    Custom = 1,
}
declare const enum UnloadSceneOptions {
    None = 0,
    UnloadAllEmbeddedSceneObjects = 1,
}
declare const enum SkinQuality {
    Auto = 0,
    Bone1 = 1,
    Bone2 = 2,
    Bone4 = 4,
}
declare const enum AccessorySlot {
    Root = 0,
    Head = 1,
    Hair = 2,
    Face = 3,
    Neck = 4,
    Torso = 5,
    RightHand = 6,
    LeftHand = 7,
    Waist = 8,
    Legs = 9,
    Feet = 10,
    Ears = 11,
    Nose = 12,
    TorsoOuter = 13,
    TorsoInner = 14,
    Backpack = 15,
    Hands = 16,
    HandsOuter = 17,
    LeftWrist = 18,
    RightWrist = 19,
    LegsOuter = 20,
    LegsInner = 21,
    FeetInner = 22,
    LeftFoot = 23,
    RightFoot = 24,
}
declare const enum VisibilityMode {
    THIRD_PERSON = 0,
    FIRST_PERSON = 1,
    BOTH = 2,
}
declare const enum AccessoryAddMode {
    ReplaceAll = 0,
    Replace = 1,
    Additive = 2,
    AddIfNone = 3,
}
declare const enum ParticleSystemSimulationSpace {
    Local = 0,
    World = 1,
    Custom = 2,
}
declare const enum ParticleSystemScalingMode {
    Hierarchy = 0,
    Local = 1,
    Shape = 2,
}
declare const enum ParticleSystemCurveMode {
    Constant = 0,
    Curve = 1,
    TwoCurves = 2,
    TwoConstants = 3,
}
declare const enum ParticleSystemGradientMode {
    Color = 0,
    Gradient = 1,
    TwoColors = 2,
    TwoGradients = 3,
    RandomColor = 4,
}
declare const enum GradientMode {
    Blend = 0,
    Fixed = 1,
    PerceptualBlend = 2,
}
declare const enum ColorSpace {
    Gamma = 0,
    Linear = 1,
    Uninitialized = -1,
}
declare const enum ParticleSystemGravitySource {
    Physics3D = 0,
    Physics2D = 1,
}
declare const enum ParticleSystemEmitterVelocityMode {
    Transform = 0,
    Rigidbody = 1,
    Custom = 2,
}
declare const enum ParticleSystemStopAction {
    None = 0,
    Disable = 1,
    Destroy = 2,
    Callback = 3,
}
declare const enum ParticleSystemRingBufferMode {
    Disabled = 0,
    PauseUntilReplaced = 1,
    LoopUntilReplaced = 2,
}
declare const enum ParticleSystemCullingMode {
    Automatic = 0,
    PauseAndCatchup = 1,
    Pause = 2,
    AlwaysSimulate = 3,
}
declare const enum ParticleSystemEmissionType {
    Time = 0,
    Distance = 1,
}
declare const enum ParticleSystemShapeType {
    Sphere = 0,
    SphereShell = 1,
    Hemisphere = 2,
    HemisphereShell = 3,
    Cone = 4,
    Box = 5,
    Mesh = 6,
    ConeShell = 7,
    ConeVolume = 8,
    ConeVolumeShell = 9,
    Circle = 10,
    CircleEdge = 11,
    SingleSidedEdge = 12,
    MeshRenderer = 13,
    SkinnedMeshRenderer = 14,
    BoxShell = 15,
    BoxEdge = 16,
    Donut = 17,
    Rectangle = 18,
    Sprite = 19,
    SpriteRenderer = 20,
}
declare const enum ParticleSystemShapeMultiModeValue {
    Random = 0,
    Loop = 1,
    PingPong = 2,
    BurstSpread = 3,
}
declare const enum ParticleSystemMeshShapeType {
    Vertex = 0,
    Edge = 1,
    Triangle = 2,
}
declare const enum SpriteDrawMode {
    Simple = 0,
    Sliced = 1,
    Tiled = 2,
}
declare const enum SpriteTileMode {
    Continuous = 0,
    Adaptive = 1,
}
declare const enum SpriteMaskInteraction {
    None = 0,
    VisibleInsideMask = 1,
    VisibleOutsideMask = 2,
}
declare const enum SpriteSortPoint {
    Center = 0,
    Pivot = 1,
}
declare const enum ParticleSystemShapeTextureChannel {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
}
declare const enum ParticleSystemInheritVelocityMode {
    Initial = 0,
    Current = 1,
}
declare const enum ParticleSystemGameObjectFilter {
    LayerMask = 0,
    List = 1,
    LayerMaskAndList = 2,
}
declare const enum ParticleSystemForceFieldShape {
    Sphere = 0,
    Hemisphere = 1,
    Cylinder = 2,
    Box = 3,
}
declare const enum ParticleSystemNoiseQuality {
    Low = 0,
    Medium = 1,
    High = 2,
}
declare const enum ParticleSystemCollisionType {
    Planes = 0,
    World = 1,
}
declare const enum ParticleSystemCollisionMode {
    Collision3D = 0,
    Collision2D = 1,
}
declare const enum ParticleSystemCollisionQuality {
    High = 0,
    Medium = 1,
    Low = 2,
}
declare const enum ParticleSystemOverlapAction {
    Ignore = 0,
    Kill = 1,
    Callback = 2,
}
declare const enum ParticleSystemColliderQueryMode {
    Disabled = 0,
    One = 1,
    All = 2,
}
declare const enum ParticleSystemSubEmitterType {
    Birth = 0,
    Collision = 1,
    Death = 2,
    Trigger = 3,
    Manual = 4,
}
declare const enum ParticleSystemSubEmitterProperties {
    InheritNothing = 0,
    InheritColor = 1,
    InheritSize = 2,
    InheritRotation = 4,
    InheritLifetime = 8,
    InheritDuration = 16,
    InheritEverything = 31,
}
declare const enum ParticleSystemAnimationMode {
    Grid = 0,
    Sprites = 1,
}
declare const enum ParticleSystemAnimationTimeMode {
    Lifetime = 0,
    Speed = 1,
    FPS = 2,
}
declare const enum ParticleSystemAnimationType {
    WholeSheet = 0,
    SingleRow = 1,
}
declare const enum ParticleSystemAnimationRowMode {
    Custom = 0,
    Random = 1,
    MeshIndex = 2,
}
declare const enum UVChannelFlags {
    UV0 = 1,
    UV1 = 2,
    UV2 = 4,
    UV3 = 8,
}
declare const enum ParticleSystemTrailMode {
    PerParticle = 0,
    Ribbon = 1,
}
declare const enum ParticleSystemTrailTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3,
    Static = 4,
}
declare const enum ParticleSystemCustomData {
    Custom1 = 0,
    Custom2 = 1,
}
declare const enum ParticleSystemCustomDataMode {
    Disabled = 0,
    Vector = 1,
    Color = 2,
}
declare const enum ParticleSystemStopBehavior {
    StopEmittingAndClear = 0,
    StopEmitting = 1,
}
declare const enum AvatarMaskBodyPart {
    Root = 0,
    Body = 1,
    Head = 2,
    LeftLeg = 3,
    RightLeg = 4,
    LeftArm = 5,
    RightArm = 6,
    LeftFingers = 7,
    RightFingers = 8,
    LeftFootIK = 9,
    RightFootIK = 10,
    LeftHandIK = 11,
    RightHandIK = 12,
    LastBodyPart = 13,
}
declare const enum ApplicationInstallMode {
    Unknown = 0,
    Store = 1,
    DeveloperBuild = 2,
    Adhoc = 3,
    Enterprise = 4,
    Editor = 5,
}
declare const enum ApplicationSandboxType {
    Unknown = 0,
    NotSandboxed = 1,
    Sandboxed = 2,
    SandboxBroken = 3,
}
declare const enum StackTraceLogType {
    None = 0,
    ScriptOnly = 1,
    Full = 2,
}
declare const enum ThreadPriority {
    Low = 0,
    BelowNormal = 1,
    Normal = 2,
    High = 4,
}
declare const enum RuntimePlatform {
    OSXEditor = 0,
    OSXPlayer = 1,
    WindowsPlayer = 2,
    OSXWebPlayer = 3,
    OSXDashboardPlayer = 4,
    WindowsWebPlayer = 5,
    WindowsEditor = 7,
    IPhonePlayer = 8,
    PS3 = 9,
    XBOX360 = 10,
    Android = 11,
    NaCl = 12,
    LinuxPlayer = 13,
    FlashPlayer = 15,
    LinuxEditor = 16,
    WebGLPlayer = 17,
    MetroPlayerX86 = 18,
    WSAPlayerX86 = 18,
    MetroPlayerX64 = 19,
    WSAPlayerX64 = 19,
    MetroPlayerARM = 20,
    WSAPlayerARM = 20,
    WP8Player = 21,
    BB10Player = 22,
    BlackBerryPlayer = 22,
    TizenPlayer = 23,
    PSP2 = 24,
    PS4 = 25,
    PSM = 26,
    XboxOne = 27,
    SamsungTVPlayer = 28,
    WiiU = 30,
    tvOS = 31,
    Switch = 32,
    Lumin = 33,
    Stadia = 34,
    LinuxHeadlessSimulation = 35,
    GameCoreXboxSeries = 36,
    GameCoreXboxOne = 37,
    PS5 = 38,
    EmbeddedLinuxArm64 = 39,
    EmbeddedLinuxArm32 = 40,
    EmbeddedLinuxX64 = 41,
    EmbeddedLinuxX86 = 42,
    LinuxServer = 43,
    WindowsServer = 44,
    OSXServer = 45,
    QNXArm32 = 46,
    QNXArm64 = 47,
    QNXX64 = 48,
    QNXX86 = 49,
    GameCoreScarlett = -1,
    CloudRendering = -1,
}
declare const enum SystemLanguage {
    Afrikaans = 0,
    Arabic = 1,
    Basque = 2,
    Belarusian = 3,
    Bulgarian = 4,
    Catalan = 5,
    Chinese = 6,
    Czech = 7,
    Danish = 8,
    Dutch = 9,
    English = 10,
    Estonian = 11,
    Faroese = 12,
    Finnish = 13,
    French = 14,
    German = 15,
    Greek = 16,
    Hebrew = 17,
    Hungarian = 18,
    Hugarian = 18,
    Icelandic = 19,
    Indonesian = 20,
    Italian = 21,
    Japanese = 22,
    Korean = 23,
    Latvian = 24,
    Lithuanian = 25,
    Norwegian = 26,
    Polish = 27,
    Portuguese = 28,
    Romanian = 29,
    Russian = 30,
    SerboCroatian = 31,
    Slovak = 32,
    Slovenian = 33,
    Spanish = 34,
    Swedish = 35,
    Thai = 36,
    Turkish = 37,
    Ukrainian = 38,
    Vietnamese = 39,
    ChineseSimplified = 40,
    ChineseTraditional = 41,
    Hindi = 42,
    Unknown = 43,
}
declare const enum NetworkReachability {
    NotReachable = 0,
    ReachableViaCarrierDataNetwork = 1,
    ReachableViaLocalAreaNetwork = 2,
}
declare const enum UserAuthorization {
    WebCam = 1,
    Microphone = 2,
}
declare const enum ParticleSystemRenderSpace {
    View = 0,
    World = 1,
    Local = 2,
    Facing = 3,
    Velocity = 4,
}
declare const enum ParticleSystemRenderMode {
    Billboard = 0,
    Stretch = 1,
    HorizontalBillboard = 2,
    VerticalBillboard = 3,
    Mesh = 4,
    None = 5,
}
declare const enum ParticleSystemMeshDistribution {
    UniformRandom = 0,
    NonUniformRandom = 1,
}
declare const enum ParticleSystemSortMode {
    None = 0,
    Distance = 1,
    OldestInFront = 2,
    YoungestInFront = 3,
    Depth = 4,
    DistanceReverse = 5,
    DepthReverse = 6,
}
declare const enum ParticleSystemVertexStreams {
    None = 0,
    Position = 1,
    Normal = 2,
    Tangent = 4,
    Color = 8,
    UV = 16,
    UV2BlendAndFrame = 32,
    CenterAndVertexID = 64,
    Size = 128,
    Rotation = 256,
    Velocity = 512,
    Lifetime = 1024,
    Custom1 = 2048,
    Custom2 = 4096,
    Random = 8192,
    All = 2147483647,
}
declare const enum ParticleSystemBakeMeshOptions {
    Default = 0,
    BakeRotationAndScale = 1,
    BakePosition = 2,
}
declare const enum ParticleSystemBakeTextureOptions {
    BakeRotationAndScale = 1,
    BakePosition = 2,
    PerVertex = 4,
    Default = 4,
    PerParticle = 8,
    IncludeParticleIndices = 16,
}
declare const enum ParticleSystemVertexStream {
    Position = 0,
    Normal = 1,
    Tangent = 2,
    Color = 3,
    UV = 4,
    UV2 = 5,
    UV3 = 6,
    UV4 = 7,
    AnimBlend = 8,
    AnimFrame = 9,
    Center = 10,
    VertexID = 11,
    SizeX = 12,
    SizeXY = 13,
    SizeXYZ = 14,
    Rotation = 15,
    Rotation3D = 16,
    RotationSpeed = 17,
    RotationSpeed3D = 18,
    Velocity = 19,
    Speed = 20,
    AgePercent = 21,
    InvStartLifetime = 22,
    StableRandomX = 23,
    StableRandomXY = 24,
    StableRandomXYZ = 25,
    StableRandomXYZW = 26,
    VaryingRandomX = 27,
    VaryingRandomXY = 28,
    VaryingRandomXYZ = 29,
    VaryingRandomXYZW = 30,
    Custom1X = 31,
    Custom1XY = 32,
    Custom1XYZ = 33,
    Custom1XYZW = 34,
    Custom2X = 35,
    Custom2XY = 36,
    Custom2XYZ = 37,
    Custom2XYZW = 38,
    NoiseSumX = 39,
    NoiseSumXY = 40,
    NoiseSumXYZ = 41,
    NoiseImpulseX = 42,
    NoiseImpulseXY = 43,
    NoiseImpulseXYZ = 44,
    MeshIndex = 45,
    ParticleIndex = 46,
    ColorPackedAsTwoFloats = 47,
    MeshAxisOfRotation = 48,
    NextTrailCenter = 49,
    PreviousTrailCenter = 50,
    PercentageAlongTrail = 51,
    TrailWidth = 52,
}
declare const enum ProfilerArea {
    CPU = 0,
    GPU = 1,
    Rendering = 2,
    Memory = 3,
    Audio = 4,
    Video = 5,
    Physics = 6,
    Physics2D = 7,
    NetworkMessages = 8,
    NetworkOperations = 9,
    UI = 10,
    UIDetails = 11,
    GlobalIllumination = 12,
    VirtualTexturing = 13,
}
declare const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    TopToBottom = 3,
}
declare const enum ContentType {
    Standard = 0,
    Autocorrected = 1,
    IntegerNumber = 2,
    DecimalNumber = 3,
    Alphanumeric = 4,
    Name = 5,
    EmailAddress = 6,
    Password = 7,
    Pin = 8,
    Custom = 9,
}
declare const enum LineType {
    SingleLine = 0,
    MultiLineSubmit = 1,
    MultiLineNewline = 2,
}
declare const enum InputType {
    Standard = 0,
    AutoCorrect = 1,
    Password = 2,
}
declare const enum Status {
    Visible = 0,
    Done = 1,
    Canceled = 2,
    LostFocus = 3,
}
declare const enum TouchScreenKeyboardType {
    Default = 0,
    ASCIICapable = 1,
    NumbersAndPunctuation = 2,
    URL = 3,
    NumberPad = 4,
    PhonePad = 5,
    NamePhonePad = 6,
    EmailAddress = 7,
    NintendoNetworkAccount = 8,
    Social = 9,
    Search = 10,
    DecimalPad = 11,
    OneTimeCode = 12,
}
declare const enum CharacterValidation {
    None = 0,
    Digit = 1,
    Integer = 2,
    Decimal = 3,
    Alphanumeric = 4,
    Name = 5,
    Regex = 6,
    EmailAddress = 7,
    CustomValidator = 8,
}
declare const enum EventType {
    MouseDown = 0,
    mouseDown = 0,
    MouseUp = 1,
    mouseUp = 1,
    MouseMove = 2,
    mouseMove = 2,
    mouseDrag = 3,
    MouseDrag = 3,
    KeyDown = 4,
    keyDown = 4,
    keyUp = 5,
    KeyUp = 5,
    ScrollWheel = 6,
    scrollWheel = 6,
    Repaint = 7,
    repaint = 7,
    Layout = 8,
    layout = 8,
    DragUpdated = 9,
    dragUpdated = 9,
    dragPerform = 10,
    DragPerform = 10,
    ignore = 11,
    Ignore = 11,
    used = 12,
    Used = 12,
    ValidateCommand = 13,
    ExecuteCommand = 14,
    DragExited = 15,
    ContextClick = 16,
    MouseEnterWindow = 20,
    MouseLeaveWindow = 21,
    TouchDown = 30,
    TouchUp = 31,
    TouchMove = 32,
    TouchEnter = 33,
    TouchLeave = 34,
    TouchStationary = 35,
}
declare const enum PointerType {
    Mouse = 0,
    Touch = 1,
    Pen = 2,
}
declare const enum EventModifiers {
    None = 0,
    Shift = 1,
    Control = 2,
    Alt = 4,
    Command = 8,
    Numeric = 16,
    CapsLock = 32,
    FunctionKey = 64,
}
declare const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    TopToBottom = 3,
}
declare const enum AudioClipLoadType {
    DecompressOnLoad = 0,
    CompressedInMemory = 1,
    Streaming = 2,
}
declare const enum AudioDataLoadState {
    Unloaded = 0,
    Loading = 1,
    Loaded = 2,
    Failed = 3,
}
declare const enum AudioMixerUpdateMode {
    Normal = 0,
    UnscaledTime = 1,
}
declare const enum GamepadSpeakerOutputType {
    Speaker = 0,
    Vibration = 1,
    SecondaryVibration = 2,
}
declare const enum AudioVelocityUpdateMode {
    Auto = 0,
    Fixed = 1,
    Dynamic = 2,
}
declare const enum AudioRolloffMode {
    Logarithmic = 0,
    Linear = 1,
    Custom = 2,
}
declare const enum AudioSourceCurveType {
    CustomRolloff = 0,
    SpatialBlend = 1,
    ReverbZoneMix = 2,
    Spread = 3,
}
declare const enum FFTWindow {
    Rectangular = 0,
    Triangle = 1,
    Hamming = 2,
    Hanning = 3,
    Blackman = 4,
    BlackmanHarris = 5,
}
declare const enum EaseType {
    Linear = 0,
    SineIn = 10,
    SineOut = 11,
    SineInOut = 12,
    QuadIn = 20,
    QuadOut = 21,
    QuadInOut = 22,
    CubicIn = 30,
    CubicOut = 31,
    CubicInOut = 32,
    QuartIn = 40,
    QuartOut = 41,
    QuartInOut = 42,
    QuintIn = 50,
    QuintOut = 51,
    QuintInOut = 52,
    ExpoIn = 60,
    ExpoOut = 61,
    ExpoInOut = 62,
    CircIn = 70,
    CircOut = 71,
    CircInOut = 72,
    BackIn = 80,
    BackOut = 81,
    BackInOut = 82,
    ElasticIn = 90,
    ElasticOut = 91,
    ElasticInOut = 92,
    BounceIn = 100,
    BounceOut = 101,
    BounceInOut = 102,
}
declare const enum ChatroomAgentMode {
    Unconnected = 0,
    Host = 1,
    Guest = 2,
}
declare const enum StereoScreenCaptureMode {
    LeftEye = 1,
    RightEye = 2,
    BothEyes = 3,
}
declare const enum CollisionType {
    None = 0,
    Solid = 1,
    Slope = 2,
}
declare const enum ContextStyle {
    None = 0,
    GreedyMeshingTiles = 1,
    ContextBlocks = 2,
    QuarterTiles = 3,
}
declare const enum CollisionFlags {
    None = 0,
    Sides = 1,
    CollidedSides = 1,
    Above = 2,
    CollidedAbove = 2,
    Below = 4,
    CollidedBelow = 4,
}
declare const enum LineTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3,
    Static = 4,
}
declare const enum LineAlignment {
    View = 0,
    Local = 1,
    TransformZ = 1,
}
declare const enum EntityAnimationEventKey {
    FOOTSTEP = 0,
    JUMP = 1,
    LAND = 2,
    SLIDE_START = 3,
    SLIDE_END = 4,
    DEFAULT = -1,
}
declare const enum Result {
    InProgress = 0,
    Success = 1,
    ConnectionError = 2,
    ProtocolError = 3,
    DataProcessingError = 4,
}
declare const enum AudioType {
    UNKNOWN = 0,
    ACC = 1,
    AIFF = 2,
    IT = 10,
    MOD = 12,
    MPEG = 13,
    OGGVORBIS = 14,
    S3M = 17,
    WAV = 20,
    XM = 21,
    XMA = 22,
    VAG = 23,
    AUDIOQUEUE = 24,
}
declare const enum ToggleTransition {
    None = 0,
    Fade = 1,
}
declare const enum TextAnchor {
    UpperLeft = 0,
    UpperCenter = 1,
    UpperRight = 2,
    MiddleLeft = 3,
    MiddleCenter = 4,
    MiddleRight = 5,
    LowerLeft = 6,
    LowerCenter = 7,
    LowerRight = 8,
}
declare const enum FitMode {
    Unconstrained = 0,
    MinSize = 1,
    PreferredSize = 2,
}
declare const enum MovementType {
    Unrestricted = 0,
    Elastic = 1,
    Clamped = 2,
}
declare const enum ScrollbarVisibility {
    Permanent = 0,
    AutoHide = 1,
    AutoHideAndExpandViewport = 2,
}
declare const enum SynchronizedProperty {
    None = 0,
    Parent = 1,
    Position = 2,
    Rotation = 4,
    Scale = 8,
}
declare const enum SaveFolder {
    ApplicationData = 0,
    PicturesFolder = 1,
    Documents = 2,
}
declare const enum LogContext {
    Client = 0,
    Server = 1,
}
declare const enum Key {
    None = 0,
    Space = 1,
    Enter = 2,
    Tab = 3,
    Backquote = 4,
    Quote = 5,
    Semicolon = 6,
    Comma = 7,
    Period = 8,
    Slash = 9,
    Backslash = 10,
    LeftBracket = 11,
    RightBracket = 12,
    Minus = 13,
    Equals = 14,
    A = 15,
    B = 16,
    C = 17,
    D = 18,
    E = 19,
    F = 20,
    G = 21,
    H = 22,
    I = 23,
    J = 24,
    K = 25,
    L = 26,
    M = 27,
    N = 28,
    O = 29,
    P = 30,
    Q = 31,
    R = 32,
    S = 33,
    T = 34,
    U = 35,
    V = 36,
    W = 37,
    X = 38,
    Y = 39,
    Z = 40,
    Digit1 = 41,
    Digit2 = 42,
    Digit3 = 43,
    Digit4 = 44,
    Digit5 = 45,
    Digit6 = 46,
    Digit7 = 47,
    Digit8 = 48,
    Digit9 = 49,
    Digit0 = 50,
    LeftShift = 51,
    RightShift = 52,
    LeftAlt = 53,
    RightAlt = 54,
    AltGr = 54,
    LeftCtrl = 55,
    RightCtrl = 56,
    LeftMeta = 57,
    LeftWindows = 57,
    LeftCommand = 57,
    LeftApple = 57,
    RightCommand = 58,
    RightMeta = 58,
    RightWindows = 58,
    RightApple = 58,
    ContextMenu = 59,
    Escape = 60,
    LeftArrow = 61,
    RightArrow = 62,
    UpArrow = 63,
    DownArrow = 64,
    Backspace = 65,
    PageDown = 66,
    PageUp = 67,
    Home = 68,
    End = 69,
    Insert = 70,
    Delete = 71,
    CapsLock = 72,
    NumLock = 73,
    PrintScreen = 74,
    ScrollLock = 75,
    Pause = 76,
    NumpadEnter = 77,
    NumpadDivide = 78,
    NumpadMultiply = 79,
    NumpadPlus = 80,
    NumpadMinus = 81,
    NumpadPeriod = 82,
    NumpadEquals = 83,
    Numpad0 = 84,
    Numpad1 = 85,
    Numpad2 = 86,
    Numpad3 = 87,
    Numpad4 = 88,
    Numpad5 = 89,
    Numpad6 = 90,
    Numpad7 = 91,
    Numpad8 = 92,
    Numpad9 = 93,
    F1 = 94,
    F2 = 95,
    F3 = 96,
    F4 = 97,
    F5 = 98,
    F6 = 99,
    F7 = 100,
    F8 = 101,
    F9 = 102,
    F10 = 103,
    F11 = 104,
    F12 = 105,
    OEM1 = 106,
    OEM2 = 107,
    OEM3 = 108,
    OEM4 = 109,
    OEM5 = 110,
    IMESelected = 111,
}
declare const enum BlendMode {
    Normal = 0,
    Additive = 1,
    Screen = 2,
    Multiply = 3,
}
declare const enum ColorBleedMode {
    ImageColor = 0,
    ShadowColor = 1,
    Black = 2,
    White = 3,
    Plugin = 4,
}
declare const enum AirshipPlatform {
    iOS = 0,
    Android = 1,
    Mac = 2,
    Windows = 3,
    Linux = 4,
}
declare const enum BuildTarget {
    StandaloneOSX = 2,
    StandaloneOSXUniversal = 3,
    StandaloneOSXIntel = 4,
    StandaloneWindows = 5,
    WebPlayer = 6,
    WebPlayerStreamed = 7,
    iOS = 9,
    PS3 = 10,
    XBOX360 = 11,
    Android = 13,
    StandaloneLinux = 17,
    StandaloneWindows64 = 19,
    WebGL = 20,
    WSAPlayer = 21,
    StandaloneLinux64 = 24,
    StandaloneLinuxUniversal = 25,
    WP8Player = 26,
    StandaloneOSXIntel64 = 27,
    BlackBerry = 28,
    Tizen = 29,
    PSP2 = 30,
    PS4 = 31,
    PSM = 32,
    XboxOne = 33,
    SamsungTV = 34,
    N3DS = 35,
    WiiU = 36,
    tvOS = 37,
    Switch = 38,
    Lumin = 39,
    Stadia = 40,
    LinuxHeadlessSimulation = 41,
    CloudRendering = 41,
    GameCoreScarlett = 42,
    GameCoreXboxSeries = 42,
    GameCoreXboxOne = 43,
    PS5 = 44,
    EmbeddedLinux = 45,
    QNX = 46,
    Bratwurst = 47,
    NoTarget = -2,
    MetroPlayer = -1,
    iPhone = -1,
    BB10 = -1,
}
declare const enum BatteryStatus {
    Unknown = 0,
    Charging = 1,
    Discharging = 2,
    NotCharging = 3,
    Full = 4,
}
declare const enum OperatingSystemFamily {
    Other = 0,
    MacOSX = 1,
    Windows = 2,
    Linux = 3,
}
declare const enum DeviceType {
    Unknown = 0,
    Handheld = 1,
    Console = 2,
    Desktop = 3,
}
declare const enum GraphicsDeviceType {
    OpenGL2 = 0,
    Direct3D9 = 1,
    Direct3D11 = 2,
    PlayStation3 = 3,
    Null = 4,
    Xbox360 = 6,
    OpenGLES2 = 8,
    OpenGLES3 = 11,
    PlayStationVita = 12,
    PlayStation4 = 13,
    XboxOne = 14,
    PlayStationMobile = 15,
    Metal = 16,
    OpenGLCore = 17,
    Direct3D12 = 18,
    N3DS = 19,
    Vulkan = 21,
    Switch = 22,
    XboxOneD3D12 = 23,
    GameCoreXboxOne = 24,
    GameCoreXboxSeries = 25,
    PlayStation5 = 26,
    PlayStation5NGGC = 27,
    WebGPU = 28,
    GameCoreScarlett = -1,
}
declare const enum RenderingThreadingMode {
    Direct = 0,
    SingleThreaded = 1,
    MultiThreaded = 2,
    LegacyJobified = 3,
    NativeGraphicsJobs = 4,
    NativeGraphicsJobsWithoutRenderThread = 5,
    NativeGraphicsJobsSplitThreading = 6,
}
declare const enum FoveatedRenderingCaps {
    None = 0,
    FoveationImage = 1,
    NonUniformRaster = 2,
    ModeChangeOnlyBeforeRenderTargetSet = 4,
}
declare const enum CopyTextureSupport {
    None = 0,
    Basic = 1,
    Copy3D = 2,
    DifferentTypes = 4,
    TextureToRT = 8,
    RTToTexture = 16,
}
declare const enum NPOTSupport {
    None = 0,
    Restricted = 1,
    Full = 2,
}
declare const enum HDRDisplaySupportFlags {
    None = 0,
    Supported = 1,
    RuntimeSwitchable = 2,
    AutomaticTonemapping = 4,
}
declare const enum FormatUsage {
    Sample = 0,
    Linear = 1,
    Sparse = 2,
    Render = 4,
    Blend = 5,
    GetPixels = 6,
    SetPixels = 7,
    SetPixels32 = 8,
    ReadPixels = 9,
    LoadStore = 10,
    MSAA2x = 11,
    MSAA4x = 12,
    MSAA8x = 13,
    StencilSampling = 16,
}
declare const enum GraphicsFormatUsage {
    None = 0,
    Sample = 1,
    Linear = 2,
    Sparse = 4,
    Render = 16,
    Blend = 32,
    GetPixels = 64,
    SetPixels = 128,
    SetPixels32 = 256,
    ReadPixels = 512,
    LoadStore = 1024,
    MSAA2x = 2048,
    MSAA4x = 4096,
    MSAA8x = 8192,
    StencilSampling = 65536,
}
declare const enum ScaleMode {
    ConstantPixelSize = 0,
    ScaleWithScreenSize = 1,
    ConstantPhysicalSize = 2,
}
declare const enum ScreenMatchMode {
    MatchWidthOrHeight = 0,
    Expand = 1,
    Shrink = 2,
}
declare const enum Unit {
    Centimeters = 0,
    Millimeters = 1,
    Inches = 2,
    Points = 3,
    Picas = 4,
}
declare const enum Corner {
    UpperLeft = 0,
    UpperRight = 1,
    LowerLeft = 2,
    LowerRight = 3,
}
declare const enum Axis {
    Horizontal = 0,
    Vertical = 1,
}
declare const enum Constraint {
    Flexible = 0,
    FixedColumnCount = 1,
    FixedRowCount = 2,
}
declare const enum FullScreenMode {
    ExclusiveFullScreen = 0,
    FullScreenWindow = 1,
    MaximizedWindow = 2,
    Windowed = 3,
}
declare const enum ScreenOrientation {
    Unknown = 0,
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeLeft = 3,
    Landscape = 3,
    LandscapeRight = 4,
    AutoRotation = 5,
}
declare const enum AirshipDeviceType {
    Tablet = 0,
    Phone = 1,
    Desktop = 2,
}
declare const enum OffMeshLinkType {
    LinkTypeManual = 0,
    LinkTypeDropDown = 1,
    LinkTypeJumpAcross = 2,
}
declare const enum NavMeshPathStatus {
    PathComplete = 0,
    PathPartial = 1,
    PathInvalid = 2,
}
declare const enum ObstacleAvoidanceType {
    NoObstacleAvoidance = 0,
    LowQualityObstacleAvoidance = 1,
    MedQualityObstacleAvoidance = 2,
    GoodQualityObstacleAvoidance = 3,
    HighQualityObstacleAvoidance = 4,
}
declare const enum NavMeshBuildDebugFlags {
    None = 0,
    InputGeometry = 1,
    Voxels = 2,
    Regions = 4,
    RawContours = 8,
    SimplifiedContours = 16,
    PolygonMeshes = 32,
    PolygonMeshesDetail = 64,
    All = 127,
}
declare const enum NavMeshObstacleShape {
    Capsule = 0,
    Box = 1,
}
declare const enum StylePropertyId {
    Unknown = 0,
    Color = 65536,
    FontSize = 65537,
    LetterSpacing = 65538,
    TextShadow = 65539,
    UnityFont = 65540,
    UnityFontDefinition = 65541,
    UnityFontStyleAndWeight = 65542,
    UnityParagraphSpacing = 65543,
    UnityTextAlign = 65544,
    UnityTextOutlineColor = 65545,
    UnityTextOutlineWidth = 65546,
    Visibility = 65547,
    WhiteSpace = 65548,
    WordSpacing = 65549,
    AlignContent = 131072,
    AlignItems = 131073,
    AlignSelf = 131074,
    BorderBottomWidth = 131075,
    BorderLeftWidth = 131076,
    BorderRightWidth = 131077,
    BorderTopWidth = 131078,
    Bottom = 131079,
    Display = 131080,
    FlexBasis = 131081,
    FlexDirection = 131082,
    FlexGrow = 131083,
    FlexShrink = 131084,
    FlexWrap = 131085,
    Height = 131086,
    JustifyContent = 131087,
    Left = 131088,
    MarginBottom = 131089,
    MarginLeft = 131090,
    MarginRight = 131091,
    MarginTop = 131092,
    MaxHeight = 131093,
    MaxWidth = 131094,
    MinHeight = 131095,
    MinWidth = 131096,
    PaddingBottom = 131097,
    PaddingLeft = 131098,
    PaddingRight = 131099,
    PaddingTop = 131100,
    Position = 131101,
    Right = 131102,
    Top = 131103,
    Width = 131104,
    Cursor = 196608,
    TextOverflow = 196609,
    UnityBackgroundImageTintColor = 196610,
    UnityOverflowClipBox = 196611,
    UnitySliceBottom = 196612,
    UnitySliceLeft = 196613,
    UnitySliceRight = 196614,
    UnitySliceScale = 196615,
    UnitySliceTop = 196616,
    UnityTextOverflowPosition = 196617,
    All = 262144,
    BackgroundPosition = 262145,
    BorderColor = 262146,
    BorderRadius = 262147,
    BorderWidth = 262148,
    Flex = 262149,
    Margin = 262150,
    Padding = 262151,
    Transition = 262152,
    UnityBackgroundScaleMode = 262153,
    UnityTextOutline = 262154,
    Rotate = 327680,
    Scale = 327681,
    TransformOrigin = 327682,
    Translate = 327683,
    TransitionDelay = 393216,
    TransitionDuration = 393217,
    TransitionProperty = 393218,
    TransitionTimingFunction = 393219,
    BackgroundColor = 458752,
    BackgroundImage = 458753,
    BackgroundPositionX = 458754,
    BackgroundPositionY = 458755,
    BackgroundRepeat = 458756,
    BackgroundSize = 458757,
    BorderBottomColor = 458758,
    BorderBottomLeftRadius = 458759,
    BorderBottomRightRadius = 458760,
    BorderLeftColor = 458761,
    BorderRightColor = 458762,
    BorderTopColor = 458763,
    BorderTopLeftRadius = 458764,
    BorderTopRightRadius = 458765,
    Opacity = 458766,
    Overflow = 458767,
    Custom = -1,
}
declare const enum LengthUnit {
    Pixel = 0,
    Percent = 1,
}
declare const enum AtlasPopulationMode {
    Static = 0,
    Dynamic = 1,
    DynamicOS = 2,
}
declare const enum TextElementType {
    Character = 1,
    Sprite = 2,
}
declare const enum AngleUnit {
    Degree = 0,
    Gradian = 1,
    Radian = 2,
    Turn = 3,
}
declare const enum BackgroundPositionKeyword {
    Center = 0,
    Top = 1,
    Bottom = 2,
    Left = 3,
    Right = 4,
}
declare const enum Repeat {
    NoRepeat = 0,
    Space = 1,
    Round = 2,
    Repeat = 3,
}
declare const enum BackgroundSizeType {
    Length = 0,
    Cover = 1,
    Contain = 2,
}
declare const enum Align {
    Auto = 0,
    FlexStart = 1,
    Center = 2,
    FlexEnd = 3,
    Stretch = 4,
}
declare const enum DisplayStyle {
    Flex = 0,
    None = 1,
}
declare const enum StyleKeyword {
    Undefined = 0,
    Null = 1,
    Auto = 2,
    None = 3,
    Initial = 4,
}
declare const enum FlexDirection {
    Column = 0,
    ColumnReverse = 1,
    Row = 2,
    RowReverse = 3,
}
declare const enum Wrap {
    NoWrap = 0,
    Wrap = 1,
    WrapReverse = 2,
}
declare const enum Justify {
    FlexStart = 0,
    Center = 1,
    FlexEnd = 2,
    SpaceBetween = 3,
    SpaceAround = 4,
    SpaceEvenly = 5,
}
declare const enum Position {
    Relative = 0,
    Absolute = 1,
}
declare const enum TextOverflow {
    Clip = 0,
    Ellipsis = 1,
}
declare const enum TimeUnit {
    Second = 0,
    Millisecond = 1,
}
declare const enum EasingMode {
    Ease = 0,
    EaseIn = 1,
    EaseOut = 2,
    EaseInOut = 3,
    Linear = 4,
    EaseInSine = 5,
    EaseOutSine = 6,
    EaseInOutSine = 7,
    EaseInCubic = 8,
    EaseOutCubic = 9,
    EaseInOutCubic = 10,
    EaseInCirc = 11,
    EaseOutCirc = 12,
    EaseInOutCirc = 13,
    EaseInElastic = 14,
    EaseOutElastic = 15,
    EaseInOutElastic = 16,
    EaseInBack = 17,
    EaseOutBack = 18,
    EaseInOutBack = 19,
    EaseInBounce = 20,
    EaseOutBounce = 21,
    EaseInOutBounce = 22,
}
declare const enum TextOverflowPosition {
    End = 0,
    Start = 1,
    Middle = 2,
}
declare const enum Visibility {
    Visible = 0,
    Hidden = 1,
}
declare const enum WhiteSpace {
    Normal = 0,
    NoWrap = 1,
}
declare const enum PropagationPhase {
    None = 0,
    TrickleDown = 1,
    AtTarget = 2,
    BubbleUp = 3,
    DefaultAction = 4,
    DefaultActionAtTarget = 5,
}
declare const enum TrickleDown {
    NoTrickleDown = 0,
    TrickleDown = 1,
}
declare const enum UsageHints {
    None = 0,
    DynamicTransform = 1,
    GroupTransform = 2,
    MaskContainer = 4,
    DynamicColor = 8,
}
declare const enum PickingMode {
    Position = 0,
    Ignore = 1,
}
declare const enum LanguageDirection {
    Inherit = 0,
    LTR = 1,
    RTL = 2,
}
declare const enum PropertyPathPartKind {
    Name = 0,
    Index = 1,
    Key = 2,
}
declare const enum ContextType {
    Player = 0,
    Editor = 1,
}
declare const enum BindingUpdateTrigger {
    WhenDirty = 0,
    OnSourceChanged = 1,
    EveryUpdate = 2,
}
declare const enum BindingLogLevel {
    None = 0,
    Once = 1,
    All = 2,
}
declare const enum ScrollerVisibility {
    Auto = 0,
    AlwaysVisible = 1,
    Hidden = 2,
}
declare const enum TouchScrollBehavior {
    Unrestricted = 0,
    Elastic = 1,
    Clamped = 2,
}
declare const enum NestedInteractionKind {
    Default = 0,
    StopScrolling = 1,
    ForwardScrolling = 2,
}
declare const enum DeltaSpeed {
    Fast = 0,
    Normal = 1,
    Slow = 2,
}
declare const enum MeasureMode {
    Undefined = 0,
    Exactly = 1,
    AtMost = 2,
}
declare const enum SliderDirection {
    Horizontal = 0,
    Vertical = 1,
}
declare const enum ScrollViewMode {
    Vertical = 0,
    Horizontal = 1,
    VerticalAndHorizontal = 2,
}
declare const enum DetailScatterMode {
    CoverageMode = 0,
    InstanceCountMode = 1,
}
declare const enum DetailRenderMode {
    GrassBillboard = 0,
    VertexLit = 1,
    Grass = 2,
}
declare const enum TerrainLayerSmoothnessSource {
    Constant = 0,
    DiffuseAlphaChannel = 1,
}
declare const enum TerrainHeightmapSyncControl {
    None = 0,
    HeightOnly = 1,
    HeightAndLod = 2,
}
declare const enum ColorGamut {
    sRGB = 0,
    Rec709 = 1,
    Rec2020 = 2,
    DisplayP3 = 3,
    HDR10 = 4,
    DolbyHDR = 5,
    P3D65G22 = 6,
}
declare const enum GraphicsTier {
    Tier1 = 0,
    Tier2 = 1,
    Tier3 = 2,
}
declare const enum OpenGLESVersion {
    None = 0,
    OpenGLES20 = 1,
    OpenGLES30 = 2,
    OpenGLES31 = 3,
    OpenGLES31AEP = 4,
    OpenGLES32 = 5,
}
declare const enum BoundingBoxMode {
    AutomaticLocal = 0,
    AutomaticWorld = 1,
    Custom = 2,
}
declare const enum ResolutionMode {
    Automatic = 0,
    Custom = 1,
}
declare const enum ProbePositionMode {
    CellCorner = 0,
    CellCenter = 1,
}
declare const enum RefreshMode {
    Automatic = 0,
    EveryFrame = 1,
    ViaScripting = 2,
}
declare const enum QualityMode {
    Low = 0,
    Normal = 1,
}
declare const enum DataFormat {
    HalfFloat = 0,
    Float = 1,
}
declare const enum EventTriggerType {
    PointerEnter = 0,
    PointerExit = 1,
    PointerDown = 2,
    PointerUp = 3,
    PointerClick = 4,
    Drag = 5,
    Drop = 6,
    Scroll = 7,
    UpdateSelected = 8,
    Select = 9,
    Deselect = 10,
    Move = 11,
    InitializePotentialDrag = 12,
    BeginDrag = 13,
    EndDrag = 14,
    Submit = 15,
    Cancel = 16,
}

    
interface RaycastHit {
    collider: Collider;
    colliderInstanceID: number;
    point: Vector3;
    normal: Vector3;
    barycentricCoordinate: Vector3;
    distance: number;
    triangleIndex: number;
    textureCoord: Vector2;
    textureCoord2: Vector2;
    transform: Transform;
    rigidbody: Rigidbody;
    articulationBody: ArticulationBody;
    lightmapCoord: Vector2;
    textureCoord1: Vector2;



}
    
    
    
    
    
    
    
    
    
interface FrustumPlanes {
    left: number;
    right: number;
    bottom: number;
    top: number;
    zNear: number;
    zFar: number;



}
    
    
    
interface Plane {
    normal: Vector3;
    distance: number;
    flipped: Plane;


    /** For a given point returns the closest point on the plane. */
    ClosestPointOnPlane(point: Vector3): Vector3;
    /** Makes the plane face in the opposite direction. */
    Flip(): void;
    /** Returns a signed distance from plane to point. */
    GetDistanceToPoint(point: Vector3): number;
    /** Is a point on the positive side of the plane? */
    GetSide(point: Vector3): boolean;
    /** Intersects a ray with the plane. */
    Raycast(ray: Ray, enter: unknown): boolean;
    /** Are two points on the same side of the plane? */
    SameSide(inPt0: Vector3, inPt1: Vector3): boolean;
    /** Sets a plane using three points that lie within it.  The points go around clockwise as you look down on the top surface of the plane. */
    Set3Points(a: Vector3, b: Vector3, c: Vector3): void;
    /** Sets a plane using a point that lies within it along with a normal to orient it. */
    SetNormalAndPosition(inNormal: Vector3, inPoint: Vector3): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
    /** Moves the plane in space by the translation vector. */
    Translate(translation: Vector3): void;

}
    
    
    
interface PlaneConstructor {

    new(inNormal: Vector3, inPoint: Vector3): Plane;
    new(inNormal: Vector3, d: number): Plane;
    new(a: Vector3, b: Vector3, c: Vector3): Plane;


    Translate(plane: Plane, translation: Vector3): Plane;
}
declare const Plane: PlaneConstructor;
    
    
    
interface Scene {
    handle: number;
    path: string;
    name: string;
    isLoaded: boolean;
    buildIndex: number;
    isDirty: boolean;
    rootCount: number;
    isSubScene: boolean;


    Equals(other: unknown): boolean;
    GetHashCode(): number;
    /** Returns all the root game objects in the Scene. */
    GetRootGameObjects(): CSArray<GameObject>;
    GetRootGameObjects(rootGameObjects: CSArray<GameObject>): void;
    /** Whether this is a valid Scene.
A Scene may be invalid if, for example, you tried to open a Scene that does not exist. In this case, the Scene returned from EditorSceneManager.OpenScene would return False for IsValid. */
    IsValid(): boolean;

}
    
interface TagHandle {


    ToString(): string;

}
    
interface TagHandleConstructor {



    GetExistingTag(tagName: string): TagHandle;
}
declare const TagHandle: TagHandleConstructor;
    
    
    
    
    
    
    
    
interface Rigidbody extends Component {
    velocity: Vector3;
    angularVelocity: Vector3;
    drag: number;
    angularDrag: number;
    mass: number;
    useGravity: boolean;
    maxDepenetrationVelocity: number;
    isKinematic: boolean;
    freezeRotation: boolean;
    constraints: RigidbodyConstraints;
    collisionDetectionMode: CollisionDetectionMode;
    automaticCenterOfMass: boolean;
    centerOfMass: Vector3;
    worldCenterOfMass: Vector3;
    automaticInertiaTensor: boolean;
    inertiaTensorRotation: Quaternion;
    inertiaTensor: Vector3;
    detectCollisions: boolean;
    position: Vector3;
    rotation: Quaternion;
    interpolation: RigidbodyInterpolation;
    solverIterations: number;
    sleepThreshold: number;
    maxAngularVelocity: number;
    maxLinearVelocity: number;
    solverVelocityIterations: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    sleepVelocity: number;
    sleepAngularVelocity: number;
    useConeFriction: boolean;
    solverIterationCount: number;
    solverVelocityIterationCount: number;


    /** Applies a force to a rigidbody that simulates explosion effects. */
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number, mode: ForceMode): void;
    /** Applies a force to a rigidbody that simulates explosion effects. */
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number): void;
    /** Applies a force to a rigidbody that simulates explosion effects. */
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number): void;
    /** Adds a force to the Rigidbody. */
    AddForce(force: Vector3, mode: ForceMode): void;
    /** Adds a force to the Rigidbody. */
    AddForce(force: Vector3): void;
    /** Adds a force to the Rigidbody. */
    AddForce(x: number, y: number, z: number, mode: ForceMode): void;
    /** Adds a force to the Rigidbody. */
    AddForce(x: number, y: number, z: number): void;
    /** Applies force at position. As a result this will apply a torque and force on the object. */
    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
    /** Applies force at position. As a result this will apply a torque and force on the object. */
    AddForceAtPosition(force: Vector3, position: Vector3): void;
    /** Adds a force to the rigidbody relative to its coordinate system. */
    AddRelativeForce(force: Vector3, mode: ForceMode): void;
    /** Adds a force to the rigidbody relative to its coordinate system. */
    AddRelativeForce(force: Vector3): void;
    /** Adds a force to the rigidbody relative to its coordinate system. */
    AddRelativeForce(x: number, y: number, z: number, mode: ForceMode): void;
    /** Adds a force to the rigidbody relative to its coordinate system. */
    AddRelativeForce(x: number, y: number, z: number): void;
    /** Adds a torque to the rigidbody relative to its coordinate system. */
    AddRelativeTorque(torque: Vector3, mode: ForceMode): void;
    /** Adds a torque to the rigidbody relative to its coordinate system. */
    AddRelativeTorque(torque: Vector3): void;
    /** Adds a torque to the rigidbody relative to its coordinate system. */
    AddRelativeTorque(x: number, y: number, z: number, mode: ForceMode): void;
    /** Adds a torque to the rigidbody relative to its coordinate system. */
    AddRelativeTorque(x: number, y: number, z: number): void;
    /** Adds a torque to the rigidbody. */
    AddTorque(torque: Vector3, mode: ForceMode): void;
    /** Adds a torque to the rigidbody. */
    AddTorque(torque: Vector3): void;
    /** Adds a torque to the rigidbody. */
    AddTorque(x: number, y: number, z: number, mode: ForceMode): void;
    /** Adds a torque to the rigidbody. */
    AddTorque(x: number, y: number, z: number): void;
    /** The closest point to the bounding box of the attached colliders. */
    ClosestPointOnBounds(position: Vector3): Vector3;
    /** Returns the force that the Rigidbody has accumulated before the simulation step. */
    GetAccumulatedForce(step: number): Vector3;
    GetAccumulatedForce(): Vector3;
    /** Returns the torque that the Rigidbody has accumulated before the simulation step. */
    GetAccumulatedTorque(step: number): Vector3;
    GetAccumulatedTorque(): Vector3;
    /** The velocity of the rigidbody at the point worldPoint in global space. */
    GetPointVelocity(worldPoint: Vector3): Vector3;
    /** The velocity relative to the rigidbody at the point relativePoint. */
    GetRelativePointVelocity(relativePoint: Vector3): Vector3;
    /** Is the rigidbody sleeping? */
    IsSleeping(): boolean;
    /** Moves the Rigidbody to position and rotates the Rigidbody to rotation. */
    Move(position: Vector3, rotation: Quaternion): void;
    /** Moves the kinematic Rigidbody towards position. */
    MovePosition(position: Vector3): void;
    /** Rotates the rigidbody to rotation. */
    MoveRotation(rot: Quaternion): void;
    /** Applies the position and rotation of the Rigidbody to the corresponding Transform component. */
    PublishTransform(): void;
    /** Reset the center of mass of the rigidbody. */
    ResetCenterOfMass(): void;
    /** Reset the inertia tensor value and rotation. */
    ResetInertiaTensor(): void;
    /** Sets the mass based on the attached colliders assuming a constant density. */
    SetDensity(density: number): void;
    SetMaxAngularVelocity(a: number): void;
    /** Forces a rigidbody to sleep at least one frame. */
    Sleep(): void;
    /** Tests if a rigidbody would collide with anything, if it was moved through the Scene. */
    SweepTest(direction: Vector3, hitInfo: unknown, maxDistance: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SweepTest(direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    SweepTest(direction: Vector3, hitInfo: unknown): boolean;
    /** Like Rigidbody.SweepTest, but returns all hits. */
    SweepTestAll(direction: Vector3, maxDistance: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    SweepTestAll(direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    SweepTestAll(direction: Vector3): CSArray<RaycastHit>;
    /** Forces a rigidbody to wake up. */
    WakeUp(): void;

}
    
    
    
interface RigidbodyConstructor {

    new(): Rigidbody;


}
declare const Rigidbody: RigidbodyConstructor;
    
interface Behaviour extends Component {
    enabled: boolean;
    isActiveAndEnabled: boolean;



}
    
interface BehaviourConstructor {

    new(): Behaviour;


}
declare const Behaviour: BehaviourConstructor;
    
interface ArticulationBody extends Behaviour {
    jointType: ArticulationJointType;
    anchorPosition: Vector3;
    parentAnchorPosition: Vector3;
    anchorRotation: Quaternion;
    parentAnchorRotation: Quaternion;
    isRoot: boolean;
    matchAnchors: boolean;
    linearLockX: ArticulationDofLock;
    linearLockY: ArticulationDofLock;
    linearLockZ: ArticulationDofLock;
    swingYLock: ArticulationDofLock;
    swingZLock: ArticulationDofLock;
    twistLock: ArticulationDofLock;
    xDrive: ArticulationDrive;
    yDrive: ArticulationDrive;
    zDrive: ArticulationDrive;
    immovable: boolean;
    useGravity: boolean;
    linearDamping: number;
    angularDamping: number;
    jointFriction: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    velocity: Vector3;
    angularVelocity: Vector3;
    mass: number;
    automaticCenterOfMass: boolean;
    centerOfMass: Vector3;
    worldCenterOfMass: Vector3;
    automaticInertiaTensor: boolean;
    inertiaTensor: Vector3;
    inertiaTensorRotation: Quaternion;
    sleepThreshold: number;
    solverIterations: number;
    solverVelocityIterations: number;
    maxAngularVelocity: number;
    maxLinearVelocity: number;
    maxJointVelocity: number;
    maxDepenetrationVelocity: number;
    jointPosition: ArticulationReducedSpace;
    jointVelocity: ArticulationReducedSpace;
    jointAcceleration: ArticulationReducedSpace;
    jointForce: ArticulationReducedSpace;
    driveForce: ArticulationReducedSpace;
    dofCount: number;
    index: number;
    collisionDetectionMode: CollisionDetectionMode;
    computeParentAnchor: boolean;


    /** Applies a force to the ArticulationBody. */
    AddForce(force: Vector3, mode: ForceMode): void;
    /** Applies a force to the ArticulationBody. */
    AddForce(force: Vector3): void;
    /** Applies a force at a specific position, resulting in applying a torque and force on the object. */
    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
    /** Applies a force at a specific position, resulting in applying a torque and force on the object. */
    AddForceAtPosition(force: Vector3, position: Vector3): void;
    /** Applies a force to the Articulation Body, relative to its local coordinate system. */
    AddRelativeForce(force: Vector3, mode: ForceMode): void;
    /** Applies a force to the Articulation Body, relative to its local coordinate system. */
    AddRelativeForce(force: Vector3): void;
    /** Applies a torque to the articulation body, relative to its local coordinate system. */
    AddRelativeTorque(torque: Vector3, mode: ForceMode): void;
    /** Applies a torque to the articulation body, relative to its local coordinate system. */
    AddRelativeTorque(torque: Vector3): void;
    /** Add torque to the articulation body. */
    AddTorque(torque: Vector3, mode: ForceMode): void;
    /** Add torque to the articulation body. */
    AddTorque(torque: Vector3): void;
    /** Returns the force that the ArticulationBody has accumulated before the simulation step. */
    GetAccumulatedForce(step: number): Vector3;
    GetAccumulatedForce(): Vector3;
    /** Returns the torque that the ArticulationBody has accumulated before the simulation step. */
    GetAccumulatedTorque(step: number): Vector3;
    GetAccumulatedTorque(): Vector3;
    /** Return the point on the articulation body that is closest to a given one. */
    GetClosestPoint(point: Vector3): Vector3;
    /** Calculates and writes dense Jacobian matrix of the articulation body hierarchy to the supplied struct. */
    GetDenseJacobian(jacobian: unknown): number;
    GetDofStartIndices(dofStartIndices: CSArray<number>): number;
    GetDriveForces(forces: CSArray<number>): number;
    GetDriveTargets(targets: CSArray<number>): number;
    GetDriveTargetVelocities(targetVelocities: CSArray<number>): number;
    GetJointAccelerations(accelerations: CSArray<number>): number;
    GetJointCoriolisCentrifugalForces(forces: CSArray<number>): number;
    GetJointExternalForces(forces: CSArray<number>, step: number): number;
    GetJointForces(forces: CSArray<number>): number;
    /** Returns the forces required for the body to reach the provided acceleration in reduced space. */
    GetJointForcesForAcceleration(acceleration: ArticulationReducedSpace): ArticulationReducedSpace;
    GetJointGravityForces(forces: CSArray<number>): number;
    GetJointPositions(positions: CSArray<number>): number;
    GetJointVelocities(velocities: CSArray<number>): number;
    /** Gets the velocity of the articulation body at the specified worldPoint in global space. */
    GetPointVelocity(worldPoint: Vector3): Vector3;
    /** The velocity relative to the articulation body at the point relativePoint. */
    GetRelativePointVelocity(relativePoint: Vector3): Vector3;
    /** Indicates whether the articulation body is sleeping. */
    IsSleeping(): boolean;
    /** Reads the position and rotation of the Articulation Body from the physics system and applies it to the corresponding Transform component. */
    PublishTransform(): void;
    /** Resets the center of mass of the articulation body. */
    ResetCenterOfMass(): void;
    /** Resets the inertia tensor value and rotation. */
    ResetInertiaTensor(): void;
    /** Sets the damping value of the specified drive. */
    SetDriveDamping(axis: ArticulationDriveAxis, value: number): void;
    /** Sets the force limit of the specified drive. */
    SetDriveForceLimit(axis: ArticulationDriveAxis, value: number): void;
    /** Sets the lower and upper limits of the drive. */
    SetDriveLimits(axis: ArticulationDriveAxis, lower: number, upper: number): void;
    /** Sets the stiffness value of the specified drive. */
    SetDriveStiffness(axis: ArticulationDriveAxis, value: number): void;
    /** Sets the target value of the specified drive. */
    SetDriveTarget(axis: ArticulationDriveAxis, value: number): void;
    SetDriveTargets(targets: CSArray<number>): void;
    SetDriveTargetVelocities(targetVelocities: CSArray<number>): void;
    /** Sets the target velocity value of the specified drive. */
    SetDriveTargetVelocity(axis: ArticulationDriveAxis, value: number): void;
    SetJointAccelerations(accelerations: CSArray<number>): void;
    SetJointForces(forces: CSArray<number>): void;
    SetJointPositions(positions: CSArray<number>): void;
    SetJointVelocities(velocities: CSArray<number>): void;
    /** Forces an articulation body to sleep. */
    Sleep(): void;
    /** Snap the anchor to the closest contact between the connected bodies. */
    SnapAnchorToClosestContact(): void;
    /** Teleport the root body of the articulation to a new pose. */
    TeleportRoot(position: Vector3, rotation: Quaternion): void;
    /** Forces an articulation body to wake up. */
    WakeUp(): void;

}
    
interface ArticulationDrive {
    lowerLimit: number;
    upperLimit: number;
    stiffness: number;
    damping: number;
    forceLimit: number;
    target: number;
    targetVelocity: number;
    driveType: ArticulationDriveType;



}
    
interface ArticulationReducedSpace {
    dofCount: number;
    Item: number;



}
    
interface ArticulationReducedSpaceConstructor {

    new(a: number): ArticulationReducedSpace;
    new(a: number, b: number): ArticulationReducedSpace;
    new(a: number, b: number, c: number): ArticulationReducedSpace;


}
declare const ArticulationReducedSpace: ArticulationReducedSpaceConstructor;
    
interface ArticulationBodyConstructor {

    new(): ArticulationBody;


}
declare const ArticulationBody: ArticulationBodyConstructor;
    
interface Bounds {
    center: Vector3;
    size: Vector3;
    extents: Vector3;
    min: Vector3;
    max: Vector3;


    /** The closest point on the bounding box. */
    ClosestPoint(point: Vector3): Vector3;
    /** Is point contained in the bounding box? */
    Contains(point: Vector3): boolean;
    /** Grows the Bounds to include the point. */
    Encapsulate(point: Vector3): void;
    /** Grow the bounds to encapsulate the bounds. */
    Encapsulate(bounds: Bounds): void;
    Equals(other: unknown): boolean;
    Equals(other: Bounds): boolean;
    /** Expand the bounds by increasing its size by amount along each side. */
    Expand(amount: number): void;
    /** Expand the bounds by increasing its size by amount along each side. */
    Expand(amount: Vector3): void;
    GetHashCode(): number;
    /** Does ray intersect this bounding box? */
    IntersectRay(ray: Ray): boolean;
    /** Does ray intersect this bounding box? */
    IntersectRay(ray: Ray, distance: unknown): boolean;
    /** Does another bounding box intersect with this bounding box? */
    Intersects(bounds: Bounds): boolean;
    /** Sets the bounds to the min and max value of the box. */
    SetMinMax(min: Vector3, max: Vector3): void;
    /** The smallest squared distance between the point and this bounding box. */
    SqrDistance(point: Vector3): number;
    /** Returns a formatted string for the bounds. */
    ToString(): string;
    /** Returns a formatted string for the bounds. */
    ToString(format: string): string;
    /** Returns a formatted string for the bounds. */
    ToString(format: string, formatProvider: unknown): string;

}
    
interface BoundsConstructor {

    new(center: Vector3, size: Vector3): Bounds;


}
declare const Bounds: BoundsConstructor;
    
interface GeometryHolder {
    Type: GeometryType;


    /** Return the specified geometric shape stored inside this Geometry Holder object. */
    As<T>(): T;

}
    
interface GeometryHolderConstructor {

    new(): GeometryHolder;


    Create<T>(geometry: T): GeometryHolder;
}
declare const GeometryHolder: GeometryHolderConstructor;
    
interface PhysicMaterial extends Object {
    bounciness: number;
    dynamicFriction: number;
    staticFriction: number;
    frictionCombine: PhysicMaterialCombine;
    bounceCombine: PhysicMaterialCombine;
    bouncyness: number;
    frictionDirection2: Vector3;
    dynamicFriction2: number;
    staticFriction2: number;
    frictionDirection: Vector3;



}
    
interface PhysicMaterialConstructor {

    new(): PhysicMaterial;
    new(name: string): PhysicMaterial;


}
declare const PhysicMaterial: PhysicMaterialConstructor;
    
    
    
    
    
interface PhysicsScene {


    /** Casts the box along a ray and returns detailed information on what was hit. */
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown): boolean;
    /** Casts the box along a ray and returns detailed information on what was hit. */
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>): number;
    /** Casts a capsule against all colliders in this physics scene and returns detailed information on what was hit. */
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    /** Casts a capsule against all colliders in this physics scene and returns detailed information on what was hit. */
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    Equals(other: unknown): boolean;
    Equals(other: PhysicsScene): boolean;
    GetHashCode(): number;
    /** Interpolates Rigidbodies in this PhysicsScene. */
    InterpolateBodies(): void;
    /** Gets whether the physics Scene is empty or not. */
    IsEmpty(): boolean;
    /** Gets whether the physics Scene is valid or not. */
    IsValid(): boolean;
    /** Find all colliders touching or inside of the given box, and store them into the buffer. */
    OverlapBox(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapBox(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>): number;
    /** Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer. */
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    /** Computes and stores colliders touching or inside the sphere into the provided buffer. */
    OverlapSphere(position: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene. */
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene. */
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene. */
    Raycast(origin: Vector3, direction: Vector3, raycastHits: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    /** Resets the Transform positions of interpolated and extrapolated Rigidbodies in this PhysicsScene to Rigidbody.position and Transform rotations to Rigidbody.rotation. */
    ResetInterpolationPoses(): void;
    /** Runs specified physics simulation stages on this physics scene. */
    RunSimulationStages(step: number, stages: SimulationStage, options: SimulationOption): void;
    /** Simulate physics associated with this PhysicsScene. */
    Simulate(step: number): void;
    /** Casts a sphere along a ray and returns detailed information on what was hit. */
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    /** Cast sphere along the direction and store the results into buffer. */
    SphereCast(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    ToString(): string;

}
    
    
interface Physics2D {



}
    
interface PhysicsScene2D {
    subStepCount: number;
    subStepLostTime: number;


    /** Casts a box against colliders in the PhysicsScene2D, returning the first intersection only. */
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    /** Casts a box against colliders in the PhysicsScene2D, returning the first intersection only. */
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    /** Casts a box against the colliders in the PhysicsScene2D, returning all intersections. */
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    /** Casts a box against the colliders in the PhysicsScene2D, returning all intersections. */
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    /** Casts a capsule against colliders in the PhysicsScene2D, returning the first intersection only. */
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    /** Casts a capsule against colliders in the PhysicsScene2D, returning the first intersection only. */
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    /** Casts a capsule against the Colliders in the PhysicsScene2D, returning all intersections. */
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    /** Casts a capsule against the Colliders in the PhysicsScene2D, returning all intersections. */
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    /** Casts a circle against colliders in the PhysicsScene2D, returning the first intersection only. */
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    /** Casts a circle against colliders in the PhysicsScene2D, returning the first intersection only. */
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    /** Casts a circle against the colliders in the PhysicsScene2D, returning all intersections. */
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    /** Casts a circle against the colliders in the PhysicsScene2D, returning all intersections. */
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Equals(other: unknown): boolean;
    Equals(other: PhysicsScene2D): boolean;
    GetHashCode(): number;
    /** Cast a 3D ray against the 2D Colliders in the Scene. */
    GetRayIntersection(ray: Ray, distance: number, layerMask: number): RaycastHit2D;
    /** Cast a 3D ray against the 2D Colliders in the Scene. */
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    /** Determines whether the physics Scene is empty or not. */
    IsEmpty(): boolean;
    /** Determines whether the physics Scene is valid or not. */
    IsValid(): boolean;
    /** Casts a line segment against colliders in the PhysicsScene2D, returning the first intersection only. */
    Linecast(start: Vector2, end: Vector2, layerMask: number): RaycastHit2D;
    /** Casts a line segment against colliders in the PhysicsScene2D, returning the first intersection only. */
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D): RaycastHit2D;
    /** Casts a line segment against colliders in the PhysicsScene2D. */
    Linecast(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number): number;
    /** Casts a line segment against colliders in the PhysicsScene2D. */
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    /** Checks an area (non-rotated box) against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number): Collider2D;
    /** Checks an area (non-rotated box) against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D): Collider2D;
    /** Checks an area (non-rotated box) against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapArea(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    /** Checks an area (non-rotated box) against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    /** Checks a box against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number): Collider2D;
    /** Checks a box against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D): Collider2D;
    /** Checks a box against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapBox(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    /** Checks a box against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    /** Checks a capsule against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): Collider2D;
    /** Checks a capsule against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D): Collider2D;
    /** Checks a capsule against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    /** Checks a capsule against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    /** Checks a circle against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapCircle(point: Vector2, radius: number, layerMask: number): Collider2D;
    /** Checks a circle against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D): Collider2D;
    /** Checks a circle against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapCircle(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number): number;
    /** Checks a circle against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    /** Checks a point against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapPoint(point: Vector2, layerMask: number): Collider2D;
    /** Checks a point against Colliders in the PhysicsScene2D, returning the first intersection only. */
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D): Collider2D;
    /** Checks a point against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapPoint(point: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    /** Checks a point against Colliders in the PhysicsScene2D, returning all intersections. */
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    /** Casts a ray against colliders in the PhysicsScene2D, returning the first intersection only. */
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    /** Casts a ray against colliders in the PhysicsScene2D, returning the first intersection only. */
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    /** Casts a ray against colliders the PhysicsScene2D, returning all intersections. */
    Raycast(origin: Vector2, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    /** Casts a ray against colliders the PhysicsScene2D, returning all intersections. */
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Simulate(deltaTime: number): boolean;
    /** Simulate physics associated with this PhysicsScene. */
    Simulate(deltaTime: number, simulationLayers: number): boolean;
    ToString(): string;

}
    
interface RaycastHit2D {
    centroid: Vector2;
    point: Vector2;
    normal: Vector2;
    distance: number;
    fraction: number;
    collider: Collider2D;
    rigidbody: Rigidbody2D;
    transform: Transform;


    CompareTo(other: RaycastHit2D): number;

}
    
interface Collider2D extends Behaviour {
    density: number;
    isTrigger: boolean;
    usedByEffector: boolean;
    compositeOperation: CompositeOperation;
    compositeOrder: number;
    composite: CompositeCollider2D;
    offset: Vector2;
    attachedRigidbody: Rigidbody2D;
    localToWorldMatrix: Matrix4x4;
    shapeCount: number;
    bounds: Bounds;
    errorState: ColliderErrorState2D;
    compositeCapable: boolean;
    sharedMaterial: PhysicsMaterial2D;
    layerOverridePriority: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    forceSendLayers: LayerMask;
    forceReceiveLayers: LayerMask;
    contactCaptureLayers: LayerMask;
    callbackLayers: LayerMask;
    friction: number;
    bounciness: number;
    usedByComposite: boolean;


    Cast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    /** Casts the Collider shape into the Scene starting at the Collider position ignoring the Collider itself. */
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    /** Casts the Collider shape into the Scene starting at the Collider position ignoring the Collider itself. */
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(position: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(position: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    /** Returns a point on the perimeter of this Collider that is closest to the specified position. */
    ClosestPoint(position: Vector2): Vector2;
    CreateMesh(useBodyPosition: boolean, useBodyRotation: boolean): Mesh;
    /** Creates a planar Mesh that is identical to the area defined by the Collider2D geometry. */
    CreateMesh(useBodyPosition: boolean, useBodyRotation: boolean, useDelaunay: boolean): Mesh;
    /** Calculates the minimum separation of this collider against another collider. */
    Distance(collider: Collider2D): ColliderDistance2D;
    /** A valid collider must be provided for the ColliderDistance2D to be valid.  If there are any problems with collider or this Collider2D such as they are disabled or do not contain any collision shapes then the separation will be invalid as indicated by ColliderDistance2D.isValid. */
    Distance(thisPosition: Vector2, thisAngle: number, collider: Collider2D, position: Vector2, angle: number): ColliderDistance2D;
    /** Retrieves all contact points for this Collider. */
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    /** Retrieves all contact points for this Collider, with the results filtered by the contactFilter. */
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    /** Retrieves all colliders in contact with this Collider. */
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    /** Retrieves all colliders in contact with this Collider, with the results filtered by the contactFilter. */
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetShapeBounds(bounds: CSArray<Bounds>, useRadii: boolean, useWorldSpace: boolean): Bounds;
    /** Generates a simple hash value based upon the geometry of the Collider2D. */
    GetShapeHash(): number;
    /** Gets all the PhysicsShape2D used by the Collider2D. */
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    /** Gets the specified range of the PhysicsShape2D used by the Collider2D. */
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D, shapeIndex: number, shapeCount: number): number;
    /** Check whether this collider is touching the collider or not. */
    IsTouching(collider: Collider2D): boolean;
    /** Check whether this collider is touching the collider or not with the results filtered by the contactFilter. */
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    /** Check whether this collider is touching other colliders or not with the results filtered by the contactFilter. */
    IsTouching(contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(): boolean;
    /** Checks whether this collider is touching any colliders on the specified layerMask or not. */
    IsTouchingLayers(layerMask: number): boolean;
    /** Get a list of all colliders that overlap this collider. */
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(results: CSArray<Collider2D>): number;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    /** Check if a collider overlaps a point in space. */
    OverlapPoint(point: Vector2): boolean;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    /** Casts a ray into the Scene that starts at the Collider position and ignores the Collider itself. */
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    /** Casts a ray into the Scene that starts at the Collider position and ignores the Collider itself. */
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;

}
    
interface CompositeCollider2D extends Collider2D {
    geometryType: GeometryType;
    generationType: GenerationType;
    useDelaunayMesh: boolean;
    vertexDistance: number;
    edgeRadius: number;
    offsetDistance: number;
    pathCount: number;
    pointCount: number;


    /** Regenerates the Composite Collider geometry. */
    GenerateGeometry(): void;
    GetCompositedColliders(colliders: CSArray<Collider2D>): number;
    /** Gets a path from the Collider by its index. */
    GetPath(index: number, points: CSArray<Vector2>): number;
    GetPath(index: number, points: CSArray<Vector2>): number;
    /** Gets the number of points in the specified path from the Collider by its index. */
    GetPathPointCount(index: number): number;

}
    
interface CompositeCollider2DConstructor {

    new(): CompositeCollider2D;


}
declare const CompositeCollider2D: CompositeCollider2DConstructor;
    
interface Rigidbody2D extends Component {
    position: Vector2;
    rotation: number;
    velocity: Vector2;
    velocityX: number;
    velocityY: number;
    angularVelocity: number;
    useAutoMass: boolean;
    mass: number;
    sharedMaterial: PhysicsMaterial2D;
    centerOfMass: Vector2;
    worldCenterOfMass: Vector2;
    inertia: number;
    drag: number;
    angularDrag: number;
    gravityScale: number;
    bodyType: RigidbodyType2D;
    useFullKinematicContacts: boolean;
    isKinematic: boolean;
    freezeRotation: boolean;
    constraints: RigidbodyConstraints2D;
    simulated: boolean;
    interpolation: RigidbodyInterpolation2D;
    sleepMode: RigidbodySleepMode2D;
    collisionDetectionMode: CollisionDetectionMode2D;
    attachedColliderCount: number;
    totalForce: Vector2;
    totalTorque: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    localToWorldMatrix: Matrix4x4;
    fixedAngle: boolean;


    AddForce(force: Vector2): void;
    /** Apply a force to the rigidbody. */
    AddForce(force: Vector2, mode: ForceMode2D): void;
    AddForceAtPosition(force: Vector2, position: Vector2): void;
    /** Apply a force at a given position in space. */
    AddForceAtPosition(force: Vector2, position: Vector2, mode: ForceMode2D): void;
    /** Adds a force to the X component of the Rigidbody2D.velocity|velocity only leaving the Y component of the world space Rigidbody2D.velocity|velocity untouched. */
    AddForceX(force: number, mode: ForceMode2D): void;
    /** Adds a force to the Y component of the Rigidbody2D.velocity|velocity only leaving the X component of the world space Rigidbody2D.velocity|velocity untouched. */
    AddForceY(force: number, mode: ForceMode2D): void;
    AddRelativeForce(relativeForce: Vector2): void;
    /** Adds a force to the local space Rigidbody2D.velocity|velocity. In other words, the force is applied in the rotated coordinate space of the Rigidbody2D. */
    AddRelativeForce(relativeForce: Vector2, mode: ForceMode2D): void;
    /** Adds a force to the X component of the Rigidbody2D.velocity|velocity in the local space of the Rigidbody2D only leaving the Y component of the local space Rigidbody2D.velocity|velocity untouched. */
    AddRelativeForceX(force: number, mode: ForceMode2D): void;
    /** Adds a force to the Y component of the Rigidbody2D.velocity|velocity in the local space of the Rigidbody2D only leaving the X component of the local space Rigidbody2D.velocity|velocity untouched. */
    AddRelativeForceY(force: number, mode: ForceMode2D): void;
    AddTorque(torque: number): void;
    /** Apply a torque at the rigidbody&#x27;s centre of mass. */
    AddTorque(torque: number, mode: ForceMode2D): void;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    /** All the Collider2D shapes attached to the Rigidbody2D are cast into the Scene starting at each Collider position ignoring the Colliders attached to the same Rigidbody2D. */
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    /** All the Collider2D shapes attached to the Rigidbody2D are cast into the Scene starting at each Collider position ignoring the Colliders attached to the same Rigidbody2D. */
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(position: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(position: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    /** Returns a point on the perimeter of all enabled Colliders attached to this Rigidbody that is closest to the specified position. */
    ClosestPoint(position: Vector2): Vector2;
    /** Calculates the minimum distance of this collider against all Collider2D attached to this Rigidbody2D. */
    Distance(collider: Collider2D): ColliderDistance2D;
    /** Calculates the minimum distance of this collider against all Collider2D attached to this Rigidbody2D. */
    Distance(thisPosition: Vector2, thisAngle: number, collider: Collider2D, position: Vector2, angle: number): ColliderDistance2D;
    GetAttachedColliders(results: CSArray<Collider2D>): number;
    GetAttachedColliders(results: CSArray<Collider2D>): number;
    /** Returns all Collider2D that are attached to this Rigidbody2D. */
    GetAttachedColliders(results: CSArray<Collider2D>, findTriggers: boolean): number;
    GetAttachedColliders(results: CSArray<Collider2D>, findTriggers: boolean): number;
    /** Retrieves all contact points for all of the Collider(s) attached to this Rigidbody. */
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    /** Retrieves all contact points for all of the Collider(s) attached to this Rigidbody, with the results filtered by the ContactFilter2D. */
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    /** Retrieves all Colliders in contact with any of the Collider(s) attached to this Rigidbody. */
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    /** Retrieves all Colliders in contact with any of the Collider(s) attached to this rigidbody, with the results filtered by the ContactFilter2D. */
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    /** Get a local space point given the point point in rigidBody global space. */
    GetPoint(point: Vector2): Vector2;
    /** The velocity of the rigidbody at the point Point in global space. */
    GetPointVelocity(point: Vector2): Vector2;
    /** Get a global space point given the point relativePoint in rigidBody local space. */
    GetRelativePoint(relativePoint: Vector2): Vector2;
    /** The velocity of the rigidbody at the point Point in local space. */
    GetRelativePointVelocity(relativePoint: Vector2): Vector2;
    /** Get a global space vector given the vector relativeVector in rigidBody local space. */
    GetRelativeVector(relativeVector: Vector2): Vector2;
    /** Gets all the PhysicsShape2D used by all Collider2D attached to the Rigidbody2D. */
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    /** Get a local space vector given the vector vector in rigidBody global space. */
    GetVector(vector: Vector2): Vector2;
    /** Is the rigidbody &quot;awake&quot;? */
    IsAwake(): boolean;
    /** Is the rigidbody &quot;sleeping&quot;? */
    IsSleeping(): boolean;
    /** Checks whether the collider  is touching any of the collider(s) attached to this rigidbody or not. */
    IsTouching(collider: Collider2D): boolean;
    /** Checks whether the collider  is touching any of the collider(s) attached to this rigidbody or not with the results filtered by the ContactFilter2D. */
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    /** Checks whether any collider is touching any of the collider(s) attached to this rigidbody or not with the results filtered by the ContactFilter2D. */
    IsTouching(contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(): boolean;
    /** Checks whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified layerMask or not. */
    IsTouchingLayers(layerMask: number): boolean;
    /** Moves the rigidbody to position. */
    MovePosition(position: Vector2): void;
    /** Moves the rigidbody position to position and the rigidbody angle to angle. */
    MovePositionAndRotation(position: Vector2, angle: number): void;
    /** Moves the rigidbody position to position and the rigidbody angle to rotation. */
    MovePositionAndRotation(position: Vector2, rotation: Quaternion): void;
    /** Rotates the Rigidbody to angle (given in degrees). */
    MoveRotation(angle: number): void;
    /** An overload of MoveRotation that allows a full 3D rotation as an argument. */
    MoveRotation(rotation: Quaternion): void;
    /** Get a list of all Colliders that overlap all Colliders attached to this Rigidbody2D filtered by the contactFilter. */
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(results: CSArray<Collider2D>): number;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    /** Check if any of the Rigidbody2D colliders overlap a point in space. */
    OverlapPoint(point: Vector2): boolean;
    /** Sets the rotation of the Rigidbody2D to angle (given in degrees). */
    SetRotation(angle: number): void;
    /** Sets the rotation of the Rigidbody2D to the z-axis rotation extracted from the full 3D rotation. */
    SetRotation(rotation: Quaternion): void;
    /** Make the rigidbody &quot;sleep&quot;. */
    Sleep(): void;
    Slide(velocity: Vector2, deltaTime: number, slideMovement: SlideMovement): SlideResults;
    /** Disables the &quot;sleeping&quot; state of a rigidbody. */
    WakeUp(): void;

}
    
interface PhysicsMaterial2D extends Object {
    bounciness: number;
    friction: number;



}
    
interface PhysicsMaterial2DConstructor {

    new(): PhysicsMaterial2D;
    new(name: string): PhysicsMaterial2D;


}
declare const PhysicsMaterial2D: PhysicsMaterial2DConstructor;
    
interface ContactFilter2D {
    useTriggers: boolean;
    useLayerMask: boolean;
    useDepth: boolean;
    useOutsideDepth: boolean;
    useNormalAngle: boolean;
    useOutsideNormalAngle: boolean;
    layerMask: LayerMask;
    minDepth: number;
    maxDepth: number;
    minNormalAngle: number;
    maxNormalAngle: number;
    isFiltering: boolean;


    /** Turns off depth filtering by setting useDepth to false.  The associated values of minDepth and maxDepth are not changed. */
    ClearDepth(): void;
    /** Turns off layer mask filtering by setting useLayerMask to false.  The associated value of layerMask is not changed. */
    ClearLayerMask(): void;
    /** Turns off normal angle filtering by setting useNormalAngle to false. The associated values of minNormalAngle and maxNormalAngle are not changed. */
    ClearNormalAngle(): void;
    /** Checks if the Transform for obj is within the depth range to be filtered. */
    IsFilteringDepth(obj: GameObject): boolean;
    /** Checks if the GameObject.layer for obj is included in the layerMask to be filtered. */
    IsFilteringLayerMask(obj: GameObject): boolean;
    /** Checks if the angle of normal is within the normal angle range to be filtered. */
    IsFilteringNormalAngle(normal: Vector2): boolean;
    /** Checks if the angle is within the normal angle range to be filtered. */
    IsFilteringNormalAngle(angle: number): boolean;
    /** Checks if the collider is a trigger and should be filtered by the useTriggers to be filtered. */
    IsFilteringTrigger(collider: Collider2D): boolean;
    /** Sets the contact filter to not filter any ContactPoint2D. */
    NoFilter(): ContactFilter2D;
    /** Sets the minDepth and maxDepth filter properties and turns on depth filtering by setting useDepth to true. */
    SetDepth(minDepth: number, maxDepth: number): void;
    /** Sets the layerMask filter property using the layerMask parameter provided and also enables layer mask filtering by setting useLayerMask to true. */
    SetLayerMask(layerMask: LayerMask): void;
    /** Sets the minNormalAngle and maxNormalAngle filter properties and turns on normal angle filtering by setting useNormalAngle to true. */
    SetNormalAngle(minNormalAngle: number, maxNormalAngle: number): void;

}
    
interface ContactFilter2DConstructor {
    NormalAngleUpperLimit: number;



}
declare const ContactFilter2D: ContactFilter2DConstructor;
    
interface ColliderDistance2D {
    pointA: Vector2;
    pointB: Vector2;
    normal: Vector2;
    distance: number;
    isOverlapped: boolean;
    isValid: boolean;



}
    
interface ContactPoint2D {
    point: Vector2;
    normal: Vector2;
    separation: number;
    normalImpulse: number;
    tangentImpulse: number;
    relativeVelocity: Vector2;
    collider: Collider2D;
    otherCollider: Collider2D;
    rigidbody: Rigidbody2D;
    otherRigidbody: Rigidbody2D;
    enabled: boolean;



}
    
interface PhysicsShapeGroup2D {
    shapeCount: number;
    vertexCount: number;
    localToWorldMatrix: Matrix4x4;


    /** Adds a copy of all the PhysicsShape2D and their geometry from the specified physicsShapeGroup into this shape group. The specified physicsShapeGroup is not modified. */
    Add(physicsShapeGroup: PhysicsShapeGroup2D): void;
    /** Adds a box shape (PhysicsShapeType2D.Polygon) to the shape group. */
    AddBox(center: Vector2, size: Vector2, angle: number, edgeRadius: number): number;
    /** Adds a capsule shape (PhysicsShapeType2D.Capsule) to the shape group. */
    AddCapsule(vertex0: Vector2, vertex1: Vector2, radius: number): number;
    /** Adds a circle shape (PhysicsShapeType2D.Circle) to the shape group. */
    AddCircle(center: Vector2, radius: number): number;
    AddEdges(vertices: CSArray<Vector2>, edgeRadius: number): number;
    AddEdges(vertices: CSArray<Vector2>, useAdjacentStart: boolean, useAdjacentEnd: boolean, adjacentStart: Vector2, adjacentEnd: Vector2, edgeRadius: number): number;
    AddPolygon(vertices: CSArray<Vector2>): number;
    /** Clears all the vertices and shapes from the PhysicsShapeGroup. */
    Clear(): void;
    /** When destroying a shape at the specified shapeIndex, all other shapes that exist above the specified shapeIndex will have their shape indices updated appropriately. */
    DeleteShape(shapeIndex: number): void;
    /** Gets the PhysicsShape2D stored at the specified shapeIndex. */
    GetShape(shapeIndex: number): PhysicsShape2D;
    GetShapeData(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;
    GetShapeData(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;
    /** Gets a single vertex of a shape. The vertex index is zero-based with the shape having a quantity of vertex specified by PhysicsShape2D.vertexCount. */
    GetShapeVertex(shapeIndex: number, vertexIndex: number): Vector2;
    GetShapeVertices(shapeIndex: number, vertices: CSArray<Vector2>): void;
    /** Sets the adjacent vertices of a shape. */
    SetShapeAdjacentVertices(shapeIndex: number, useAdjacentStart: boolean, useAdjacentEnd: boolean, adjacentStart: Vector2, adjacentEnd: Vector2): void;
    /** Sets the radius of a shape. */
    SetShapeRadius(shapeIndex: number, radius: number): void;
    /** Sets a single vertex of a shape. */
    SetShapeVertex(shapeIndex: number, vertexIndex: number, vertex: Vector2): void;

}
    
interface PhysicsShape2D {
    shapeType: PhysicsShapeType2D;
    radius: number;
    vertexStartIndex: number;
    vertexCount: number;
    useAdjacentStart: boolean;
    useAdjacentEnd: boolean;
    adjacentStart: Vector2;
    adjacentEnd: Vector2;



}
    
interface PhysicsShapeGroup2DConstructor {

    new(shapeCapacity: number, vertexCapacity: number): PhysicsShapeGroup2D;


}
declare const PhysicsShapeGroup2D: PhysicsShapeGroup2DConstructor;
    
interface SlideResults {
    remainingVelocity: Vector2;
    position: Vector2;
    iterationsUsed: number;
    slideHit: RaycastHit2D;
    surfaceHit: RaycastHit2D;



}
    
interface SlideMovement {
    maxIterations: number;
    surfaceSlideAngle: number;
    gravitySlipAngle: number;
    surfaceUp: Vector2;
    surfaceAnchor: Vector2;
    gravity: Vector2;
    startPosition: Vector2;
    selectedCollider: Collider2D;
    layerMask: LayerMask;
    useLayerMask: boolean;
    useStartPosition: boolean;
    useNoMove: boolean;
    useSimulationMove: boolean;
    useAttachedTriggers: boolean;


    SetLayerMask(mask: LayerMask): void;
    SetStartPosition(position: Vector2): void;

}
    
interface SlideMovementConstructor {

    new(): SlideMovement;


}
declare const SlideMovement: SlideMovementConstructor;
    
interface Rigidbody2DConstructor {

    new(): Rigidbody2D;


}
declare const Rigidbody2D: Rigidbody2DConstructor;
    
interface Mesh extends Object {
    uv1: CSArray<Vector2>;
    indexFormat: IndexFormat;
    vertexBufferCount: number;
    vertexBufferTarget: Target;
    indexBufferTarget: Target;
    blendShapeCount: number;
    bindposeCount: number;
    bindposes: CSArray<Matrix4x4>;
    isReadable: boolean;
    vertexCount: number;
    subMeshCount: number;
    bounds: Bounds;
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    tangents: CSArray<Vector4>;
    uv: CSArray<Vector2>;
    uv2: CSArray<Vector2>;
    uv3: CSArray<Vector2>;
    uv4: CSArray<Vector2>;
    uv5: CSArray<Vector2>;
    uv6: CSArray<Vector2>;
    uv7: CSArray<Vector2>;
    uv8: CSArray<Vector2>;
    colors: CSArray<Color>;
    colors32: CSArray<Color32>;
    vertexAttributeCount: number;
    triangles: CSArray<number>;
    boneWeights: CSArray<BoneWeight>;
    skinWeightBufferLayout: SkinWeights;


    /** Adds a new blend shape frame. */
    AddBlendShapeFrame(shapeName: string, frameWeight: number, deltaVertices: CSArray<Vector3>, deltaNormals: CSArray<Vector3>, deltaTangents: CSArray<Vector3>): void;
    /** Clears all vertex data and all triangle indices. */
    Clear(keepVertexLayout: boolean): void;
    Clear(): void;
    /** Clears all blend shapes from Mesh. */
    ClearBlendShapes(): void;
    /** Combines several Meshes into this Mesh. */
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean, useMatrices: boolean, hasLightmapData: boolean): void;
    /** Combines several Meshes into this Mesh. */
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean, useMatrices: boolean): void;
    /** Combines several Meshes into this Mesh. */
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean): void;
    /** Combines several Meshes into this Mesh. */
    CombineMeshes(combine: CSArray<CombineInstance>): void;
    /** Gets the bone weights for the Mesh. */
    GetAllBoneWeights(): CSArray<BoneWeight1>;
    /** Gets the base vertex index of the given sub-mesh. */
    GetBaseVertex(submesh: number): number;
    /** Gets the bind poses of the Mesh. */
    GetBindposes(): CSArray<Matrix4x4>;
    GetBindposes(bindposes: CSArray<Matrix4x4>): void;
    /** Retrieves a GraphicsBuffer that provides direct read and write access to GPU blend shape vertex data. */
    GetBlendShapeBuffer(layout: BlendShapeBufferLayout): GraphicsBuffer;
    /** Retrieves a GraphicsBuffer that provides direct read and write access to GPU blend shape vertex data. */
    GetBlendShapeBuffer(): GraphicsBuffer;
    /** Get the location of blend shape vertex data for a given blend shape. */
    GetBlendShapeBufferRange(blendShapeIndex: number): BlendShapeBufferRange;
    /** Returns the frame count for a blend shape. */
    GetBlendShapeFrameCount(shapeIndex: number): number;
    /** Retreives deltaVertices, deltaNormals and deltaTangents of a blend shape frame. */
    GetBlendShapeFrameVertices(shapeIndex: number, frameIndex: number, deltaVertices: CSArray<Vector3>, deltaNormals: CSArray<Vector3>, deltaTangents: CSArray<Vector3>): void;
    /** Returns the weight of a blend shape frame. */
    GetBlendShapeFrameWeight(shapeIndex: number, frameIndex: number): number;
    /** Returns index of BlendShape by given name. */
    GetBlendShapeIndex(blendShapeName: string): number;
    /** Returns name of BlendShape by given index. */
    GetBlendShapeName(shapeIndex: number): string;
    /** The number of non-zero bone weights for each vertex. */
    GetBonesPerVertex(): CSArray<number>;
    /** Retrieves a GraphicsBuffer that provides direct read and write access to GPU bone weight data. */
    GetBoneWeightBuffer(layout: SkinWeights): GraphicsBuffer;
    GetBoneWeights(boneWeights: CSArray<BoneWeight>): void;
    GetColors(colors: CSArray<Color>): void;
    GetColors(colors: CSArray<Color32>): void;
    /** Retrieves a GraphicsBuffer to the GPU index buffer. */
    GetIndexBuffer(): GraphicsBuffer;
    /** Gets the index count of the given sub-mesh. */
    GetIndexCount(submesh: number): number;
    /** Gets the starting index location within the Mesh&#x27;s index buffer, for the given sub-mesh. */
    GetIndexStart(submesh: number): number;
    /** Fetches the index list for the specified sub-mesh. */
    GetIndices(submesh: number): CSArray<number>;
    /** Fetches the index list for the specified sub-mesh. */
    GetIndices(submesh: number, applyBaseVertex: boolean): CSArray<number>;
    GetIndices(indices: CSArray<number>, submesh: number): void;
    GetIndices(indices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetIndices(indices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    /** Retrieves a native (underlying graphics API) pointer to the index buffer. */
    GetNativeIndexBufferPtr(): unknown;
    /** Retrieves a native (underlying graphics API) pointer to the vertex buffer. */
    GetNativeVertexBufferPtr(index: number): unknown;
    GetNormals(normals: CSArray<Vector3>): void;
    /** Get information about a sub-mesh of the Mesh. */
    GetSubMesh(index: number): SubMeshDescriptor;
    GetTangents(tangents: CSArray<Vector4>): void;
    /** Gets the topology of a sub-mesh. */
    GetTopology(submesh: number): MeshTopology;
    /** Fetches the triangle list for the specified sub-mesh on this object. */
    GetTriangles(submesh: number): CSArray<number>;
    /** Fetches the triangle list for the specified sub-mesh on this object. */
    GetTriangles(submesh: number, applyBaseVertex: boolean): CSArray<number>;
    GetTriangles(triangles: CSArray<number>, submesh: number): void;
    GetTriangles(triangles: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetTriangles(triangles: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    /** The UV distribution metric can be used to calculate the desired mipmap level based on the position of the camera. */
    GetUVDistributionMetric(uvSetIndex: number): number;
    GetUVs(channel: number, uvs: CSArray<Vector2>): void;
    GetUVs(channel: number, uvs: CSArray<Vector3>): void;
    GetUVs(channel: number, uvs: CSArray<Vector4>): void;
    /** Returns information about a vertex attribute based on its index. */
    GetVertexAttribute(index: number): VertexAttributeDescriptor;
    /** Get dimension of a specific vertex data attribute on this Mesh. */
    GetVertexAttributeDimension(attr: VertexAttribute): number;
    /** Get format of a specific vertex data attribute on this Mesh. */
    GetVertexAttributeFormat(attr: VertexAttribute): VertexAttributeFormat;
    /** Get offset within a vertex buffer stream of a specific vertex data attribute on this Mesh. */
    GetVertexAttributeOffset(attr: VertexAttribute): number;
    /** Get information about vertex attributes of a Mesh. */
    GetVertexAttributes(): CSArray<VertexAttributeDescriptor>;
    /** Get information about vertex attributes of a Mesh, without memory allocations. */
    GetVertexAttributes(attributes: CSArray<VertexAttributeDescriptor>): number;
    GetVertexAttributes(attributes: CSArray<VertexAttributeDescriptor>): number;
    /** Gets the vertex buffer stream index of a specific vertex data attribute on this Mesh. */
    GetVertexAttributeStream(attr: VertexAttribute): number;
    /** Retrieves a GraphicsBuffer that provides direct acces to the GPU vertex buffer. */
    GetVertexBuffer(index: number): GraphicsBuffer;
    /** Get vertex buffer stream stride in bytes. */
    GetVertexBufferStride(stream: number): number;
    GetVertices(vertices: CSArray<Vector3>): void;
    /** Checks if a specific vertex data attribute exists on this Mesh. */
    HasVertexAttribute(attr: VertexAttribute): boolean;
    /** Optimize mesh for frequent updates. */
    MarkDynamic(): void;
    /** Notify Renderer components of mesh geometry change. */
    MarkModified(): void;
    /** Optimizes the Mesh data to improve rendering performance. */
    Optimize(): void;
    /** Optimizes the geometry of the Mesh to improve rendering performance. */
    OptimizeIndexBuffers(): void;
    /** Optimizes the vertices of the Mesh to improve rendering performance. */
    OptimizeReorderVertexBuffer(): void;
    RecalculateBounds(): void;
    /** Recalculate the bounding volume of the Mesh and all of its sub-meshes with the vertex data. */
    RecalculateBounds(flags: MeshUpdateFlags): void;
    RecalculateNormals(): void;
    /** Recalculates the normals of the Mesh from the triangles and vertices. */
    RecalculateNormals(flags: MeshUpdateFlags): void;
    RecalculateTangents(): void;
    /** Recalculates the tangents of the Mesh from the normals and texture coordinates. */
    RecalculateTangents(flags: MeshUpdateFlags): void;
    /** Recalculates the UV distribution metric of the Mesh from the vertices and uv coordinates. */
    RecalculateUVDistributionMetric(uvSetIndex: number, uvAreaThreshold: number): void;
    /** Recalculates the UV distribution metrics of the Mesh from the vertices and uv coordinates. */
    RecalculateUVDistributionMetrics(uvAreaThreshold: number): void;
    SetBindposes(poses: CSArray<Matrix4x4>): void;
    SetBoneWeights(bonesPerVertex: CSArray<number>, weights: CSArray<BoneWeight1>): void;
    SetColors(inColors: CSArray<Color>): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Set the per-vertex colors of the Mesh. */
    SetColors(inColors: CSArray<Color>): void;
    /** Sets the per-vertex colors of the Mesh, using a part of the input array. */
    SetColors(inColors: CSArray<Color>, start: number, length: number): void;
    /** Sets the per-vertex colors of the Mesh, using a part of the input array. */
    SetColors(inColors: CSArray<Color>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color32>): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Set the per-vertex colors of the Mesh. */
    SetColors(inColors: CSArray<Color32>): void;
    /** Sets the per-vertex colors of the Mesh, using a part of the input array. */
    SetColors(inColors: CSArray<Color32>, start: number, length: number): void;
    /** Sets the per-vertex colors of the Mesh, using a part of the input array. */
    SetColors(inColors: CSArray<Color32>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors<T>(inColors: CSArray<T>): void;
    SetColors<T>(inColors: CSArray<T>, start: number, length: number): void;
    SetColors<T>(inColors: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    /** Sets the index buffer size and format. */
    SetIndexBufferParams(indexCount: number, format: IndexFormat): void;
    /** Sets the index buffer for the sub-mesh. */
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number): void;
    /** Sets the index buffer for the sub-mesh. */
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean): void;
    /** Sets the index buffer for the sub-mesh. */
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    /** Sets the index buffer of a sub-mesh, using a part of the input array. */
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    /** Sets the index buffer for the sub-mesh. */
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    /** Sets the index buffer of a sub-mesh, using a part of the input array. */
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices<T>(indices: CSArray<T>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices<T>(indices: CSArray<T>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetNormals(inNormals: CSArray<Vector3>): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Set the normals of the Mesh. */
    SetNormals(inNormals: CSArray<Vector3>): void;
    /** Sets the vertex normals of the Mesh, using a part of the input array. */
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number): void;
    /** Sets the vertex normals of the Mesh, using a part of the input array. */
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetNormals<T>(inNormals: CSArray<T>): void;
    SetNormals<T>(inNormals: CSArray<T>, start: number, length: number): void;
    SetNormals<T>(inNormals: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Sets the information about a sub-mesh of the Mesh. */
    SetSubMesh(index: number, desc: SubMeshDescriptor, flags: MeshUpdateFlags): void;
    /** Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes. */
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, start: number, count: number, flags: MeshUpdateFlags): void;
    /** Sets information defining all sub-meshes in this Mesh, replacing any existing sub-meshes. */
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, flags: MeshUpdateFlags): void;
    SetSubMeshes<T>(desc: CSArray<T>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes<T>(desc: CSArray<T>, flags: MeshUpdateFlags): void;
    SetTangents(inTangents: CSArray<Vector4>): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Set the tangents of the Mesh. */
    SetTangents(inTangents: CSArray<Vector4>): void;
    /** Sets the tangents of the Mesh, using a part of the input array. */
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number): void;
    /** Sets the tangents of the Mesh, using a part of the input array. */
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTangents<T>(inTangents: CSArray<T>): void;
    SetTangents<T>(inTangents: CSArray<T>, start: number, length: number): void;
    SetTangents<T>(inTangents: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Sets the triangle list for the sub-mesh. */
    SetTriangles(triangles: CSArray<number>, submesh: number): void;
    /** Sets the triangle list for the sub-mesh. */
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean): void;
    /** Sets the triangle list for the sub-mesh. */
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    /** Sets the triangle list of the Mesh, using a part of the input array. */
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    /** Sets the triangle list for the sub-mesh. */
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    /** Sets the triangle list of the Mesh, using a part of the input array. */
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Sets the texture coordinates (UVs) stored in a given channel. */
    SetUVs(channel: number, uvs: CSArray<Vector2>): void;
    /** Sets the texture coordinates (UVs) stored in a given channel. */
    SetUVs(channel: number, uvs: CSArray<Vector3>): void;
    /** Sets the texture coordinates (UVs) stored in a given channel. */
    SetUVs(channel: number, uvs: CSArray<Vector4>): void;
    /** Sets the UVs of the Mesh, using a part of the input array. */
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number): void;
    /** Sets the UVs of the Mesh, using a part of the input array. */
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Sets the UVs of the Mesh, using a part of the input array. */
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number): void;
    /** Sets the UVs of the Mesh, using a part of the input array. */
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Sets the UVs of the Mesh, using a part of the input array. */
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number): void;
    /** Sets the UVs of the Mesh, using a part of the input array. */
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>, start: number, length: number): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    /** Sets the vertex buffer size and layout. */
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertices(inVertices: CSArray<Vector3>): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Assigns a new vertex positions array. */
    SetVertices(inVertices: CSArray<Vector3>): void;
    /** Sets the vertex positions of the Mesh, using a part of the input array. */
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number): void;
    /** Sets the vertex positions of the Mesh, using a part of the input array. */
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertices<T>(inVertices: CSArray<T>): void;
    SetVertices<T>(inVertices: CSArray<T>, start: number, length: number): void;
    SetVertices<T>(inVertices: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    /** Upload previously done Mesh modifications to the graphics API. */
    UploadMeshData(markNoLongerReadable: boolean): void;

}
    
    
    
interface Color32 {
    r: number;
    g: number;
    b: number;
    a: number;
    Item: number;


    /** Returns a formatted string for this color. */
    ToString(): string;
    /** Returns a formatted string for this color. */
    ToString(format: string): string;
    /** Returns a formatted string for this color. */
    ToString(format: string, formatProvider: unknown): string;

}
    
interface Color32Constructor {

    new(r: number, g: number, b: number, a: number): Color32;


    Lerp(a: Color32, b: Color32, t: number): Color32;
    LerpUnclamped(a: Color32, b: Color32, t: number): Color32;
}
declare const Color32: Color32Constructor;
    
interface BoneWeight {
    weight0: number;
    weight1: number;
    weight2: number;
    weight3: number;
    boneIndex0: number;
    boneIndex1: number;
    boneIndex2: number;
    boneIndex3: number;


    Equals(other: unknown): boolean;
    Equals(other: BoneWeight): boolean;
    GetHashCode(): number;

}
    
interface CombineInstance {
    mesh: Mesh;
    subMeshIndex: number;
    transform: Matrix4x4;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;



}
    
interface BoneWeight1 {
    weight: number;
    boneIndex: number;


    Equals(other: unknown): boolean;
    Equals(other: BoneWeight1): boolean;
    GetHashCode(): number;

}
    
interface GraphicsBuffer {
    count: number;
    stride: number;
    target: Target;
    usageFlags: UsageFlags;
    bufferHandle: GraphicsBufferHandle;
    name: string;


    Dispose(): void;
    /** Read data values from the buffer into an array. The array can only use &amp;lt;a href&#x3D;&quot;https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types&quot;&amp;gt;blittable&amp;lt;a&amp;gt; types. */
    GetData(data: unknown): void;
    /** Read data values from the buffer into an array. The array can only use &amp;lt;a href&#x3D;&quot;https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types&quot;&amp;gt;blittable&amp;lt;a&amp;gt; types. */
    GetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    /** Retrieve a native (underlying graphics API) pointer to the buffer. */
    GetNativeBufferPtr(): unknown;
    /** Returns true if this graphics buffer is valid, or false otherwise. */
    IsValid(): boolean;
    /** Begins a write operation to the buffer */
    LockBufferForWrite<T>(bufferStartIndex: number, count: number): CSArray<T>;
    /** Release a Graphics Buffer. */
    Release(): void;
    /** Sets counter value of append/consume buffer. */
    SetCounterValue(counterValue: number): void;
    /** Set the buffer with values from an array. */
    SetData(data: unknown): void;
    SetData<T>(data: CSArray<T>): void;
    SetData<T>(data: CSArray<T>): void;
    /** Partial copy of data values from an array into the buffer. */
    SetData(data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    /** Ends a write operation to the buffer */
    UnlockBufferAfterWrite<T>(countWritten: number): void;

}
    
interface GraphicsBufferHandle {
    value: number;


    CompareTo(other: GraphicsBufferHandle): number;
    Equals(obj: unknown): boolean;
    Equals(other: GraphicsBufferHandle): boolean;
    GetHashCode(): number;

}
    
interface ComputeBuffer {
    count: number;
    stride: number;
    name: string;


    /** Begins a write operation to the buffer */
    BeginWrite<T>(computeBufferStartIndex: number, count: number): CSArray<T>;
    Dispose(): void;
    /** Ends a write operation to the buffer */
    EndWrite<T>(countWritten: number): void;
    /** Read data values from the buffer into an array. The array can only use &amp;lt;a href&#x3D;&quot;https:docs.microsoft.comen-usdotnetframeworkinteropblittable-and-non-blittable-types&quot;&amp;gt;blittable&amp;lt;a&amp;gt; types. */
    GetData(data: unknown): void;
    /** Partial read of data values from the buffer into an array. */
    GetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    /** Retrieve a native (underlying graphics API) pointer to the buffer. */
    GetNativeBufferPtr(): unknown;
    /** Returns true if this compute buffer is valid and false otherwise. */
    IsValid(): boolean;
    /** Release a Compute Buffer. */
    Release(): void;
    /** Sets counter value of append/consume buffer. */
    SetCounterValue(counterValue: number): void;
    /** Set the buffer with values from an array. */
    SetData(data: unknown): void;
    SetData<T>(data: CSArray<T>): void;
    SetData<T>(data: CSArray<T>): void;
    /** Partial copy of data values from an array into the buffer. */
    SetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, nativeBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;

}
    
interface ComputeBufferConstructor {

    new(count: number, stride: number): ComputeBuffer;
    new(count: number, stride: number, type: ComputeBufferType): ComputeBuffer;
    new(count: number, stride: number, type: ComputeBufferType, usage: ComputeBufferMode): ComputeBuffer;


    CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
}
declare const ComputeBuffer: ComputeBufferConstructor;
    
interface GraphicsBufferConstructor {

    new(target: Target, count: number, stride: number): GraphicsBuffer;
    new(target: Target, usageFlags: UsageFlags, count: number, stride: number): GraphicsBuffer;


    CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCount(src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCount(src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyCount(src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
}
declare const GraphicsBuffer: GraphicsBufferConstructor;
    
interface BlendShapeBufferRange {
    startIndex: number;
    endIndex: number;



}
    
interface SubMeshDescriptor {
    bounds: Bounds;
    topology: MeshTopology;
    indexStart: number;
    indexCount: number;
    baseVertex: number;
    firstVertex: number;
    vertexCount: number;


    ToString(): string;

}
    
interface SubMeshDescriptorConstructor {

    new(indexStart: number, indexCount: number, topology: MeshTopology): SubMeshDescriptor;


}
declare const SubMeshDescriptor: SubMeshDescriptorConstructor;
    
interface VertexAttributeDescriptor {
    attribute: VertexAttribute;
    format: VertexAttributeFormat;
    dimension: number;
    stream: number;


    Equals(other: unknown): boolean;
    Equals(other: VertexAttributeDescriptor): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface VertexAttributeDescriptorConstructor {

    new(attribute: VertexAttribute, format: VertexAttributeFormat, dimension: number, stream: number): VertexAttributeDescriptor;


}
declare const VertexAttributeDescriptor: VertexAttributeDescriptorConstructor;
    
interface MeshDataArray {
    Length: number;
    Item: MeshData;


    Dispose(): void;

}
    
interface MeshData {
    vertexCount: number;
    vertexBufferCount: number;
    indexFormat: IndexFormat;
    subMeshCount: number;


    GetColors(outColors: CSArray<Color>): void;
    GetColors(outColors: CSArray<Color32>): void;
    GetIndexData<T>(): CSArray<T>;
    GetIndices(outIndices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetIndices(outIndices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetNormals(outNormals: CSArray<Vector3>): void;
    GetSubMesh(index: number): SubMeshDescriptor;
    GetTangents(outTangents: CSArray<Vector4>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector2>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector3>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector4>): void;
    GetVertexAttributeDimension(attr: VertexAttribute): number;
    GetVertexAttributeFormat(attr: VertexAttribute): VertexAttributeFormat;
    GetVertexAttributeOffset(attr: VertexAttribute): number;
    GetVertexAttributeStream(attr: VertexAttribute): number;
    GetVertexBufferStride(stream: number): number;
    GetVertexData<T>(stream: number): CSArray<T>;
    GetVertices(outVertices: CSArray<Vector3>): void;
    HasVertexAttribute(attr: VertexAttribute): boolean;
    SetIndexBufferParams(indexCount: number, format: IndexFormat): void;
    SetSubMesh(index: number, desc: SubMeshDescriptor, flags: MeshUpdateFlags): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;

}
    
interface MeshConstructor {

    new(): Mesh;


    AcquireReadOnlyMeshData(mesh: Mesh): MeshDataArray;
    AcquireReadOnlyMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AcquireReadOnlyMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AllocateWritableMeshData(meshCount: number): MeshDataArray;
    AllocateWritableMeshData(mesh: Mesh): MeshDataArray;
    AllocateWritableMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AllocateWritableMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, mesh: Mesh, flags: MeshUpdateFlags): void;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, meshes: CSArray<Mesh>, flags: MeshUpdateFlags): void;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, meshes: CSArray<Mesh>, flags: MeshUpdateFlags): void;
}
declare const Mesh: MeshConstructor;
    
interface Collider2DConstructor {

    new(): Collider2D;


}
declare const Collider2D: Collider2DConstructor;
    
interface PhysicsScene2DConstructor {



    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(position: Vector2, angle: number, collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapCollider(position: Vector2, angle: number, collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
}
declare const PhysicsScene2D: PhysicsScene2DConstructor;
    
interface PhysicsJobOptions2D {
    useMultithreading: boolean;
    useConsistencySorting: boolean;
    interpolationPosesPerJob: number;
    newContactsPerJob: number;
    collideContactsPerJob: number;
    clearFlagsPerJob: number;
    clearBodyForcesPerJob: number;
    syncDiscreteFixturesPerJob: number;
    syncContinuousFixturesPerJob: number;
    findNearestContactsPerJob: number;
    updateTriggerContactsPerJob: number;
    islandSolverCostThreshold: number;
    islandSolverBodyCostScale: number;
    islandSolverContactCostScale: number;
    islandSolverJointCostScale: number;
    islandSolverBodiesPerJob: number;
    islandSolverContactsPerJob: number;



}
    
interface Physics2DConstructor {
    IgnoreRaycastLayer: number;
    DefaultRaycastLayers: number;
    AllLayers: number;
    MaxPolygonShapeVertices: number;
    defaultPhysicsScene: PhysicsScene2D;
    velocityIterations: number;
    positionIterations: number;
    gravity: Vector2;
    queriesHitTriggers: boolean;
    queriesStartInColliders: boolean;
    callbacksOnDisable: boolean;
    reuseCollisionCallbacks: boolean;
    autoSyncTransforms: boolean;
    simulationMode: SimulationMode2D;
    simulationLayers: LayerMask;
    useSubStepping: boolean;
    useSubStepContacts: boolean;
    minSubStepFPS: number;
    maxSubStepCount: number;
    jobOptions: PhysicsJobOptions2D;
    bounceThreshold: number;
    maxLinearCorrection: number;
    maxAngularCorrection: number;
    maxTranslationSpeed: number;
    maxRotationSpeed: number;
    defaultContactOffset: number;
    baumgarteScale: number;
    baumgarteTOIScale: number;
    timeToSleep: number;
    linearSleepTolerance: number;
    angularSleepTolerance: number;
    raycastsHitTriggers: boolean;
    raycastsStartInColliders: boolean;
    deleteStopsCallbacks: boolean;
    changeStopsCallbacks: boolean;
    minPenetrationForPenalty: number;
    velocityThreshold: number;
    autoSimulation: boolean;
    colliderAwakeColor: Color;
    colliderAsleepColor: Color;
    colliderContactColor: Color;
    colliderAABBColor: Color;
    contactArrowScale: number;
    alwaysShowColliders: boolean;
    showCollidersFilled: boolean;
    showColliderSleep: boolean;
    showColliderContacts: boolean;
    showColliderAABB: boolean;

    new(): Physics2D;


    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>): number;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>): number;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>): number;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    ClosestPoint(position: Vector2, collider: Collider2D): Vector2;
    ClosestPoint(position: Vector2, rigidbody: Rigidbody2D): Vector2;
    Distance(colliderA: Collider2D, colliderB: Collider2D): ColliderDistance2D;
    Distance(colliderA: Collider2D, positionA: Vector2, angleA: number, colliderB: Collider2D, positionB: Vector2, angleB: number): ColliderDistance2D;
    GetContacts(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetIgnoreCollision(collider1: Collider2D, collider2: Collider2D): boolean;
    GetIgnoreLayerCollision(layer1: number, layer2: number): boolean;
    GetLayerCollisionMask(layer: number): number;
    GetRayIntersection(ray: Ray): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number, layerMask: number): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    GetRayIntersectionAll(ray: Ray): CSArray<RaycastHit2D>;
    GetRayIntersectionAll(ray: Ray, distance: number): CSArray<RaycastHit2D>;
    GetRayIntersectionAll(ray: Ray, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    GetRayIntersectionNonAlloc(ray: Ray, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    GetRayIntersectionNonAlloc(ray: Ray, results: CSArray<RaycastHit2D>): number;
    GetRayIntersectionNonAlloc(ray: Ray, results: CSArray<RaycastHit2D>, distance: number): number;
    IgnoreCollision(collider1: Collider2D, collider2: Collider2D): void;
    IgnoreCollision(collider1: Collider2D, collider2: Collider2D, ignore: boolean): void;
    IgnoreLayerCollision(layer1: number, layer2: number): void;
    IgnoreLayerCollision(layer1: number, layer2: number, ignore: boolean): void;
    IsTouching(collider1: Collider2D, collider2: Collider2D): boolean;
    IsTouching(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(collider: Collider2D): boolean;
    IsTouchingLayers(collider: Collider2D, layerMask: number): boolean;
    Linecast(start: Vector2, end: Vector2): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number, minDepth: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    LinecastAll(start: Vector2, end: Vector2): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    LinecastNonAlloc(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>): number;
    LinecastNonAlloc(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number): number;
    LinecastNonAlloc(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number, minDepth: number): number;
    LinecastNonAlloc(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapArea(pointA: Vector2, pointB: Vector2): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapAreaNonAlloc(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>): number;
    OverlapAreaNonAlloc(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapAreaNonAlloc(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapAreaNonAlloc(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapBoxNonAlloc(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>): number;
    OverlapBoxNonAlloc(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapBoxNonAlloc(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapBoxNonAlloc(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapCapsuleNonAlloc(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>): number;
    OverlapCapsuleNonAlloc(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCapsuleNonAlloc(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapCapsuleNonAlloc(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapCircle(point: Vector2, radius: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number, minDepth: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircleAll(point: Vector2, radius: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapCircleNonAlloc(point: Vector2, radius: number, results: CSArray<Collider2D>): number;
    OverlapCircleNonAlloc(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCircleNonAlloc(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapCircleNonAlloc(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number, minDepth: number): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPointAll(point: Vector2): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapPointNonAlloc(point: Vector2, results: CSArray<Collider2D>): number;
    OverlapPointNonAlloc(point: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapPointNonAlloc(point: Vector2, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapPointNonAlloc(point: Vector2, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    Raycast(origin: Vector2, direction: Vector2): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    RaycastAll(origin: Vector2, direction: Vector2): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>): number;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    SetLayerCollisionMask(layer: number, layerMask: number): void;
    Simulate(deltaTime: number): boolean;
    Simulate(deltaTime: number, simulationLayers: number): boolean;
    SyncTransforms(): void;
}
declare const Physics2D: Physics2DConstructor;
    
interface MonoBehaviour extends Behaviour {
    destroyCancellationToken: unknown;
    useGUILayout: boolean;
    didStart: boolean;
    didAwake: boolean;
    runInEditMode: boolean;


    /** Cancels all Invoke calls on this MonoBehaviour. */
    CancelInvoke(): void;
    /** Cancels all Invoke calls with name methodName on this behaviour. */
    CancelInvoke(methodName: string): void;
    /** Invokes the method methodName in time seconds. */
    Invoke(methodName: string, time: number): void;
    /** Invokes the method methodName in time seconds, then repeatedly every repeatRate seconds. */
    InvokeRepeating(methodName: string, time: number, repeatRate: number): void;
    /** Is any invoke pending on this MonoBehaviour? */
    IsInvoking(): boolean;
    /** Is any invoke on methodName pending? */
    IsInvoking(methodName: string): boolean;
    /** Starts a coroutine named methodName. */
    StartCoroutine(methodName: string): Coroutine;
    /** Starts a coroutine named methodName. */
    StartCoroutine(methodName: string, value: unknown): Coroutine;
    /** Starts a Coroutine. */
    StartCoroutine(routine: unknown): Coroutine;
    StartCoroutine_Auto(routine: unknown): Coroutine;
    /** Stops all coroutines running on this behaviour. */
    StopAllCoroutines(): void;
    /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour. */
    StopCoroutine(routine: unknown): void;
    /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour. */
    StopCoroutine(routine: Coroutine): void;
    /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour. */
    StopCoroutine(methodName: string): void;

}
    
interface YieldInstruction {



}
    
interface YieldInstructionConstructor {

    new(): YieldInstruction;


}
declare const YieldInstruction: YieldInstructionConstructor;
    
interface Coroutine extends YieldInstruction {



}
    
interface MonoBehaviourConstructor {

    new(): MonoBehaviour;


    print(message: unknown): void;
}
declare const MonoBehaviour: MonoBehaviourConstructor;
    
interface Debug {



}
    
interface StartupLog {
    timestamp: number;
    logType: LogType;
    message: string;



}
    
interface DebugConstructor {
    unityLogger: unknown;
    developerConsoleEnabled: boolean;
    developerConsoleVisible: boolean;
    isDebugBuild: boolean;
    logger: unknown;

    new(): Debug;


    Assert(condition: boolean): void;
    Assert(condition: boolean, context: Object): void;
    Assert(condition: boolean, message: unknown): void;
    Assert(condition: boolean, message: string): void;
    Assert(condition: boolean, message: unknown, context: Object): void;
    Assert(condition: boolean, message: string, context: Object): void;
    Assert(condition: boolean, format: string, args: CSArray<unknown>): void;
    AssertFormat(condition: boolean, format: string, args: CSArray<unknown>): void;
    AssertFormat(condition: boolean, context: Object, format: string, args: CSArray<unknown>): void;
    Break(): void;
    ClearDeveloperConsole(): void;
    DebugBreak(): void;
    DrawLine(start: Vector3, end: Vector3, color: Color, duration: number): void;
    DrawLine(start: Vector3, end: Vector3, color: Color): void;
    DrawLine(start: Vector3, end: Vector3): void;
    DrawLine(start: Vector3, end: Vector3, color: Color, duration: number, depthTest: boolean): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color): void;
    DrawRay(start: Vector3, dir: Vector3): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number, depthTest: boolean): void;
    ExtractStackTraceNoAlloc(buffer: unknown, bufferMax: number, projectFolder: string): number;
    Log(message: unknown): void;
    Log(message: unknown, context: Object): void;
    LogAssertion(message: unknown): void;
    LogAssertion(message: unknown, context: Object): void;
    LogAssertionFormat(format: string, args: CSArray<unknown>): void;
    LogAssertionFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogError(message: unknown): void;
    LogError(message: unknown, context: Object): void;
    LogErrorFormat(format: string, args: CSArray<unknown>): void;
    LogErrorFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogException(exception: unknown): void;
    LogException(exception: unknown, context: Object): void;
    LogFormat(format: string, args: CSArray<unknown>): void;
    LogFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogFormat(logType: LogType, logOptions: LogOption, context: Object, format: string, args: CSArray<unknown>): void;
    LogWarning(message: unknown): void;
    LogWarning(message: unknown, context: Object): void;
    LogWarningFormat(format: string, args: CSArray<unknown>): void;
    LogWarningFormat(context: Object, format: string, args: CSArray<unknown>): void;
    RetrieveStartupLogs(): CSArray<StartupLog>;
}
declare const Debug: DebugConstructor;
    
interface Sprite extends Object {
    bounds: Bounds;
    rect: Rect;
    border: Vector4;
    texture: Texture2D;
    pixelsPerUnit: number;
    spriteAtlasTextureScale: number;
    associatedAlphaSplitTexture: Texture2D;
    pivot: Vector2;
    packed: boolean;
    packingMode: SpritePackingMode;
    packingRotation: SpritePackingRotation;
    textureRect: Rect;
    textureRectOffset: Vector2;
    vertices: CSArray<Vector2>;
    triangles: CSArray<number>;
    uv: CSArray<Vector2>;


    /** Adds a ScriptableObject reference to the sprite. */
    AddScriptableObject(obj: ScriptableObject): boolean;
    GetPhysicsShape(shapeIdx: number, physicsShape: CSArray<Vector2>): number;
    /** The number of physics shapes for the Sprite. */
    GetPhysicsShapeCount(): number;
    /** Retrieves the number of points in the selected physics shape for the sprite. */
    GetPhysicsShapePointCount(shapeIdx: number): number;
    /** Retrieves an array of ScriptableObject referenced by the sprite. */
    GetScriptableObjects(scriptableObjects: CSArray<ScriptableObject>): number;
    /** Gets the number of ScriptableObject that the sprite references. */
    GetScriptableObjectsCount(): number;
    /** Gets the number of Secondary Textures that the Sprite is using. */
    GetSecondaryTextureCount(): number;
    /** Retrieves an array of SecondarySpriteTexture used by the Sprite. */
    GetSecondaryTextures(secondaryTexture: CSArray<SecondarySpriteTexture>): number;
    /** Sets up new Sprite geometry. */
    OverrideGeometry(vertices: CSArray<Vector2>, triangles: CSArray<number>): void;
    OverridePhysicsShape(physicsShapes: CSArray<CSArray<Vector2>>): void;
    /** Removes the ScriptableObject reference from the sprite. */
    RemoveScriptableObjectAt(i: number): boolean;
    /** Replace the ScriptableObject reference from the sprite. */
    SetScriptableObjectAt(obj: ScriptableObject, i: number): boolean;

}
    
interface Rect {
    x: number;
    y: number;
    position: Vector2;
    center: Vector2;
    min: Vector2;
    max: Vector2;
    width: number;
    height: number;
    size: Vector2;
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
    left: number;
    right: number;
    top: number;
    bottom: number;


    /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work. */
    Contains(point: Vector2): boolean;
    /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work. */
    Contains(point: Vector3): boolean;
    /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work. */
    Contains(point: Vector3, allowInverse: boolean): boolean;
    Equals(other: unknown): boolean;
    Equals(other: Rect): boolean;
    GetHashCode(): number;
    /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work. */
    Overlaps(other: Rect): boolean;
    /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work. */
    Overlaps(other: Rect, allowInverse: boolean): boolean;
    /** Set components of an existing Rect. */
    Set(x: number, y: number, width: number, height: number): void;
    /** Returns a formatted string for this Rect. */
    ToString(): string;
    /** Returns a formatted string for this Rect. */
    ToString(format: string): string;
    /** Returns a formatted string for this Rect. */
    ToString(format: string, formatProvider: unknown): string;

}
    
interface RectConstructor {
    zero: Rect;

    new(x: number, y: number, width: number, height: number): Rect;
    new(position: Vector2, size: Vector2): Rect;
    new(source: Rect): Rect;


    MinMaxRect(xmin: number, ymin: number, xmax: number, ymax: number): Rect;
    NormalizedToPoint(rectangle: Rect, normalizedRectCoordinates: Vector2): Vector2;
    PointToNormalized(rectangle: Rect, point: Vector2): Vector2;
}
declare const Rect: RectConstructor;
    
interface Texture extends Object {
    mipmapCount: number;
    graphicsFormat: GraphicsFormat;
    width: number;
    height: number;
    dimension: TextureDimension;
    isReadable: boolean;
    wrapMode: TextureWrapMode;
    wrapModeU: TextureWrapMode;
    wrapModeV: TextureWrapMode;
    wrapModeW: TextureWrapMode;
    filterMode: FilterMode;
    anisoLevel: number;
    mipMapBias: number;
    texelSize: Vector2;
    updateCount: number;
    isDataSRGB: boolean;
    imageContentsHash: Hash128;
    graphicsTexture: GraphicsTexture;


    GetNativeTextureID(): number;
    /** Retrieve a native (underlying graphics API) pointer to the Texture resource. */
    GetNativeTexturePtr(): unknown;
    /** Increment the update counter. */
    IncrementUpdateCount(): void;

}
    
interface Hash128 {
    isValid: boolean;


    /** Hash new input string and combine with the current hash value. */
    Append(data: string): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(val: unknown): void;
    /** Hash new input data and combine with the current hash value. */
    Append(val: number): void;
    /** Hash new input data and combine with the current hash value. */
    Append(val: number): void;
    /** Hash new input data and combine with the current hash value. */
    Append(data: unknown, size: number): void;
    CompareTo(rhs: Hash128): number;
    CompareTo(obj: unknown): number;
    Equals(obj: unknown): boolean;
    Equals(obj: Hash128): boolean;
    GetHashCode(): number;
    /** Convert a Hash128 to string. */
    ToString(): string;

}
    
interface Hash128Constructor {

    new(u32_0: number, u32_1: number, u32_2: number, u32_3: number): Hash128;
    new(u64_0: number, u64_1: number): Hash128;


    Compute(data: string): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(val: unknown): Hash128;
    Compute(val: number): Hash128;
    Compute(val: number): Hash128;
    Compute(data: unknown, size: number): Hash128;
    Parse(hashString: string): Hash128;
}
declare const Hash128: Hash128Constructor;
    
interface GraphicsTexture {
    descriptor: GraphicsTextureDescriptor;
    state: GraphicsTextureState;


    Dispose(): void;

}
    
interface GraphicsTextureDescriptor {
    width: number;
    height: number;
    depth: number;
    arrayLength: number;
    format: GraphicsFormat;
    dimension: TextureDimension;
    mipCount: number;
    numSamples: number;
    flags: GraphicsTextureDescriptorFlags;



}
    
interface GraphicsTextureConstructor {
    active: GraphicsTexture;

    new(desc: GraphicsTextureDescriptor): GraphicsTexture;


}
declare const GraphicsTexture: GraphicsTextureConstructor;
    
interface TextureConstructor {
    GenerateAllMips: number;
    masterTextureLimit: number;
    globalMipmapLimit: number;
    anisotropicFiltering: AnisotropicFiltering;
    totalTextureMemory: number;
    desiredTextureMemory: number;
    targetTextureMemory: number;
    currentTextureMemory: number;
    nonStreamingTextureMemory: number;
    streamingMipmapUploadCount: number;
    streamingRendererCount: number;
    streamingTextureCount: number;
    nonStreamingTextureCount: number;
    streamingTexturePendingLoadCount: number;
    streamingTextureLoadingCount: number;
    streamingTextureForceLoadAll: boolean;
    streamingTextureDiscardUnusedMips: boolean;
    allowThreadedTextureCreation: boolean;



    SetGlobalAnisotropicFilteringLimits(forcedMin: number, globalMax: number): void;
    SetStreamingTextureMaterialDebugProperties(): void;
}
declare const Texture: TextureConstructor;
    
interface Texture2D extends Texture {
    format: TextureFormat;
    mipmapLimitGroup: string;
    activeMipmapLimit: number;
    isReadable: boolean;
    vtOnly: boolean;
    streamingMipmaps: boolean;
    streamingMipmapsPriority: number;
    requestedMipmapLevel: number;
    minimumMipmapLevel: number;
    calculatedMipmapLevel: number;
    desiredMipmapLevel: number;
    loadingMipmapLevel: number;
    loadedMipmapLevel: number;
    alphaIsTransparency: boolean;
    ignoreMipmapLimit: boolean;


    /** Copies changes you&#x27;ve made in a CPU texture to the GPU. */
    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    /** Resets the minimumMipmapLevel field. */
    ClearMinimumMipmapLevel(): void;
    /** Resets the requestedMipmapLevel field. */
    ClearRequestedMipmapLevel(): void;
    /** Compress texture at runtime to DXT/BCn or ETC formats. */
    Compress(highQuality: boolean): void;
    /** Gets the pixel color at coordinates (x, y). */
    GetPixel(x: number, y: number): Color;
    /** Gets the pixel color at coordinates (x, y). */
    GetPixel(x: number, y: number, mipLevel: number): Color;
    /** Gets the filtered pixel color at the normalized coordinates (u, v). */
    GetPixelBilinear(u: number, v: number): Color;
    /** Gets the filtered pixel color at the normalized coordinates (u, v). */
    GetPixelBilinear(u: number, v: number, mipLevel: number): Color;
    /** Gets the raw data from a texture. */
    GetPixelData<T>(mipLevel: number): CSArray<T>;
    /** Gets the pixel color data for part of a mipmap level as Color structs. */
    GetPixels(x: number, y: number, blockWidth: number, blockHeight: number, miplevel: number): CSArray<Color>;
    /** Gets the pixel color data for part of a mipmap level as Color structs. */
    GetPixels(x: number, y: number, blockWidth: number, blockHeight: number): CSArray<Color>;
    /** Gets the pixel color data for a mipmap level as Color structs. */
    GetPixels(miplevel: number): CSArray<Color>;
    GetPixels(): CSArray<Color>;
    /** Gets the pixel color data for a mipmap level as Color32 structs. */
    GetPixels32(miplevel: number): CSArray<Color32>;
    GetPixels32(): CSArray<Color32>;
    /** Gets the raw data from a texture, as a copy. */
    GetRawTextureData(): CSArray<number>;
    /** Gets the raw data from a texture, as a copy. */
    GetRawTextureData<T>(): CSArray<T>;
    /** Checks to see whether the mipmap level set by requestedMipmapLevel has finished loading. */
    IsRequestedMipmapLevelLoaded(): boolean;
    /** Sets the raw data of an entire texture in CPU memory. */
    LoadRawTextureData(data: unknown, size: number): void;
    /** Sets the raw data of an entire texture in CPU memory. */
    LoadRawTextureData(data: CSArray<number>): void;
    LoadRawTextureData<T>(data: CSArray<T>): void;
    /** Packs multiple Textures into a texture atlas. */
    PackTextures(textures: CSArray<Texture2D>, padding: number, maximumAtlasSize: number, makeNoLongerReadable: boolean): CSArray<Rect>;
    PackTextures(textures: CSArray<Texture2D>, padding: number, maximumAtlasSize: number): CSArray<Rect>;
    PackTextures(textures: CSArray<Texture2D>, padding: number): CSArray<Rect>;
    /** Reads pixels from the current render target and writes them to a texture. */
    ReadPixels(source: Rect, destX: number, destY: number, recalculateMipMaps: boolean): void;
    ReadPixels(source: Rect, destX: number, destY: number): void;
    /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture. */
    Reinitialize(width: number, height: number): boolean;
    /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture. */
    Reinitialize(width: number, height: number, format: TextureFormat, hasMipMap: boolean): boolean;
    /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture. */
    Reinitialize(width: number, height: number, format: GraphicsFormat, hasMipMap: boolean): boolean;
    /** Resizes the texture. */
    Resize(width: number, height: number): boolean;
    /** Resizes the texture. */
    Resize(width: number, height: number, format: TextureFormat, hasMipMap: boolean): boolean;
    Resize(width: number, height: number, format: GraphicsFormat, hasMipMap: boolean): boolean;
    /** Sets the pixel color at coordinates (x,y). */
    SetPixel(x: number, y: number, color: Color): void;
    /** Sets the pixel color at coordinates (x,y). */
    SetPixel(x: number, y: number, color: Color, mipLevel: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    /** Sets the pixel colors of part of a mipmap level. */
    SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color>, miplevel: number): void;
    SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color>): void;
    /** Sets the pixel colors of an entire mipmap level. */
    SetPixels(colors: CSArray<Color>, miplevel: number): void;
    SetPixels(colors: CSArray<Color>): void;
    /** Sets the pixel colors of an entire mipmap level. */
    SetPixels32(colors: CSArray<Color32>, miplevel: number): void;
    /** Sets the pixel colors of an entire mipmap level. */
    SetPixels32(colors: CSArray<Color32>): void;
    /** Sets the pixel colors of part of a mipmap level. */
    SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color32>, miplevel: number): void;
    /** Sets the pixel colors of part of a mipmap level. */
    SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color32>): void;
    /** Updates Unity texture to use different native texture object. */
    UpdateExternalTexture(nativeTex: unknown): void;

}
    
interface Texture2DConstructor {
    whiteTexture: Texture2D;
    blackTexture: Texture2D;
    redTexture: Texture2D;
    grayTexture: Texture2D;
    linearGrayTexture: Texture2D;
    normalTexture: Texture2D;

    new(width: number, height: number, format: DefaultFormat, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, mipmapLimitGroupName: string, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, flags: TextureCreationFlags, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, mipmapLimitGroupName: string, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, flags: TextureCreationFlags, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean, ignoreMipmapLimit: boolean, mipmapLimitGroupName: string): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean, linear: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean, linear: boolean, createUninitialized: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean): Texture2D;
    new(width: number, height: number): Texture2D;


    CreateExternalTexture(width: number, height: number, format: TextureFormat, mipChain: boolean, linear: boolean, nativeTex: unknown): Texture2D;
    GenerateAtlas(sizes: CSArray<Vector2>, padding: number, atlasSize: number, results: CSArray<Rect>): boolean;
}
declare const Texture2D: Texture2DConstructor;
    
interface ScriptableObject extends Object {


    SetDirty(): void;

}
    
interface ScriptableObjectConstructor {

    new(): ScriptableObject;


    CreateInstance(className: string): ScriptableObject;
    CreateInstance(type: unknown): ScriptableObject;
    CreateInstance<T>(): T;
}
declare const ScriptableObject: ScriptableObjectConstructor;
    
interface SecondarySpriteTexture {
    name: string;
    texture: Texture2D;



}
    
interface SpriteConstructor {



    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: boolean): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: boolean, secondaryTextures: CSArray<SecondarySpriteTexture>): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2): Sprite;
}
declare const Sprite: SpriteConstructor;
    
interface TextAsset extends Object {
    bytes: CSArray<number>;
    text: string;
    dataSize: number;


    /** Gets raw text asset data. */
    GetData<T>(): CSArray<T>;
    /** Returns the contents of the TextAsset. */
    ToString(): string;

}
    
interface TextAssetConstructor {

    new(): TextAsset;
    new(text: string): TextAsset;


}
declare const TextAsset: TextAssetConstructor;
    
interface Resources {



}
    
interface AsyncOperation extends YieldInstruction {
    isDone: boolean;
    progress: number;
    priority: number;
    allowSceneActivation: boolean;



}
    
interface AsyncOperationConstructor {

    new(): AsyncOperation;


}
declare const AsyncOperation: AsyncOperationConstructor;
    
interface ResourceRequest extends AsyncOperation {
    asset: Object;



}
    
interface ResourceRequestConstructor {

    new(): ResourceRequest;


}
declare const ResourceRequest: ResourceRequestConstructor;
    
interface ResourcesConstructor {

    new(): Resources;


    FindObjectsOfTypeAll(type: unknown): CSArray<Object>;
    FindObjectsOfTypeAll<T>(): CSArray<T>;
    GetBuiltinResource(type: unknown, path: string): Object;
    GetBuiltinResource<T>(path: string): T;
    InstanceIDIsValid(instanceId: number): boolean;
    InstanceIDsToValidArray(instanceIDs: CSArray<number>, validArray: CSArray<boolean>): void;
    InstanceIDsToValidArray(instanceIDs: unknown, validArray: unknown): void;
    InstanceIDToObject(instanceID: number): Object;
    InstanceIDToObjectList(instanceIDs: CSArray<number>, objects: CSArray<Object>): void;
    Load(path: string): Object;
    Load<T>(path: string): T;
    Load(path: string, systemTypeInstance: unknown): Object;
    LoadAll(path: string, systemTypeInstance: unknown): CSArray<Object>;
    LoadAll(path: string): CSArray<Object>;
    LoadAll<T>(path: string): CSArray<T>;
    LoadAssetAtPath(assetPath: string, type: unknown): Object;
    LoadAssetAtPath<T>(assetPath: string): T;
    LoadAsync(path: string): ResourceRequest;
    LoadAsync<T>(path: string): ResourceRequest;
    LoadAsync(path: string, type: unknown): ResourceRequest;
    UnloadAsset(assetToUnload: Object): void;
    UnloadUnusedAssets(): AsyncOperation;
}
declare const Resources: ResourcesConstructor;
    
interface AgonesCore {



}
    
interface AgonesProxy extends MonoBehaviour {


    Connect(): void;
    Ready(): void;
    Shutdown(): void;

}
    
interface AgonesProxyConstructor {

    new(): AgonesProxy;


}
declare const AgonesProxy: AgonesProxyConstructor;
    
interface AgonesCoreConstructor {
    Agones: AgonesProxy;

    new(): AgonesCore;


    SetAgonesProxy(agones: AgonesProxy): void;
}
declare const AgonesCore: AgonesCoreConstructor;
    
interface RunCore {



}
    
interface RunCoreConstructor {
    launchInDedicatedServerMode: boolean;

    new(): RunCore;


    IsClient(): boolean;
    IsClone(): boolean;
    IsEditor(): boolean;
    IsInternal(): boolean;
    IsServer(): boolean;
    OnLoad(): void;
}
declare const RunCore: RunCoreConstructor;
    
interface NetworkCore {



}
    
interface Net extends MonoBehaviour {


    BroadcastToAllClients(blob: BinaryBlob, reliable: number): void;
    BroadcastToAllExceptClient(ignoredClientId: number, blob: BinaryBlob, reliable: number): void;
    BroadcastToClient(clientId: number, blob: BinaryBlob, reliable: number): void;
    BroadcastToClients(clientIds: CSArray<number>, blob: BinaryBlob, reliable: number): void;
    BroadcastToServer(blob: BinaryBlob, reliable: number): void;

}
    
interface BinaryBlob {
    m_dataSize: number;
    m_data: CSArray<number>;


    GetDictionary(): CSDictionary<unknown, unknown>;

}
    
interface BinaryBlobConstructor {

    new(): BinaryBlob;
    new(bytes: CSArray<number>): BinaryBlob;


}
declare const BinaryBlob: BinaryBlobConstructor;
    
interface NetConstructor {

    new(): Net;


}
declare const Net: NetConstructor;
    
interface NetworkManager extends MonoBehaviour {
    Initialized: boolean;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    ObserverManager: ObserverManager;
    DebugManager: DebugManager;
    StatisticsManager: StatisticsManager;
    ObjectPool: ObjectPool;
    RollbackManager: RollbackManager;
    IsClientOnly: boolean;
    IsServerOnly: boolean;
    IsHost: boolean;
    IsClient: boolean;
    IsServer: boolean;
    IsServerStarted: boolean;
    IsServerOnlyStarted: boolean;
    IsClientStarted: boolean;
    IsClientOnlyStarted: boolean;
    IsHostStarted: boolean;
    IsOffline: boolean;
    SpawnablePrefabs: PrefabObjects;
    RuntimeSpawnablePrefabs: CSDictionary<number, PrefabObjects>;


    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    GetInstance<T>(): T;
    GetPooledInstantiated(prefab: NetworkObject, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: NetworkObject, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: GameObject, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: GameObject, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefabId: number, collectionId: number, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefabId: number, collectionId: number, parent: Transform, position: unknown, rotation: unknown, scale: unknown, makeActive: boolean, asServer: boolean): NetworkObject;
    GetPrefab(prefabId: number, asServer: boolean): NetworkObject;
    GetPrefabIndex(prefab: GameObject, asServer: boolean): number;
    GetPrefabObjects<T>(spawnableCollectionId: number, createIfMissing: boolean): PrefabObjects;
    HasInstance<T>(): boolean;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    RemoveSpawnableCollection(spawnableCollectionId: number): boolean;
    StorePooledInstantiated(instantiated: NetworkObject, asServer: boolean): void;
    TryGetInstance<T>(result: unknown): boolean;
    TryRegisterInstance<T>(component: T): boolean;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;

}
    
interface ServerManager extends MonoBehaviour {
    Clients: CSDictionary<number, NetworkConnection>;
    Started: boolean;
    Objects: ServerObjects;
    NetworkManager: NetworkManager;
    ShareIds: boolean;


    AnyServerStarted(excludedIndex: unknown): boolean;
    Broadcast<T>(connection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(connections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(networkObject: NetworkObject, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(connections: CSArray<NetworkConnection>, excludedConnection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(connections: CSArray<NetworkConnection>, excludedConnections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(excludedConnection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(excludedConnections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Despawn(go: GameObject, despawnType: unknown): void;
    Despawn(networkObject: NetworkObject, despawnType: unknown): void;
    GetAuthenticator(): Authenticator;
    GetStartOnHeadless(): boolean;
    Kick(conn: NetworkConnection, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(clientId: number, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(conn: NetworkConnection, reader: Reader, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    OneServerStarted(): boolean;
    RegisterBroadcast<T>(handler: unknown, requireAuthentication: boolean): void;
    SetAuthenticator(value: Authenticator): void;
    SetFrameRate(value: number): void;
    SetRemoteClientTimeout(timeoutType: RemoteTimeoutType, duration: number): void;
    SetStartOnHeadless(value: boolean): void;
    Spawn(go: GameObject, ownerConnection: NetworkConnection, scene: Scene): void;
    Spawn(nob: NetworkObject, ownerConnection: NetworkConnection, scene: Scene): void;
    StartConnection(): boolean;
    StartConnection(port: number): boolean;
    StopConnection(sendDisconnectMessage: boolean): boolean;
    UnregisterBroadcast<T>(handler: unknown): void;

}
    
interface IResettable {


    InitializeState(): void;
    ResetState(): void;

}
    
interface NetworkConnection extends IResettable {
    ClientId: number;
    Objects: CSArray<NetworkObject>;
    CustomData: unknown;
    LevelOfDetails: CSDictionary<NetworkObject, LevelOfDetailData>;
    NetworkManager: NetworkManager;
    TransportIndex: number;
    IsAuthenticated: boolean;
    Authenticated: boolean;
    IsActive: boolean;
    IsValid: boolean;
    FirstObject: NetworkObject;
    Scenes: CSArray<Scene>;
    Disconnecting: boolean;
    PacketTick: EstimatedTick;
    LocalTick: EstimatedTick;
    ReplicateTick: EstimatedTick;
    IsHost: boolean;
    IsLocalClient: boolean;


    Broadcast<T>(message: T, requireAuthenticated: boolean, channel: Channel): void;
    Disconnect(immediately: boolean): void;
    Equals(obj: unknown): boolean;
    Equals(nc: NetworkConnection): boolean;
    GetAddress(): string;
    GetHashCode(): number;
    InitializeState(): void;
    Kick(kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(reader: Reader, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    LoadedStartScenes(): boolean;
    LoadedStartScenes(asServer: boolean): boolean;
    ResetState(): void;
    SetFirstObject(nob: NetworkObject): void;
    ToString(): string;

}
    
    
interface NetworkObserver extends MonoBehaviour {
    OverrideType: ConditionOverrideType;
    UpdateHostVisibility: boolean;
    ObserverConditions: CSArray<ObserverCondition>;


    GetObserverCondition<T>(): ObserverCondition;
    SetUpdateHostVisibility(value: boolean): void;

}
    
interface ObserverCondition extends ScriptableObject {
    NetworkObject: NetworkObject;


    ConditionMet(connection: NetworkConnection, currentlyAdded: boolean, notProcessed: unknown): boolean;
    Deinitialize(destroyed: boolean): void;
    GetConditionType(): ObserverConditionType;
    GetIsEnabled(): boolean;
    Initialize(networkObject: NetworkObject): void;
    SetIsEnabled(value: boolean): void;

}
    
interface NetworkObserverConstructor {

    new(): NetworkObserver;


}
declare const NetworkObserver: NetworkObserverConstructor;
    
interface NetworkBehaviour extends MonoBehaviour {
    OnStartServerCalled: boolean;
    OnStartClientCalled: boolean;
    IsSpawned: boolean;
    ComponentIndex: number;
    NetworkObject: NetworkObject;
    IsBehaviourReconciling: boolean;
    IsClientOnly: boolean;
    IsServerOnly: boolean;
    IsHost: boolean;
    IsClient: boolean;
    IsServer: boolean;
    IsDeinitializing: boolean;
    NetworkManager: NetworkManager;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    ObserverManager: ObserverManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    PredictionManager: PredictionManager;
    RollbackManager: RollbackManager;
    NetworkObserver: NetworkObserver;
    IsClientInitialized: boolean;
    IsClientStarted: boolean;
    IsClientOnlyInitialized: boolean;
    IsClientOnlyStarted: boolean;
    IsServerInitialized: boolean;
    IsServerStarted: boolean;
    IsServerOnlyInitialized: boolean;
    IsServerOnlyStarted: boolean;
    IsHostInitialized: boolean;
    IsHostStarted: boolean;
    IsOffline: boolean;
    IsNetworked: boolean;
    IsManagerReconciling: boolean;
    Observers: CSArray<NetworkConnection>;
    IsOwner: boolean;
    HasAuthority: boolean;
    IsOwnerOrServer: boolean;
    Owner: NetworkConnection;
    OwnerId: number;
    ObjectId: number;
    LocalConnection: NetworkConnection;


    CanLog(loggingType: LoggingType): boolean;
    ClearBuffedRpcs(): void;
    ClearReplicateCache(): void;
    ClearReplicateCache_Internal<T>(replicatesQueue: unknown, replicatesHistory: CSArray<T>): void;
    CreateReconcile(): void;
    Despawn(go: GameObject, despawnType: unknown): void;
    Despawn(nob: NetworkObject, despawnType: unknown): void;
    Despawn(despawnType: unknown): void;
    GetInstance<T>(): T;
    GiveOwnership(newOwner: NetworkConnection): void;
    NetworkInitializeIfDisabled(): void;
    OnDespawnServer(connection: NetworkConnection): void;
    OnOwnershipClient(prevOwner: NetworkConnection): void;
    OnOwnershipServer(prevOwner: NetworkConnection): void;
    OnSpawnServer(connection: NetworkConnection): void;
    OnStartClient(): void;
    OnStartNetwork(): void;
    OnStartServer(): void;
    OnStopClient(): void;
    OnStopNetwork(): void;
    OnStopServer(): void;
    OwnerMatches(connection: NetworkConnection): boolean;
    ReadPayload(connection: NetworkConnection, reader: Reader): void;
    Reconcile_Client<T, T2>(reconcileDel: unknown, replicatesHistory: CSArray<T2>, data: T): void;
    Reconcile_Reader<T>(reader: PooledReader, data: unknown, channel: Channel): void;
    Reconcile_Server<T>(methodHash: number, data: T, channel: Channel): void;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    RegisterObserversRpc(hash: number, del: ClientRpcDelegate): void;
    RegisterReconcileRpc(hash: number, del: ReconcileRpcDelegate): void;
    RegisterReplicateRpc(hash: number, del: ReplicateRpcDelegate): void;
    RegisterServerRpc(hash: number, del: ServerRpcDelegate): void;
    RegisterTargetRpc(hash: number, del: ClientRpcDelegate): void;
    RemoveOwnership(): void;
    Replicate_Authoritative<T>(del: unknown, methodHash: number, replicatesQueue: unknown, replicatesHistory: CSArray<T>, data: T, channel: Channel): void;
    Replicate_NonAuthoritative<T>(del: unknown, replicatesQueue: unknown, replicatesHistory: CSArray<T>, channel: Channel): void;
    Replicate_Reader<T>(hash: number, reader: PooledReader, sender: NetworkConnection, arrBuffer: CSArray<T>, replicatesQueue: unknown, replicatesHistory: CSArray<T>, channel: Channel): void;
    Replicate_SendNonAuthoritative<T>(hash: number, replicatesQueue: unknown, channel: Channel): void;
    ResetState(asServer: boolean): void;
    ResetSyncVarFields(): void;
    SendObserversRpc(hash: number, methodWriter: PooledWriter, channel: Channel, orderType: DataOrderType, bufferLast: boolean, excludeServer: boolean, excludeOwner: boolean): void;
    SendServerRpc(hash: number, methodWriter: PooledWriter, channel: Channel, orderType: DataOrderType): void;
    SendTargetRpc(hash: number, methodWriter: PooledWriter, channel: Channel, orderType: DataOrderType, target: NetworkConnection, excludeServer: boolean, validateTarget: boolean): void;
    Server_SendReconcileRpc<T>(hash: number, reconcileData: T, channel: Channel): void;
    Spawn(go: GameObject, ownerConnection: NetworkConnection, scene: Scene): void;
    Spawn(nob: NetworkObject, ownerConnection: NetworkConnection, scene: Scene): void;
    ToString(): string;
    TryRegisterInstance<T>(component: T): boolean;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
    WritePayload(connection: NetworkConnection, writer: Writer): void;

}
    
interface ClientManager extends MonoBehaviour {
    Connection: NetworkConnection;
    Clients: CSDictionary<number, NetworkConnection>;
    IsServerDevelopment: boolean;
    Started: boolean;
    Objects: ClientObjects;
    NetworkManager: NetworkManager;
    LevelOfDetailInterval: number;


    Broadcast<T>(message: T, channel: Channel): void;
    GetTransportIndex(): number;
    RegisterBroadcast<T>(handler: unknown): void;
    SetFrameRate(value: number): void;
    SetRemoteServerTimeout(timeoutType: RemoteTimeoutType, duration: number): void;
    StartConnection(): boolean;
    StartConnection(address: string): boolean;
    StartConnection(address: string, port: number): boolean;
    StopConnection(): boolean;
    UnregisterBroadcast<T>(handler: unknown): void;

}
    
interface ManagedObjects {
    Spawned: CSDictionary<number, NetworkObject>;
    SceneObjects: CSDictionary<number, NetworkObject>;



}
    
interface ManagedObjectsConstructor {



    InitializePrefab(prefab: NetworkObject, index: number, collectionId: unknown): void;
}
declare const ManagedObjects: ManagedObjectsConstructor;
    
interface ClientObjects extends ManagedObjects {


    WriteDepawn(nob: NetworkObject, writer: Writer): void;

}
    
interface Writer {
    Position: number;
    Length: number;
    NetworkManager: NetworkManager;
    Capacity: number;


    EnsureBufferCapacity(count: number): void;
    EnsureBufferLength(count: number): void;
    FastInsertByte(value: number, index: number): void;
    GetArraySegment(): CSArray<number>;
    GetBuffer(): CSArray<number>;
    Reserve(count: number): void;
    Reset(manager: NetworkManager): void;
    ToString(): string;
    Write<T>(value: T): void;
    WriteArray<T>(value: CSArray<T>, offset: number, count: number): void;
    WriteArray<T>(value: CSArray<T>, offset: number): void;
    WriteArray<T>(value: CSArray<T>): void;
    WriteArraySegment(value: CSArray<number>): void;
    WriteArraySegmentAndSize(value: CSArray<number>): void;
    Writebool2(value: bool2): void;
    Writebool2x2(value: bool2x2): void;
    Writebool2x3(value: bool2x3): void;
    Writebool2x4(value: bool2x4): void;
    Writebool3(value: bool3): void;
    Writebool3x2(value: bool3x2): void;
    Writebool3x3(value: bool3x3): void;
    Writebool3x4(value: bool3x4): void;
    Writebool4(value: bool4): void;
    Writebool4x2(value: bool4x2): void;
    Writebool4x3(value: bool4x3): void;
    Writebool4x4(value: bool4x4): void;
    WriteBoolean(value: boolean): void;
    WriteByte(value: number): void;
    WriteBytes(value: CSArray<number>, offset: number, count: number): void;
    WriteBytesAndSize(value: CSArray<number>, offset: number, count: number): void;
    WriteBytesAndSize(value: CSArray<number>): void;
    WriteChannel(channel: Channel): void;
    WriteChar(value: string): void;
    WriteColor(value: Color, packType: AutoPackType): void;
    WriteColor32(value: Color32): void;
    WriteDateTime(dt: string): void;
    WriteDecimal(value: number): void;
    WriteDictionary<TKey, TValue>(dict: CSDictionary<TKey, TValue>): void;
    WriteDouble(value: number): void;
    Writedouble2(value: double2): void;
    Writedouble2x2(value: double2x2): void;
    Writedouble2x3(value: double2x3): void;
    Writedouble2x4(value: double2x4): void;
    Writedouble3(value: double3): void;
    Writedouble3x2(value: double3x2): void;
    Writedouble3x3(value: double3x3): void;
    Writedouble3x4(value: double3x4): void;
    Writedouble4(value: double4): void;
    Writedouble4x2(value: double4x2): void;
    Writedouble4x3(value: double4x3): void;
    Writedouble4x4(value: double4x4): void;
    Writefloat2(value: float2): void;
    Writefloat2x2(value: float2x2): void;
    Writefloat2x3(value: float2x3): void;
    Writefloat2x4(value: float2x4): void;
    Writefloat3(value: float3): void;
    Writefloat3x2(value: float3x2): void;
    Writefloat3x3(value: float3x3): void;
    Writefloat3x4(value: float3x4): void;
    Writefloat4(value: float4): void;
    Writefloat4x2(value: float4x2): void;
    Writefloat4x3(value: float4x3): void;
    Writefloat4x4(value: float4x4): void;
    WriteGameObject(go: GameObject): void;
    WriteGuidAllocated(value: unknown): void;
    Writehalf(value: half): void;
    Writehalf2(value: half2): void;
    Writehalf3(value: half3): void;
    Writehalf4(value: half4): void;
    WriteInt16(value: number, packType: AutoPackType): void;
    Writeint2(value: int2): void;
    Writeint2x2(value: int2x2): void;
    Writeint2x3(value: int2x3): void;
    Writeint2x4(value: int2x4): void;
    Writeint3(value: int3): void;
    WriteInt32(value: number, packType: AutoPackType): void;
    Writeint3x2(value: int3x2): void;
    Writeint3x3(value: int3x3): void;
    Writeint3x4(value: int3x4): void;
    Writeint4(value: int4): void;
    Writeint4x2(value: int4x2): void;
    Writeint4x3(value: int4x3): void;
    Writeint4x4(value: int4x4): void;
    WriteInt64(value: number, packType: AutoPackType): void;
    WriteLayerMask(value: LayerMask): void;
    WriteList<T>(value: CSArray<T>): void;
    WriteList<T>(value: CSArray<T>, offset: number, count: number): void;
    WriteList<T>(value: CSArray<T>, offset: number): void;
    WriteMatrix4x4(value: Matrix4x4): void;
    WriteNetworkBehaviour(nb: NetworkBehaviour): void;
    WriteNetworkBehaviourId(nb: NetworkBehaviour): void;
    WriteNetworkConnection(connection: NetworkConnection): void;
    WriteNetworkConnectionId(id: number): void;
    WriteNetworkObject(nob: NetworkObject): void;
    WriteNetworkObjectId(nob: NetworkObject): void;
    WriteNetworkObjectId(objectId: number): void;
    WritePackedWhole(value: number): void;
    WritePlane(value: Plane): void;
    Writequaternion(value: quaternion): void;
    WriteQuaternion(value: Quaternion, packType: AutoPackType): void;
    Writerandom(random: Random): void;
    WriteRay(value: Ray): void;
    WriteRay2D(value: Ray2D): void;
    WriteRect(value: Rect): void;
    WriteRigidTransform(value: RigidTransform): void;
    WriteSByte(value: number): void;
    WriteSingle(value: number, packType: AutoPackType): void;
    WriteString(value: string): void;
    WriteTickUnpacked(value: number): void;
    WriteTransform(t: Transform): void;
    WriteUInt16(value: number, packType: AutoPackType): void;
    Writeuint2(value: uint2): void;
    Writeuint2x2(value: uint2x2): void;
    Writeuint2x3(value: uint2x3): void;
    Writeuint2x4(value: uint2x4): void;
    Writeuint3(value: uint3): void;
    WriteUInt32(value: number, packType: AutoPackType): void;
    Writeuint3x2(value: uint3x2): void;
    Writeuint3x3(value: uint3x3): void;
    Writeuint3x4(value: uint3x4): void;
    Writeuint4(value: uint4): void;
    Writeuint4x2(value: uint4x2): void;
    Writeuint4x3(value: uint4x3): void;
    Writeuint4x4(value: uint4x4): void;
    WriteUInt64(value: number, packType: AutoPackType): void;
    WriteUnpacked<T>(value: T): void;
    WriteVector2(value: Vector2): void;
    WriteVector2Int(value: Vector2Int, packType: AutoPackType): void;
    WriteVector3(value: Vector3): void;
    WriteVector3Int(value: unknown, packType: AutoPackType): void;
    WriteVector4(value: Vector4): void;
    ZigZagEncode(value: number): number;

}
    
interface bool2 {
    x: boolean;
    y: boolean;
    xxxx: bool4;
    xxxy: bool4;
    xxyx: bool4;
    xxyy: bool4;
    xyxx: bool4;
    xyxy: bool4;
    xyyx: bool4;
    xyyy: bool4;
    yxxx: bool4;
    yxxy: bool4;
    yxyx: bool4;
    yxyy: bool4;
    yyxx: bool4;
    yyxy: bool4;
    yyyx: bool4;
    yyyy: bool4;
    xxx: bool3;
    xxy: bool3;
    xyx: bool3;
    xyy: bool3;
    yxx: bool3;
    yxy: bool3;
    yyx: bool3;
    yyy: bool3;
    xx: bool2;
    xy: bool2;
    yx: bool2;
    yy: bool2;
    Item: boolean;


    Equals(rhs: bool2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool4 {
    x: boolean;
    y: boolean;
    z: boolean;
    w: boolean;
    xxxx: bool4;
    xxxy: bool4;
    xxxz: bool4;
    xxxw: bool4;
    xxyx: bool4;
    xxyy: bool4;
    xxyz: bool4;
    xxyw: bool4;
    xxzx: bool4;
    xxzy: bool4;
    xxzz: bool4;
    xxzw: bool4;
    xxwx: bool4;
    xxwy: bool4;
    xxwz: bool4;
    xxww: bool4;
    xyxx: bool4;
    xyxy: bool4;
    xyxz: bool4;
    xyxw: bool4;
    xyyx: bool4;
    xyyy: bool4;
    xyyz: bool4;
    xyyw: bool4;
    xyzx: bool4;
    xyzy: bool4;
    xyzz: bool4;
    xyzw: bool4;
    xywx: bool4;
    xywy: bool4;
    xywz: bool4;
    xyww: bool4;
    xzxx: bool4;
    xzxy: bool4;
    xzxz: bool4;
    xzxw: bool4;
    xzyx: bool4;
    xzyy: bool4;
    xzyz: bool4;
    xzyw: bool4;
    xzzx: bool4;
    xzzy: bool4;
    xzzz: bool4;
    xzzw: bool4;
    xzwx: bool4;
    xzwy: bool4;
    xzwz: bool4;
    xzww: bool4;
    xwxx: bool4;
    xwxy: bool4;
    xwxz: bool4;
    xwxw: bool4;
    xwyx: bool4;
    xwyy: bool4;
    xwyz: bool4;
    xwyw: bool4;
    xwzx: bool4;
    xwzy: bool4;
    xwzz: bool4;
    xwzw: bool4;
    xwwx: bool4;
    xwwy: bool4;
    xwwz: bool4;
    xwww: bool4;
    yxxx: bool4;
    yxxy: bool4;
    yxxz: bool4;
    yxxw: bool4;
    yxyx: bool4;
    yxyy: bool4;
    yxyz: bool4;
    yxyw: bool4;
    yxzx: bool4;
    yxzy: bool4;
    yxzz: bool4;
    yxzw: bool4;
    yxwx: bool4;
    yxwy: bool4;
    yxwz: bool4;
    yxww: bool4;
    yyxx: bool4;
    yyxy: bool4;
    yyxz: bool4;
    yyxw: bool4;
    yyyx: bool4;
    yyyy: bool4;
    yyyz: bool4;
    yyyw: bool4;
    yyzx: bool4;
    yyzy: bool4;
    yyzz: bool4;
    yyzw: bool4;
    yywx: bool4;
    yywy: bool4;
    yywz: bool4;
    yyww: bool4;
    yzxx: bool4;
    yzxy: bool4;
    yzxz: bool4;
    yzxw: bool4;
    yzyx: bool4;
    yzyy: bool4;
    yzyz: bool4;
    yzyw: bool4;
    yzzx: bool4;
    yzzy: bool4;
    yzzz: bool4;
    yzzw: bool4;
    yzwx: bool4;
    yzwy: bool4;
    yzwz: bool4;
    yzww: bool4;
    ywxx: bool4;
    ywxy: bool4;
    ywxz: bool4;
    ywxw: bool4;
    ywyx: bool4;
    ywyy: bool4;
    ywyz: bool4;
    ywyw: bool4;
    ywzx: bool4;
    ywzy: bool4;
    ywzz: bool4;
    ywzw: bool4;
    ywwx: bool4;
    ywwy: bool4;
    ywwz: bool4;
    ywww: bool4;
    zxxx: bool4;
    zxxy: bool4;
    zxxz: bool4;
    zxxw: bool4;
    zxyx: bool4;
    zxyy: bool4;
    zxyz: bool4;
    zxyw: bool4;
    zxzx: bool4;
    zxzy: bool4;
    zxzz: bool4;
    zxzw: bool4;
    zxwx: bool4;
    zxwy: bool4;
    zxwz: bool4;
    zxww: bool4;
    zyxx: bool4;
    zyxy: bool4;
    zyxz: bool4;
    zyxw: bool4;
    zyyx: bool4;
    zyyy: bool4;
    zyyz: bool4;
    zyyw: bool4;
    zyzx: bool4;
    zyzy: bool4;
    zyzz: bool4;
    zyzw: bool4;
    zywx: bool4;
    zywy: bool4;
    zywz: bool4;
    zyww: bool4;
    zzxx: bool4;
    zzxy: bool4;
    zzxz: bool4;
    zzxw: bool4;
    zzyx: bool4;
    zzyy: bool4;
    zzyz: bool4;
    zzyw: bool4;
    zzzx: bool4;
    zzzy: bool4;
    zzzz: bool4;
    zzzw: bool4;
    zzwx: bool4;
    zzwy: bool4;
    zzwz: bool4;
    zzww: bool4;
    zwxx: bool4;
    zwxy: bool4;
    zwxz: bool4;
    zwxw: bool4;
    zwyx: bool4;
    zwyy: bool4;
    zwyz: bool4;
    zwyw: bool4;
    zwzx: bool4;
    zwzy: bool4;
    zwzz: bool4;
    zwzw: bool4;
    zwwx: bool4;
    zwwy: bool4;
    zwwz: bool4;
    zwww: bool4;
    wxxx: bool4;
    wxxy: bool4;
    wxxz: bool4;
    wxxw: bool4;
    wxyx: bool4;
    wxyy: bool4;
    wxyz: bool4;
    wxyw: bool4;
    wxzx: bool4;
    wxzy: bool4;
    wxzz: bool4;
    wxzw: bool4;
    wxwx: bool4;
    wxwy: bool4;
    wxwz: bool4;
    wxww: bool4;
    wyxx: bool4;
    wyxy: bool4;
    wyxz: bool4;
    wyxw: bool4;
    wyyx: bool4;
    wyyy: bool4;
    wyyz: bool4;
    wyyw: bool4;
    wyzx: bool4;
    wyzy: bool4;
    wyzz: bool4;
    wyzw: bool4;
    wywx: bool4;
    wywy: bool4;
    wywz: bool4;
    wyww: bool4;
    wzxx: bool4;
    wzxy: bool4;
    wzxz: bool4;
    wzxw: bool4;
    wzyx: bool4;
    wzyy: bool4;
    wzyz: bool4;
    wzyw: bool4;
    wzzx: bool4;
    wzzy: bool4;
    wzzz: bool4;
    wzzw: bool4;
    wzwx: bool4;
    wzwy: bool4;
    wzwz: bool4;
    wzww: bool4;
    wwxx: bool4;
    wwxy: bool4;
    wwxz: bool4;
    wwxw: bool4;
    wwyx: bool4;
    wwyy: bool4;
    wwyz: bool4;
    wwyw: bool4;
    wwzx: bool4;
    wwzy: bool4;
    wwzz: bool4;
    wwzw: bool4;
    wwwx: bool4;
    wwwy: bool4;
    wwwz: bool4;
    wwww: bool4;
    xxx: bool3;
    xxy: bool3;
    xxz: bool3;
    xxw: bool3;
    xyx: bool3;
    xyy: bool3;
    xyz: bool3;
    xyw: bool3;
    xzx: bool3;
    xzy: bool3;
    xzz: bool3;
    xzw: bool3;
    xwx: bool3;
    xwy: bool3;
    xwz: bool3;
    xww: bool3;
    yxx: bool3;
    yxy: bool3;
    yxz: bool3;
    yxw: bool3;
    yyx: bool3;
    yyy: bool3;
    yyz: bool3;
    yyw: bool3;
    yzx: bool3;
    yzy: bool3;
    yzz: bool3;
    yzw: bool3;
    ywx: bool3;
    ywy: bool3;
    ywz: bool3;
    yww: bool3;
    zxx: bool3;
    zxy: bool3;
    zxz: bool3;
    zxw: bool3;
    zyx: bool3;
    zyy: bool3;
    zyz: bool3;
    zyw: bool3;
    zzx: bool3;
    zzy: bool3;
    zzz: bool3;
    zzw: bool3;
    zwx: bool3;
    zwy: bool3;
    zwz: bool3;
    zww: bool3;
    wxx: bool3;
    wxy: bool3;
    wxz: bool3;
    wxw: bool3;
    wyx: bool3;
    wyy: bool3;
    wyz: bool3;
    wyw: bool3;
    wzx: bool3;
    wzy: bool3;
    wzz: bool3;
    wzw: bool3;
    wwx: bool3;
    wwy: bool3;
    wwz: bool3;
    www: bool3;
    xx: bool2;
    xy: bool2;
    xz: bool2;
    xw: bool2;
    yx: bool2;
    yy: bool2;
    yz: bool2;
    yw: bool2;
    zx: bool2;
    zy: bool2;
    zz: bool2;
    zw: bool2;
    wx: bool2;
    wy: bool2;
    wz: bool2;
    ww: bool2;
    Item: boolean;


    Equals(rhs: bool4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool3 {
    x: boolean;
    y: boolean;
    z: boolean;
    xxxx: bool4;
    xxxy: bool4;
    xxxz: bool4;
    xxyx: bool4;
    xxyy: bool4;
    xxyz: bool4;
    xxzx: bool4;
    xxzy: bool4;
    xxzz: bool4;
    xyxx: bool4;
    xyxy: bool4;
    xyxz: bool4;
    xyyx: bool4;
    xyyy: bool4;
    xyyz: bool4;
    xyzx: bool4;
    xyzy: bool4;
    xyzz: bool4;
    xzxx: bool4;
    xzxy: bool4;
    xzxz: bool4;
    xzyx: bool4;
    xzyy: bool4;
    xzyz: bool4;
    xzzx: bool4;
    xzzy: bool4;
    xzzz: bool4;
    yxxx: bool4;
    yxxy: bool4;
    yxxz: bool4;
    yxyx: bool4;
    yxyy: bool4;
    yxyz: bool4;
    yxzx: bool4;
    yxzy: bool4;
    yxzz: bool4;
    yyxx: bool4;
    yyxy: bool4;
    yyxz: bool4;
    yyyx: bool4;
    yyyy: bool4;
    yyyz: bool4;
    yyzx: bool4;
    yyzy: bool4;
    yyzz: bool4;
    yzxx: bool4;
    yzxy: bool4;
    yzxz: bool4;
    yzyx: bool4;
    yzyy: bool4;
    yzyz: bool4;
    yzzx: bool4;
    yzzy: bool4;
    yzzz: bool4;
    zxxx: bool4;
    zxxy: bool4;
    zxxz: bool4;
    zxyx: bool4;
    zxyy: bool4;
    zxyz: bool4;
    zxzx: bool4;
    zxzy: bool4;
    zxzz: bool4;
    zyxx: bool4;
    zyxy: bool4;
    zyxz: bool4;
    zyyx: bool4;
    zyyy: bool4;
    zyyz: bool4;
    zyzx: bool4;
    zyzy: bool4;
    zyzz: bool4;
    zzxx: bool4;
    zzxy: bool4;
    zzxz: bool4;
    zzyx: bool4;
    zzyy: bool4;
    zzyz: bool4;
    zzzx: bool4;
    zzzy: bool4;
    zzzz: bool4;
    xxx: bool3;
    xxy: bool3;
    xxz: bool3;
    xyx: bool3;
    xyy: bool3;
    xyz: bool3;
    xzx: bool3;
    xzy: bool3;
    xzz: bool3;
    yxx: bool3;
    yxy: bool3;
    yxz: bool3;
    yyx: bool3;
    yyy: bool3;
    yyz: bool3;
    yzx: bool3;
    yzy: bool3;
    yzz: bool3;
    zxx: bool3;
    zxy: bool3;
    zxz: bool3;
    zyx: bool3;
    zyy: bool3;
    zyz: bool3;
    zzx: bool3;
    zzy: bool3;
    zzz: bool3;
    xx: bool2;
    xy: bool2;
    xz: bool2;
    yx: bool2;
    yy: bool2;
    yz: bool2;
    zx: bool2;
    zy: bool2;
    zz: bool2;
    Item: boolean;


    Equals(rhs: bool3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool3Constructor {

    new(x: boolean, y: boolean, z: boolean): bool3;
    new(x: boolean, yz: bool2): bool3;
    new(xy: bool2, z: boolean): bool3;
    new(xyz: bool3): bool3;
    new(v: boolean): bool3;


}
declare const bool3: bool3Constructor;
    
interface bool4Constructor {

    new(x: boolean, y: boolean, z: boolean, w: boolean): bool4;
    new(x: boolean, y: boolean, zw: bool2): bool4;
    new(x: boolean, yz: bool2, w: boolean): bool4;
    new(x: boolean, yzw: bool3): bool4;
    new(xy: bool2, z: boolean, w: boolean): bool4;
    new(xy: bool2, zw: bool2): bool4;
    new(xyz: bool3, w: boolean): bool4;
    new(xyzw: bool4): bool4;
    new(v: boolean): bool4;


}
declare const bool4: bool4Constructor;
    
interface bool2Constructor {

    new(x: boolean, y: boolean): bool2;
    new(xy: bool2): bool2;
    new(v: boolean): bool2;


}
declare const bool2: bool2Constructor;
    
interface bool2x2 {
    c0: bool2;
    c1: bool2;
    Item: unknown;


    Equals(rhs: bool2x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool2x2Constructor {

    new(c0: bool2, c1: bool2): bool2x2;
    new(m00: boolean, m01: boolean, m10: boolean, m11: boolean): bool2x2;
    new(v: boolean): bool2x2;


}
declare const bool2x2: bool2x2Constructor;
    
interface bool2x3 {
    c0: bool2;
    c1: bool2;
    c2: bool2;
    Item: unknown;


    Equals(rhs: bool2x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool2x3Constructor {

    new(c0: bool2, c1: bool2, c2: bool2): bool2x3;
    new(m00: boolean, m01: boolean, m02: boolean, m10: boolean, m11: boolean, m12: boolean): bool2x3;
    new(v: boolean): bool2x3;


}
declare const bool2x3: bool2x3Constructor;
    
interface bool2x4 {
    c0: bool2;
    c1: bool2;
    c2: bool2;
    c3: bool2;
    Item: unknown;


    Equals(rhs: bool2x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool2x4Constructor {

    new(c0: bool2, c1: bool2, c2: bool2, c3: bool2): bool2x4;
    new(m00: boolean, m01: boolean, m02: boolean, m03: boolean, m10: boolean, m11: boolean, m12: boolean, m13: boolean): bool2x4;
    new(v: boolean): bool2x4;


}
declare const bool2x4: bool2x4Constructor;
    
interface bool3x2 {
    c0: bool3;
    c1: bool3;
    Item: unknown;


    Equals(rhs: bool3x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool3x2Constructor {

    new(c0: bool3, c1: bool3): bool3x2;
    new(m00: boolean, m01: boolean, m10: boolean, m11: boolean, m20: boolean, m21: boolean): bool3x2;
    new(v: boolean): bool3x2;


}
declare const bool3x2: bool3x2Constructor;
    
interface bool3x3 {
    c0: bool3;
    c1: bool3;
    c2: bool3;
    Item: unknown;


    Equals(rhs: bool3x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool3x3Constructor {

    new(c0: bool3, c1: bool3, c2: bool3): bool3x3;
    new(m00: boolean, m01: boolean, m02: boolean, m10: boolean, m11: boolean, m12: boolean, m20: boolean, m21: boolean, m22: boolean): bool3x3;
    new(v: boolean): bool3x3;


}
declare const bool3x3: bool3x3Constructor;
    
interface bool3x4 {
    c0: bool3;
    c1: bool3;
    c2: bool3;
    c3: bool3;
    Item: unknown;


    Equals(rhs: bool3x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool3x4Constructor {

    new(c0: bool3, c1: bool3, c2: bool3, c3: bool3): bool3x4;
    new(m00: boolean, m01: boolean, m02: boolean, m03: boolean, m10: boolean, m11: boolean, m12: boolean, m13: boolean, m20: boolean, m21: boolean, m22: boolean, m23: boolean): bool3x4;
    new(v: boolean): bool3x4;


}
declare const bool3x4: bool3x4Constructor;
    
interface bool4x2 {
    c0: bool4;
    c1: bool4;
    Item: unknown;


    Equals(rhs: bool4x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool4x2Constructor {

    new(c0: bool4, c1: bool4): bool4x2;
    new(m00: boolean, m01: boolean, m10: boolean, m11: boolean, m20: boolean, m21: boolean, m30: boolean, m31: boolean): bool4x2;
    new(v: boolean): bool4x2;


}
declare const bool4x2: bool4x2Constructor;
    
interface bool4x3 {
    c0: bool4;
    c1: bool4;
    c2: bool4;
    Item: unknown;


    Equals(rhs: bool4x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool4x3Constructor {

    new(c0: bool4, c1: bool4, c2: bool4): bool4x3;
    new(m00: boolean, m01: boolean, m02: boolean, m10: boolean, m11: boolean, m12: boolean, m20: boolean, m21: boolean, m22: boolean, m30: boolean, m31: boolean, m32: boolean): bool4x3;
    new(v: boolean): bool4x3;


}
declare const bool4x3: bool4x3Constructor;
    
interface bool4x4 {
    c0: bool4;
    c1: bool4;
    c2: bool4;
    c3: bool4;
    Item: unknown;


    Equals(rhs: bool4x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface bool4x4Constructor {

    new(c0: bool4, c1: bool4, c2: bool4, c3: bool4): bool4x4;
    new(m00: boolean, m01: boolean, m02: boolean, m03: boolean, m10: boolean, m11: boolean, m12: boolean, m13: boolean, m20: boolean, m21: boolean, m22: boolean, m23: boolean, m30: boolean, m31: boolean, m32: boolean, m33: boolean): bool4x4;
    new(v: boolean): bool4x4;


}
declare const bool4x4: bool4x4Constructor;
    
interface double2 {
    x: number;
    y: number;
    xxxx: double4;
    xxxy: double4;
    xxyx: double4;
    xxyy: double4;
    xyxx: double4;
    xyxy: double4;
    xyyx: double4;
    xyyy: double4;
    yxxx: double4;
    yxxy: double4;
    yxyx: double4;
    yxyy: double4;
    yyxx: double4;
    yyxy: double4;
    yyyx: double4;
    yyyy: double4;
    xxx: double3;
    xxy: double3;
    xyx: double3;
    xyy: double3;
    yxx: double3;
    yxy: double3;
    yyx: double3;
    yyy: double3;
    xx: double2;
    xy: double2;
    yx: double2;
    yy: double2;
    Item: number;


    Equals(rhs: double2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double4 {
    x: number;
    y: number;
    z: number;
    w: number;
    xxxx: double4;
    xxxy: double4;
    xxxz: double4;
    xxxw: double4;
    xxyx: double4;
    xxyy: double4;
    xxyz: double4;
    xxyw: double4;
    xxzx: double4;
    xxzy: double4;
    xxzz: double4;
    xxzw: double4;
    xxwx: double4;
    xxwy: double4;
    xxwz: double4;
    xxww: double4;
    xyxx: double4;
    xyxy: double4;
    xyxz: double4;
    xyxw: double4;
    xyyx: double4;
    xyyy: double4;
    xyyz: double4;
    xyyw: double4;
    xyzx: double4;
    xyzy: double4;
    xyzz: double4;
    xyzw: double4;
    xywx: double4;
    xywy: double4;
    xywz: double4;
    xyww: double4;
    xzxx: double4;
    xzxy: double4;
    xzxz: double4;
    xzxw: double4;
    xzyx: double4;
    xzyy: double4;
    xzyz: double4;
    xzyw: double4;
    xzzx: double4;
    xzzy: double4;
    xzzz: double4;
    xzzw: double4;
    xzwx: double4;
    xzwy: double4;
    xzwz: double4;
    xzww: double4;
    xwxx: double4;
    xwxy: double4;
    xwxz: double4;
    xwxw: double4;
    xwyx: double4;
    xwyy: double4;
    xwyz: double4;
    xwyw: double4;
    xwzx: double4;
    xwzy: double4;
    xwzz: double4;
    xwzw: double4;
    xwwx: double4;
    xwwy: double4;
    xwwz: double4;
    xwww: double4;
    yxxx: double4;
    yxxy: double4;
    yxxz: double4;
    yxxw: double4;
    yxyx: double4;
    yxyy: double4;
    yxyz: double4;
    yxyw: double4;
    yxzx: double4;
    yxzy: double4;
    yxzz: double4;
    yxzw: double4;
    yxwx: double4;
    yxwy: double4;
    yxwz: double4;
    yxww: double4;
    yyxx: double4;
    yyxy: double4;
    yyxz: double4;
    yyxw: double4;
    yyyx: double4;
    yyyy: double4;
    yyyz: double4;
    yyyw: double4;
    yyzx: double4;
    yyzy: double4;
    yyzz: double4;
    yyzw: double4;
    yywx: double4;
    yywy: double4;
    yywz: double4;
    yyww: double4;
    yzxx: double4;
    yzxy: double4;
    yzxz: double4;
    yzxw: double4;
    yzyx: double4;
    yzyy: double4;
    yzyz: double4;
    yzyw: double4;
    yzzx: double4;
    yzzy: double4;
    yzzz: double4;
    yzzw: double4;
    yzwx: double4;
    yzwy: double4;
    yzwz: double4;
    yzww: double4;
    ywxx: double4;
    ywxy: double4;
    ywxz: double4;
    ywxw: double4;
    ywyx: double4;
    ywyy: double4;
    ywyz: double4;
    ywyw: double4;
    ywzx: double4;
    ywzy: double4;
    ywzz: double4;
    ywzw: double4;
    ywwx: double4;
    ywwy: double4;
    ywwz: double4;
    ywww: double4;
    zxxx: double4;
    zxxy: double4;
    zxxz: double4;
    zxxw: double4;
    zxyx: double4;
    zxyy: double4;
    zxyz: double4;
    zxyw: double4;
    zxzx: double4;
    zxzy: double4;
    zxzz: double4;
    zxzw: double4;
    zxwx: double4;
    zxwy: double4;
    zxwz: double4;
    zxww: double4;
    zyxx: double4;
    zyxy: double4;
    zyxz: double4;
    zyxw: double4;
    zyyx: double4;
    zyyy: double4;
    zyyz: double4;
    zyyw: double4;
    zyzx: double4;
    zyzy: double4;
    zyzz: double4;
    zyzw: double4;
    zywx: double4;
    zywy: double4;
    zywz: double4;
    zyww: double4;
    zzxx: double4;
    zzxy: double4;
    zzxz: double4;
    zzxw: double4;
    zzyx: double4;
    zzyy: double4;
    zzyz: double4;
    zzyw: double4;
    zzzx: double4;
    zzzy: double4;
    zzzz: double4;
    zzzw: double4;
    zzwx: double4;
    zzwy: double4;
    zzwz: double4;
    zzww: double4;
    zwxx: double4;
    zwxy: double4;
    zwxz: double4;
    zwxw: double4;
    zwyx: double4;
    zwyy: double4;
    zwyz: double4;
    zwyw: double4;
    zwzx: double4;
    zwzy: double4;
    zwzz: double4;
    zwzw: double4;
    zwwx: double4;
    zwwy: double4;
    zwwz: double4;
    zwww: double4;
    wxxx: double4;
    wxxy: double4;
    wxxz: double4;
    wxxw: double4;
    wxyx: double4;
    wxyy: double4;
    wxyz: double4;
    wxyw: double4;
    wxzx: double4;
    wxzy: double4;
    wxzz: double4;
    wxzw: double4;
    wxwx: double4;
    wxwy: double4;
    wxwz: double4;
    wxww: double4;
    wyxx: double4;
    wyxy: double4;
    wyxz: double4;
    wyxw: double4;
    wyyx: double4;
    wyyy: double4;
    wyyz: double4;
    wyyw: double4;
    wyzx: double4;
    wyzy: double4;
    wyzz: double4;
    wyzw: double4;
    wywx: double4;
    wywy: double4;
    wywz: double4;
    wyww: double4;
    wzxx: double4;
    wzxy: double4;
    wzxz: double4;
    wzxw: double4;
    wzyx: double4;
    wzyy: double4;
    wzyz: double4;
    wzyw: double4;
    wzzx: double4;
    wzzy: double4;
    wzzz: double4;
    wzzw: double4;
    wzwx: double4;
    wzwy: double4;
    wzwz: double4;
    wzww: double4;
    wwxx: double4;
    wwxy: double4;
    wwxz: double4;
    wwxw: double4;
    wwyx: double4;
    wwyy: double4;
    wwyz: double4;
    wwyw: double4;
    wwzx: double4;
    wwzy: double4;
    wwzz: double4;
    wwzw: double4;
    wwwx: double4;
    wwwy: double4;
    wwwz: double4;
    wwww: double4;
    xxx: double3;
    xxy: double3;
    xxz: double3;
    xxw: double3;
    xyx: double3;
    xyy: double3;
    xyz: double3;
    xyw: double3;
    xzx: double3;
    xzy: double3;
    xzz: double3;
    xzw: double3;
    xwx: double3;
    xwy: double3;
    xwz: double3;
    xww: double3;
    yxx: double3;
    yxy: double3;
    yxz: double3;
    yxw: double3;
    yyx: double3;
    yyy: double3;
    yyz: double3;
    yyw: double3;
    yzx: double3;
    yzy: double3;
    yzz: double3;
    yzw: double3;
    ywx: double3;
    ywy: double3;
    ywz: double3;
    yww: double3;
    zxx: double3;
    zxy: double3;
    zxz: double3;
    zxw: double3;
    zyx: double3;
    zyy: double3;
    zyz: double3;
    zyw: double3;
    zzx: double3;
    zzy: double3;
    zzz: double3;
    zzw: double3;
    zwx: double3;
    zwy: double3;
    zwz: double3;
    zww: double3;
    wxx: double3;
    wxy: double3;
    wxz: double3;
    wxw: double3;
    wyx: double3;
    wyy: double3;
    wyz: double3;
    wyw: double3;
    wzx: double3;
    wzy: double3;
    wzz: double3;
    wzw: double3;
    wwx: double3;
    wwy: double3;
    wwz: double3;
    www: double3;
    xx: double2;
    xy: double2;
    xz: double2;
    xw: double2;
    yx: double2;
    yy: double2;
    yz: double2;
    yw: double2;
    zx: double2;
    zy: double2;
    zz: double2;
    zw: double2;
    wx: double2;
    wy: double2;
    wz: double2;
    ww: double2;
    Item: number;


    Equals(rhs: double4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double3 {
    x: number;
    y: number;
    z: number;
    xxxx: double4;
    xxxy: double4;
    xxxz: double4;
    xxyx: double4;
    xxyy: double4;
    xxyz: double4;
    xxzx: double4;
    xxzy: double4;
    xxzz: double4;
    xyxx: double4;
    xyxy: double4;
    xyxz: double4;
    xyyx: double4;
    xyyy: double4;
    xyyz: double4;
    xyzx: double4;
    xyzy: double4;
    xyzz: double4;
    xzxx: double4;
    xzxy: double4;
    xzxz: double4;
    xzyx: double4;
    xzyy: double4;
    xzyz: double4;
    xzzx: double4;
    xzzy: double4;
    xzzz: double4;
    yxxx: double4;
    yxxy: double4;
    yxxz: double4;
    yxyx: double4;
    yxyy: double4;
    yxyz: double4;
    yxzx: double4;
    yxzy: double4;
    yxzz: double4;
    yyxx: double4;
    yyxy: double4;
    yyxz: double4;
    yyyx: double4;
    yyyy: double4;
    yyyz: double4;
    yyzx: double4;
    yyzy: double4;
    yyzz: double4;
    yzxx: double4;
    yzxy: double4;
    yzxz: double4;
    yzyx: double4;
    yzyy: double4;
    yzyz: double4;
    yzzx: double4;
    yzzy: double4;
    yzzz: double4;
    zxxx: double4;
    zxxy: double4;
    zxxz: double4;
    zxyx: double4;
    zxyy: double4;
    zxyz: double4;
    zxzx: double4;
    zxzy: double4;
    zxzz: double4;
    zyxx: double4;
    zyxy: double4;
    zyxz: double4;
    zyyx: double4;
    zyyy: double4;
    zyyz: double4;
    zyzx: double4;
    zyzy: double4;
    zyzz: double4;
    zzxx: double4;
    zzxy: double4;
    zzxz: double4;
    zzyx: double4;
    zzyy: double4;
    zzyz: double4;
    zzzx: double4;
    zzzy: double4;
    zzzz: double4;
    xxx: double3;
    xxy: double3;
    xxz: double3;
    xyx: double3;
    xyy: double3;
    xyz: double3;
    xzx: double3;
    xzy: double3;
    xzz: double3;
    yxx: double3;
    yxy: double3;
    yxz: double3;
    yyx: double3;
    yyy: double3;
    yyz: double3;
    yzx: double3;
    yzy: double3;
    yzz: double3;
    zxx: double3;
    zxy: double3;
    zxz: double3;
    zyx: double3;
    zyy: double3;
    zyz: double3;
    zzx: double3;
    zzy: double3;
    zzz: double3;
    xx: double2;
    xy: double2;
    xz: double2;
    yx: double2;
    yy: double2;
    yz: double2;
    zx: double2;
    zy: double2;
    zz: double2;
    Item: number;


    Equals(rhs: double3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double3Constructor {
    zero: double3;

    new(x: number, y: number, z: number): double3;
    new(x: number, yz: double2): double3;
    new(xy: double2, z: number): double3;
    new(xyz: double3): double3;
    new(v: number): double3;
    new(v: boolean): double3;
    new(v: bool3): double3;
    new(v: number): double3;
    new(v: int3): double3;
    new(v: number): double3;
    new(v: uint3): double3;
    new(v: half): double3;
    new(v: half3): double3;
    new(v: number): double3;
    new(v: float3): double3;


}
declare const double3: double3Constructor;
    
interface double4Constructor {
    zero: double4;

    new(x: number, y: number, z: number, w: number): double4;
    new(x: number, y: number, zw: double2): double4;
    new(x: number, yz: double2, w: number): double4;
    new(x: number, yzw: double3): double4;
    new(xy: double2, z: number, w: number): double4;
    new(xy: double2, zw: double2): double4;
    new(xyz: double3, w: number): double4;
    new(xyzw: double4): double4;
    new(v: number): double4;
    new(v: boolean): double4;
    new(v: bool4): double4;
    new(v: number): double4;
    new(v: int4): double4;
    new(v: number): double4;
    new(v: uint4): double4;
    new(v: half): double4;
    new(v: half4): double4;
    new(v: number): double4;
    new(v: float4): double4;


}
declare const double4: double4Constructor;
    
interface double2Constructor {
    zero: double2;

    new(x: number, y: number): double2;
    new(xy: double2): double2;
    new(v: number): double2;
    new(v: boolean): double2;
    new(v: bool2): double2;
    new(v: number): double2;
    new(v: int2): double2;
    new(v: number): double2;
    new(v: uint2): double2;
    new(v: half): double2;
    new(v: half2): double2;
    new(v: number): double2;
    new(v: float2): double2;


}
declare const double2: double2Constructor;
    
interface double2x2 {
    c0: double2;
    c1: double2;
    Item: unknown;


    Equals(rhs: double2x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double2x2Constructor {
    identity: double2x2;
    zero: double2x2;

    new(c0: double2, c1: double2): double2x2;
    new(m00: number, m01: number, m10: number, m11: number): double2x2;
    new(v: number): double2x2;
    new(v: boolean): double2x2;
    new(v: bool2x2): double2x2;
    new(v: number): double2x2;
    new(v: int2x2): double2x2;
    new(v: number): double2x2;
    new(v: uint2x2): double2x2;
    new(v: number): double2x2;
    new(v: float2x2): double2x2;


}
declare const double2x2: double2x2Constructor;
    
interface double2x3 {
    c0: double2;
    c1: double2;
    c2: double2;
    Item: unknown;


    Equals(rhs: double2x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double2x3Constructor {
    zero: double2x3;

    new(c0: double2, c1: double2, c2: double2): double2x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number): double2x3;
    new(v: number): double2x3;
    new(v: boolean): double2x3;
    new(v: bool2x3): double2x3;
    new(v: number): double2x3;
    new(v: int2x3): double2x3;
    new(v: number): double2x3;
    new(v: uint2x3): double2x3;
    new(v: number): double2x3;
    new(v: float2x3): double2x3;


}
declare const double2x3: double2x3Constructor;
    
interface double2x4 {
    c0: double2;
    c1: double2;
    c2: double2;
    c3: double2;
    Item: unknown;


    Equals(rhs: double2x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double2x4Constructor {
    zero: double2x4;

    new(c0: double2, c1: double2, c2: double2, c3: double2): double2x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number): double2x4;
    new(v: number): double2x4;
    new(v: boolean): double2x4;
    new(v: bool2x4): double2x4;
    new(v: number): double2x4;
    new(v: int2x4): double2x4;
    new(v: number): double2x4;
    new(v: uint2x4): double2x4;
    new(v: number): double2x4;
    new(v: float2x4): double2x4;


}
declare const double2x4: double2x4Constructor;
    
interface double3x2 {
    c0: double3;
    c1: double3;
    Item: unknown;


    Equals(rhs: double3x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double3x2Constructor {
    zero: double3x2;

    new(c0: double3, c1: double3): double3x2;
    new(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number): double3x2;
    new(v: number): double3x2;
    new(v: boolean): double3x2;
    new(v: bool3x2): double3x2;
    new(v: number): double3x2;
    new(v: int3x2): double3x2;
    new(v: number): double3x2;
    new(v: uint3x2): double3x2;
    new(v: number): double3x2;
    new(v: float3x2): double3x2;


}
declare const double3x2: double3x2Constructor;
    
interface double3x3 {
    c0: double3;
    c1: double3;
    c2: double3;
    Item: unknown;


    Equals(rhs: double3x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double3x3Constructor {
    identity: double3x3;
    zero: double3x3;

    new(c0: double3, c1: double3, c2: double3): double3x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): double3x3;
    new(v: number): double3x3;
    new(v: boolean): double3x3;
    new(v: bool3x3): double3x3;
    new(v: number): double3x3;
    new(v: int3x3): double3x3;
    new(v: number): double3x3;
    new(v: uint3x3): double3x3;
    new(v: number): double3x3;
    new(v: float3x3): double3x3;


}
declare const double3x3: double3x3Constructor;
    
interface double3x4 {
    c0: double3;
    c1: double3;
    c2: double3;
    c3: double3;
    Item: unknown;


    Equals(rhs: double3x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double3x4Constructor {
    zero: double3x4;

    new(c0: double3, c1: double3, c2: double3, c3: double3): double3x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number): double3x4;
    new(v: number): double3x4;
    new(v: boolean): double3x4;
    new(v: bool3x4): double3x4;
    new(v: number): double3x4;
    new(v: int3x4): double3x4;
    new(v: number): double3x4;
    new(v: uint3x4): double3x4;
    new(v: number): double3x4;
    new(v: float3x4): double3x4;


}
declare const double3x4: double3x4Constructor;
    
interface double4x2 {
    c0: double4;
    c1: double4;
    Item: unknown;


    Equals(rhs: double4x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double4x2Constructor {
    zero: double4x2;

    new(c0: double4, c1: double4): double4x2;
    new(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number, m30: number, m31: number): double4x2;
    new(v: number): double4x2;
    new(v: boolean): double4x2;
    new(v: bool4x2): double4x2;
    new(v: number): double4x2;
    new(v: int4x2): double4x2;
    new(v: number): double4x2;
    new(v: uint4x2): double4x2;
    new(v: number): double4x2;
    new(v: float4x2): double4x2;


}
declare const double4x2: double4x2Constructor;
    
interface double4x3 {
    c0: double4;
    c1: double4;
    c2: double4;
    Item: unknown;


    Equals(rhs: double4x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double4x3Constructor {
    zero: double4x3;

    new(c0: double4, c1: double4, c2: double4): double4x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number, m30: number, m31: number, m32: number): double4x3;
    new(v: number): double4x3;
    new(v: boolean): double4x3;
    new(v: bool4x3): double4x3;
    new(v: number): double4x3;
    new(v: int4x3): double4x3;
    new(v: number): double4x3;
    new(v: uint4x3): double4x3;
    new(v: number): double4x3;
    new(v: float4x3): double4x3;


}
declare const double4x3: double4x3Constructor;
    
interface double4x4 {
    c0: double4;
    c1: double4;
    c2: double4;
    c3: double4;
    Item: unknown;


    Equals(rhs: double4x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface double4x4Constructor {
    identity: double4x4;
    zero: double4x4;

    new(c0: double4, c1: double4, c2: double4, c3: double4): double4x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): double4x4;
    new(v: number): double4x4;
    new(v: boolean): double4x4;
    new(v: bool4x4): double4x4;
    new(v: number): double4x4;
    new(v: int4x4): double4x4;
    new(v: number): double4x4;
    new(v: uint4x4): double4x4;
    new(v: number): double4x4;
    new(v: float4x4): double4x4;


}
declare const double4x4: double4x4Constructor;
    
interface float2 {
    x: number;
    y: number;
    xxxx: float4;
    xxxy: float4;
    xxyx: float4;
    xxyy: float4;
    xyxx: float4;
    xyxy: float4;
    xyyx: float4;
    xyyy: float4;
    yxxx: float4;
    yxxy: float4;
    yxyx: float4;
    yxyy: float4;
    yyxx: float4;
    yyxy: float4;
    yyyx: float4;
    yyyy: float4;
    xxx: float3;
    xxy: float3;
    xyx: float3;
    xyy: float3;
    yxx: float3;
    yxy: float3;
    yyx: float3;
    yyy: float3;
    xx: float2;
    xy: float2;
    yx: float2;
    yy: float2;
    Item: number;


    Equals(rhs: float2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float4 {
    x: number;
    y: number;
    z: number;
    w: number;
    xxxx: float4;
    xxxy: float4;
    xxxz: float4;
    xxxw: float4;
    xxyx: float4;
    xxyy: float4;
    xxyz: float4;
    xxyw: float4;
    xxzx: float4;
    xxzy: float4;
    xxzz: float4;
    xxzw: float4;
    xxwx: float4;
    xxwy: float4;
    xxwz: float4;
    xxww: float4;
    xyxx: float4;
    xyxy: float4;
    xyxz: float4;
    xyxw: float4;
    xyyx: float4;
    xyyy: float4;
    xyyz: float4;
    xyyw: float4;
    xyzx: float4;
    xyzy: float4;
    xyzz: float4;
    xyzw: float4;
    xywx: float4;
    xywy: float4;
    xywz: float4;
    xyww: float4;
    xzxx: float4;
    xzxy: float4;
    xzxz: float4;
    xzxw: float4;
    xzyx: float4;
    xzyy: float4;
    xzyz: float4;
    xzyw: float4;
    xzzx: float4;
    xzzy: float4;
    xzzz: float4;
    xzzw: float4;
    xzwx: float4;
    xzwy: float4;
    xzwz: float4;
    xzww: float4;
    xwxx: float4;
    xwxy: float4;
    xwxz: float4;
    xwxw: float4;
    xwyx: float4;
    xwyy: float4;
    xwyz: float4;
    xwyw: float4;
    xwzx: float4;
    xwzy: float4;
    xwzz: float4;
    xwzw: float4;
    xwwx: float4;
    xwwy: float4;
    xwwz: float4;
    xwww: float4;
    yxxx: float4;
    yxxy: float4;
    yxxz: float4;
    yxxw: float4;
    yxyx: float4;
    yxyy: float4;
    yxyz: float4;
    yxyw: float4;
    yxzx: float4;
    yxzy: float4;
    yxzz: float4;
    yxzw: float4;
    yxwx: float4;
    yxwy: float4;
    yxwz: float4;
    yxww: float4;
    yyxx: float4;
    yyxy: float4;
    yyxz: float4;
    yyxw: float4;
    yyyx: float4;
    yyyy: float4;
    yyyz: float4;
    yyyw: float4;
    yyzx: float4;
    yyzy: float4;
    yyzz: float4;
    yyzw: float4;
    yywx: float4;
    yywy: float4;
    yywz: float4;
    yyww: float4;
    yzxx: float4;
    yzxy: float4;
    yzxz: float4;
    yzxw: float4;
    yzyx: float4;
    yzyy: float4;
    yzyz: float4;
    yzyw: float4;
    yzzx: float4;
    yzzy: float4;
    yzzz: float4;
    yzzw: float4;
    yzwx: float4;
    yzwy: float4;
    yzwz: float4;
    yzww: float4;
    ywxx: float4;
    ywxy: float4;
    ywxz: float4;
    ywxw: float4;
    ywyx: float4;
    ywyy: float4;
    ywyz: float4;
    ywyw: float4;
    ywzx: float4;
    ywzy: float4;
    ywzz: float4;
    ywzw: float4;
    ywwx: float4;
    ywwy: float4;
    ywwz: float4;
    ywww: float4;
    zxxx: float4;
    zxxy: float4;
    zxxz: float4;
    zxxw: float4;
    zxyx: float4;
    zxyy: float4;
    zxyz: float4;
    zxyw: float4;
    zxzx: float4;
    zxzy: float4;
    zxzz: float4;
    zxzw: float4;
    zxwx: float4;
    zxwy: float4;
    zxwz: float4;
    zxww: float4;
    zyxx: float4;
    zyxy: float4;
    zyxz: float4;
    zyxw: float4;
    zyyx: float4;
    zyyy: float4;
    zyyz: float4;
    zyyw: float4;
    zyzx: float4;
    zyzy: float4;
    zyzz: float4;
    zyzw: float4;
    zywx: float4;
    zywy: float4;
    zywz: float4;
    zyww: float4;
    zzxx: float4;
    zzxy: float4;
    zzxz: float4;
    zzxw: float4;
    zzyx: float4;
    zzyy: float4;
    zzyz: float4;
    zzyw: float4;
    zzzx: float4;
    zzzy: float4;
    zzzz: float4;
    zzzw: float4;
    zzwx: float4;
    zzwy: float4;
    zzwz: float4;
    zzww: float4;
    zwxx: float4;
    zwxy: float4;
    zwxz: float4;
    zwxw: float4;
    zwyx: float4;
    zwyy: float4;
    zwyz: float4;
    zwyw: float4;
    zwzx: float4;
    zwzy: float4;
    zwzz: float4;
    zwzw: float4;
    zwwx: float4;
    zwwy: float4;
    zwwz: float4;
    zwww: float4;
    wxxx: float4;
    wxxy: float4;
    wxxz: float4;
    wxxw: float4;
    wxyx: float4;
    wxyy: float4;
    wxyz: float4;
    wxyw: float4;
    wxzx: float4;
    wxzy: float4;
    wxzz: float4;
    wxzw: float4;
    wxwx: float4;
    wxwy: float4;
    wxwz: float4;
    wxww: float4;
    wyxx: float4;
    wyxy: float4;
    wyxz: float4;
    wyxw: float4;
    wyyx: float4;
    wyyy: float4;
    wyyz: float4;
    wyyw: float4;
    wyzx: float4;
    wyzy: float4;
    wyzz: float4;
    wyzw: float4;
    wywx: float4;
    wywy: float4;
    wywz: float4;
    wyww: float4;
    wzxx: float4;
    wzxy: float4;
    wzxz: float4;
    wzxw: float4;
    wzyx: float4;
    wzyy: float4;
    wzyz: float4;
    wzyw: float4;
    wzzx: float4;
    wzzy: float4;
    wzzz: float4;
    wzzw: float4;
    wzwx: float4;
    wzwy: float4;
    wzwz: float4;
    wzww: float4;
    wwxx: float4;
    wwxy: float4;
    wwxz: float4;
    wwxw: float4;
    wwyx: float4;
    wwyy: float4;
    wwyz: float4;
    wwyw: float4;
    wwzx: float4;
    wwzy: float4;
    wwzz: float4;
    wwzw: float4;
    wwwx: float4;
    wwwy: float4;
    wwwz: float4;
    wwww: float4;
    xxx: float3;
    xxy: float3;
    xxz: float3;
    xxw: float3;
    xyx: float3;
    xyy: float3;
    xyz: float3;
    xyw: float3;
    xzx: float3;
    xzy: float3;
    xzz: float3;
    xzw: float3;
    xwx: float3;
    xwy: float3;
    xwz: float3;
    xww: float3;
    yxx: float3;
    yxy: float3;
    yxz: float3;
    yxw: float3;
    yyx: float3;
    yyy: float3;
    yyz: float3;
    yyw: float3;
    yzx: float3;
    yzy: float3;
    yzz: float3;
    yzw: float3;
    ywx: float3;
    ywy: float3;
    ywz: float3;
    yww: float3;
    zxx: float3;
    zxy: float3;
    zxz: float3;
    zxw: float3;
    zyx: float3;
    zyy: float3;
    zyz: float3;
    zyw: float3;
    zzx: float3;
    zzy: float3;
    zzz: float3;
    zzw: float3;
    zwx: float3;
    zwy: float3;
    zwz: float3;
    zww: float3;
    wxx: float3;
    wxy: float3;
    wxz: float3;
    wxw: float3;
    wyx: float3;
    wyy: float3;
    wyz: float3;
    wyw: float3;
    wzx: float3;
    wzy: float3;
    wzz: float3;
    wzw: float3;
    wwx: float3;
    wwy: float3;
    wwz: float3;
    www: float3;
    xx: float2;
    xy: float2;
    xz: float2;
    xw: float2;
    yx: float2;
    yy: float2;
    yz: float2;
    yw: float2;
    zx: float2;
    zy: float2;
    zz: float2;
    zw: float2;
    wx: float2;
    wy: float2;
    wz: float2;
    ww: float2;
    Item: number;


    Equals(rhs: float4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float3 {
    x: number;
    y: number;
    z: number;
    xxxx: float4;
    xxxy: float4;
    xxxz: float4;
    xxyx: float4;
    xxyy: float4;
    xxyz: float4;
    xxzx: float4;
    xxzy: float4;
    xxzz: float4;
    xyxx: float4;
    xyxy: float4;
    xyxz: float4;
    xyyx: float4;
    xyyy: float4;
    xyyz: float4;
    xyzx: float4;
    xyzy: float4;
    xyzz: float4;
    xzxx: float4;
    xzxy: float4;
    xzxz: float4;
    xzyx: float4;
    xzyy: float4;
    xzyz: float4;
    xzzx: float4;
    xzzy: float4;
    xzzz: float4;
    yxxx: float4;
    yxxy: float4;
    yxxz: float4;
    yxyx: float4;
    yxyy: float4;
    yxyz: float4;
    yxzx: float4;
    yxzy: float4;
    yxzz: float4;
    yyxx: float4;
    yyxy: float4;
    yyxz: float4;
    yyyx: float4;
    yyyy: float4;
    yyyz: float4;
    yyzx: float4;
    yyzy: float4;
    yyzz: float4;
    yzxx: float4;
    yzxy: float4;
    yzxz: float4;
    yzyx: float4;
    yzyy: float4;
    yzyz: float4;
    yzzx: float4;
    yzzy: float4;
    yzzz: float4;
    zxxx: float4;
    zxxy: float4;
    zxxz: float4;
    zxyx: float4;
    zxyy: float4;
    zxyz: float4;
    zxzx: float4;
    zxzy: float4;
    zxzz: float4;
    zyxx: float4;
    zyxy: float4;
    zyxz: float4;
    zyyx: float4;
    zyyy: float4;
    zyyz: float4;
    zyzx: float4;
    zyzy: float4;
    zyzz: float4;
    zzxx: float4;
    zzxy: float4;
    zzxz: float4;
    zzyx: float4;
    zzyy: float4;
    zzyz: float4;
    zzzx: float4;
    zzzy: float4;
    zzzz: float4;
    xxx: float3;
    xxy: float3;
    xxz: float3;
    xyx: float3;
    xyy: float3;
    xyz: float3;
    xzx: float3;
    xzy: float3;
    xzz: float3;
    yxx: float3;
    yxy: float3;
    yxz: float3;
    yyx: float3;
    yyy: float3;
    yyz: float3;
    yzx: float3;
    yzy: float3;
    yzz: float3;
    zxx: float3;
    zxy: float3;
    zxz: float3;
    zyx: float3;
    zyy: float3;
    zyz: float3;
    zzx: float3;
    zzy: float3;
    zzz: float3;
    xx: float2;
    xy: float2;
    xz: float2;
    yx: float2;
    yy: float2;
    yz: float2;
    zx: float2;
    zy: float2;
    zz: float2;
    Item: number;


    Equals(rhs: float3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float3Constructor {
    zero: float3;

    new(x: number, y: number, z: number): float3;
    new(x: number, yz: float2): float3;
    new(xy: float2, z: number): float3;
    new(xyz: float3): float3;
    new(v: number): float3;
    new(v: boolean): float3;
    new(v: bool3): float3;
    new(v: number): float3;
    new(v: int3): float3;
    new(v: number): float3;
    new(v: uint3): float3;
    new(v: half): float3;
    new(v: half3): float3;
    new(v: number): float3;
    new(v: double3): float3;


}
declare const float3: float3Constructor;
    
interface float4Constructor {
    zero: float4;

    new(x: number, y: number, z: number, w: number): float4;
    new(x: number, y: number, zw: float2): float4;
    new(x: number, yz: float2, w: number): float4;
    new(x: number, yzw: float3): float4;
    new(xy: float2, z: number, w: number): float4;
    new(xy: float2, zw: float2): float4;
    new(xyz: float3, w: number): float4;
    new(xyzw: float4): float4;
    new(v: number): float4;
    new(v: boolean): float4;
    new(v: bool4): float4;
    new(v: number): float4;
    new(v: int4): float4;
    new(v: number): float4;
    new(v: uint4): float4;
    new(v: half): float4;
    new(v: half4): float4;
    new(v: number): float4;
    new(v: double4): float4;


}
declare const float4: float4Constructor;
    
interface float2Constructor {
    zero: float2;

    new(x: number, y: number): float2;
    new(xy: float2): float2;
    new(v: number): float2;
    new(v: boolean): float2;
    new(v: bool2): float2;
    new(v: number): float2;
    new(v: int2): float2;
    new(v: number): float2;
    new(v: uint2): float2;
    new(v: half): float2;
    new(v: half2): float2;
    new(v: number): float2;
    new(v: double2): float2;


}
declare const float2: float2Constructor;
    
interface float2x2 {
    c0: float2;
    c1: float2;
    Item: unknown;


    Equals(rhs: float2x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float2x2Constructor {
    identity: float2x2;
    zero: float2x2;

    new(c0: float2, c1: float2): float2x2;
    new(m00: number, m01: number, m10: number, m11: number): float2x2;
    new(v: number): float2x2;
    new(v: boolean): float2x2;
    new(v: bool2x2): float2x2;
    new(v: number): float2x2;
    new(v: int2x2): float2x2;
    new(v: number): float2x2;
    new(v: uint2x2): float2x2;
    new(v: number): float2x2;
    new(v: double2x2): float2x2;


    Rotate(angle: number): float2x2;
    Scale(s: number): float2x2;
    Scale(x: number, y: number): float2x2;
    Scale(v: float2): float2x2;
}
declare const float2x2: float2x2Constructor;
    
interface float2x3 {
    c0: float2;
    c1: float2;
    c2: float2;
    Item: unknown;


    Equals(rhs: float2x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float2x3Constructor {
    zero: float2x3;

    new(c0: float2, c1: float2, c2: float2): float2x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number): float2x3;
    new(v: number): float2x3;
    new(v: boolean): float2x3;
    new(v: bool2x3): float2x3;
    new(v: number): float2x3;
    new(v: int2x3): float2x3;
    new(v: number): float2x3;
    new(v: uint2x3): float2x3;
    new(v: number): float2x3;
    new(v: double2x3): float2x3;


}
declare const float2x3: float2x3Constructor;
    
interface float2x4 {
    c0: float2;
    c1: float2;
    c2: float2;
    c3: float2;
    Item: unknown;


    Equals(rhs: float2x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float2x4Constructor {
    zero: float2x4;

    new(c0: float2, c1: float2, c2: float2, c3: float2): float2x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number): float2x4;
    new(v: number): float2x4;
    new(v: boolean): float2x4;
    new(v: bool2x4): float2x4;
    new(v: number): float2x4;
    new(v: int2x4): float2x4;
    new(v: number): float2x4;
    new(v: uint2x4): float2x4;
    new(v: number): float2x4;
    new(v: double2x4): float2x4;


}
declare const float2x4: float2x4Constructor;
    
interface float3x2 {
    c0: float3;
    c1: float3;
    Item: unknown;


    Equals(rhs: float3x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float3x2Constructor {
    zero: float3x2;

    new(c0: float3, c1: float3): float3x2;
    new(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number): float3x2;
    new(v: number): float3x2;
    new(v: boolean): float3x2;
    new(v: bool3x2): float3x2;
    new(v: number): float3x2;
    new(v: int3x2): float3x2;
    new(v: number): float3x2;
    new(v: uint3x2): float3x2;
    new(v: number): float3x2;
    new(v: double3x2): float3x2;


}
declare const float3x2: float3x2Constructor;
    
interface float3x3 {
    c0: float3;
    c1: float3;
    c2: float3;
    Item: unknown;


    Equals(rhs: float3x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float3x3Constructor {
    identity: float3x3;
    zero: float3x3;

    new(c0: float3, c1: float3, c2: float3): float3x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): float3x3;
    new(v: number): float3x3;
    new(v: boolean): float3x3;
    new(v: bool3x3): float3x3;
    new(v: number): float3x3;
    new(v: int3x3): float3x3;
    new(v: number): float3x3;
    new(v: uint3x3): float3x3;
    new(v: number): float3x3;
    new(v: double3x3): float3x3;
    new(f4x4: float4x4): float3x3;
    new(q: quaternion): float3x3;


    AxisAngle(axis: float3, angle: number): float3x3;
    Euler(xyz: float3, order: RotationOrder): float3x3;
    Euler(x: number, y: number, z: number, order: RotationOrder): float3x3;
    EulerXYZ(xyz: float3): float3x3;
    EulerXYZ(x: number, y: number, z: number): float3x3;
    EulerXZY(xyz: float3): float3x3;
    EulerXZY(x: number, y: number, z: number): float3x3;
    EulerYXZ(xyz: float3): float3x3;
    EulerYXZ(x: number, y: number, z: number): float3x3;
    EulerYZX(xyz: float3): float3x3;
    EulerYZX(x: number, y: number, z: number): float3x3;
    EulerZXY(xyz: float3): float3x3;
    EulerZXY(x: number, y: number, z: number): float3x3;
    EulerZYX(xyz: float3): float3x3;
    EulerZYX(x: number, y: number, z: number): float3x3;
    LookRotation(forward: float3, up: float3): float3x3;
    LookRotationSafe(forward: float3, up: float3): float3x3;
    RotateX(angle: number): float3x3;
    RotateY(angle: number): float3x3;
    RotateZ(angle: number): float3x3;
    Scale(s: number): float3x3;
    Scale(x: number, y: number, z: number): float3x3;
    Scale(v: float3): float3x3;
}
declare const float3x3: float3x3Constructor;
    
interface float3x4 {
    c0: float3;
    c1: float3;
    c2: float3;
    c3: float3;
    Item: unknown;


    Equals(rhs: float3x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float3x4Constructor {
    zero: float3x4;

    new(c0: float3, c1: float3, c2: float3, c3: float3): float3x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number): float3x4;
    new(v: number): float3x4;
    new(v: boolean): float3x4;
    new(v: bool3x4): float3x4;
    new(v: number): float3x4;
    new(v: int3x4): float3x4;
    new(v: number): float3x4;
    new(v: uint3x4): float3x4;
    new(v: number): float3x4;
    new(v: double3x4): float3x4;


}
declare const float3x4: float3x4Constructor;
    
interface float4x2 {
    c0: float4;
    c1: float4;
    Item: unknown;


    Equals(rhs: float4x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float4x2Constructor {
    zero: float4x2;

    new(c0: float4, c1: float4): float4x2;
    new(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number, m30: number, m31: number): float4x2;
    new(v: number): float4x2;
    new(v: boolean): float4x2;
    new(v: bool4x2): float4x2;
    new(v: number): float4x2;
    new(v: int4x2): float4x2;
    new(v: number): float4x2;
    new(v: uint4x2): float4x2;
    new(v: number): float4x2;
    new(v: double4x2): float4x2;


}
declare const float4x2: float4x2Constructor;
    
interface float4x3 {
    c0: float4;
    c1: float4;
    c2: float4;
    Item: unknown;


    Equals(rhs: float4x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface float4x3Constructor {
    zero: float4x3;

    new(c0: float4, c1: float4, c2: float4): float4x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number, m30: number, m31: number, m32: number): float4x3;
    new(v: number): float4x3;
    new(v: boolean): float4x3;
    new(v: bool4x3): float4x3;
    new(v: number): float4x3;
    new(v: int4x3): float4x3;
    new(v: number): float4x3;
    new(v: uint4x3): float4x3;
    new(v: number): float4x3;
    new(v: double4x3): float4x3;


}
declare const float4x3: float4x3Constructor;
    
interface float4x4 {
    c0: float4;
    c1: float4;
    c2: float4;
    c3: float4;
    Item: unknown;


    Equals(rhs: float4x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface quaternion {
    value: float4;


    Equals(x: quaternion): boolean;
    Equals(x: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface quaternionConstructor {
    identity: quaternion;

    new(x: number, y: number, z: number, w: number): quaternion;
    new(value: float4): quaternion;
    new(m: float3x3): quaternion;
    new(m: float4x4): quaternion;


    AxisAngle(axis: float3, angle: number): quaternion;
    Euler(xyz: float3, order: RotationOrder): quaternion;
    Euler(x: number, y: number, z: number, order: RotationOrder): quaternion;
    EulerXYZ(xyz: float3): quaternion;
    EulerXYZ(x: number, y: number, z: number): quaternion;
    EulerXZY(xyz: float3): quaternion;
    EulerXZY(x: number, y: number, z: number): quaternion;
    EulerYXZ(xyz: float3): quaternion;
    EulerYXZ(x: number, y: number, z: number): quaternion;
    EulerYZX(xyz: float3): quaternion;
    EulerYZX(x: number, y: number, z: number): quaternion;
    EulerZXY(xyz: float3): quaternion;
    EulerZXY(x: number, y: number, z: number): quaternion;
    EulerZYX(xyz: float3): quaternion;
    EulerZYX(x: number, y: number, z: number): quaternion;
    LookRotation(forward: float3, up: float3): quaternion;
    LookRotationSafe(forward: float3, up: float3): quaternion;
    RotateX(angle: number): quaternion;
    RotateY(angle: number): quaternion;
    RotateZ(angle: number): quaternion;
}
declare const quaternion: quaternionConstructor;
    
interface float4x4Constructor {
    identity: float4x4;
    zero: float4x4;

    new(c0: float4, c1: float4, c2: float4, c3: float4): float4x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): float4x4;
    new(v: number): float4x4;
    new(v: boolean): float4x4;
    new(v: bool4x4): float4x4;
    new(v: number): float4x4;
    new(v: int4x4): float4x4;
    new(v: number): float4x4;
    new(v: uint4x4): float4x4;
    new(v: number): float4x4;
    new(v: double4x4): float4x4;
    new(rotation: float3x3, translation: float3): float4x4;
    new(rotation: quaternion, translation: float3): float4x4;
    new(transform: RigidTransform): float4x4;


    AxisAngle(axis: float3, angle: number): float4x4;
    Euler(xyz: float3, order: RotationOrder): float4x4;
    Euler(x: number, y: number, z: number, order: RotationOrder): float4x4;
    EulerXYZ(xyz: float3): float4x4;
    EulerXYZ(x: number, y: number, z: number): float4x4;
    EulerXZY(xyz: float3): float4x4;
    EulerXZY(x: number, y: number, z: number): float4x4;
    EulerYXZ(xyz: float3): float4x4;
    EulerYXZ(x: number, y: number, z: number): float4x4;
    EulerYZX(xyz: float3): float4x4;
    EulerYZX(x: number, y: number, z: number): float4x4;
    EulerZXY(xyz: float3): float4x4;
    EulerZXY(x: number, y: number, z: number): float4x4;
    EulerZYX(xyz: float3): float4x4;
    EulerZYX(x: number, y: number, z: number): float4x4;
    LookAt(eye: float3, target: float3, up: float3): float4x4;
    Ortho(width: number, height: number, near: number, far: number): float4x4;
    OrthoOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number): float4x4;
    PerspectiveFov(verticalFov: number, aspect: number, near: number, far: number): float4x4;
    PerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number): float4x4;
    RotateX(angle: number): float4x4;
    RotateY(angle: number): float4x4;
    RotateZ(angle: number): float4x4;
    Scale(s: number): float4x4;
    Scale(x: number, y: number, z: number): float4x4;
    Scale(scales: float3): float4x4;
    Translate(vector: float3): float4x4;
    TRS(translation: float3, rotation: quaternion, scale: float3): float4x4;
}
declare const float4x4: float4x4Constructor;
    
interface half {
    value: number;


    Equals(rhs: half): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface halfConstructor {
    zero: half;
    MaxValue: number;
    MinValue: number;
    MaxValueAsHalf: half;
    MinValueAsHalf: half;

    new(x: half): half;
    new(v: number): half;
    new(v: number): half;


}
declare const half: halfConstructor;
    
interface half2 {
    x: half;
    y: half;
    xxxx: half4;
    xxxy: half4;
    xxyx: half4;
    xxyy: half4;
    xyxx: half4;
    xyxy: half4;
    xyyx: half4;
    xyyy: half4;
    yxxx: half4;
    yxxy: half4;
    yxyx: half4;
    yxyy: half4;
    yyxx: half4;
    yyxy: half4;
    yyyx: half4;
    yyyy: half4;
    xxx: half3;
    xxy: half3;
    xyx: half3;
    xyy: half3;
    yxx: half3;
    yxy: half3;
    yyx: half3;
    yyy: half3;
    xx: half2;
    xy: half2;
    yx: half2;
    yy: half2;
    Item: half;


    Equals(rhs: half2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface half4 {
    x: half;
    y: half;
    z: half;
    w: half;
    xxxx: half4;
    xxxy: half4;
    xxxz: half4;
    xxxw: half4;
    xxyx: half4;
    xxyy: half4;
    xxyz: half4;
    xxyw: half4;
    xxzx: half4;
    xxzy: half4;
    xxzz: half4;
    xxzw: half4;
    xxwx: half4;
    xxwy: half4;
    xxwz: half4;
    xxww: half4;
    xyxx: half4;
    xyxy: half4;
    xyxz: half4;
    xyxw: half4;
    xyyx: half4;
    xyyy: half4;
    xyyz: half4;
    xyyw: half4;
    xyzx: half4;
    xyzy: half4;
    xyzz: half4;
    xyzw: half4;
    xywx: half4;
    xywy: half4;
    xywz: half4;
    xyww: half4;
    xzxx: half4;
    xzxy: half4;
    xzxz: half4;
    xzxw: half4;
    xzyx: half4;
    xzyy: half4;
    xzyz: half4;
    xzyw: half4;
    xzzx: half4;
    xzzy: half4;
    xzzz: half4;
    xzzw: half4;
    xzwx: half4;
    xzwy: half4;
    xzwz: half4;
    xzww: half4;
    xwxx: half4;
    xwxy: half4;
    xwxz: half4;
    xwxw: half4;
    xwyx: half4;
    xwyy: half4;
    xwyz: half4;
    xwyw: half4;
    xwzx: half4;
    xwzy: half4;
    xwzz: half4;
    xwzw: half4;
    xwwx: half4;
    xwwy: half4;
    xwwz: half4;
    xwww: half4;
    yxxx: half4;
    yxxy: half4;
    yxxz: half4;
    yxxw: half4;
    yxyx: half4;
    yxyy: half4;
    yxyz: half4;
    yxyw: half4;
    yxzx: half4;
    yxzy: half4;
    yxzz: half4;
    yxzw: half4;
    yxwx: half4;
    yxwy: half4;
    yxwz: half4;
    yxww: half4;
    yyxx: half4;
    yyxy: half4;
    yyxz: half4;
    yyxw: half4;
    yyyx: half4;
    yyyy: half4;
    yyyz: half4;
    yyyw: half4;
    yyzx: half4;
    yyzy: half4;
    yyzz: half4;
    yyzw: half4;
    yywx: half4;
    yywy: half4;
    yywz: half4;
    yyww: half4;
    yzxx: half4;
    yzxy: half4;
    yzxz: half4;
    yzxw: half4;
    yzyx: half4;
    yzyy: half4;
    yzyz: half4;
    yzyw: half4;
    yzzx: half4;
    yzzy: half4;
    yzzz: half4;
    yzzw: half4;
    yzwx: half4;
    yzwy: half4;
    yzwz: half4;
    yzww: half4;
    ywxx: half4;
    ywxy: half4;
    ywxz: half4;
    ywxw: half4;
    ywyx: half4;
    ywyy: half4;
    ywyz: half4;
    ywyw: half4;
    ywzx: half4;
    ywzy: half4;
    ywzz: half4;
    ywzw: half4;
    ywwx: half4;
    ywwy: half4;
    ywwz: half4;
    ywww: half4;
    zxxx: half4;
    zxxy: half4;
    zxxz: half4;
    zxxw: half4;
    zxyx: half4;
    zxyy: half4;
    zxyz: half4;
    zxyw: half4;
    zxzx: half4;
    zxzy: half4;
    zxzz: half4;
    zxzw: half4;
    zxwx: half4;
    zxwy: half4;
    zxwz: half4;
    zxww: half4;
    zyxx: half4;
    zyxy: half4;
    zyxz: half4;
    zyxw: half4;
    zyyx: half4;
    zyyy: half4;
    zyyz: half4;
    zyyw: half4;
    zyzx: half4;
    zyzy: half4;
    zyzz: half4;
    zyzw: half4;
    zywx: half4;
    zywy: half4;
    zywz: half4;
    zyww: half4;
    zzxx: half4;
    zzxy: half4;
    zzxz: half4;
    zzxw: half4;
    zzyx: half4;
    zzyy: half4;
    zzyz: half4;
    zzyw: half4;
    zzzx: half4;
    zzzy: half4;
    zzzz: half4;
    zzzw: half4;
    zzwx: half4;
    zzwy: half4;
    zzwz: half4;
    zzww: half4;
    zwxx: half4;
    zwxy: half4;
    zwxz: half4;
    zwxw: half4;
    zwyx: half4;
    zwyy: half4;
    zwyz: half4;
    zwyw: half4;
    zwzx: half4;
    zwzy: half4;
    zwzz: half4;
    zwzw: half4;
    zwwx: half4;
    zwwy: half4;
    zwwz: half4;
    zwww: half4;
    wxxx: half4;
    wxxy: half4;
    wxxz: half4;
    wxxw: half4;
    wxyx: half4;
    wxyy: half4;
    wxyz: half4;
    wxyw: half4;
    wxzx: half4;
    wxzy: half4;
    wxzz: half4;
    wxzw: half4;
    wxwx: half4;
    wxwy: half4;
    wxwz: half4;
    wxww: half4;
    wyxx: half4;
    wyxy: half4;
    wyxz: half4;
    wyxw: half4;
    wyyx: half4;
    wyyy: half4;
    wyyz: half4;
    wyyw: half4;
    wyzx: half4;
    wyzy: half4;
    wyzz: half4;
    wyzw: half4;
    wywx: half4;
    wywy: half4;
    wywz: half4;
    wyww: half4;
    wzxx: half4;
    wzxy: half4;
    wzxz: half4;
    wzxw: half4;
    wzyx: half4;
    wzyy: half4;
    wzyz: half4;
    wzyw: half4;
    wzzx: half4;
    wzzy: half4;
    wzzz: half4;
    wzzw: half4;
    wzwx: half4;
    wzwy: half4;
    wzwz: half4;
    wzww: half4;
    wwxx: half4;
    wwxy: half4;
    wwxz: half4;
    wwxw: half4;
    wwyx: half4;
    wwyy: half4;
    wwyz: half4;
    wwyw: half4;
    wwzx: half4;
    wwzy: half4;
    wwzz: half4;
    wwzw: half4;
    wwwx: half4;
    wwwy: half4;
    wwwz: half4;
    wwww: half4;
    xxx: half3;
    xxy: half3;
    xxz: half3;
    xxw: half3;
    xyx: half3;
    xyy: half3;
    xyz: half3;
    xyw: half3;
    xzx: half3;
    xzy: half3;
    xzz: half3;
    xzw: half3;
    xwx: half3;
    xwy: half3;
    xwz: half3;
    xww: half3;
    yxx: half3;
    yxy: half3;
    yxz: half3;
    yxw: half3;
    yyx: half3;
    yyy: half3;
    yyz: half3;
    yyw: half3;
    yzx: half3;
    yzy: half3;
    yzz: half3;
    yzw: half3;
    ywx: half3;
    ywy: half3;
    ywz: half3;
    yww: half3;
    zxx: half3;
    zxy: half3;
    zxz: half3;
    zxw: half3;
    zyx: half3;
    zyy: half3;
    zyz: half3;
    zyw: half3;
    zzx: half3;
    zzy: half3;
    zzz: half3;
    zzw: half3;
    zwx: half3;
    zwy: half3;
    zwz: half3;
    zww: half3;
    wxx: half3;
    wxy: half3;
    wxz: half3;
    wxw: half3;
    wyx: half3;
    wyy: half3;
    wyz: half3;
    wyw: half3;
    wzx: half3;
    wzy: half3;
    wzz: half3;
    wzw: half3;
    wwx: half3;
    wwy: half3;
    wwz: half3;
    www: half3;
    xx: half2;
    xy: half2;
    xz: half2;
    xw: half2;
    yx: half2;
    yy: half2;
    yz: half2;
    yw: half2;
    zx: half2;
    zy: half2;
    zz: half2;
    zw: half2;
    wx: half2;
    wy: half2;
    wz: half2;
    ww: half2;
    Item: half;


    Equals(rhs: half4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface half3 {
    x: half;
    y: half;
    z: half;
    xxxx: half4;
    xxxy: half4;
    xxxz: half4;
    xxyx: half4;
    xxyy: half4;
    xxyz: half4;
    xxzx: half4;
    xxzy: half4;
    xxzz: half4;
    xyxx: half4;
    xyxy: half4;
    xyxz: half4;
    xyyx: half4;
    xyyy: half4;
    xyyz: half4;
    xyzx: half4;
    xyzy: half4;
    xyzz: half4;
    xzxx: half4;
    xzxy: half4;
    xzxz: half4;
    xzyx: half4;
    xzyy: half4;
    xzyz: half4;
    xzzx: half4;
    xzzy: half4;
    xzzz: half4;
    yxxx: half4;
    yxxy: half4;
    yxxz: half4;
    yxyx: half4;
    yxyy: half4;
    yxyz: half4;
    yxzx: half4;
    yxzy: half4;
    yxzz: half4;
    yyxx: half4;
    yyxy: half4;
    yyxz: half4;
    yyyx: half4;
    yyyy: half4;
    yyyz: half4;
    yyzx: half4;
    yyzy: half4;
    yyzz: half4;
    yzxx: half4;
    yzxy: half4;
    yzxz: half4;
    yzyx: half4;
    yzyy: half4;
    yzyz: half4;
    yzzx: half4;
    yzzy: half4;
    yzzz: half4;
    zxxx: half4;
    zxxy: half4;
    zxxz: half4;
    zxyx: half4;
    zxyy: half4;
    zxyz: half4;
    zxzx: half4;
    zxzy: half4;
    zxzz: half4;
    zyxx: half4;
    zyxy: half4;
    zyxz: half4;
    zyyx: half4;
    zyyy: half4;
    zyyz: half4;
    zyzx: half4;
    zyzy: half4;
    zyzz: half4;
    zzxx: half4;
    zzxy: half4;
    zzxz: half4;
    zzyx: half4;
    zzyy: half4;
    zzyz: half4;
    zzzx: half4;
    zzzy: half4;
    zzzz: half4;
    xxx: half3;
    xxy: half3;
    xxz: half3;
    xyx: half3;
    xyy: half3;
    xyz: half3;
    xzx: half3;
    xzy: half3;
    xzz: half3;
    yxx: half3;
    yxy: half3;
    yxz: half3;
    yyx: half3;
    yyy: half3;
    yyz: half3;
    yzx: half3;
    yzy: half3;
    yzz: half3;
    zxx: half3;
    zxy: half3;
    zxz: half3;
    zyx: half3;
    zyy: half3;
    zyz: half3;
    zzx: half3;
    zzy: half3;
    zzz: half3;
    xx: half2;
    xy: half2;
    xz: half2;
    yx: half2;
    yy: half2;
    yz: half2;
    zx: half2;
    zy: half2;
    zz: half2;
    Item: half;


    Equals(rhs: half3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface half3Constructor {
    zero: half3;

    new(x: half, y: half, z: half): half3;
    new(x: half, yz: half2): half3;
    new(xy: half2, z: half): half3;
    new(xyz: half3): half3;
    new(v: half): half3;
    new(v: number): half3;
    new(v: float3): half3;
    new(v: number): half3;
    new(v: double3): half3;


}
declare const half3: half3Constructor;
    
interface half4Constructor {
    zero: half4;

    new(x: half, y: half, z: half, w: half): half4;
    new(x: half, y: half, zw: half2): half4;
    new(x: half, yz: half2, w: half): half4;
    new(x: half, yzw: half3): half4;
    new(xy: half2, z: half, w: half): half4;
    new(xy: half2, zw: half2): half4;
    new(xyz: half3, w: half): half4;
    new(xyzw: half4): half4;
    new(v: half): half4;
    new(v: number): half4;
    new(v: float4): half4;
    new(v: number): half4;
    new(v: double4): half4;


}
declare const half4: half4Constructor;
    
interface half2Constructor {
    zero: half2;

    new(x: half, y: half): half2;
    new(xy: half2): half2;
    new(v: half): half2;
    new(v: number): half2;
    new(v: float2): half2;
    new(v: number): half2;
    new(v: double2): half2;


}
declare const half2: half2Constructor;
    
interface int2 {
    x: number;
    y: number;
    xxxx: int4;
    xxxy: int4;
    xxyx: int4;
    xxyy: int4;
    xyxx: int4;
    xyxy: int4;
    xyyx: int4;
    xyyy: int4;
    yxxx: int4;
    yxxy: int4;
    yxyx: int4;
    yxyy: int4;
    yyxx: int4;
    yyxy: int4;
    yyyx: int4;
    yyyy: int4;
    xxx: int3;
    xxy: int3;
    xyx: int3;
    xyy: int3;
    yxx: int3;
    yxy: int3;
    yyx: int3;
    yyy: int3;
    xx: int2;
    xy: int2;
    yx: int2;
    yy: int2;
    Item: number;


    Equals(rhs: int2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int4 {
    x: number;
    y: number;
    z: number;
    w: number;
    xxxx: int4;
    xxxy: int4;
    xxxz: int4;
    xxxw: int4;
    xxyx: int4;
    xxyy: int4;
    xxyz: int4;
    xxyw: int4;
    xxzx: int4;
    xxzy: int4;
    xxzz: int4;
    xxzw: int4;
    xxwx: int4;
    xxwy: int4;
    xxwz: int4;
    xxww: int4;
    xyxx: int4;
    xyxy: int4;
    xyxz: int4;
    xyxw: int4;
    xyyx: int4;
    xyyy: int4;
    xyyz: int4;
    xyyw: int4;
    xyzx: int4;
    xyzy: int4;
    xyzz: int4;
    xyzw: int4;
    xywx: int4;
    xywy: int4;
    xywz: int4;
    xyww: int4;
    xzxx: int4;
    xzxy: int4;
    xzxz: int4;
    xzxw: int4;
    xzyx: int4;
    xzyy: int4;
    xzyz: int4;
    xzyw: int4;
    xzzx: int4;
    xzzy: int4;
    xzzz: int4;
    xzzw: int4;
    xzwx: int4;
    xzwy: int4;
    xzwz: int4;
    xzww: int4;
    xwxx: int4;
    xwxy: int4;
    xwxz: int4;
    xwxw: int4;
    xwyx: int4;
    xwyy: int4;
    xwyz: int4;
    xwyw: int4;
    xwzx: int4;
    xwzy: int4;
    xwzz: int4;
    xwzw: int4;
    xwwx: int4;
    xwwy: int4;
    xwwz: int4;
    xwww: int4;
    yxxx: int4;
    yxxy: int4;
    yxxz: int4;
    yxxw: int4;
    yxyx: int4;
    yxyy: int4;
    yxyz: int4;
    yxyw: int4;
    yxzx: int4;
    yxzy: int4;
    yxzz: int4;
    yxzw: int4;
    yxwx: int4;
    yxwy: int4;
    yxwz: int4;
    yxww: int4;
    yyxx: int4;
    yyxy: int4;
    yyxz: int4;
    yyxw: int4;
    yyyx: int4;
    yyyy: int4;
    yyyz: int4;
    yyyw: int4;
    yyzx: int4;
    yyzy: int4;
    yyzz: int4;
    yyzw: int4;
    yywx: int4;
    yywy: int4;
    yywz: int4;
    yyww: int4;
    yzxx: int4;
    yzxy: int4;
    yzxz: int4;
    yzxw: int4;
    yzyx: int4;
    yzyy: int4;
    yzyz: int4;
    yzyw: int4;
    yzzx: int4;
    yzzy: int4;
    yzzz: int4;
    yzzw: int4;
    yzwx: int4;
    yzwy: int4;
    yzwz: int4;
    yzww: int4;
    ywxx: int4;
    ywxy: int4;
    ywxz: int4;
    ywxw: int4;
    ywyx: int4;
    ywyy: int4;
    ywyz: int4;
    ywyw: int4;
    ywzx: int4;
    ywzy: int4;
    ywzz: int4;
    ywzw: int4;
    ywwx: int4;
    ywwy: int4;
    ywwz: int4;
    ywww: int4;
    zxxx: int4;
    zxxy: int4;
    zxxz: int4;
    zxxw: int4;
    zxyx: int4;
    zxyy: int4;
    zxyz: int4;
    zxyw: int4;
    zxzx: int4;
    zxzy: int4;
    zxzz: int4;
    zxzw: int4;
    zxwx: int4;
    zxwy: int4;
    zxwz: int4;
    zxww: int4;
    zyxx: int4;
    zyxy: int4;
    zyxz: int4;
    zyxw: int4;
    zyyx: int4;
    zyyy: int4;
    zyyz: int4;
    zyyw: int4;
    zyzx: int4;
    zyzy: int4;
    zyzz: int4;
    zyzw: int4;
    zywx: int4;
    zywy: int4;
    zywz: int4;
    zyww: int4;
    zzxx: int4;
    zzxy: int4;
    zzxz: int4;
    zzxw: int4;
    zzyx: int4;
    zzyy: int4;
    zzyz: int4;
    zzyw: int4;
    zzzx: int4;
    zzzy: int4;
    zzzz: int4;
    zzzw: int4;
    zzwx: int4;
    zzwy: int4;
    zzwz: int4;
    zzww: int4;
    zwxx: int4;
    zwxy: int4;
    zwxz: int4;
    zwxw: int4;
    zwyx: int4;
    zwyy: int4;
    zwyz: int4;
    zwyw: int4;
    zwzx: int4;
    zwzy: int4;
    zwzz: int4;
    zwzw: int4;
    zwwx: int4;
    zwwy: int4;
    zwwz: int4;
    zwww: int4;
    wxxx: int4;
    wxxy: int4;
    wxxz: int4;
    wxxw: int4;
    wxyx: int4;
    wxyy: int4;
    wxyz: int4;
    wxyw: int4;
    wxzx: int4;
    wxzy: int4;
    wxzz: int4;
    wxzw: int4;
    wxwx: int4;
    wxwy: int4;
    wxwz: int4;
    wxww: int4;
    wyxx: int4;
    wyxy: int4;
    wyxz: int4;
    wyxw: int4;
    wyyx: int4;
    wyyy: int4;
    wyyz: int4;
    wyyw: int4;
    wyzx: int4;
    wyzy: int4;
    wyzz: int4;
    wyzw: int4;
    wywx: int4;
    wywy: int4;
    wywz: int4;
    wyww: int4;
    wzxx: int4;
    wzxy: int4;
    wzxz: int4;
    wzxw: int4;
    wzyx: int4;
    wzyy: int4;
    wzyz: int4;
    wzyw: int4;
    wzzx: int4;
    wzzy: int4;
    wzzz: int4;
    wzzw: int4;
    wzwx: int4;
    wzwy: int4;
    wzwz: int4;
    wzww: int4;
    wwxx: int4;
    wwxy: int4;
    wwxz: int4;
    wwxw: int4;
    wwyx: int4;
    wwyy: int4;
    wwyz: int4;
    wwyw: int4;
    wwzx: int4;
    wwzy: int4;
    wwzz: int4;
    wwzw: int4;
    wwwx: int4;
    wwwy: int4;
    wwwz: int4;
    wwww: int4;
    xxx: int3;
    xxy: int3;
    xxz: int3;
    xxw: int3;
    xyx: int3;
    xyy: int3;
    xyz: int3;
    xyw: int3;
    xzx: int3;
    xzy: int3;
    xzz: int3;
    xzw: int3;
    xwx: int3;
    xwy: int3;
    xwz: int3;
    xww: int3;
    yxx: int3;
    yxy: int3;
    yxz: int3;
    yxw: int3;
    yyx: int3;
    yyy: int3;
    yyz: int3;
    yyw: int3;
    yzx: int3;
    yzy: int3;
    yzz: int3;
    yzw: int3;
    ywx: int3;
    ywy: int3;
    ywz: int3;
    yww: int3;
    zxx: int3;
    zxy: int3;
    zxz: int3;
    zxw: int3;
    zyx: int3;
    zyy: int3;
    zyz: int3;
    zyw: int3;
    zzx: int3;
    zzy: int3;
    zzz: int3;
    zzw: int3;
    zwx: int3;
    zwy: int3;
    zwz: int3;
    zww: int3;
    wxx: int3;
    wxy: int3;
    wxz: int3;
    wxw: int3;
    wyx: int3;
    wyy: int3;
    wyz: int3;
    wyw: int3;
    wzx: int3;
    wzy: int3;
    wzz: int3;
    wzw: int3;
    wwx: int3;
    wwy: int3;
    wwz: int3;
    www: int3;
    xx: int2;
    xy: int2;
    xz: int2;
    xw: int2;
    yx: int2;
    yy: int2;
    yz: int2;
    yw: int2;
    zx: int2;
    zy: int2;
    zz: int2;
    zw: int2;
    wx: int2;
    wy: int2;
    wz: int2;
    ww: int2;
    Item: number;


    Equals(rhs: int4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int3 {
    x: number;
    y: number;
    z: number;
    xxxx: int4;
    xxxy: int4;
    xxxz: int4;
    xxyx: int4;
    xxyy: int4;
    xxyz: int4;
    xxzx: int4;
    xxzy: int4;
    xxzz: int4;
    xyxx: int4;
    xyxy: int4;
    xyxz: int4;
    xyyx: int4;
    xyyy: int4;
    xyyz: int4;
    xyzx: int4;
    xyzy: int4;
    xyzz: int4;
    xzxx: int4;
    xzxy: int4;
    xzxz: int4;
    xzyx: int4;
    xzyy: int4;
    xzyz: int4;
    xzzx: int4;
    xzzy: int4;
    xzzz: int4;
    yxxx: int4;
    yxxy: int4;
    yxxz: int4;
    yxyx: int4;
    yxyy: int4;
    yxyz: int4;
    yxzx: int4;
    yxzy: int4;
    yxzz: int4;
    yyxx: int4;
    yyxy: int4;
    yyxz: int4;
    yyyx: int4;
    yyyy: int4;
    yyyz: int4;
    yyzx: int4;
    yyzy: int4;
    yyzz: int4;
    yzxx: int4;
    yzxy: int4;
    yzxz: int4;
    yzyx: int4;
    yzyy: int4;
    yzyz: int4;
    yzzx: int4;
    yzzy: int4;
    yzzz: int4;
    zxxx: int4;
    zxxy: int4;
    zxxz: int4;
    zxyx: int4;
    zxyy: int4;
    zxyz: int4;
    zxzx: int4;
    zxzy: int4;
    zxzz: int4;
    zyxx: int4;
    zyxy: int4;
    zyxz: int4;
    zyyx: int4;
    zyyy: int4;
    zyyz: int4;
    zyzx: int4;
    zyzy: int4;
    zyzz: int4;
    zzxx: int4;
    zzxy: int4;
    zzxz: int4;
    zzyx: int4;
    zzyy: int4;
    zzyz: int4;
    zzzx: int4;
    zzzy: int4;
    zzzz: int4;
    xxx: int3;
    xxy: int3;
    xxz: int3;
    xyx: int3;
    xyy: int3;
    xyz: int3;
    xzx: int3;
    xzy: int3;
    xzz: int3;
    yxx: int3;
    yxy: int3;
    yxz: int3;
    yyx: int3;
    yyy: int3;
    yyz: int3;
    yzx: int3;
    yzy: int3;
    yzz: int3;
    zxx: int3;
    zxy: int3;
    zxz: int3;
    zyx: int3;
    zyy: int3;
    zyz: int3;
    zzx: int3;
    zzy: int3;
    zzz: int3;
    xx: int2;
    xy: int2;
    xz: int2;
    yx: int2;
    yy: int2;
    yz: int2;
    zx: int2;
    zy: int2;
    zz: int2;
    Item: number;


    Equals(rhs: int3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int3Constructor {
    zero: int3;

    new(x: number, y: number, z: number): int3;
    new(x: number, yz: int2): int3;
    new(xy: int2, z: number): int3;
    new(xyz: int3): int3;
    new(v: number): int3;
    new(v: boolean): int3;
    new(v: bool3): int3;
    new(v: number): int3;
    new(v: uint3): int3;
    new(v: number): int3;
    new(v: float3): int3;
    new(v: number): int3;
    new(v: double3): int3;


}
declare const int3: int3Constructor;
    
interface int4Constructor {
    zero: int4;

    new(x: number, y: number, z: number, w: number): int4;
    new(x: number, y: number, zw: int2): int4;
    new(x: number, yz: int2, w: number): int4;
    new(x: number, yzw: int3): int4;
    new(xy: int2, z: number, w: number): int4;
    new(xy: int2, zw: int2): int4;
    new(xyz: int3, w: number): int4;
    new(xyzw: int4): int4;
    new(v: number): int4;
    new(v: boolean): int4;
    new(v: bool4): int4;
    new(v: number): int4;
    new(v: uint4): int4;
    new(v: number): int4;
    new(v: float4): int4;
    new(v: number): int4;
    new(v: double4): int4;


}
declare const int4: int4Constructor;
    
interface int2Constructor {
    zero: int2;

    new(x: number, y: number): int2;
    new(xy: int2): int2;
    new(v: number): int2;
    new(v: boolean): int2;
    new(v: bool2): int2;
    new(v: number): int2;
    new(v: uint2): int2;
    new(v: number): int2;
    new(v: float2): int2;
    new(v: number): int2;
    new(v: double2): int2;


}
declare const int2: int2Constructor;
    
interface int2x2 {
    c0: int2;
    c1: int2;
    Item: unknown;


    Equals(rhs: int2x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int2x2Constructor {
    identity: int2x2;
    zero: int2x2;

    new(c0: int2, c1: int2): int2x2;
    new(m00: number, m01: number, m10: number, m11: number): int2x2;
    new(v: number): int2x2;
    new(v: boolean): int2x2;
    new(v: bool2x2): int2x2;
    new(v: number): int2x2;
    new(v: uint2x2): int2x2;
    new(v: number): int2x2;
    new(v: float2x2): int2x2;
    new(v: number): int2x2;
    new(v: double2x2): int2x2;


}
declare const int2x2: int2x2Constructor;
    
interface int2x3 {
    c0: int2;
    c1: int2;
    c2: int2;
    Item: unknown;


    Equals(rhs: int2x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int2x3Constructor {
    zero: int2x3;

    new(c0: int2, c1: int2, c2: int2): int2x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number): int2x3;
    new(v: number): int2x3;
    new(v: boolean): int2x3;
    new(v: bool2x3): int2x3;
    new(v: number): int2x3;
    new(v: uint2x3): int2x3;
    new(v: number): int2x3;
    new(v: float2x3): int2x3;
    new(v: number): int2x3;
    new(v: double2x3): int2x3;


}
declare const int2x3: int2x3Constructor;
    
interface int2x4 {
    c0: int2;
    c1: int2;
    c2: int2;
    c3: int2;
    Item: unknown;


    Equals(rhs: int2x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int2x4Constructor {
    zero: int2x4;

    new(c0: int2, c1: int2, c2: int2, c3: int2): int2x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number): int2x4;
    new(v: number): int2x4;
    new(v: boolean): int2x4;
    new(v: bool2x4): int2x4;
    new(v: number): int2x4;
    new(v: uint2x4): int2x4;
    new(v: number): int2x4;
    new(v: float2x4): int2x4;
    new(v: number): int2x4;
    new(v: double2x4): int2x4;


}
declare const int2x4: int2x4Constructor;
    
interface int3x2 {
    c0: int3;
    c1: int3;
    Item: unknown;


    Equals(rhs: int3x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int3x2Constructor {
    zero: int3x2;

    new(c0: int3, c1: int3): int3x2;
    new(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number): int3x2;
    new(v: number): int3x2;
    new(v: boolean): int3x2;
    new(v: bool3x2): int3x2;
    new(v: number): int3x2;
    new(v: uint3x2): int3x2;
    new(v: number): int3x2;
    new(v: float3x2): int3x2;
    new(v: number): int3x2;
    new(v: double3x2): int3x2;


}
declare const int3x2: int3x2Constructor;
    
interface int3x3 {
    c0: int3;
    c1: int3;
    c2: int3;
    Item: unknown;


    Equals(rhs: int3x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int3x3Constructor {
    identity: int3x3;
    zero: int3x3;

    new(c0: int3, c1: int3, c2: int3): int3x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): int3x3;
    new(v: number): int3x3;
    new(v: boolean): int3x3;
    new(v: bool3x3): int3x3;
    new(v: number): int3x3;
    new(v: uint3x3): int3x3;
    new(v: number): int3x3;
    new(v: float3x3): int3x3;
    new(v: number): int3x3;
    new(v: double3x3): int3x3;


}
declare const int3x3: int3x3Constructor;
    
interface int3x4 {
    c0: int3;
    c1: int3;
    c2: int3;
    c3: int3;
    Item: unknown;


    Equals(rhs: int3x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int3x4Constructor {
    zero: int3x4;

    new(c0: int3, c1: int3, c2: int3, c3: int3): int3x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number): int3x4;
    new(v: number): int3x4;
    new(v: boolean): int3x4;
    new(v: bool3x4): int3x4;
    new(v: number): int3x4;
    new(v: uint3x4): int3x4;
    new(v: number): int3x4;
    new(v: float3x4): int3x4;
    new(v: number): int3x4;
    new(v: double3x4): int3x4;


}
declare const int3x4: int3x4Constructor;
    
interface int4x2 {
    c0: int4;
    c1: int4;
    Item: unknown;


    Equals(rhs: int4x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int4x2Constructor {
    zero: int4x2;

    new(c0: int4, c1: int4): int4x2;
    new(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number, m30: number, m31: number): int4x2;
    new(v: number): int4x2;
    new(v: boolean): int4x2;
    new(v: bool4x2): int4x2;
    new(v: number): int4x2;
    new(v: uint4x2): int4x2;
    new(v: number): int4x2;
    new(v: float4x2): int4x2;
    new(v: number): int4x2;
    new(v: double4x2): int4x2;


}
declare const int4x2: int4x2Constructor;
    
interface int4x3 {
    c0: int4;
    c1: int4;
    c2: int4;
    Item: unknown;


    Equals(rhs: int4x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int4x3Constructor {
    zero: int4x3;

    new(c0: int4, c1: int4, c2: int4): int4x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number, m30: number, m31: number, m32: number): int4x3;
    new(v: number): int4x3;
    new(v: boolean): int4x3;
    new(v: bool4x3): int4x3;
    new(v: number): int4x3;
    new(v: uint4x3): int4x3;
    new(v: number): int4x3;
    new(v: float4x3): int4x3;
    new(v: number): int4x3;
    new(v: double4x3): int4x3;


}
declare const int4x3: int4x3Constructor;
    
interface int4x4 {
    c0: int4;
    c1: int4;
    c2: int4;
    c3: int4;
    Item: unknown;


    Equals(rhs: int4x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface int4x4Constructor {
    identity: int4x4;
    zero: int4x4;

    new(c0: int4, c1: int4, c2: int4, c3: int4): int4x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): int4x4;
    new(v: number): int4x4;
    new(v: boolean): int4x4;
    new(v: bool4x4): int4x4;
    new(v: number): int4x4;
    new(v: uint4x4): int4x4;
    new(v: number): int4x4;
    new(v: float4x4): int4x4;
    new(v: number): int4x4;
    new(v: double4x4): int4x4;


}
declare const int4x4: int4x4Constructor;
    
    
interface uint2 {
    x: number;
    y: number;
    xxxx: uint4;
    xxxy: uint4;
    xxyx: uint4;
    xxyy: uint4;
    xyxx: uint4;
    xyxy: uint4;
    xyyx: uint4;
    xyyy: uint4;
    yxxx: uint4;
    yxxy: uint4;
    yxyx: uint4;
    yxyy: uint4;
    yyxx: uint4;
    yyxy: uint4;
    yyyx: uint4;
    yyyy: uint4;
    xxx: uint3;
    xxy: uint3;
    xyx: uint3;
    xyy: uint3;
    yxx: uint3;
    yxy: uint3;
    yyx: uint3;
    yyy: uint3;
    xx: uint2;
    xy: uint2;
    yx: uint2;
    yy: uint2;
    Item: number;


    Equals(rhs: uint2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint4 {
    x: number;
    y: number;
    z: number;
    w: number;
    xxxx: uint4;
    xxxy: uint4;
    xxxz: uint4;
    xxxw: uint4;
    xxyx: uint4;
    xxyy: uint4;
    xxyz: uint4;
    xxyw: uint4;
    xxzx: uint4;
    xxzy: uint4;
    xxzz: uint4;
    xxzw: uint4;
    xxwx: uint4;
    xxwy: uint4;
    xxwz: uint4;
    xxww: uint4;
    xyxx: uint4;
    xyxy: uint4;
    xyxz: uint4;
    xyxw: uint4;
    xyyx: uint4;
    xyyy: uint4;
    xyyz: uint4;
    xyyw: uint4;
    xyzx: uint4;
    xyzy: uint4;
    xyzz: uint4;
    xyzw: uint4;
    xywx: uint4;
    xywy: uint4;
    xywz: uint4;
    xyww: uint4;
    xzxx: uint4;
    xzxy: uint4;
    xzxz: uint4;
    xzxw: uint4;
    xzyx: uint4;
    xzyy: uint4;
    xzyz: uint4;
    xzyw: uint4;
    xzzx: uint4;
    xzzy: uint4;
    xzzz: uint4;
    xzzw: uint4;
    xzwx: uint4;
    xzwy: uint4;
    xzwz: uint4;
    xzww: uint4;
    xwxx: uint4;
    xwxy: uint4;
    xwxz: uint4;
    xwxw: uint4;
    xwyx: uint4;
    xwyy: uint4;
    xwyz: uint4;
    xwyw: uint4;
    xwzx: uint4;
    xwzy: uint4;
    xwzz: uint4;
    xwzw: uint4;
    xwwx: uint4;
    xwwy: uint4;
    xwwz: uint4;
    xwww: uint4;
    yxxx: uint4;
    yxxy: uint4;
    yxxz: uint4;
    yxxw: uint4;
    yxyx: uint4;
    yxyy: uint4;
    yxyz: uint4;
    yxyw: uint4;
    yxzx: uint4;
    yxzy: uint4;
    yxzz: uint4;
    yxzw: uint4;
    yxwx: uint4;
    yxwy: uint4;
    yxwz: uint4;
    yxww: uint4;
    yyxx: uint4;
    yyxy: uint4;
    yyxz: uint4;
    yyxw: uint4;
    yyyx: uint4;
    yyyy: uint4;
    yyyz: uint4;
    yyyw: uint4;
    yyzx: uint4;
    yyzy: uint4;
    yyzz: uint4;
    yyzw: uint4;
    yywx: uint4;
    yywy: uint4;
    yywz: uint4;
    yyww: uint4;
    yzxx: uint4;
    yzxy: uint4;
    yzxz: uint4;
    yzxw: uint4;
    yzyx: uint4;
    yzyy: uint4;
    yzyz: uint4;
    yzyw: uint4;
    yzzx: uint4;
    yzzy: uint4;
    yzzz: uint4;
    yzzw: uint4;
    yzwx: uint4;
    yzwy: uint4;
    yzwz: uint4;
    yzww: uint4;
    ywxx: uint4;
    ywxy: uint4;
    ywxz: uint4;
    ywxw: uint4;
    ywyx: uint4;
    ywyy: uint4;
    ywyz: uint4;
    ywyw: uint4;
    ywzx: uint4;
    ywzy: uint4;
    ywzz: uint4;
    ywzw: uint4;
    ywwx: uint4;
    ywwy: uint4;
    ywwz: uint4;
    ywww: uint4;
    zxxx: uint4;
    zxxy: uint4;
    zxxz: uint4;
    zxxw: uint4;
    zxyx: uint4;
    zxyy: uint4;
    zxyz: uint4;
    zxyw: uint4;
    zxzx: uint4;
    zxzy: uint4;
    zxzz: uint4;
    zxzw: uint4;
    zxwx: uint4;
    zxwy: uint4;
    zxwz: uint4;
    zxww: uint4;
    zyxx: uint4;
    zyxy: uint4;
    zyxz: uint4;
    zyxw: uint4;
    zyyx: uint4;
    zyyy: uint4;
    zyyz: uint4;
    zyyw: uint4;
    zyzx: uint4;
    zyzy: uint4;
    zyzz: uint4;
    zyzw: uint4;
    zywx: uint4;
    zywy: uint4;
    zywz: uint4;
    zyww: uint4;
    zzxx: uint4;
    zzxy: uint4;
    zzxz: uint4;
    zzxw: uint4;
    zzyx: uint4;
    zzyy: uint4;
    zzyz: uint4;
    zzyw: uint4;
    zzzx: uint4;
    zzzy: uint4;
    zzzz: uint4;
    zzzw: uint4;
    zzwx: uint4;
    zzwy: uint4;
    zzwz: uint4;
    zzww: uint4;
    zwxx: uint4;
    zwxy: uint4;
    zwxz: uint4;
    zwxw: uint4;
    zwyx: uint4;
    zwyy: uint4;
    zwyz: uint4;
    zwyw: uint4;
    zwzx: uint4;
    zwzy: uint4;
    zwzz: uint4;
    zwzw: uint4;
    zwwx: uint4;
    zwwy: uint4;
    zwwz: uint4;
    zwww: uint4;
    wxxx: uint4;
    wxxy: uint4;
    wxxz: uint4;
    wxxw: uint4;
    wxyx: uint4;
    wxyy: uint4;
    wxyz: uint4;
    wxyw: uint4;
    wxzx: uint4;
    wxzy: uint4;
    wxzz: uint4;
    wxzw: uint4;
    wxwx: uint4;
    wxwy: uint4;
    wxwz: uint4;
    wxww: uint4;
    wyxx: uint4;
    wyxy: uint4;
    wyxz: uint4;
    wyxw: uint4;
    wyyx: uint4;
    wyyy: uint4;
    wyyz: uint4;
    wyyw: uint4;
    wyzx: uint4;
    wyzy: uint4;
    wyzz: uint4;
    wyzw: uint4;
    wywx: uint4;
    wywy: uint4;
    wywz: uint4;
    wyww: uint4;
    wzxx: uint4;
    wzxy: uint4;
    wzxz: uint4;
    wzxw: uint4;
    wzyx: uint4;
    wzyy: uint4;
    wzyz: uint4;
    wzyw: uint4;
    wzzx: uint4;
    wzzy: uint4;
    wzzz: uint4;
    wzzw: uint4;
    wzwx: uint4;
    wzwy: uint4;
    wzwz: uint4;
    wzww: uint4;
    wwxx: uint4;
    wwxy: uint4;
    wwxz: uint4;
    wwxw: uint4;
    wwyx: uint4;
    wwyy: uint4;
    wwyz: uint4;
    wwyw: uint4;
    wwzx: uint4;
    wwzy: uint4;
    wwzz: uint4;
    wwzw: uint4;
    wwwx: uint4;
    wwwy: uint4;
    wwwz: uint4;
    wwww: uint4;
    xxx: uint3;
    xxy: uint3;
    xxz: uint3;
    xxw: uint3;
    xyx: uint3;
    xyy: uint3;
    xyz: uint3;
    xyw: uint3;
    xzx: uint3;
    xzy: uint3;
    xzz: uint3;
    xzw: uint3;
    xwx: uint3;
    xwy: uint3;
    xwz: uint3;
    xww: uint3;
    yxx: uint3;
    yxy: uint3;
    yxz: uint3;
    yxw: uint3;
    yyx: uint3;
    yyy: uint3;
    yyz: uint3;
    yyw: uint3;
    yzx: uint3;
    yzy: uint3;
    yzz: uint3;
    yzw: uint3;
    ywx: uint3;
    ywy: uint3;
    ywz: uint3;
    yww: uint3;
    zxx: uint3;
    zxy: uint3;
    zxz: uint3;
    zxw: uint3;
    zyx: uint3;
    zyy: uint3;
    zyz: uint3;
    zyw: uint3;
    zzx: uint3;
    zzy: uint3;
    zzz: uint3;
    zzw: uint3;
    zwx: uint3;
    zwy: uint3;
    zwz: uint3;
    zww: uint3;
    wxx: uint3;
    wxy: uint3;
    wxz: uint3;
    wxw: uint3;
    wyx: uint3;
    wyy: uint3;
    wyz: uint3;
    wyw: uint3;
    wzx: uint3;
    wzy: uint3;
    wzz: uint3;
    wzw: uint3;
    wwx: uint3;
    wwy: uint3;
    wwz: uint3;
    www: uint3;
    xx: uint2;
    xy: uint2;
    xz: uint2;
    xw: uint2;
    yx: uint2;
    yy: uint2;
    yz: uint2;
    yw: uint2;
    zx: uint2;
    zy: uint2;
    zz: uint2;
    zw: uint2;
    wx: uint2;
    wy: uint2;
    wz: uint2;
    ww: uint2;
    Item: number;


    Equals(rhs: uint4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint3 {
    x: number;
    y: number;
    z: number;
    xxxx: uint4;
    xxxy: uint4;
    xxxz: uint4;
    xxyx: uint4;
    xxyy: uint4;
    xxyz: uint4;
    xxzx: uint4;
    xxzy: uint4;
    xxzz: uint4;
    xyxx: uint4;
    xyxy: uint4;
    xyxz: uint4;
    xyyx: uint4;
    xyyy: uint4;
    xyyz: uint4;
    xyzx: uint4;
    xyzy: uint4;
    xyzz: uint4;
    xzxx: uint4;
    xzxy: uint4;
    xzxz: uint4;
    xzyx: uint4;
    xzyy: uint4;
    xzyz: uint4;
    xzzx: uint4;
    xzzy: uint4;
    xzzz: uint4;
    yxxx: uint4;
    yxxy: uint4;
    yxxz: uint4;
    yxyx: uint4;
    yxyy: uint4;
    yxyz: uint4;
    yxzx: uint4;
    yxzy: uint4;
    yxzz: uint4;
    yyxx: uint4;
    yyxy: uint4;
    yyxz: uint4;
    yyyx: uint4;
    yyyy: uint4;
    yyyz: uint4;
    yyzx: uint4;
    yyzy: uint4;
    yyzz: uint4;
    yzxx: uint4;
    yzxy: uint4;
    yzxz: uint4;
    yzyx: uint4;
    yzyy: uint4;
    yzyz: uint4;
    yzzx: uint4;
    yzzy: uint4;
    yzzz: uint4;
    zxxx: uint4;
    zxxy: uint4;
    zxxz: uint4;
    zxyx: uint4;
    zxyy: uint4;
    zxyz: uint4;
    zxzx: uint4;
    zxzy: uint4;
    zxzz: uint4;
    zyxx: uint4;
    zyxy: uint4;
    zyxz: uint4;
    zyyx: uint4;
    zyyy: uint4;
    zyyz: uint4;
    zyzx: uint4;
    zyzy: uint4;
    zyzz: uint4;
    zzxx: uint4;
    zzxy: uint4;
    zzxz: uint4;
    zzyx: uint4;
    zzyy: uint4;
    zzyz: uint4;
    zzzx: uint4;
    zzzy: uint4;
    zzzz: uint4;
    xxx: uint3;
    xxy: uint3;
    xxz: uint3;
    xyx: uint3;
    xyy: uint3;
    xyz: uint3;
    xzx: uint3;
    xzy: uint3;
    xzz: uint3;
    yxx: uint3;
    yxy: uint3;
    yxz: uint3;
    yyx: uint3;
    yyy: uint3;
    yyz: uint3;
    yzx: uint3;
    yzy: uint3;
    yzz: uint3;
    zxx: uint3;
    zxy: uint3;
    zxz: uint3;
    zyx: uint3;
    zyy: uint3;
    zyz: uint3;
    zzx: uint3;
    zzy: uint3;
    zzz: uint3;
    xx: uint2;
    xy: uint2;
    xz: uint2;
    yx: uint2;
    yy: uint2;
    yz: uint2;
    zx: uint2;
    zy: uint2;
    zz: uint2;
    Item: number;


    Equals(rhs: uint3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint3Constructor {
    zero: uint3;

    new(x: number, y: number, z: number): uint3;
    new(x: number, yz: uint2): uint3;
    new(xy: uint2, z: number): uint3;
    new(xyz: uint3): uint3;
    new(v: number): uint3;
    new(v: boolean): uint3;
    new(v: bool3): uint3;
    new(v: number): uint3;
    new(v: int3): uint3;
    new(v: number): uint3;
    new(v: float3): uint3;
    new(v: number): uint3;
    new(v: double3): uint3;


}
declare const uint3: uint3Constructor;
    
interface uint4Constructor {
    zero: uint4;

    new(x: number, y: number, z: number, w: number): uint4;
    new(x: number, y: number, zw: uint2): uint4;
    new(x: number, yz: uint2, w: number): uint4;
    new(x: number, yzw: uint3): uint4;
    new(xy: uint2, z: number, w: number): uint4;
    new(xy: uint2, zw: uint2): uint4;
    new(xyz: uint3, w: number): uint4;
    new(xyzw: uint4): uint4;
    new(v: number): uint4;
    new(v: boolean): uint4;
    new(v: bool4): uint4;
    new(v: number): uint4;
    new(v: int4): uint4;
    new(v: number): uint4;
    new(v: float4): uint4;
    new(v: number): uint4;
    new(v: double4): uint4;


}
declare const uint4: uint4Constructor;
    
interface uint2Constructor {
    zero: uint2;

    new(x: number, y: number): uint2;
    new(xy: uint2): uint2;
    new(v: number): uint2;
    new(v: boolean): uint2;
    new(v: bool2): uint2;
    new(v: number): uint2;
    new(v: int2): uint2;
    new(v: number): uint2;
    new(v: float2): uint2;
    new(v: number): uint2;
    new(v: double2): uint2;


}
declare const uint2: uint2Constructor;
    
    
interface Ray2D {
    origin: Vector2;
    direction: Vector2;


    /** Get a point that lies a given distance along a ray. */
    GetPoint(distance: number): Vector2;
    /** Returns a formatted string for this 2D ray. */
    ToString(): string;
    /** Returns a formatted string for this 2D ray. */
    ToString(format: string): string;
    /** Returns a formatted string for this 2D ray. */
    ToString(format: string, formatProvider: unknown): string;

}
    
interface Ray2DConstructor {

    new(origin: Vector2, direction: Vector2): Ray2D;


}
declare const Ray2D: Ray2DConstructor;
    
interface RigidTransform {
    rot: quaternion;
    pos: float3;


    Equals(x: RigidTransform): boolean;
    Equals(x: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface RigidTransformConstructor {
    identity: RigidTransform;

    new(rotation: quaternion, translation: float3): RigidTransform;
    new(rotation: float3x3, translation: float3): RigidTransform;
    new(transform: float4x4): RigidTransform;


    AxisAngle(axis: float3, angle: number): RigidTransform;
    Euler(xyz: float3, order: RotationOrder): RigidTransform;
    Euler(x: number, y: number, z: number, order: RotationOrder): RigidTransform;
    EulerXYZ(xyz: float3): RigidTransform;
    EulerXYZ(x: number, y: number, z: number): RigidTransform;
    EulerXZY(xyz: float3): RigidTransform;
    EulerXZY(x: number, y: number, z: number): RigidTransform;
    EulerYXZ(xyz: float3): RigidTransform;
    EulerYXZ(x: number, y: number, z: number): RigidTransform;
    EulerYZX(xyz: float3): RigidTransform;
    EulerYZX(x: number, y: number, z: number): RigidTransform;
    EulerZXY(xyz: float3): RigidTransform;
    EulerZXY(x: number, y: number, z: number): RigidTransform;
    EulerZYX(xyz: float3): RigidTransform;
    EulerZYX(x: number, y: number, z: number): RigidTransform;
    RotateX(angle: number): RigidTransform;
    RotateY(angle: number): RigidTransform;
    RotateZ(angle: number): RigidTransform;
    Translate(vector: float3): RigidTransform;
}
declare const RigidTransform: RigidTransformConstructor;
    
interface uint2x2 {
    c0: uint2;
    c1: uint2;
    Item: unknown;


    Equals(rhs: uint2x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint2x2Constructor {
    identity: uint2x2;
    zero: uint2x2;

    new(c0: uint2, c1: uint2): uint2x2;
    new(m00: number, m01: number, m10: number, m11: number): uint2x2;
    new(v: number): uint2x2;
    new(v: boolean): uint2x2;
    new(v: bool2x2): uint2x2;
    new(v: number): uint2x2;
    new(v: int2x2): uint2x2;
    new(v: number): uint2x2;
    new(v: float2x2): uint2x2;
    new(v: number): uint2x2;
    new(v: double2x2): uint2x2;


}
declare const uint2x2: uint2x2Constructor;
    
interface uint2x3 {
    c0: uint2;
    c1: uint2;
    c2: uint2;
    Item: unknown;


    Equals(rhs: uint2x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint2x3Constructor {
    zero: uint2x3;

    new(c0: uint2, c1: uint2, c2: uint2): uint2x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number): uint2x3;
    new(v: number): uint2x3;
    new(v: boolean): uint2x3;
    new(v: bool2x3): uint2x3;
    new(v: number): uint2x3;
    new(v: int2x3): uint2x3;
    new(v: number): uint2x3;
    new(v: float2x3): uint2x3;
    new(v: number): uint2x3;
    new(v: double2x3): uint2x3;


}
declare const uint2x3: uint2x3Constructor;
    
interface uint2x4 {
    c0: uint2;
    c1: uint2;
    c2: uint2;
    c3: uint2;
    Item: unknown;


    Equals(rhs: uint2x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint2x4Constructor {
    zero: uint2x4;

    new(c0: uint2, c1: uint2, c2: uint2, c3: uint2): uint2x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number): uint2x4;
    new(v: number): uint2x4;
    new(v: boolean): uint2x4;
    new(v: bool2x4): uint2x4;
    new(v: number): uint2x4;
    new(v: int2x4): uint2x4;
    new(v: number): uint2x4;
    new(v: float2x4): uint2x4;
    new(v: number): uint2x4;
    new(v: double2x4): uint2x4;


}
declare const uint2x4: uint2x4Constructor;
    
interface uint3x2 {
    c0: uint3;
    c1: uint3;
    Item: unknown;


    Equals(rhs: uint3x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint3x2Constructor {
    zero: uint3x2;

    new(c0: uint3, c1: uint3): uint3x2;
    new(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number): uint3x2;
    new(v: number): uint3x2;
    new(v: boolean): uint3x2;
    new(v: bool3x2): uint3x2;
    new(v: number): uint3x2;
    new(v: int3x2): uint3x2;
    new(v: number): uint3x2;
    new(v: float3x2): uint3x2;
    new(v: number): uint3x2;
    new(v: double3x2): uint3x2;


}
declare const uint3x2: uint3x2Constructor;
    
interface uint3x3 {
    c0: uint3;
    c1: uint3;
    c2: uint3;
    Item: unknown;


    Equals(rhs: uint3x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint3x3Constructor {
    identity: uint3x3;
    zero: uint3x3;

    new(c0: uint3, c1: uint3, c2: uint3): uint3x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number): uint3x3;
    new(v: number): uint3x3;
    new(v: boolean): uint3x3;
    new(v: bool3x3): uint3x3;
    new(v: number): uint3x3;
    new(v: int3x3): uint3x3;
    new(v: number): uint3x3;
    new(v: float3x3): uint3x3;
    new(v: number): uint3x3;
    new(v: double3x3): uint3x3;


}
declare const uint3x3: uint3x3Constructor;
    
interface uint3x4 {
    c0: uint3;
    c1: uint3;
    c2: uint3;
    c3: uint3;
    Item: unknown;


    Equals(rhs: uint3x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint3x4Constructor {
    zero: uint3x4;

    new(c0: uint3, c1: uint3, c2: uint3, c3: uint3): uint3x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number): uint3x4;
    new(v: number): uint3x4;
    new(v: boolean): uint3x4;
    new(v: bool3x4): uint3x4;
    new(v: number): uint3x4;
    new(v: int3x4): uint3x4;
    new(v: number): uint3x4;
    new(v: float3x4): uint3x4;
    new(v: number): uint3x4;
    new(v: double3x4): uint3x4;


}
declare const uint3x4: uint3x4Constructor;
    
interface uint4x2 {
    c0: uint4;
    c1: uint4;
    Item: unknown;


    Equals(rhs: uint4x2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint4x2Constructor {
    zero: uint4x2;

    new(c0: uint4, c1: uint4): uint4x2;
    new(m00: number, m01: number, m10: number, m11: number, m20: number, m21: number, m30: number, m31: number): uint4x2;
    new(v: number): uint4x2;
    new(v: boolean): uint4x2;
    new(v: bool4x2): uint4x2;
    new(v: number): uint4x2;
    new(v: int4x2): uint4x2;
    new(v: number): uint4x2;
    new(v: float4x2): uint4x2;
    new(v: number): uint4x2;
    new(v: double4x2): uint4x2;


}
declare const uint4x2: uint4x2Constructor;
    
interface uint4x3 {
    c0: uint4;
    c1: uint4;
    c2: uint4;
    Item: unknown;


    Equals(rhs: uint4x3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint4x3Constructor {
    zero: uint4x3;

    new(c0: uint4, c1: uint4, c2: uint4): uint4x3;
    new(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number, m30: number, m31: number, m32: number): uint4x3;
    new(v: number): uint4x3;
    new(v: boolean): uint4x3;
    new(v: bool4x3): uint4x3;
    new(v: number): uint4x3;
    new(v: int4x3): uint4x3;
    new(v: number): uint4x3;
    new(v: float4x3): uint4x3;
    new(v: number): uint4x3;
    new(v: double4x3): uint4x3;


}
declare const uint4x3: uint4x3Constructor;
    
interface uint4x4 {
    c0: uint4;
    c1: uint4;
    c2: uint4;
    c3: uint4;
    Item: unknown;


    Equals(rhs: uint4x4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;

}
    
interface uint4x4Constructor {
    identity: uint4x4;
    zero: uint4x4;

    new(c0: uint4, c1: uint4, c2: uint4, c3: uint4): uint4x4;
    new(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number): uint4x4;
    new(v: number): uint4x4;
    new(v: boolean): uint4x4;
    new(v: bool4x4): uint4x4;
    new(v: number): uint4x4;
    new(v: int4x4): uint4x4;
    new(v: number): uint4x4;
    new(v: float4x4): uint4x4;
    new(v: number): uint4x4;
    new(v: double4x4): uint4x4;


}
declare const uint4x4: uint4x4Constructor;
    
    
    
interface WriterConstructor {
    UNSET_COLLECTION_SIZE_VALUE: number;

    new(): Writer;


}
declare const Writer: WriterConstructor;
    
interface ClientManagerConstructor {

    new(): ClientManager;


}
declare const ClientManager: ClientManagerConstructor;
    
interface ObserverManager extends MonoBehaviour {
    UpdateHostVisibility: boolean;
    MaximumTimedObserversDuration: number;


    SetMaximumTimedObserversDuration(value: number): void;
    SetUpdateHostVisibility(value: boolean, updateType: HostVisibilityUpdateTypes): void;

}
    
interface ObserverManagerConstructor {

    new(): ObserverManager;


    GetLevelOfDetailInterval(lodIndex: number): number;
}
declare const ObserverManager: ObserverManagerConstructor;
    
interface TransportManager extends MonoBehaviour {
    Transport: Transport;
    HasIntermediateLayer: boolean;
    LatencySimulator: LatencySimulator;


    GetLowestMTU(): number;
    GetLowestMTU(channel: number): number;
    GetMTU(channel: number): number;
    GetMTU(transportIndex: number, channel: number): number;
    GetMTU<T>(channel: number): number;
    GetMTUReserve(): number;
    GetTransport(index: number): Transport;
    GetTransport<T>(): T;
    IsLocalTransport(connectionId: number): boolean;
    SetMTUReserve(value: number): void;

}
    
interface Transport extends MonoBehaviour {
    NetworkManager: NetworkManager;
    Index: number;


    GetClientAddress(): string;
    GetConnectionAddress(connectionId: number): string;
    GetConnectionState(server: boolean): LocalConnectionState;
    GetConnectionState(connectionId: number): RemoteConnectionState;
    GetMaximumClients(): number;
    GetMTU(channel: number): number;
    GetPort(): number;
    GetServerBindAddress(addressType: IPAddressType): string;
    GetTimeout(asServer: boolean): number;
    HandleClientConnectionState(connectionStateArgs: ClientConnectionStateArgs): void;
    HandleClientReceivedDataArgs(receivedDataArgs: ClientReceivedDataArgs): void;
    HandleRemoteConnectionState(connectionStateArgs: RemoteConnectionStateArgs): void;
    HandleServerConnectionState(connectionStateArgs: ServerConnectionStateArgs): void;
    HandleServerReceivedDataArgs(receivedDataArgs: ServerReceivedDataArgs): void;
    Initialize(networkManager: NetworkManager, transportIndex: number): void;
    IsLocalTransport(connectionid: number): boolean;
    IterateIncoming(server: boolean): void;
    IterateOutgoing(server: boolean): void;
    SendToClient(channelId: number, segment: CSArray<number>, connectionId: number): void;
    SendToServer(channelId: number, segment: CSArray<number>): void;
    SetClientAddress(address: string): void;
    SetMaximumClients(value: number): void;
    SetPort(port: number): void;
    SetServerBindAddress(address: string, addressType: IPAddressType): void;
    SetTimeout(value: number, asServer: boolean): void;
    Shutdown(): void;
    StartConnection(server: boolean): boolean;
    StopConnection(server: boolean): boolean;
    StopConnection(connectionId: number, immediately: boolean): boolean;

}
    
interface ClientConnectionStateArgs {
    ConnectionState: LocalConnectionState;
    TransportIndex: number;



}
    
interface ClientConnectionStateArgsConstructor {

    new(connectionState: LocalConnectionState, transportIndex: number): ClientConnectionStateArgs;


}
declare const ClientConnectionStateArgs: ClientConnectionStateArgsConstructor;
    
interface ClientReceivedDataArgs {
    Data: CSArray<number>;
    Channel: Channel;
    TransportIndex: number;



}
    
interface ClientReceivedDataArgsConstructor {

    new(data: CSArray<number>, channel: Channel, transportIndex: number): ClientReceivedDataArgs;


}
declare const ClientReceivedDataArgs: ClientReceivedDataArgsConstructor;
    
interface RemoteConnectionStateArgs {
    TransportIndex: number;
    ConnectionState: RemoteConnectionState;
    ConnectionId: number;



}
    
interface RemoteConnectionStateArgsConstructor {

    new(connectionState: RemoteConnectionState, connectionId: number, transportIndex: number): RemoteConnectionStateArgs;


}
declare const RemoteConnectionStateArgs: RemoteConnectionStateArgsConstructor;
    
interface ServerConnectionStateArgs {
    TransportIndex: number;
    ConnectionState: LocalConnectionState;



}
    
interface ServerConnectionStateArgsConstructor {

    new(connectionState: LocalConnectionState, transportIndex: number): ServerConnectionStateArgs;


}
declare const ServerConnectionStateArgs: ServerConnectionStateArgsConstructor;
    
interface ServerReceivedDataArgs {
    Data: CSArray<number>;
    Channel: Channel;
    ConnectionId: number;
    TransportIndex: number;
    FinalizeMethod: unknown;



}
    
interface ServerReceivedDataArgsConstructor {

    new(data: CSArray<number>, channel: Channel, connectionId: number, transportIndex: number): ServerReceivedDataArgs;
    new(data: CSArray<number>, channel: Channel, connectionId: number, transportIndex: number, finalizeMethod: unknown): ServerReceivedDataArgs;


}
declare const ServerReceivedDataArgs: ServerReceivedDataArgsConstructor;
    
interface LatencySimulator {


    AddOutgoing(channelId: number, segment: CSArray<number>, toServer: boolean, connectionId: number): void;
    GetEnabled(): boolean;
    GetLatency(): number;
    GetOutOfOrder(): number;
    GetPacketLost(): number;
    Initialize(manager: NetworkManager, transport: Transport): void;
    IterateOutgoing(toServer: boolean): void;
    RemovePendingForConnection(connectionId: number): void;
    Reset(): void;
    SetEnabled(value: boolean): void;
    SetLatency(value: number): void;
    SetOutOfOrder(value: number): void;
    SetPacketLoss(value: number): void;

}
    
interface LatencySimulatorConstructor {

    new(): LatencySimulator;


}
declare const LatencySimulator: LatencySimulatorConstructor;
    
interface TransportManagerConstructor {
    PACKETID_LENGTH: number;
    OBJECT_ID_LENGTH: number;
    COMPONENT_INDEX_LENGTH: number;
    UNPACKED_TICK_LENGTH: number;
    UNPACKED_SIZE_LENGTH: number;
    SPLIT_INDICATOR_LENGTH: number;
    CHANNEL_COUNT: number;
    MINIMUM_MTU_RESERVE: number;
    INVALID_MTU: number;

    new(): TransportManager;


}
declare const TransportManager: TransportManagerConstructor;
    
interface TimeManager extends MonoBehaviour {
    NetworkManager: NetworkManager;
    RoundTripTime: number;
    LastPacketTick: EstimatedTick;
    Tick: number;
    TickDelta: number;
    FrameTicked: boolean;
    ServerUptime: number;
    ClientUptime: number;
    TickRate: number;
    PingInterval: number;
    PhysicsMode: PhysicsMode;
    LocalTick: number;


    GetPhysicsTimeScale(): number;
    GetPreciseTick(tick: number): PreciseTick;
    GetPreciseTick(tickType: TickType): PreciseTick;
    GetTickPercentAsByte(): number;
    GetTickPercentAsDouble(): number;
    LocalTickToTick(localTick: number): number;
    SetPhysicsMode(mode: PhysicsMode): void;
    SetPhysicsTimeScale(value: number): void;
    SetTickRate(value: number): void;
    TicksToTime(tickType: TickType): number;
    TicksToTime(pt: PreciseTick): number;
    TicksToTime(ticks: number): number;
    TickToLocalTick(tick: number): number;
    TimePassed(currentTick: number, previousTick: number): number;
    TimePassed(preciseTick: PreciseTick, allowNegative: boolean): number;
    TimePassed(previousTick: number, allowNegative: boolean): number;
    TimeToTicks(time: number, rounding: TickRounding): number;

}
    
interface EstimatedTick {
    LocalTick: number;
    RemoteTick: number;
    LastRemoteTick: number;
    IsLastRemoteTickOrdered: boolean;
    IsUnset: boolean;


    Initialize(tm: TimeManager, remoteTick: number, lastRemoteTick: number, localTick: number): void;
    IsCurrent(tm: TimeManager): boolean;
    LocalTickDifference(tm: TimeManager): number;
    Reset(): void;
    Update(tm: TimeManager, remoteTick: number, oldTickOption: OldTickOption, resetValue: boolean): boolean;
    Update(remoteTick: number, oldTickOption: OldTickOption, resetValue: boolean): boolean;
    UpdateValue(): void;
    Value(tm: TimeManager): number;
    Value(isCurrent: unknown, tm: TimeManager): number;

}
    
interface EstimatedTickConstructor {

    new(): EstimatedTick;


}
declare const EstimatedTick: EstimatedTickConstructor;
    
interface PreciseTick {
    Tick: number;
    PercentAsDouble: number;
    PercentAsByte: number;


    ToString(): string;

}
    
interface PreciseTickConstructor {

    new(tick: number, percentAsByte: number): PreciseTick;
    new(tick: number, percent: number): PreciseTick;


    AsDouble(tick: number, percent: number): PreciseTick;
}
declare const PreciseTick: PreciseTickConstructor;
    
interface TimeManagerConstructor {
    UNSET_TICK: number;

    new(): TimeManager;


    GetTickPercentAsDouble(value: number): number;
}
declare const TimeManager: TimeManagerConstructor;
    
    
interface SceneProcessorBase extends MonoBehaviour {


    ActivateLoadedScenes(): void;
    AddLoadedScene(scene: Scene): void;
    AsyncsIsDone(): unknown;
    BeginLoadAsync(sceneName: string, parameters: LoadSceneParameters): void;
    BeginUnloadAsync(scene: Scene): void;
    FindOrCreateScene(name: string): Scene;
    GetDelayedDestroyScene(): Scene;
    GetFallbackActiveScene(): Scene;
    GetLoadedScenes(): CSArray<Scene>;
    GetMovedObjectsScene(): Scene;
    GetPercentComplete(): number;
    Initialize(manager: SceneManager): void;
    IsPercentComplete(): boolean;
    LoadEnd(queueData: LoadQueueData): void;
    LoadStart(queueData: LoadQueueData): void;
    UnloadEnd(queueData: LoadQueueData): void;
    UnloadEnd(queueData: UnloadQueueData): void;
    UnloadStart(queueData: LoadQueueData): void;
    UnloadStart(queueData: UnloadQueueData): void;

}
    
interface LoadSceneParameters {
    loadSceneMode: LoadSceneMode;
    localPhysicsMode: LocalPhysicsMode;



}
    
interface LoadSceneParametersConstructor {

    new(mode: LoadSceneMode): LoadSceneParameters;
    new(mode: LoadSceneMode, physicsMode: LocalPhysicsMode): LoadSceneParameters;


}
declare const LoadSceneParameters: LoadSceneParametersConstructor;
    
interface LoadQueueData {
    ScopeType: SceneScopeType;
    Connections: CSArray<NetworkConnection>;
    SceneLoadData: SceneLoadData;
    GlobalScenes: CSArray<string>;
    AsServer: boolean;



}
    
interface SceneLoadData {
    PreferredActiveScene: PreferredScene;
    SceneLookupDatas: CSArray<SceneLookupData>;
    MovedNetworkObjects: CSArray<NetworkObject>;
    ReplaceScenes: ReplaceOption;
    Params: LoadParams;
    Options: LoadOptions;


    GetFirstLookupScene(): Scene;

}
    
interface PreferredScene {
    Client: SceneLookupData;
    Server: SceneLookupData;



}
    
interface SceneLookupData {
    Handle: number;
    Name: string;
    NameOnly: string;
    IsValid: boolean;


    Equals(sld: SceneLookupData): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GetScene(foundByHandle: unknown, warnIfDuplicates: boolean): Scene;
    ToString(): string;

}
    
interface SceneLookupDataConstructor {

    new(): SceneLookupData;
    new(scene: Scene): SceneLookupData;
    new(name: string): SceneLookupData;
    new(handle: number): SceneLookupData;
    new(handle: number, name: string): SceneLookupData;


    CreateData(scene: Scene): SceneLookupData;
    CreateData(name: string): SceneLookupData;
    CreateData(handle: number): SceneLookupData;
    CreateData(scenes: CSArray<Scene>): CSArray<SceneLookupData>;
    CreateData(names: CSArray<string>): CSArray<SceneLookupData>;
    CreateData(handles: CSArray<number>): CSArray<SceneLookupData>;
    CreateData(scenes: CSArray<Scene>): CSArray<SceneLookupData>;
    CreateData(names: CSArray<string>): CSArray<SceneLookupData>;
    CreateData(handles: CSArray<number>): CSArray<SceneLookupData>;
    ValidateData(data: SceneLookupData): CSArray<SceneLookupData>;
    ValidateData(datas: CSArray<SceneLookupData>): CSArray<SceneLookupData>;
}
declare const SceneLookupData: SceneLookupDataConstructor;
    
interface PreferredSceneConstructor {

    new(client: SceneLookupData, server: SceneLookupData): PreferredScene;
    new(sld: SceneLookupData): PreferredScene;


}
declare const PreferredScene: PreferredSceneConstructor;
    
interface LoadParams {
    ServerParams: CSArray<unknown>;
    ClientParams: CSArray<number>;



}
    
interface LoadParamsConstructor {

    new(): LoadParams;


}
declare const LoadParams: LoadParamsConstructor;
    
interface LoadOptions {
    AutomaticallyUnload: boolean;
    AllowStacking: boolean;
    LocalPhysics: LocalPhysicsMode;
    ReloadScenes: boolean;
    Addressables: boolean;



}
    
interface LoadOptionsConstructor {

    new(): LoadOptions;


}
declare const LoadOptions: LoadOptionsConstructor;
    
interface SceneLoadDataConstructor {

    new(): SceneLoadData;
    new(scene: Scene): SceneLoadData;
    new(sceneName: string): SceneLoadData;
    new(sceneHandle: number): SceneLoadData;
    new(sceneHandle: number, sceneName: string): SceneLoadData;
    new(sceneLookupData: SceneLookupData): SceneLoadData;
    new(scenes: CSArray<Scene>): SceneLoadData;
    new(sceneNames: CSArray<string>): SceneLoadData;
    new(sceneHandles: CSArray<number>): SceneLoadData;
    new(scenes: CSArray<Scene>): SceneLoadData;
    new(sceneNames: CSArray<string>): SceneLoadData;
    new(sceneHandles: CSArray<number>): SceneLoadData;
    new(sceneLookupDatas: CSArray<SceneLookupData>): SceneLoadData;
    new(scene: Scene, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    new(scenes: CSArray<Scene>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    new(sceneNames: CSArray<string>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    new(sceneHandles: CSArray<number>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    new(sceneLookupDatas: CSArray<SceneLookupData>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;


}
declare const SceneLoadData: SceneLoadDataConstructor;
    
interface LoadQueueDataConstructor {

    new(): LoadQueueData;


}
declare const LoadQueueData: LoadQueueDataConstructor;
    
interface UnloadQueueData {
    ScopeType: SceneScopeType;
    Connections: CSArray<NetworkConnection>;
    SceneUnloadData: SceneUnloadData;
    GlobalScenes: CSArray<string>;
    AsServer: boolean;



}
    
interface SceneUnloadData {
    PreferredActiveScene: PreferredScene;
    SceneLookupDatas: CSArray<SceneLookupData>;
    Params: UnloadParams;
    Options: UnloadOptions;



}
    
interface UnloadParams {
    ServerParams: CSArray<unknown>;
    ClientParams: CSArray<number>;



}
    
interface UnloadParamsConstructor {

    new(): UnloadParams;


}
declare const UnloadParams: UnloadParamsConstructor;
    
interface UnloadOptions {
    Mode: ServerUnloadMode;
    Addressables: boolean;



}
    
interface UnloadOptionsConstructor {

    new(): UnloadOptions;


}
declare const UnloadOptions: UnloadOptionsConstructor;
    
interface SceneUnloadDataConstructor {

    new(): SceneUnloadData;
    new(scene: Scene): SceneUnloadData;
    new(sceneName: string): SceneUnloadData;
    new(sceneHandle: number): SceneUnloadData;
    new(sceneLookupData: SceneLookupData): SceneUnloadData;
    new(scenes: CSArray<Scene>): SceneUnloadData;
    new(sceneNames: CSArray<string>): SceneUnloadData;
    new(sceneHandles: CSArray<number>): SceneUnloadData;
    new(scenes: CSArray<Scene>): SceneUnloadData;
    new(sceneNames: CSArray<string>): SceneUnloadData;
    new(sceneHandles: CSArray<number>): SceneUnloadData;
    new(sceneLookupDatas: CSArray<SceneLookupData>): SceneUnloadData;


}
declare const SceneUnloadData: SceneUnloadDataConstructor;
    
interface UnloadQueueDataConstructor {

    new(): UnloadQueueData;


}
declare const UnloadQueueData: UnloadQueueDataConstructor;
    
    
interface PredictionManager extends MonoBehaviour {
    IsReconciling: boolean;
    ClientReplayTick: number;
    ServerReplayTick: number;
    ClientStateTick: number;
    ServerStateTick: number;


    GetMaximumServerReplicates(): number;
    SetMaximumServerReplicates(value: number): void;

}
    
interface PredictionManagerConstructor {

    new(): PredictionManager;


}
declare const PredictionManager: PredictionManagerConstructor;
    
interface RollbackManager extends MonoBehaviour {


    Return(): void;
    Rollback(origin: Vector3, normalizedDirection: Vector3, distance: number, pt: PreciseTick, asOwnerAndClientHost: boolean): void;
    Rollback(scene: Scene, origin: Vector3, normalizedDirection: Vector3, distance: number, pt: PreciseTick, asOwnerAndClientHost: boolean): void;
    Rollback(sceneHandle: number, origin: Vector3, normalizedDirection: Vector3, distance: number, pt: PreciseTick, asOwnerAndClientHost: boolean): void;
    Rollback(scene: Scene, origin: Vector2, normalizedDirection: Vector2, distance: number, pt: PreciseTick, asOwnerAndClientHost: boolean): void;
    Rollback(origin: Vector2, normalizedDirection: Vector2, distance: number, pt: PreciseTick, asOwnerAndClientHost: boolean): void;
    Rollback(pt: PreciseTick, physicsType: RollbackPhysicsType, asOwnerAndClientHost: boolean): void;
    Rollback(scene: Scene, pt: PreciseTick, physicsType: RollbackPhysicsType, asOwnerAndClientHost: boolean): void;
    Rollback(sceneHandle: number, pt: PreciseTick, physicsType: RollbackPhysicsType, asOwnerAndClientHost: boolean): void;
    Rollback(scene: Scene, origin: Vector3, normalizedDirection: Vector3, distance: number, pt: PreciseTick, physicsType: RollbackPhysicsType, asOwnerAndClientHost: boolean): void;
    Rollback(sceneHandle: number, origin: Vector3, normalizedDirection: Vector3, distance: number, pt: PreciseTick, physicsType: RollbackPhysicsType, asOwnerAndClientHost: boolean): void;

}
    
interface RollbackManagerConstructor {

    new(): RollbackManager;


}
declare const RollbackManager: RollbackManagerConstructor;
    
interface Reader {
    Source: DataSource;
    NetworkManager: NetworkManager;
    Position: number;
    Capacity: number;
    Offset: number;
    Length: number;
    Remaining: number;
    NetworkConnection: NetworkConnection;


    BlockCopy(target: CSArray<number>, targetOffset: number, count: number): void;
    Clear(): void;
    GetArraySegmentBuffer(): CSArray<number>;
    GetByteBuffer(): CSArray<number>;
    GetByteBufferAllocated(): CSArray<number>;
    GetRemainingData(): CSArray<number>;
    Read<T>(): T;
    ReadArray<T>(collection: CSArray<T>): number;
    ReadArrayAllocated<T>(): CSArray<T>;
    ReadArraySegment(count: number): CSArray<number>;
    ReadArraySegmentAndSize(): CSArray<number>;
    Readbool2(): bool2;
    Readbool2x2(): bool2x2;
    Readbool2x3(): bool2x3;
    Readbool2x4(): bool2x4;
    Readbool3(): bool3;
    Readbool3x2(): bool3x2;
    Readbool3x3(): bool3x3;
    Readbool3x4(): bool3x4;
    Readbool4(): bool4;
    Readbool4x2(): bool4x2;
    Readbool4x3(): bool4x3;
    Readbool4x4(): bool4x4;
    ReadBoolean(): boolean;
    ReadByte(): number;
    ReadBytes(buffer: CSArray<number>, count: number): void;
    ReadBytesAllocated(count: number): CSArray<number>;
    ReadBytesAndSize(target: CSArray<number>): number;
    ReadBytesAndSizeAllocated(): CSArray<number>;
    ReadChannel(): Channel;
    ReadChar(): string;
    ReadColor(packType: AutoPackType): Color;
    ReadColor32(): Color32;
    ReadDateTime(): string;
    ReadDecimal(): number;
    ReadDictionaryAllocated<TKey, TValue>(): CSDictionary<TKey, TValue>;
    ReadDouble(): number;
    Readdouble2(): double2;
    Readdouble2x2(): double2x2;
    Readdouble2x3(): double2x3;
    Readdouble2x4(): double2x4;
    Readdouble3(): double3;
    Readdouble3x2(): double3x2;
    Readdouble3x3(): double3x3;
    Readdouble3x4(): double3x4;
    Readdouble4(): double4;
    Readdouble4x2(): double4x2;
    Readdouble4x3(): double4x3;
    Readdouble4x4(): double4x4;
    Readfloat2(): float2;
    Readfloat2x2(): float2x2;
    Readfloat2x3(): float2x3;
    Readfloat2x4(): float2x4;
    Readfloat3(): float3;
    Readfloat3x2(): float3x2;
    Readfloat3x3(): float3x3;
    Readfloat3x4(): float3x4;
    Readfloat4(): float4;
    Readfloat4x2(): float4x2;
    Readfloat4x3(): float4x3;
    Readfloat4x4(): float4x4;
    ReadGameObject(): GameObject;
    ReadGuid(): unknown;
    Readhalf(): half;
    Readhalf2(): half2;
    Readhalf3(): half3;
    Readhalf4(): half4;
    ReadInt16(packType: AutoPackType): number;
    Readint2(): int2;
    Readint2x2(): int2x2;
    Readint2x3(): int2x3;
    Readint2x4(): int2x4;
    Readint3(): int3;
    ReadInt32(packType: AutoPackType): number;
    Readint3x2(): int3x2;
    Readint3x3(): int3x3;
    Readint3x4(): int3x4;
    Readint4(): int4;
    Readint4x2(): int4x2;
    Readint4x3(): int4x3;
    Readint4x4(): int4x4;
    ReadInt64(packType: AutoPackType): number;
    ReadLayerMask(): LayerMask;
    ReadList<T>(collection: CSArray<T>, allowNullification: boolean): number;
    ReadListAllocated<T>(): CSArray<T>;
    ReadMatrix4x4(): Matrix4x4;
    ReadNetworkBehaviour(objectId: unknown, componentIndex: unknown, readSpawningObjects: CSArray<number>): NetworkBehaviour;
    ReadNetworkBehaviour(): NetworkBehaviour;
    ReadNetworkConnection(): NetworkConnection;
    ReadNetworkConnectionId(): number;
    ReadNetworkObject(): NetworkObject;
    ReadNetworkObject(objectOrPrefabId: unknown, readSpawningObjects: CSArray<number>): NetworkObject;
    ReadNetworkObjectId(): number;
    ReadPackedWhole(): number;
    ReadPlane(): Plane;
    Readquaternion(): quaternion;
    ReadQuaternion(packType: AutoPackType): Quaternion;
    Readrandom(): Random;
    ReadRay(): Ray;
    ReadRay2D(): Ray2D;
    ReadRect(): Rect;
    ReadRigidTransform(): RigidTransform;
    ReadSByte(): number;
    ReadSingle(packType: AutoPackType): number;
    ReadString(): string;
    ReadTickUnpacked(): number;
    ReadTransform(): Transform;
    ReadUInt16(packType: AutoPackType): number;
    Readuint2(): uint2;
    Readuint2x2(): uint2x2;
    Readuint2x3(): uint2x3;
    Readuint2x4(): uint2x4;
    Readuint3(): uint3;
    ReadUInt32(packType: AutoPackType): number;
    Readuint3x2(): uint3x2;
    Readuint3x3(): uint3x3;
    Readuint3x4(): uint3x4;
    Readuint4(): uint4;
    Readuint4x2(): uint4x2;
    Readuint4x3(): uint4x3;
    Readuint4x4(): uint4x4;
    ReadUInt64(packType: AutoPackType): number;
    ReadUnpacked<T>(): T;
    ReadVector2(): Vector2;
    ReadVector2Int(packType: AutoPackType): Vector2Int;
    ReadVector3(): Vector3;
    ReadVector3Int(packType: AutoPackType): unknown;
    ReadVector4(): Vector4;
    RemainingToString(): string;
    Skip(value: number): void;
    ToString(): string;
    ZigZagDecode(value: number): number;

}
    
interface ReaderConstructor {
    LastNetworkObject: NetworkObject;
    LastNetworkBehaviour: NetworkBehaviour;

    new(bytes: CSArray<number>, networkManager: NetworkManager, networkConnection: NetworkConnection, source: DataSource): Reader;
    new(segment: CSArray<number>, networkManager: NetworkManager, networkConnection: NetworkConnection, source: DataSource): Reader;


}
declare const Reader: ReaderConstructor;
    
interface PooledReader extends Reader {


    Store(): void;

}
    
interface IReconcileData {


    Dispose(): void;
    GetTick(): number;
    SetTick(value: number): void;

}
    
interface ClientRpcDelegate {


    BeginInvoke(reader: PooledReader, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel): void;

}
    
interface ClientRpcDelegateConstructor {

    new(object: unknown, method: unknown): ClientRpcDelegate;


}
declare const ClientRpcDelegate: ClientRpcDelegateConstructor;
    
interface ReconcileRpcDelegate {


    BeginInvoke(reader: PooledReader, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel): void;

}
    
interface ReconcileRpcDelegateConstructor {

    new(object: unknown, method: unknown): ReconcileRpcDelegate;


}
declare const ReconcileRpcDelegate: ReconcileRpcDelegateConstructor;
    
interface ReplicateRpcDelegate {


    BeginInvoke(reader: PooledReader, sender: NetworkConnection, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, sender: NetworkConnection, channel: Channel): void;

}
    
interface ReplicateRpcDelegateConstructor {

    new(object: unknown, method: unknown): ReplicateRpcDelegate;


}
declare const ReplicateRpcDelegate: ReplicateRpcDelegateConstructor;
    
interface ServerRpcDelegate {


    BeginInvoke(reader: PooledReader, channel: Channel, sender: NetworkConnection, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel, sender: NetworkConnection): void;

}
    
interface ServerRpcDelegateConstructor {

    new(object: unknown, method: unknown): ServerRpcDelegate;


}
declare const ServerRpcDelegate: ServerRpcDelegateConstructor;
    
interface PooledWriter extends Writer {


    Store(): void;
    StoreLength(): void;

}
    
interface PooledWriterConstructor {

    new(): PooledWriter;


}
declare const PooledWriter: PooledWriterConstructor;
    
interface PredictedSpawn extends NetworkBehaviour {


    Awake(): void;
    GetAllowDespawning(): boolean;
    GetAllowSpawning(): boolean;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnTryDepawnServer(despawner: NetworkConnection): boolean;
    OnTryDespawnClient(): boolean;
    OnTrySpawnClient(owner: NetworkConnection): boolean;
    OnTrySpawnServer(spawner: NetworkConnection, owner: NetworkConnection): boolean;
    SetAllowDespawning(value: boolean): void;
    SetAllowSpawning(value: boolean): void;

}
    
interface PredictedSpawnConstructor {

    new(): PredictedSpawn;


}
declare const PredictedSpawn: PredictedSpawnConstructor;
    
interface ChildTransformTickSmoother extends IResettable {


    Deinitialize(): void;
    Initialize(nob: NetworkObject, graphicalObject: Transform, detach: boolean, teleportDistance: number, tickDelta: number, ownerInterpolation: number, ownerSmoothedProperties: TransformPropertiesFlag, spectatorInterpolation: number, specatorSmoothedProperties: TransformPropertiesFlag, adaptiveInterpolation: AdaptiveInterpolationType): void;
    InitializeState(): void;
    OnPostReplay(clientTick: number): void;
    OnPostTick(clientTick: number): void;
    OnPreReconcile(): void;
    OnPreTick(): void;
    ResetState(): void;
    SetAdaptiveInterpolation(adaptiveInterpolation: AdaptiveInterpolationType): void;
    SetSmoothedProperties(value: TransformPropertiesFlag, forSpectator: boolean): void;
    SetSpectatorInterpolation(value: number, disableAdaptiveInterpolation: boolean): void;

}
    
interface ChildTransformTickSmootherConstructor {

    new(): ChildTransformTickSmoother;


}
declare const ChildTransformTickSmoother: ChildTransformTickSmootherConstructor;
    
interface RigidbodyPauser extends IResettable {
    Paused: boolean;


    InitializeState(): void;
    Pause(): void;
    ResetState(): void;
    Unpause(): void;
    UpdateRigidbodies(): void;
    UpdateRigidbodies(t: Transform, rbType: RigidbodyType, getInChildren: boolean): void;

}
    
interface RigidbodyPauserConstructor {

    new(): RigidbodyPauser;


}
declare const RigidbodyPauser: RigidbodyPauserConstructor;
    
    
interface LevelOfDetailData extends IResettable {
    CurrentLevelOfDetail: number;
    PreviousLevelOfDetail: number;


    InitializeState(): void;
    ResetState(): void;

}
    
interface LevelOfDetailDataConstructor {

    new(): LevelOfDetailData;


}
declare const LevelOfDetailData: LevelOfDetailDataConstructor;
    
interface NetworkConnectionConstructor {
    UNSET_CLIENTID_VALUE: number;
    MAXIMUM_CLIENTID_VALUE: number;
    MAXIMUM_CLIENTID_WITHOUT_SIMULATED_VALUE: number;
    SIMULATED_CLIENTID_VALUE: number;
    CLIENTID_UNCOMPRESSED_RESERVE_LENGTH: number;

    new(): NetworkConnection;
    new(manager: NetworkManager, clientId: number, transportIndex: number, asServer: boolean): NetworkConnection;


}
declare const NetworkConnection: NetworkConnectionConstructor;
    
interface ServerObjects extends ManagedObjects {


    AddTimedNetworkObserver(networkObject: NetworkObject): void;
    RebuildObservers(timedOnly: boolean): void;
    RebuildObservers(nob: NetworkObject, timedOnly: boolean): void;
    RebuildObservers(connection: NetworkConnection, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, timedOnly: boolean): void;
    RebuildObservers(connections: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, conn: NetworkConnection, timedOnly: boolean): void;
    RebuildObservers(networkObject: NetworkObject, connections: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, conns: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nob: NetworkObject, conn: NetworkConnection, timedOnly: boolean): void;
    RecentlyDespawned(objectId: number, ticks: number): boolean;
    RemoveTimedNetworkObserver(networkObject: NetworkObject): void;

}
    
interface Authenticator extends MonoBehaviour {
    Initialized: boolean;


    InitializeOnce(networkManager: NetworkManager): void;
    OnRemoteConnection(connection: NetworkConnection): void;

}
    
interface ServerManagerConstructor {
    MAXIMUM_REMOTE_CLIENT_TIMEOUT_DURATION: number;

    new(): ServerManager;


}
declare const ServerManager: ServerManagerConstructor;
    
interface DebugManager extends MonoBehaviour {
    WriteSceneObjectDetails: boolean;
    ObserverRpcLinks: boolean;
    TargetRpcLinks: boolean;
    ReplicateRpcLinks: boolean;
    ReconcileRpcLinks: boolean;
    ServerRpcLinks: boolean;



}
    
interface DebugManagerConstructor {

    new(): DebugManager;


}
declare const DebugManager: DebugManagerConstructor;
    
interface StatisticsManager extends MonoBehaviour {
    NetworkTraffic: NetworkTraficStatistics;



}
    
interface NetworkTraficStatistics {
    UpdateClient: boolean;
    UpdateServer: boolean;


    LocalClientReceivedData(dataLength: number): void;
    LocalServerReceivedData(dataLength: number): void;
    SetUpdateClient(update: boolean): void;
    SetUpdateServer(update: boolean): void;

}
    
interface NetworkTraficStatisticsConstructor {

    new(): NetworkTraficStatistics;


    FormatBytesToLargest(bytes: number): string;
}
declare const NetworkTraficStatistics: NetworkTraficStatisticsConstructor;
    
interface StatisticsManagerConstructor {

    new(): StatisticsManager;


}
declare const StatisticsManager: StatisticsManagerConstructor;
    
interface ObjectPool extends MonoBehaviour {


    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    GetPrefab(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    InitializeOnce(nm: NetworkManager): void;
    LateUpdate(): void;
    RetrieveObject(prefabId: number, collectionId: number, parent: Transform, position: unknown, rotation: unknown, scale: unknown, makeActive: boolean, asServer: boolean): NetworkObject;
    StoreObject(instantiated: NetworkObject, asServer: boolean): void;

}
    
interface PrefabObjects extends ScriptableObject {
    CollectionId: number;


    AddObject(networkObject: NetworkObject, checkForDuplicates: boolean): void;
    AddObject(dualPrefab: DualPrefab, checkForDuplicates: boolean): void;
    AddObjects(networkObjects: CSArray<NetworkObject>, checkForDuplicates: boolean): void;
    AddObjects(networkObjects: CSArray<NetworkObject>, checkForDuplicates: boolean): void;
    AddObjects(dualPrefab: CSArray<DualPrefab>, checkForDuplicates: boolean): void;
    AddObjects(dualPrefab: CSArray<DualPrefab>, checkForDuplicates: boolean): void;
    Clear(): void;
    GetObject(asServer: boolean, id: number): NetworkObject;
    GetObjectCount(): number;
    InitializePrefabRange(startIndex: number): void;
    RemoveNull(): void;

}
    
interface DualPrefab {
    Server: NetworkObject;
    Client: NetworkObject;



}
    
interface NetworkManagerConstructor {
    FISHNET_VERSION: string;
    Instances: CSArray<NetworkManager>;
    EmptyConnection: NetworkConnection;

    new(): NetworkManager;


}
declare const NetworkManager: NetworkManagerConstructor;
    
interface NetworkCoreConstructor {
    Net: Net;
    NetworkManager: NetworkManager;

    new(): NetworkCore;


    Despawn(obj: GameObject): void;
    SetNet(net: Net): void;
    Spawn(obj: GameObject, clientId: number): void;
    Spawn(obj: GameObject): void;
}
declare const NetworkCore: NetworkCoreConstructor;
    
interface Camera extends Behaviour {
    nearClipPlane: number;
    farClipPlane: number;
    fieldOfView: number;
    renderingPath: RenderingPath;
    actualRenderingPath: RenderingPath;
    allowHDR: boolean;
    allowMSAA: boolean;
    allowDynamicResolution: boolean;
    forceIntoRenderTexture: boolean;
    orthographicSize: number;
    orthographic: boolean;
    opaqueSortMode: OpaqueSortMode;
    transparencySortMode: TransparencySortMode;
    transparencySortAxis: Vector3;
    depth: number;
    aspect: number;
    velocity: Vector3;
    cullingMask: number;
    eventMask: number;
    layerCullSpherical: boolean;
    cameraType: CameraType;
    overrideSceneCullingMask: number;
    layerCullDistances: CSArray<number>;
    useOcclusionCulling: boolean;
    cullingMatrix: Matrix4x4;
    backgroundColor: Color;
    clearFlags: CameraClearFlags;
    depthTextureMode: DepthTextureMode;
    clearStencilAfterLightingPass: boolean;
    usePhysicalProperties: boolean;
    iso: number;
    shutterSpeed: number;
    aperture: number;
    focusDistance: number;
    focalLength: number;
    bladeCount: number;
    curvature: Vector2;
    barrelClipping: number;
    anamorphism: number;
    sensorSize: Vector2;
    lensShift: Vector2;
    gateFit: GateFitMode;
    rect: Rect;
    pixelRect: Rect;
    pixelWidth: number;
    pixelHeight: number;
    scaledPixelWidth: number;
    scaledPixelHeight: number;
    targetTexture: RenderTexture;
    activeTexture: RenderTexture;
    targetDisplay: number;
    cameraToWorldMatrix: Matrix4x4;
    worldToCameraMatrix: Matrix4x4;
    projectionMatrix: Matrix4x4;
    nonJitteredProjectionMatrix: Matrix4x4;
    useJitteredProjectionMatrixForTransparentRendering: boolean;
    previousViewProjectionMatrix: Matrix4x4;
    scene: Scene;
    stereoEnabled: boolean;
    stereoSeparation: number;
    stereoConvergence: number;
    areVRStereoViewMatricesWithinSingleCullTolerance: boolean;
    stereoTargetEye: StereoTargetEyeMask;
    stereoActiveEye: MonoOrStereoscopicEye;
    sceneViewFilterMode: SceneViewFilterMode;
    renderCloudsInSceneView: boolean;
    commandBufferCount: number;
    isOrthoGraphic: boolean;
    near: number;
    far: number;
    fov: number;
    hdr: boolean;
    stereoMirrorMode: boolean;


    /** Add a command buffer to be executed at a specified place. */
    AddCommandBuffer(evt: CameraEvent, buffer: CommandBuffer): void;
    /** Adds a command buffer to the GPU&#x27;s async compute queues and executes that command buffer when graphics processing reaches a given point. */
    AddCommandBufferAsync(evt: CameraEvent, buffer: CommandBuffer, queueType: ComputeQueueType): void;
    CalculateFrustumCorners(viewport: Rect, z: number, eye: MonoOrStereoscopicEye, outCorners: CSArray<Vector3>): void;
    /** Calculates and returns oblique near-plane projection matrix. */
    CalculateObliqueMatrix(clipPlane: Vector4): Matrix4x4;
    /** Makes this camera&#x27;s settings match other camera. */
    CopyFrom(other: Camera): void;
    CopyStereoDeviceProjectionMatrixToNonJittered(eye: StereoscopicEye): void;
    DoClear(): void;
    /** Get command buffers to be executed at a specified place. */
    GetCommandBuffers(evt: CameraEvent): CSArray<CommandBuffer>;
    /** Retrieves the effective vertical field of view of the camera, including GateFit.
                    Fitting the sensor gate and the resolution gate has an impact on the final field of view. If the sensor gate aspect ratio is the same as the resolution gate aspect ratio or if the camera is not in physical mode, then this method returns the same value as the fieldofview property. */
    GetGateFittedFieldOfView(): number;
    /** Retrieves the effective lens offset of the camera, including GateFit.
                    Fitting the sensor gate and the resolution gate has an impact on the final obliqueness of the projection. If the sensor gate aspect ratio is the same as the resolution gate aspect ratio, then this method returns the same value as the lenshift property. If the camera is not in physical mode, then this methods returns Vector2.zero. */
    GetGateFittedLensShift(): Vector2;
    GetScreenHeight(): number;
    GetScreenWidth(): number;
    GetStereoNonJitteredProjectionMatrix(eye: StereoscopicEye): Matrix4x4;
    GetStereoProjectionMatrices(): CSArray<Matrix4x4>;
    GetStereoProjectionMatrix(eye: StereoscopicEye): Matrix4x4;
    GetStereoViewMatrices(): CSArray<Matrix4x4>;
    GetStereoViewMatrix(eye: StereoscopicEye): Matrix4x4;
    /** Remove all command buffers set on this camera. */
    RemoveAllCommandBuffers(): void;
    /** Remove command buffer from execution at a specified place. */
    RemoveCommandBuffer(evt: CameraEvent, buffer: CommandBuffer): void;
    /** Remove command buffers from execution at a specified place. */
    RemoveCommandBuffers(evt: CameraEvent): void;
    /** Render the camera manually. */
    Render(): void;
    RenderDontRestore(): void;
    /** Render into a static cubemap from this camera. */
    RenderToCubemap(cubemap: Cubemap, faceMask: number): boolean;
    RenderToCubemap(cubemap: Cubemap): boolean;
    /** Render into a cubemap from this camera. */
    RenderToCubemap(cubemap: RenderTexture, faceMask: number): boolean;
    RenderToCubemap(cubemap: RenderTexture): boolean;
    RenderToCubemap(cubemap: RenderTexture, faceMask: number, stereoEye: MonoOrStereoscopicEye): boolean;
    /** Render the camera with shader replacement. */
    RenderWithShader(shader: Shader, replacementTag: string): void;
    /** Revert all camera parameters to default. */
    Reset(): void;
    /** Revert the aspect ratio to the screen&#x27;s aspect ratio. */
    ResetAspect(): void;
    /** Make culling queries reflect the camera&#x27;s built in parameters. */
    ResetCullingMatrix(): void;
    /** Reset to the default field of view. */
    ResetFieldOfView(): void;
    /** Make the projection reflect normal camera&#x27;s parameters. */
    ResetProjectionMatrix(): void;
    /** Remove shader replacement from camera. */
    ResetReplacementShader(): void;
    /** Reset the camera to using the Unity computed projection matrices for all stereoscopic eyes. */
    ResetStereoProjectionMatrices(): void;
    /** Reset the camera to using the Unity computed view matrices for all stereoscopic eyes. */
    ResetStereoViewMatrices(): void;
    /** Resets this Camera&#x27;s transparency sort settings to the default. Default transparency settings are taken from GraphicsSettings instead of directly from this Camera. */
    ResetTransparencySortSettings(): void;
    /** Make the rendering position reflect the camera&#x27;s position in the Scene. */
    ResetWorldToCameraMatrix(): void;
    ScreenPointToRay(pos: Vector3, eye: MonoOrStereoscopicEye): Ray;
    /** Returns a ray going from camera through a screen point. */
    ScreenPointToRay(pos: Vector3): Ray;
    /** Transforms position from screen space into viewport space. */
    ScreenToViewportPoint(position: Vector3): Vector3;
    ScreenToWorldPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    /** Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game&#x27;s hierarchy. */
    ScreenToWorldPoint(position: Vector3): Vector3;
    /** Make the camera render with shader replacement. */
    SetReplacementShader(shader: Shader, replacementTag: string): void;
    /** Sets custom projection matrices for both the left and right stereoscopic eyes. */
    SetStereoProjectionMatrices(leftMatrix: Matrix4x4, rightMatrix: Matrix4x4): void;
    SetStereoProjectionMatrix(eye: StereoscopicEye, matrix: Matrix4x4): void;
    /** Set custom view matrices for both eyes. */
    SetStereoViewMatrices(leftMatrix: Matrix4x4, rightMatrix: Matrix4x4): void;
    SetStereoViewMatrix(eye: StereoscopicEye, matrix: Matrix4x4): void;
    /** Sets the Camera to render to the chosen buffers of one or more RenderTextures. */
    SetTargetBuffers(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer): void;
    /** Sets the Camera to render to the chosen buffers of one or more RenderTextures. */
    SetTargetBuffers(colorBuffer: CSArray<RenderBuffer>, depthBuffer: RenderBuffer): void;
    SubmitRenderRequest<RequestData>(renderRequest: RequestData): void;
    SubmitRenderRequests(renderRequests: CSArray<RenderRequest>): void;
    /** Get culling parameters for a camera. */
    TryGetCullingParameters(cullingParameters: unknown): boolean;
    /** Get culling parameters for a camera. */
    TryGetCullingParameters(stereoAware: boolean, cullingParameters: unknown): boolean;
    ViewportPointToRay(pos: Vector3, eye: MonoOrStereoscopicEye): Ray;
    /** Returns a ray going from camera through a viewport point. */
    ViewportPointToRay(pos: Vector3): Ray;
    /** Transforms position from viewport space into screen space. */
    ViewportToScreenPoint(position: Vector3): Vector3;
    ViewportToWorldPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    /** Transforms position from viewport space into world space. */
    ViewportToWorldPoint(position: Vector3): Vector3;
    WorldToScreenPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    /** Transforms position from world space into screen space. */
    WorldToScreenPoint(position: Vector3): Vector3;
    WorldToViewportPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    /** Transforms position from world space into viewport space. */
    WorldToViewportPoint(position: Vector3): Vector3;

}
    
interface RenderTexture extends Texture {
    width: number;
    height: number;
    dimension: TextureDimension;
    graphicsFormat: GraphicsFormat;
    useMipMap: boolean;
    sRGB: boolean;
    vrUsage: VRTextureUsage;
    memorylessMode: RenderTextureMemoryless;
    format: RenderTextureFormat;
    stencilFormat: GraphicsFormat;
    depthStencilFormat: GraphicsFormat;
    autoGenerateMips: boolean;
    volumeDepth: number;
    antiAliasing: number;
    bindTextureMS: boolean;
    enableRandomWrite: boolean;
    useDynamicScale: boolean;
    useDynamicScaleExplicit: boolean;
    isPowerOfTwo: boolean;
    colorBuffer: RenderBuffer;
    depthBuffer: RenderBuffer;
    depth: number;
    descriptor: RenderTextureDescriptor;
    generateMips: boolean;
    isCubemap: boolean;
    isVolume: boolean;


    /** Applies the scale. */
    ApplyDynamicScale(): void;
    ConvertToEquirect(equirect: RenderTexture, eye: MonoOrStereoscopicEye): void;
    /** Actually creates the RenderTexture. */
    Create(): boolean;
    /** Hint the GPU driver that the contents of the RenderTexture will not be used. */
    DiscardContents(discardColor: boolean, discardDepth: boolean): void;
    /** Hint the GPU driver that the contents of the RenderTexture will not be used. */
    DiscardContents(): void;
    /** Generate mipmap levels of a render texture. */
    GenerateMips(): void;
    /** Retrieve a native (underlying graphics API) pointer to the depth buffer resource. */
    GetNativeDepthBufferPtr(): unknown;
    GetTexelOffset(): Vector2;
    /** Is the render texture actually created? */
    IsCreated(): boolean;
    /** Indicate that there&#x27;s a RenderTexture restore operation expected. */
    MarkRestoreExpected(): void;
    /** Releases the RenderTexture. */
    Release(): void;
    /** Force an antialiased render texture to be resolved. */
    ResolveAntiAliasedSurface(): void;
    /** Force an antialiased render texture to be resolved. */
    ResolveAntiAliasedSurface(target: RenderTexture): void;
    SetBorderColor(color: Color): void;
    /** Assigns this RenderTexture as a global shader property named propertyName. */
    SetGlobalShaderProperty(propertyName: string): void;

}
    
interface RenderBuffer {


    /** Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS. */
    GetNativeRenderBufferPtr(): unknown;

}
    
interface RenderTextureDescriptor {
    width: number;
    height: number;
    msaaSamples: number;
    volumeDepth: number;
    mipCount: number;
    graphicsFormat: GraphicsFormat;
    stencilFormat: GraphicsFormat;
    depthStencilFormat: GraphicsFormat;
    colorFormat: RenderTextureFormat;
    sRGB: boolean;
    depthBufferBits: number;
    dimension: TextureDimension;
    shadowSamplingMode: ShadowSamplingMode;
    vrUsage: VRTextureUsage;
    flags: RenderTextureCreationFlags;
    memoryless: RenderTextureMemoryless;
    useMipMap: boolean;
    autoGenerateMips: boolean;
    enableRandomWrite: boolean;
    bindMS: boolean;
    useDynamicScale: boolean;
    useDynamicScaleExplicit: boolean;



}
    
interface RenderTextureDescriptorConstructor {

    new(width: number, height: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthBufferBits: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number, mipCount: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number, mipCount: number, readWrite: RenderTextureReadWrite): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthBufferBits: number, mipCount: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: number): RenderTextureDescriptor;


}
declare const RenderTextureDescriptor: RenderTextureDescriptorConstructor;
    
interface RenderTextureConstructor {
    active: RenderTexture;
    enabled: boolean;

    new(desc: RenderTextureDescriptor): RenderTexture;
    new(textureToCopy: RenderTexture): RenderTexture;
    new(width: number, height: number, depth: number, format: DefaultFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: GraphicsFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: GraphicsFormat, mipCount: number): RenderTexture;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: number): RenderTexture;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat): RenderTexture;
    new(width: number, height: number, depth: number): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat, mipCount: number): RenderTexture;


    GetTemporary(desc: RenderTextureDescriptor): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: boolean): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: boolean): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number): RenderTexture;
    GetTemporary(width: number, height: number): RenderTexture;
    ReleaseTemporary(temp: RenderTexture): void;
    SupportsStencil(rt: RenderTexture): boolean;
}
declare const RenderTexture: RenderTextureConstructor;
    
interface CommandBuffer {
    name: string;
    sizeInBytes: number;


    BeginRenderPass(width: number, height: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>): void;
    BeginRenderPass(width: number, height: number, volumeDepth: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>): void;
    BeginRenderPass(width: number, height: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>, debugNameUtf8: unknown): void;
    BeginRenderPass(width: number, height: number, volumeDepth: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>, debugNameUtf8: unknown): void;
    /** Adds a command to begin profile sampling. */
    BeginSample(name: string): void;
    /** Adds a command to begin profile sampling. */
    BeginSample(sampler: CustomSampler): void;
    BeginSample(marker: ProfilerMarker): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: Texture, dest: RenderTargetIdentifier): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: Texture, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: Texture, dest: RenderTargetIdentifier, mat: Material): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: Texture, dest: RenderTargetIdentifier, mat: Material, pass: number): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: number): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, sourceDepthSlice: number, destDepthSlice: number): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2, sourceDepthSlice: number, destDepthSlice: number): void;
    /** Adds a command to use a shader to copy the pixel data from a texture into a render texture. */
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: number, destDepthSlice: number): void;
    /** Adds a command to build the RayTracingAccelerationStructure to be used in a ray tracing dispatch or when using inline ray tracing (ray queries). */
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure): void;
    /** Adds a command to build the RayTracingAccelerationStructure to be used in a ray tracing dispatch or when using inline ray tracing (ray queries). */
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure, relativeOrigin: Vector3): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure, buildSettings: BuildSettings): void;
    /** Clear all commands in the buffer. */
    Clear(): void;
    /** Clear random write targets for level pixel shaders. */
    ClearRandomWriteTargets(): void;
    /** Adds a &quot;clear render target&quot; command. */
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color): void;
    /** Adds a &quot;clear render target&quot; command. */
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color, depth: number): void;
    /** Adds a &quot;clear render target&quot; command. */
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color, depth: number, stencil: number): void;
    /** Adds a &quot;clear render target&quot; command. */
    ClearRenderTarget(clearFlags: RTClearFlags, backgroundColor: Color, depth: number, stencil: number): void;
    /** Adds a &quot;clear render target&quot; command. */
    ClearRenderTarget(clearFlags: RTClearFlags, backgroundColors: CSArray<Color>, depth: number, stencil: number): void;
    /** Adds a command to configure foveated rendering. */
    ConfigureFoveatedRendering(platformData: unknown): void;
    /** Adds a command to copy the pixel data from one texture, convert the data into a different format, and copy it into another texture. */
    ConvertTexture(src: RenderTargetIdentifier, dst: RenderTargetIdentifier): void;
    /** Adds a command to copy the pixel data from one texture, convert the data into a different format, and copy it into another texture. */
    ConvertTexture(src: RenderTargetIdentifier, srcElement: number, dst: RenderTargetIdentifier, dstElement: number): void;
    /** Adds a command to copy the contents of one GraphicsBuffer into another. */
    CopyBuffer(source: GraphicsBuffer, dest: GraphicsBuffer): void;
    /** Adds a command to copy ComputeBuffer or GraphicsBuffer counter value. */
    CopyCounterValue(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    /** Adds a command to copy ComputeBuffer or GraphicsBuffer counter value. */
    CopyCounterValue(src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    /** Adds a command to copy ComputeBuffer or GraphicsBuffer counter value. */
    CopyCounterValue(src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    /** Adds a command to copy ComputeBuffer or GraphicsBuffer counter value. */
    CopyCounterValue(src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    /** Adds a command to copy pixel data from one texture to another. */
    CopyTexture(src: RenderTargetIdentifier, dst: RenderTargetIdentifier): void;
    /** Adds a command to copy pixel data from one texture to another. */
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, dst: RenderTargetIdentifier, dstElement: number): void;
    /** Adds a command to copy pixel data from one texture to another. */
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, srcMip: number, dst: RenderTargetIdentifier, dstElement: number, dstMip: number): void;
    /** Adds a command to copy pixel data from one texture to another. */
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, srcMip: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number, dst: RenderTargetIdentifier, dstElement: number, dstMip: number, dstX: number, dstY: number): void;
    /** Shortcut for calling CommandBuffer.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter. */
    CreateAsyncGraphicsFence(): GraphicsFence;
    /** Shortcut for calling CommandBuffer.CreateGraphicsFence with Rendering.GraphicsFenceType.AsyncQueueSynchronisation as the first parameter. */
    CreateAsyncGraphicsFence(stage: SynchronisationStage): GraphicsFence;
    /** This functionality is deprecated, and should no longer be used. Please use CommandBuffer.CreateGraphicsFence. */
    CreateGPUFence(stage: SynchronisationStage): GPUFence;
    CreateGPUFence(): GPUFence;
    /** Creates a GraphicsFence. */
    CreateGraphicsFence(fenceType: GraphicsFenceType, stage: SynchronisationStageFlags): GraphicsFence;
    /** Adds a command to disable a global or local shader keyword. */
    DisableKeyword(keyword: unknown): void;
    /** Adds a command to disable a global or local shader keyword. */
    DisableKeyword(material: Material, keyword: unknown): void;
    /** Adds a command to disable a global or local shader keyword. */
    DisableKeyword(computeShader: ComputeShader, keyword: unknown): void;
    /** Add a command to disable the hardware scissor rectangle. */
    DisableScissorRect(): void;
    /** Adds a command to disable a global shader keyword with a given name. */
    DisableShaderKeyword(keyword: string): void;
    /** Add a command to execute a ComputeShader. */
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, threadGroupsX: number, threadGroupsY: number, threadGroupsZ: number): void;
    /** Add a command to execute a ComputeShader. */
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, indirectBuffer: ComputeBuffer, argsOffset: number): void;
    /** Add a command to execute a ComputeShader. */
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, indirectBuffer: GraphicsBuffer, argsOffset: number): void;
    /** Adds a command to execute a RayTracingShader. */
    DispatchRays(rayTracingShader: RayTracingShader, rayGenName: string, width: number, height: number, depth: number, camera: Camera): void;
    Dispose(): void;
    /** Add a &quot;draw mesh&quot; command. */
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, shaderPass: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw mesh&quot; command. */
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, shaderPass: number): void;
    /** Add a &quot;draw mesh&quot; command. */
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number): void;
    /** Add a &quot;draw mesh&quot; command. */
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material): void;
    /** Adds a &quot;draw mesh with instancing&quot; command.

The mesh will be just drawn once, it won&#x27;t be per-pixel lit and will not cast or receive realtime shadows.

The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.

InvalidOperationException will be thrown if the current platform doesn&#x27;t support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing. */
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock): void;
    /** Adds a &quot;draw mesh with instancing&quot; command.

The mesh will be just drawn once, it won&#x27;t be per-pixel lit and will not cast or receive realtime shadows.

The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.

InvalidOperationException will be thrown if the current platform doesn&#x27;t support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing. */
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>, count: number): void;
    /** Adds a &quot;draw mesh with instancing&quot; command.

The mesh will be just drawn once, it won&#x27;t be per-pixel lit and will not cast or receive realtime shadows.

The command will not immediately fail and throw an exception if Material.enableInstancing is false, but it will log an error and skips rendering each time the command is being executed if such a condition is detected.

InvalidOperationException will be thrown if the current platform doesn&#x27;t support this API (i.e. if GPU instancing is not available). See SystemInfo.supportsInstancing. */
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>): void;
    /** Add a &quot;draw mesh with indirect instancing&quot; command. */
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw mesh with indirect instancing&quot; command. */
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    /** Add a &quot;draw mesh with indirect instancing&quot; command. */
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer): void;
    /** Add a &quot;draw mesh with indirect instancing&quot; command. */
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw mesh with indirect instancing&quot; command. */
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    /** Add a &quot;draw mesh with indirect instancing&quot; command. */
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer): void;
    /** Add a &quot;draw mesh with instancing&quot; command.

Draw a mesh using Procedural Instancing. This is similar to Graphics.DrawMeshInstancedIndirect, except that when the instance count is known from script, it can be supplied directly using this method, rather than via a ComputeBuffer.
If Material.enableInstancing is false, the command logs an error and skips rendering each time the command is executed; the command does not immediately fail and throw an exception.

InvalidOperationException will be thrown if the current platform doesn&#x27;t support this API (for example, if GPU instancing is not available). See SystemInfo.supportsInstancing. */
    DrawMeshInstancedProcedural(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, count: number, properties: MaterialPropertyBlock): void;
    DrawMultipleMeshes(matrices: CSArray<Matrix4x4>, meshes: CSArray<Mesh>, subsetIndices: CSArray<number>, count: number, material: Material, shaderPass: number, properties: MaterialPropertyBlock): void;
    /** Adds a command onto the commandbuffer to draw the VR Device&#x27;s occlusion mesh to the current render target. */
    DrawOcclusionMesh(normalizedCamViewport: RectInt): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number, instanceCount: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number, instanceCount: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number, instanceCount: number): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    /** Add a &quot;draw procedural geometry&quot; command. */
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer): void;
    /** Add a &quot;draw renderer&quot; command. */
    DrawRenderer(renderer: Renderer, material: Material, submeshIndex: number, shaderPass: number): void;
    /** Add a &quot;draw renderer&quot; command. */
    DrawRenderer(renderer: Renderer, material: Material, submeshIndex: number): void;
    /** Add a &quot;draw renderer&quot; command. */
    DrawRenderer(renderer: Renderer, material: Material): void;
    /** Adds a &quot;draw renderer list&quot; command. */
    DrawRendererList(rendererList: RendererList): void;
    /** Adds a command to enable a global or local shader keyword. */
    EnableKeyword(keyword: unknown): void;
    /** Adds a command to enable a global or local shader keyword. */
    EnableKeyword(material: Material, keyword: unknown): void;
    /** Adds a command to enable a global or local shader keyword. */
    EnableKeyword(computeShader: ComputeShader, keyword: unknown): void;
    /** Add a command to enable the hardware scissor rectangle. */
    EnableScissorRect(scissor: Rect): void;
    /** Adds a command to enable a global keyword with a given name. */
    EnableShaderKeyword(keyword: string): void;
    /** Terminate the active native renderpass. */
    EndRenderPass(): void;
    /** Adds a command to end profile sampling. */
    EndSample(name: string): void;
    /** Adds a command to end profile sampling. */
    EndSample(sampler: CustomSampler): void;
    EndSample(marker: ProfilerMarker): void;
    /** Generate mipmap levels of a render texture. */
    GenerateMips(rt: RenderTargetIdentifier): void;
    /** Generate mipmap levels of a render texture. */
    GenerateMips(rt: RenderTexture): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless, useDynamicScale: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless, useDynamicScale: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless): void;
    /** Add a &quot;get a temporary render texture&quot; command. */
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number): void;
    /** Add a &quot;get a temporary render texture&quot; command. */
    GetTemporaryRT(nameID: number, desc: RenderTextureDescriptor, filter: FilterMode): void;
    GetTemporaryRT(nameID: number, desc: RenderTextureDescriptor): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, useDynamicScale: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat): void;
    /** Add a &quot;get a temporary render texture array&quot; command. */
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number): void;
    /** Increments the updateCount property of a Texture. */
    IncrementUpdateCount(dest: RenderTargetIdentifier): void;
    /** Schedules an invocation of the OnRenderObject callback for MonoBehaviour scripts. */
    InvokeOnRenderObjectCallbacks(): void;
    /** Send a user-defined blit event to a native code plugin. */
    IssuePluginCustomBlit(callback: unknown, command: number, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, commandParam: number, commandFlags: number): void;
    /** Deprecated. Use CommandBuffer.IssuePluginCustomTextureUpdateV2 instead. */
    IssuePluginCustomTextureUpdate(callback: unknown, targetTexture: Texture, userData: number): void;
    /** Deprecated. Use CommandBuffer.IssuePluginCustomTextureUpdateV2 instead. */
    IssuePluginCustomTextureUpdateV1(callback: unknown, targetTexture: Texture, userData: number): void;
    /** Send a texture update event to a native code plugin. */
    IssuePluginCustomTextureUpdateV2(callback: unknown, targetTexture: Texture, userData: number): void;
    /** Send a user-defined event to a native code plugin. */
    IssuePluginEvent(callback: unknown, eventID: number): void;
    /** Send a user-defined event to a native code plugin with custom data. */
    IssuePluginEventAndData(callback: unknown, eventID: number, data: unknown): void;
    /** Send a user-defined event to a native code plugin with custom data and callback flags. */
    IssuePluginEventAndDataWithFlags(callback: unknown, eventID: number, flags: CustomMarkerCallbackFlags, data: unknown): void;
    /** Mark a global shader property id to be late latched.  Possible shader properties include view, inverseView, viewProjection, and inverseViewProjection matrices. The Universal Render Pipeline (URP) uses this function to support late latching of shader properties. If you call this function when using built-in Unity rendering or the High-Definition Rendering Pipeline (HDRP), the results are ignored. */
    MarkLateLatchMatrixShaderPropertyID(matrixPropertyType: CameraLateLatchMatrixType, shaderPropertyID: number): void;
    /** Start the next native subpass as discribed by CommandBuffer.BeginRenderPass. */
    NextSubPass(): void;
    ProcessVTFeedback(rt: RenderTargetIdentifier, resolver: unknown, slice: number, x: number, width: number, y: number, height: number, mip: number): void;
    Release(): void;
    /** Add a &quot;release a temporary render texture&quot; command. */
    ReleaseTemporaryRT(nameID: number): void;
    RequestAsyncReadback(src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadback(src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadback(src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadback(src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    /** Force an antialiased render texture to be resolved. */
    ResolveAntiAliasedSurface(rt: RenderTexture, target: RenderTexture): void;
    /** Adds a command to set the counter value of append/consume buffer. */
    SetBufferCounterValue(buffer: ComputeBuffer, counterValue: number): void;
    /** Adds a command to set the counter value of append/consume buffer. */
    SetBufferCounterValue(buffer: GraphicsBuffer, counterValue: number): void;
    /** Adds a command to set the buffer with values from an array. */
    SetBufferData(buffer: ComputeBuffer, data: unknown): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    /** Adds a command to process a partial copy of data values from an array into the buffer. */
    SetBufferData(buffer: ComputeBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    /** Adds a command to set the buffer with values from an array. */
    SetBufferData(buffer: GraphicsBuffer, data: unknown): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>): void;
    /** Adds a command to process a partial copy of data values from an array into the buffer. */
    SetBufferData(buffer: GraphicsBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferCounterValue(buffer: ComputeBuffer, counterValue: number): void;
    SetComputeBufferData(buffer: ComputeBuffer, data: unknown): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetComputeBufferData(buffer: ComputeBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    /** Adds a command to set an input or output buffer parameter on a ComputeShader. */
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, buffer: ComputeBuffer): void;
    /** Adds a command to set an input or output buffer parameter on a ComputeShader. */
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, buffer: ComputeBuffer): void;
    /** Adds a command to set an input or output buffer parameter on a ComputeShader. */
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, bufferHandle: GraphicsBufferHandle): void;
    /** Adds a command to set an input or output buffer parameter on a ComputeShader. */
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, bufferHandle: GraphicsBufferHandle): void;
    /** Adds a command to set an input or output buffer parameter on a ComputeShader. */
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, buffer: GraphicsBuffer): void;
    /** Adds a command to set an input or output buffer parameter on a ComputeShader. */
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, buffer: GraphicsBuffer): void;
    /** Adds a command to set a constant buffer on a ComputeShader. */
    SetComputeConstantBufferParam(computeShader: ComputeShader, nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    /** Adds a command to set a constant buffer on a ComputeShader. */
    SetComputeConstantBufferParam(computeShader: ComputeShader, name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    /** Adds a command to set a constant buffer on a ComputeShader. */
    SetComputeConstantBufferParam(computeShader: ComputeShader, nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    /** Adds a command to set a constant buffer on a ComputeShader. */
    SetComputeConstantBufferParam(computeShader: ComputeShader, name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    /** Adds a command to set a float parameter on a ComputeShader. */
    SetComputeFloatParam(computeShader: ComputeShader, nameID: number, val: number): void;
    /** Adds a command to set a float parameter on a ComputeShader. */
    SetComputeFloatParam(computeShader: ComputeShader, name: string, val: number): void;
    /** Adds a command to set multiple consecutive float parameters on a ComputeShader. */
    SetComputeFloatParams(computeShader: ComputeShader, name: string, values: CSArray<number>): void;
    /** Adds a command to set multiple consecutive float parameters on a ComputeShader. */
    SetComputeFloatParams(computeShader: ComputeShader, nameID: number, values: CSArray<number>): void;
    /** Adds a command to set an integer parameter on a ComputeShader. */
    SetComputeIntParam(computeShader: ComputeShader, nameID: number, val: number): void;
    /** Adds a command to set an integer parameter on a ComputeShader. */
    SetComputeIntParam(computeShader: ComputeShader, name: string, val: number): void;
    /** Adds a command to set multiple consecutive integer parameters on a ComputeShader. */
    SetComputeIntParams(computeShader: ComputeShader, name: string, values: CSArray<number>): void;
    /** Adds a command to set multiple consecutive integer parameters on a ComputeShader. */
    SetComputeIntParams(computeShader: ComputeShader, nameID: number, values: CSArray<number>): void;
    /** Adds a command to set a matrix array parameter on a ComputeShader. */
    SetComputeMatrixArrayParam(computeShader: ComputeShader, nameID: number, values: CSArray<Matrix4x4>): void;
    /** Adds a command to set a matrix array parameter on a ComputeShader. */
    SetComputeMatrixArrayParam(computeShader: ComputeShader, name: string, values: CSArray<Matrix4x4>): void;
    /** Adds a command to set a matrix parameter on a ComputeShader. */
    SetComputeMatrixParam(computeShader: ComputeShader, nameID: number, val: Matrix4x4): void;
    /** Adds a command to set a matrix parameter on a ComputeShader. */
    SetComputeMatrixParam(computeShader: ComputeShader, name: string, val: Matrix4x4): void;
    /** Sets the parameters for a compute shader kernel from a Material. */
    SetComputeParamsFromMaterial(computeShader: ComputeShader, kernelIndex: number, material: Material): void;
    /** Adds a command to set a texture parameter on a ComputeShader. */
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier): void;
    /** Adds a command to set a texture parameter on a ComputeShader. */
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier): void;
    /** Adds a command to set a texture parameter on a ComputeShader. */
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier, mipLevel: number): void;
    /** Adds a command to set a texture parameter on a ComputeShader. */
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier, mipLevel: number): void;
    /** Adds a command to set a texture parameter on a ComputeShader. */
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier, mipLevel: number, element: RenderTextureSubElement): void;
    /** Adds a command to set a texture parameter on a ComputeShader. */
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier, mipLevel: number, element: RenderTextureSubElement): void;
    /** Adds a command to set a vector array parameter on a ComputeShader. */
    SetComputeVectorArrayParam(computeShader: ComputeShader, nameID: number, values: CSArray<Vector4>): void;
    /** Adds a command to set a vector array parameter on a ComputeShader. */
    SetComputeVectorArrayParam(computeShader: ComputeShader, name: string, values: CSArray<Vector4>): void;
    /** Adds a command to set a vector parameter on a ComputeShader. */
    SetComputeVectorParam(computeShader: ComputeShader, nameID: number, val: Vector4): void;
    /** Adds a command to set a vector parameter on a ComputeShader. */
    SetComputeVectorParam(computeShader: ComputeShader, name: string, val: Vector4): void;
    /** Set flags describing the intention for how the command buffer will be executed. */
    SetExecutionFlags(flags: CommandBufferExecutionFlags): void;
    /** Adds a command to set the mode to use for foveated rendering. */
    SetFoveatedRenderingMode(foveatedRenderingMode: FoveatedRenderingMode): void;
    /** Add a &quot;set global shader buffer property&quot; command. */
    SetGlobalBuffer(name: string, value: ComputeBuffer): void;
    /** Add a &quot;set global shader buffer property&quot; command. */
    SetGlobalBuffer(nameID: number, value: ComputeBuffer): void;
    /** Add a &quot;set global shader buffer property&quot; command. */
    SetGlobalBuffer(name: string, value: GraphicsBuffer): void;
    /** Add a &quot;set global shader buffer property&quot; command. */
    SetGlobalBuffer(nameID: number, value: GraphicsBuffer): void;
    /** Add a &quot;set global shader color property&quot; command. */
    SetGlobalColor(nameID: number, value: Color): void;
    /** Add a &quot;set global shader color property&quot; command. */
    SetGlobalColor(name: string, value: Color): void;
    /** Add a command to bind a global constant buffer. */
    SetGlobalConstantBuffer(buffer: ComputeBuffer, nameID: number, offset: number, size: number): void;
    /** Add a command to bind a global constant buffer. */
    SetGlobalConstantBuffer(buffer: ComputeBuffer, name: string, offset: number, size: number): void;
    /** Add a command to bind a global constant buffer. */
    SetGlobalConstantBuffer(buffer: GraphicsBuffer, nameID: number, offset: number, size: number): void;
    /** Add a command to bind a global constant buffer. */
    SetGlobalConstantBuffer(buffer: GraphicsBuffer, name: string, offset: number, size: number): void;
    /** Adds a command to set the global depth bias. */
    SetGlobalDepthBias(bias: number, slopeBias: number): void;
    /** Add a &quot;set global shader float property&quot; command. */
    SetGlobalFloat(nameID: number, value: number): void;
    /** Add a &quot;set global shader float property&quot; command. */
    SetGlobalFloat(name: string, value: number): void;
    /** Add a &quot;set global shader float array property&quot; command. */
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(propertyName: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    /** Add a &quot;set global shader float array property&quot; command. */
    SetGlobalFloatArray(propertyName: string, values: CSArray<number>): void;
    /** Adds a command to set the value of a given property for all Shaders, where the property has a type of Int in ShaderLab code. */
    SetGlobalInt(nameID: number, value: number): void;
    /** Adds a command to set the value of a given property for all Shaders, where the property has a type of Int in ShaderLab code. */
    SetGlobalInt(name: string, value: number): void;
    /** Adds a command to set the value of a given property for all Shaders, where the property is an integer. */
    SetGlobalInteger(nameID: number, value: number): void;
    /** Adds a command to set the value of a given property for all Shaders, where the property is an integer. */
    SetGlobalInteger(name: string, value: number): void;
    /** Add a &quot;set global shader matrix property&quot; command. */
    SetGlobalMatrix(nameID: number, value: Matrix4x4): void;
    /** Add a &quot;set global shader matrix property&quot; command. */
    SetGlobalMatrix(name: string, value: Matrix4x4): void;
    /** Add a &quot;set global shader matrix array property&quot; command. */
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(propertyName: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Add a &quot;set global shader matrix array property&quot; command. */
    SetGlobalMatrixArray(propertyName: string, values: CSArray<Matrix4x4>): void;
    /** Adds a command to bind the RayTracingAccelerationStructure object to all shader stages. */
    SetGlobalRayTracingAccelerationStructure(name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    /** Adds a command to bind the RayTracingAccelerationStructure object to all shader stages. */
    SetGlobalRayTracingAccelerationStructure(nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    /** Add a &quot;set global shader texture property&quot; command, referencing a RenderTexture. */
    SetGlobalTexture(name: string, value: RenderTargetIdentifier): void;
    /** Add a &quot;set global shader texture property&quot; command, referencing a RenderTexture. */
    SetGlobalTexture(nameID: number, value: RenderTargetIdentifier): void;
    /** Add a &quot;set global shader texture property&quot; command, referencing a RenderTexture. */
    SetGlobalTexture(name: string, value: RenderTargetIdentifier, element: RenderTextureSubElement): void;
    /** Add a &quot;set global shader texture property&quot; command, referencing a RenderTexture. */
    SetGlobalTexture(nameID: number, value: RenderTargetIdentifier, element: RenderTextureSubElement): void;
    /** Add a &quot;set global shader vector property&quot; command. */
    SetGlobalVector(nameID: number, value: Vector4): void;
    /** Add a &quot;set global shader vector property&quot; command. */
    SetGlobalVector(name: string, value: Vector4): void;
    /** Add a &quot;set global shader vector array property&quot; command. */
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(propertyName: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    /** Add a &quot;set global shader vector array property&quot; command. */
    SetGlobalVectorArray(propertyName: string, values: CSArray<Vector4>): void;
    /** Adds a command to multiply the instance count of every draw call by a specific multiplier. */
    SetInstanceMultiplier(multiplier: number): void;
    /** Add a &quot;set invert culling&quot; command to the buffer. */
    SetInvertCulling(invertCulling: boolean): void;
    /** Adds a command to set the state of a global or local shader keyword. */
    SetKeyword(keyword: unknown, value: boolean): void;
    /** Adds a command to set the state of a global or local shader keyword. */
    SetKeyword(material: Material, keyword: unknown, value: boolean): void;
    /** Adds a command to set the state of a global or local shader keyword. */
    SetKeyword(computeShader: ComputeShader, keyword: unknown, value: boolean): void;
    /** Set the current stereo projection matrices for late latching. Stereo matrices is passed in as an array of two matrices. */
    SetLateLatchProjectionMatrices(projectionMat: CSArray<Matrix4x4>): void;
    /** Add a command to set the projection matrix. */
    SetProjectionMatrix(proj: Matrix4x4): void;
    /** Set random write target for level pixel shaders. */
    SetRandomWriteTarget(index: number, rt: RenderTargetIdentifier): void;
    /** Set random write target for level pixel shaders. */
    SetRandomWriteTarget(index: number, buffer: ComputeBuffer, preserveCounterValue: boolean): void;
    /** Set random write target for level pixel shaders. */
    SetRandomWriteTarget(index: number, buffer: ComputeBuffer): void;
    /** Set random write target for level pixel shaders. */
    SetRandomWriteTarget(index: number, buffer: GraphicsBuffer, preserveCounterValue: boolean): void;
    /** Set random write target for level pixel shaders. */
    SetRandomWriteTarget(index: number, buffer: GraphicsBuffer): void;
    /** Adds a command to set the RayTracingAccelerationStructure to be used in a RayTracingShader or a ComputeShader. */
    SetRayTracingAccelerationStructure(rayTracingShader: RayTracingShader, name: string, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    /** Adds a command to set the RayTracingAccelerationStructure to be used in a RayTracingShader or a ComputeShader. */
    SetRayTracingAccelerationStructure(rayTracingShader: RayTracingShader, nameID: number, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    /** Adds a command to set the RayTracingAccelerationStructure to be used in a RayTracingShader or a ComputeShader. */
    SetRayTracingAccelerationStructure(computeShader: ComputeShader, kernelIndex: number, name: string, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    /** Adds a command to set the RayTracingAccelerationStructure to be used in a RayTracingShader or a ComputeShader. */
    SetRayTracingAccelerationStructure(computeShader: ComputeShader, kernelIndex: number, nameID: number, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    /** Adds a command to set an input or output buffer parameter on a RayTracingShader. */
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: ComputeBuffer): void;
    /** Adds a command to set an input or output buffer parameter on a RayTracingShader. */
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: ComputeBuffer): void;
    /** Adds a command to set an input or output buffer parameter on a RayTracingShader. */
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: GraphicsBuffer): void;
    /** Adds a command to set an input or output buffer parameter on a RayTracingShader. */
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: GraphicsBuffer): void;
    /** Adds a command to set an input or output buffer parameter on a RayTracingShader. */
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, bufferHandle: GraphicsBufferHandle): void;
    /** Adds a command to set an input or output buffer parameter on a RayTracingShader. */
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, bufferHandle: GraphicsBufferHandle): void;
    /** Adds a command to set a constant buffer on a RayTracingShader. */
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    /** Adds a command to set a constant buffer on a RayTracingShader. */
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    /** Adds a command to set a constant buffer on a RayTracingShader. */
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    /** Adds a command to set a constant buffer on a RayTracingShader. */
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    /** Adds a command to set a float parameter on a RayTracingShader. */
    SetRayTracingFloatParam(rayTracingShader: RayTracingShader, name: string, val: number): void;
    /** Adds a command to set a float parameter on a RayTracingShader. */
    SetRayTracingFloatParam(rayTracingShader: RayTracingShader, nameID: number, val: number): void;
    /** Adds a command to set multiple consecutive float parameters on a RayTracingShader. */
    SetRayTracingFloatParams(rayTracingShader: RayTracingShader, name: string, values: CSArray<number>): void;
    /** Adds a command to set multiple consecutive float parameters on a RayTracingShader. */
    SetRayTracingFloatParams(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<number>): void;
    /** Adds a command to set an integer parameter on a RayTracingShader. */
    SetRayTracingIntParam(rayTracingShader: RayTracingShader, name: string, val: number): void;
    /** Adds a command to set an integer parameter on a RayTracingShader. */
    SetRayTracingIntParam(rayTracingShader: RayTracingShader, nameID: number, val: number): void;
    /** Adds a command to set multiple consecutive integer parameters on a RayTracingShader. */
    SetRayTracingIntParams(rayTracingShader: RayTracingShader, name: string, values: CSArray<number>): void;
    /** Adds a command to set multiple consecutive integer parameters on a RayTracingShader. */
    SetRayTracingIntParams(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<number>): void;
    /** Adds a command to set a matrix array parameter on a RayTracingShader. */
    SetRayTracingMatrixArrayParam(rayTracingShader: RayTracingShader, name: string, values: CSArray<Matrix4x4>): void;
    /** Adds a command to set a matrix array parameter on a RayTracingShader. */
    SetRayTracingMatrixArrayParam(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<Matrix4x4>): void;
    /** Adds a command to set a matrix parameter on a RayTracingShader. */
    SetRayTracingMatrixParam(rayTracingShader: RayTracingShader, name: string, val: Matrix4x4): void;
    /** Adds a command to set a matrix parameter on a RayTracingShader. */
    SetRayTracingMatrixParam(rayTracingShader: RayTracingShader, nameID: number, val: Matrix4x4): void;
    /** Adds a command to select which Shader Pass to use when executing ray/geometry intersection shaders. */
    SetRayTracingShaderPass(rayTracingShader: RayTracingShader, passName: string): void;
    /** Adds a command to set a texture parameter on a RayTracingShader. */
    SetRayTracingTextureParam(rayTracingShader: RayTracingShader, name: string, rt: RenderTargetIdentifier): void;
    /** Adds a command to set a texture parameter on a RayTracingShader. */
    SetRayTracingTextureParam(rayTracingShader: RayTracingShader, nameID: number, rt: RenderTargetIdentifier): void;
    /** Adds a command to set a vector array parameter on a RayTracingShader. */
    SetRayTracingVectorArrayParam(rayTracingShader: RayTracingShader, name: string, values: CSArray<Vector4>): void;
    /** Adds a command to set a vector array parameter on a RayTracingShader. */
    SetRayTracingVectorArrayParam(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<Vector4>): void;
    /** Adds a command to set a vector parameter on a RayTracingShader. */
    SetRayTracingVectorParam(rayTracingShader: RayTracingShader, name: string, val: Vector4): void;
    /** Adds a command to set a vector parameter on a RayTracingShader. */
    SetRayTracingVectorParam(rayTracingShader: RayTracingShader, nameID: number, val: Vector4): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(rt: RenderTargetIdentifier): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(rt: RenderTargetIdentifier, loadAction: RenderBufferLoadAction, storeAction: RenderBufferStoreAction): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(rt: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(color: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depth: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(colors: CSArray<RenderTargetIdentifier>, depth: RenderTargetIdentifier): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(colors: CSArray<RenderTargetIdentifier>, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(binding: RenderTargetBinding, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    /** Add a &quot;set active render target&quot; command. */
    SetRenderTarget(binding: RenderTargetBinding): void;
    /** Add a &quot;set shadow sampling mode&quot; command. */
    SetShadowSamplingMode(shadowmap: RenderTargetIdentifier, mode: ShadowSamplingMode): void;
    SetSinglePassStereo(mode: SinglePassStereoMode): void;
    /** Schedules the setup of Camera specific global Shader variables. */
    SetupCameraProperties(camera: Camera): void;
    /** Add a command to set the view matrix. */
    SetViewMatrix(view: Matrix4x4): void;
    /** Add a command to set the rendering viewport. */
    SetViewport(pixelRect: Rect): void;
    /** Add a command to set the view and projection matrices. */
    SetViewProjectionMatrices(view: Matrix4x4, proj: Matrix4x4): void;
    /** Add a &quot;set wireframe&quot; command to the buffer. */
    SetWireframe(enable: boolean): void;
    /** Unmark a global shader property for late latching. After unmarking, the shader property will no longer be late latched.  This function is intended for the Universal Render Pipeline (URP) to specify late latched shader properties. */
    UnmarkLateLatchMatrix(matrixPropertyType: CameraLateLatchMatrixType): void;
    /** Adds an &quot;AsyncGPUReadback.WaitAllRequests&quot; command to the CommandBuffer. */
    WaitAllAsyncReadbackRequests(): void;
    /** Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence. */
    WaitOnAsyncGraphicsFence(fence: GraphicsFence): void;
    /** Instructs the GPU to pause processing of the queue until it passes through the GraphicsFence fence. */
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStage): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStageFlags): void;
    /** This functionality is deprecated, and should no longer be used. Please use CommandBuffer.WaitOnAsyncGraphicsFence. */
    WaitOnGPUFence(fence: GPUFence, stage: SynchronisationStage): void;
    WaitOnGPUFence(fence: GPUFence): void;

}
    
interface AttachmentDescriptor {
    loadAction: RenderBufferLoadAction;
    storeAction: RenderBufferStoreAction;
    graphicsFormat: GraphicsFormat;
    format: RenderTextureFormat;
    loadStoreTarget: RenderTargetIdentifier;
    resolveTarget: RenderTargetIdentifier;
    clearColor: Color;
    clearDepth: number;
    clearStencil: number;


    /** When the RenderPass starts, clear this attachment into the color or depth/stencil values given (depending on the format of this attachment). Changes loadAction to RenderBufferLoadAction.Clear. */
    ConfigureClear(clearColor: Color, clearDepth: number, clearStencil: number): void;
    /** When the renderpass that uses this attachment ends, resolve the MSAA surface into the given target. */
    ConfigureResolveTarget(target: RenderTargetIdentifier): void;
    /** Binds this AttachmentDescriptor to the given target surface. */
    ConfigureTarget(target: RenderTargetIdentifier, loadExistingContents: boolean, storeResults: boolean): void;
    Equals(other: AttachmentDescriptor): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;

}
    
interface RenderTargetIdentifier {


    Equals(rhs: RenderTargetIdentifier): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface RenderTargetIdentifierConstructor {
    AllDepthSlices: number;

    new(type: BuiltinRenderTextureType): RenderTargetIdentifier;
    new(type: BuiltinRenderTextureType, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(name: string): RenderTargetIdentifier;
    new(name: string, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(nameID: number): RenderTargetIdentifier;
    new(nameID: number, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(renderTargetIdentifier: RenderTargetIdentifier, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(tex: Texture): RenderTargetIdentifier;
    new(tex: Texture, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(buf: RenderBuffer, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;


}
declare const RenderTargetIdentifier: RenderTargetIdentifierConstructor;
    
interface AttachmentDescriptorConstructor {

    new(format: GraphicsFormat): AttachmentDescriptor;
    new(format: RenderTextureFormat): AttachmentDescriptor;
    new(format: RenderTextureFormat, target: RenderTargetIdentifier, loadExistingContents: boolean, storeResults: boolean, resolve: boolean): AttachmentDescriptor;


}
declare const AttachmentDescriptor: AttachmentDescriptorConstructor;
    
interface SubPassDescriptor {
    inputs: AttachmentIndexArray;
    colorOutputs: AttachmentIndexArray;
    flags: SubPassFlags;



}
    
interface AttachmentIndexArray {
    Item: number;
    Length: number;



}
    
interface AttachmentIndexArrayConstructor {
    Emtpy: AttachmentIndexArray;
    MaxAttachments: number;

    new(numAttachments: number): AttachmentIndexArray;
    new(attachments: CSArray<number>): AttachmentIndexArray;
    new(attachments: CSArray<number>): AttachmentIndexArray;


}
declare const AttachmentIndexArray: AttachmentIndexArrayConstructor;
    
interface Sampler {
    isValid: boolean;
    name: string;


    /** Returns Recorder associated with the Sampler. */
    GetRecorder(): Recorder;

}
    
interface Recorder {
    isValid: boolean;
    enabled: boolean;
    elapsedNanoseconds: number;
    gpuElapsedNanoseconds: number;
    sampleBlockCount: number;
    gpuSampleBlockCount: number;


    /** Configures the recorder to collect samples from all threads. */
    CollectFromAllThreads(): void;
    /** Configures the recorder to only collect data from the current thread. */
    FilterToCurrentThread(): void;

}
    
interface RecorderConstructor {



    Get(samplerName: string): Recorder;
}
declare const Recorder: RecorderConstructor;
    
interface SamplerConstructor {



    Get(name: string): Sampler;
    GetNames(names: CSArray<string>): number;
}
declare const Sampler: SamplerConstructor;
    
interface CustomSampler extends Sampler {


    /** Begin profiling a piece of code with a custom label defined by this instance of CustomSampler. */
    Begin(): void;
    /** Begin profiling a piece of code with a custom label defined by this instance of CustomSampler. */
    Begin(targetObject: Object): void;
    /** End profiling a piece of code with a custom label. */
    End(): void;

}
    
interface CustomSamplerConstructor {



    Create(name: string, collectGpuData: boolean): CustomSampler;
}
declare const CustomSampler: CustomSamplerConstructor;
    
interface ProfilerMarker {
    Handle: unknown;


    /** Creates a helper struct for the scoped using blocks. */
    Auto(): AutoScope;
    /** Begin profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker. */
    Begin(): void;
    /** Begin profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker. */
    Begin(contextUnityObject: Object): void;
    /** End profiling a piece of code marked with a custom name defined by this instance of ProfilerMarker. */
    End(): void;

}
    
interface AutoScope {


    Dispose(): void;

}
    
interface ProfilerMarkerConstructor {

    new(name: string): ProfilerMarker;
    new(name: unknown, nameLen: number): ProfilerMarker;
    new(category: ProfilerCategory, name: string): ProfilerMarker;
    new(category: ProfilerCategory, name: unknown, nameLen: number): ProfilerMarker;
    new(category: ProfilerCategory, name: string, flags: MarkerFlags): ProfilerMarker;
    new(category: ProfilerCategory, name: unknown, nameLen: number, flags: MarkerFlags): ProfilerMarker;


}
declare const ProfilerMarker: ProfilerMarkerConstructor;
    
interface Material extends Object {
    shader: Shader;
    color: Color;
    mainTexture: Texture;
    mainTextureOffset: Vector2;
    mainTextureScale: Vector2;
    renderQueue: number;
    enabledKeywords: CSArray<LocalKeyword>;
    globalIlluminationFlags: MaterialGlobalIlluminationFlags;
    doubleSidedGI: boolean;
    enableInstancing: boolean;
    passCount: number;
    shaderKeywords: CSArray<string>;
    parent: Material;
    isVariant: boolean;


    /** Applies an override associated with a Material Variant to a target. */
    ApplyPropertyOverride(destination: Material, nameID: number, recordUndo: boolean): void;
    /** Applies an override associated with a Material Variant to a target. */
    ApplyPropertyOverride(destination: Material, name: string, recordUndo: boolean): void;
    /** Computes a CRC hash value from the content of the material. */
    ComputeCRC(): number;
    /** Copies properties, keyword states and settings from mat to this material, but only if they exist in both materials. */
    CopyMatchingPropertiesFromMaterial(mat: Material): void;
    /** Copy properties from other material into this material. */
    CopyPropertiesFromMaterial(mat: Material): void;
    /** Disables a local shader keyword for this material. */
    DisableKeyword(keyword: string): void;
    /** Disables a local shader keyword for this material. */
    DisableKeyword(keyword: unknown): void;
    /** Enables a local shader keyword for this material. */
    EnableKeyword(keyword: string): void;
    /** Enables a local shader keyword for this material. */
    EnableKeyword(keyword: unknown): void;
    /** Returns the index of the pass passName. */
    FindPass(passName: string): number;
    /** Get a named Graphics Buffer value. */
    GetBuffer(name: string): GraphicsBufferHandle;
    /** Get a named color value. */
    GetColor(name: string): Color;
    /** Get a named color value. */
    GetColor(nameID: number): Color;
    /** Get a named color array. */
    GetColorArray(name: string): CSArray<Color>;
    /** Get a named color array. */
    GetColorArray(nameID: number): CSArray<Color>;
    GetColorArray(name: string, values: CSArray<Color>): void;
    GetColorArray(nameID: number, values: CSArray<Color>): void;
    /** Get a named Constant Buffer value. */
    GetConstantBuffer(name: string): GraphicsBufferHandle;
    /** Get a named float value. */
    GetFloat(name: string): number;
    /** Get a named float value. */
    GetFloat(nameID: number): number;
    /** Get a named float array. */
    GetFloatArray(name: string): CSArray<number>;
    /** Get a named float array. */
    GetFloatArray(nameID: number): CSArray<number>;
    GetFloatArray(name: string, values: CSArray<number>): void;
    GetFloatArray(nameID: number, values: CSArray<number>): void;
    /** This method is deprecated. Use GetFloat or GetInteger instead. */
    GetInt(name: string): number;
    /** This method is deprecated. Use GetFloat or GetInteger instead. */
    GetInt(nameID: number): number;
    /** Get a named integer value. */
    GetInteger(name: string): number;
    /** Get a named integer value. */
    GetInteger(nameID: number): number;
    /** Get a named matrix value from the shader. */
    GetMatrix(name: string): Matrix4x4;
    /** Get a named matrix value from the shader. */
    GetMatrix(nameID: number): Matrix4x4;
    /** Get a named matrix array. */
    GetMatrixArray(name: string): CSArray<Matrix4x4>;
    /** Get a named matrix array. */
    GetMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Returns the name of the shader pass at index pass. */
    GetPassName(pass: number): string;
    /** Retrieves a list of the named properties in the material that match the input property type. */
    GetPropertyNames(type: MaterialPropertyType): CSArray<string>;
    /** Checks whether a given Shader pass is enabled on this Material. */
    GetShaderPassEnabled(passName: string): boolean;
    /** Get the value of material&#x27;s shader tag. */
    GetTag(tag: string, searchFallbacks: boolean, defaultValue: string): string;
    /** Get the value of material&#x27;s shader tag. */
    GetTag(tag: string, searchFallbacks: boolean): string;
    /** Get a named texture. */
    GetTexture(name: string): Texture;
    /** Get a named texture. */
    GetTexture(nameID: number): Texture;
    /** Gets the placement offset of texture propertyName. */
    GetTextureOffset(name: string): Vector2;
    /** Gets the placement offset of texture propertyName. */
    GetTextureOffset(nameID: number): Vector2;
    /** Return the name IDs of all texture properties exposed on this material. */
    GetTexturePropertyNameIDs(): CSArray<number>;
    GetTexturePropertyNameIDs(outNames: CSArray<number>): void;
    /** Returns the names of all texture properties exposed on this material. */
    GetTexturePropertyNames(): CSArray<string>;
    GetTexturePropertyNames(outNames: CSArray<string>): void;
    /** Gets the placement scale of texture propertyName. */
    GetTextureScale(name: string): Vector2;
    /** Gets the placement scale of texture propertyName. */
    GetTextureScale(nameID: number): Vector2;
    /** Get a named vector value. */
    GetVector(name: string): Vector4;
    /** Get a named vector value. */
    GetVector(nameID: number): Vector4;
    /** Get a named vector array. */
    GetVectorArray(name: string): CSArray<Vector4>;
    /** Get a named vector array. */
    GetVectorArray(nameID: number): CSArray<Vector4>;
    GetVectorArray(name: string, values: CSArray<Vector4>): void;
    GetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    /** Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name. */
    HasBuffer(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name. */
    HasBuffer(nameID: number): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Color property with the given name. */
    HasColor(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Color property with the given name. */
    HasColor(nameID: number): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name. */
    HasConstantBuffer(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name. */
    HasConstantBuffer(nameID: number): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property. */
    HasFloat(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property. */
    HasFloat(nameID: number): boolean;
    /** This method is deprecated. Use HasFloat or HasInteger instead. */
    HasInt(name: string): boolean;
    /** This method is deprecated. Use HasFloat or HasInteger instead. */
    HasInt(nameID: number): boolean;
    /** Checks if the ShaderLab file assigned to the Material has an Integer property with the given name. */
    HasInteger(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has an Integer property with the given name. */
    HasInteger(nameID: number): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property. */
    HasMatrix(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property. */
    HasMatrix(nameID: number): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a property with the given name. */
    HasProperty(nameID: number): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a property with the given name. */
    HasProperty(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Texture property with the given name. */
    HasTexture(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Texture property with the given name. */
    HasTexture(nameID: number): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property. */
    HasVector(name: string): boolean;
    /** Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property. */
    HasVector(nameID: number): boolean;
    /** Returns True if the given material is an ancestor of this Material. */
    IsChildOf(ancestor: Material): boolean;
    /** Checks whether a local shader keyword is enabled for this material. */
    IsKeywordEnabled(keyword: string): boolean;
    /** Checks whether a local shader keyword is enabled for this material. */
    IsKeywordEnabled(keyword: unknown): boolean;
    /** Checks whether a property is locked by this material. */
    IsPropertyLocked(nameID: number): boolean;
    /** Checks whether a property is locked by this material. */
    IsPropertyLocked(name: string): boolean;
    /** Checks whether a property is locked by any of ancestor of this material. */
    IsPropertyLockedByAncestor(nameID: number): boolean;
    /** Checks whether a property is locked by any of ancestor of this material. */
    IsPropertyLockedByAncestor(name: string): boolean;
    /** Checks whether a property is overriden by this material. */
    IsPropertyOverriden(nameID: number): boolean;
    /** Checks whether a property is overriden by this material. */
    IsPropertyOverriden(name: string): boolean;
    /** Interpolate properties between two materials. */
    Lerp(start: Material, end: Material, t: number): void;
    /** Removes all property overrides on this material. */
    RevertAllPropertyOverrides(): void;
    /** Removes the override on a property. */
    RevertPropertyOverride(nameID: number): void;
    /** Removes the override on a property. */
    RevertPropertyOverride(name: string): void;
    /** Sets a named buffer value. */
    SetBuffer(name: string, value: ComputeBuffer): void;
    /** Sets a named buffer value. */
    SetBuffer(nameID: number, value: ComputeBuffer): void;
    /** Sets a named buffer value. */
    SetBuffer(name: string, value: GraphicsBuffer): void;
    /** Sets a named buffer value. */
    SetBuffer(nameID: number, value: GraphicsBuffer): void;
    /** Sets a color value. */
    SetColor(name: string, value: Color): void;
    /** Sets a color value. */
    SetColor(nameID: number, value: Color): void;
    SetColorArray(name: string, values: CSArray<Color>): void;
    SetColorArray(nameID: number, values: CSArray<Color>): void;
    /** Sets a color array property. */
    SetColorArray(name: string, values: CSArray<Color>): void;
    /** Sets a color array property. */
    SetColorArray(nameID: number, values: CSArray<Color>): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material. */
    SetConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material. */
    SetConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material. */
    SetConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material. */
    SetConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    /** Sets a named float value. */
    SetFloat(name: string, value: number): void;
    /** Sets a named float value. */
    SetFloat(nameID: number, value: number): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    /** Sets a float array property. */
    SetFloatArray(name: string, values: CSArray<number>): void;
    /** Sets a float array property. */
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    /** This method is deprecated. Use SetFloat or SetInteger instead. */
    SetInt(name: string, value: number): void;
    /** This method is deprecated. Use SetFloat or SetInteger instead. */
    SetInt(nameID: number, value: number): void;
    /** Sets a named integer value. */
    SetInteger(name: string, value: number): void;
    /** Sets a named integer value. */
    SetInteger(nameID: number, value: number): void;
    /** Sets the state of a local shader keyword for this material. */
    SetKeyword(keyword: unknown, value: boolean): void;
    /** Sets a named matrix for the shader. */
    SetMatrix(name: string, value: Matrix4x4): void;
    /** Sets a named matrix for the shader. */
    SetMatrix(nameID: number, value: Matrix4x4): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Sets a matrix array property. */
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    /** Sets a matrix array property. */
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Sets an override tag/value on the material. */
    SetOverrideTag(tag: string, val: string): void;
    /** Activate the given pass for rendering. */
    SetPass(pass: number): boolean;
    /** Sets the lock state of a property for this material. */
    SetPropertyLock(nameID: number, value: boolean): void;
    /** Sets the lock state of a property for this material. */
    SetPropertyLock(name: string, value: boolean): void;
    /** Enables or disables a Shader pass on a per-Material level. */
    SetShaderPassEnabled(passName: string, enabled: boolean): void;
    /** Sets a named texture. */
    SetTexture(name: string, value: Texture): void;
    /** Sets a named texture. */
    SetTexture(nameID: number, value: Texture): void;
    /** Sets a named texture. */
    SetTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    /** Sets a named texture. */
    SetTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    /** Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance. */
    SetTextureOffset(name: string, value: Vector2): void;
    /** Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance. */
    SetTextureOffset(nameID: number, value: Vector2): void;
    /** Sets the placement scale of texture propertyName. */
    SetTextureScale(name: string, value: Vector2): void;
    /** Sets the placement scale of texture propertyName. */
    SetTextureScale(nameID: number, value: Vector2): void;
    /** Sets a named vector value. */
    SetVector(name: string, value: Vector4): void;
    /** Sets a named vector value. */
    SetVector(nameID: number, value: Vector4): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    /** Sets a vector array property. */
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    /** Sets a vector array property. */
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;

}
    
interface Shader extends Object {
    maximumLOD: number;
    isSupported: boolean;
    keywordSpace: LocalKeywordSpace;
    renderQueue: number;
    passCount: number;
    subshaderCount: number;


    /** Searches for the tag specified by tagName on the shader&#x27;s active SubShader and returns the value of the tag. */
    FindPassTagValue(passIndex: number, tagName: ShaderTagId): ShaderTagId;
    /** Searches for the tag specified by tagName on the SubShader specified by subshaderIndex and returns the value of the tag. */
    FindPassTagValue(subshaderIndex: number, passIndex: number, tagName: ShaderTagId): ShaderTagId;
    /** Finds the index of a shader property by its name. */
    FindPropertyIndex(propertyName: string): number;
    /** Searches for the tag specified by tagName on the SubShader specified by subshaderIndex and returns the value of the tag. */
    FindSubshaderTagValue(subshaderIndex: number, tagName: ShaderTagId): ShaderTagId;
    /** Find the name of a texture stack a texture belongs too. */
    FindTextureStack(propertyIndex: number, stackName: CSArray<string>, layerIndex: unknown): boolean;
    /** Returns the dependency shader. */
    GetDependency(name: string): Shader;
    /** Returns the number of passes in the given SubShader. */
    GetPassCountInSubshader(subshaderIndex: number): number;
    /** Returns an array of strings containing attributes of the shader property at the specified index. */
    GetPropertyAttributes(propertyIndex: number): CSArray<string>;
    /** Returns the number of properties in this Shader. */
    GetPropertyCount(): number;
    /** Returns the default float value of the shader property at the specified index. */
    GetPropertyDefaultFloatValue(propertyIndex: number): number;
    /** Returns the default int value of the shader property at the specified index. */
    GetPropertyDefaultIntValue(propertyIndex: number): number;
    /** Returns the default Vector4 value of the shader property at the specified index. */
    GetPropertyDefaultVectorValue(propertyIndex: number): Vector4;
    /** Returns the description string of the shader property at the specified index. */
    GetPropertyDescription(propertyIndex: number): string;
    /** Returns the ShaderPropertyFlags of the shader property at the specified index. */
    GetPropertyFlags(propertyIndex: number): ShaderPropertyFlags;
    /** Returns the name of the shader property at the specified index. */
    GetPropertyName(propertyIndex: number): string;
    /** Returns the nameId of the shader property at the specified index. */
    GetPropertyNameId(propertyIndex: number): number;
    /** Returns the min and max limits for a &amp;lt;a href&#x3D;&quot;Rendering.ShaderPropertyType.Range.html&quot;&amp;gt;Range&amp;lt;/a&amp;gt; property at the specified index. */
    GetPropertyRangeLimits(propertyIndex: number): Vector2;
    /** Returns the default Texture name of a &amp;lt;a href&#x3D;&quot;Rendering.ShaderPropertyType.Texture.html&quot;&amp;gt;Texture&amp;lt;/a&amp;gt; shader property at the specified index. */
    GetPropertyTextureDefaultName(propertyIndex: number): string;
    /** Returns the TextureDimension of a &amp;lt;a href&#x3D;&quot;Rendering.ShaderPropertyType.Texture.html&quot;&amp;gt;Texture&amp;lt;/a&amp;gt; shader property at the specified index. */
    GetPropertyTextureDimension(propertyIndex: number): TextureDimension;
    /** Returns the ShaderPropertyType of the property at the specified index. */
    GetPropertyType(propertyIndex: number): ShaderPropertyType;

}
    
interface LocalKeywordSpace {
    keywords: CSArray<LocalKeyword>;
    keywordNames: CSArray<string>;
    keywordCount: number;


    Equals(o: unknown): boolean;
    Equals(rhs: LocalKeywordSpace): boolean;
    /** Searches for a local shader keyword with a given name in the keyword space. */
    FindKeyword(name: string): LocalKeyword;
    GetHashCode(): number;

}
    
interface LocalKeyword {
    name: string;
    isDynamic: boolean;
    isOverridable: boolean;
    isValid: boolean;
    type: ShaderKeywordType;


    Equals(o: unknown): boolean;
    Equals(rhs: LocalKeyword): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface LocalKeywordConstructor {

    new(shader: Shader, name: string): LocalKeyword;
    new(shader: ComputeShader, name: string): LocalKeyword;


}
declare const LocalKeyword: LocalKeywordConstructor;
    
interface ShaderTagId {
    name: string;


    Equals(obj: unknown): boolean;
    Equals(other: ShaderTagId): boolean;
    GetHashCode(): number;

}
    
interface ShaderTagIdConstructor {
    none: ShaderTagId;

    new(name: string): ShaderTagId;


}
declare const ShaderTagId: ShaderTagIdConstructor;
    
interface GlobalKeyword {
    name: string;


    ToString(): string;

}
    
interface GlobalKeywordConstructor {

    new(name: string): GlobalKeyword;


    Create(name: string): GlobalKeyword;
}
declare const GlobalKeyword: GlobalKeywordConstructor;
    
interface RayTracingAccelerationStructure {


    /** Adds a ray tracing instance to the RayTracingAccelerationStructure. */
    AddInstance(targetRenderer: Renderer, subMeshFlags: CSArray<number>, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, id: number): number;
    /** Adds a ray tracing instance associated with a list of axis-aligned bounding boxes (AABBs) to the RayTracingAccelerationStructure for procedural geometry generation using intersection shaders. */
    AddInstance(config: RayTracingAABBsInstanceConfig, matrix: Matrix4x4, id: number): number;
    AddInstance(config: unknown, matrix: Matrix4x4, prevMatrix: unknown, id: number): number;
    AddInstance(config: unknown, matrix: Matrix4x4, prevMatrix: unknown, id: number): number;
    /** Deprecated. Please use the alternate method for adding Renderers to the acceleration structure. */
    AddInstance(targetRenderer: Renderer, subMeshMask: CSArray<boolean>, subMeshTransparencyFlags: CSArray<boolean>, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, id: number): void;
    /** Deprecated. Please use the alternate method for adding procedural geometry (AABBs) to the acceleration structure. */
    AddInstance(aabbBuffer: GraphicsBuffer, numElements: number, material: Material, isCutOff: boolean, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, reuseBounds: boolean, id: number): void;
    /** Deprecated. Please use the alternate method for adding procedural geometry (AABBs) to the acceleration structure. */
    AddInstance(aabbBuffer: GraphicsBuffer, aabbCount: number, dynamicData: boolean, matrix: Matrix4x4, material: Material, opaqueMaterial: boolean, properties: MaterialPropertyBlock, mask: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, id: number): number;
    /** Adds the ray tracing instances associated with a VFXRenderer to the RayTracingAccelerationStructure. */
    AddVFXInstances(targetRenderer: Renderer, vfxSystemMasks: CSArray<number>): void;
    /** Builds acceleration structures on the GPU. Allocates any GPU memory required for storing acceleration structure data. */
    Build(): void;
    /** Builds acceleration structures on the GPU. Allocates any GPU memory required for storing acceleration structure data. */
    Build(relativeOrigin: Vector3): void;
    Build(buildSettings: BuildSettings): void;
    /** Removes all ray tracing instances from the RayTracingAccelerationStructure. */
    ClearInstances(): void;
    /** Populates the RayTracingAccelerationStructure with ray tracing instances that Unity associates with Renderers in the Scene by using filtering and culling parameters. */
    CullInstances(cullingConfig: unknown): RayTracingInstanceCullingResults;
    /** Destroys this RayTracingAccelerationStructure and frees the GPU memory used for storing acceleration structure data. */
    Dispose(): void;
    /** Returns the number of ray tracing instances in the RayTracingAccelerationStructure. */
    GetInstanceCount(): number;
    /** Returns the total size of this RayTracingAccelerationStructure in GPU memory in bytes. */
    GetSize(): number;
    /** Destroys this RayTracingAccelerationStructure and frees the GPU memory used for storing acceleration structure data. */
    Release(): void;
    /** Removes a ray tracing instance associated with a Renderer from this RayTracingAccelerationStructure. */
    RemoveInstance(targetRenderer: Renderer): void;
    /** Removes a ray tracing instance associated with an axis-aligned bounding box (AABBs) GraphicsBuffer or a Mesh instance from this RayTracingAccelerationStructure. */
    RemoveInstance(handle: number): void;
    /** Remove the ray tracing instances associated with a VFXRenderer from the RayTracingAccelerationStructure. */
    RemoveVFXInstances(targetRenderer: Renderer): void;
    /** Updates the transforms of all instances in this RayTracingAccelerationStructure. */
    Update(): void;
    /** Updates the transforms of all instances in this RayTracingAccelerationStructure. */
    Update(relativeOrigin: Vector3): void;
    /** Updates the instance ID of a ray tracing instance. */
    UpdateInstanceID(renderer: Renderer, instanceID: number): void;
    /** Updates the instance ID of a ray tracing instance. */
    UpdateInstanceID(handle: number, instanceID: number): void;
    /** Updates the instance mask of a ray tracing instance. */
    UpdateInstanceMask(renderer: Renderer, mask: number): void;
    /** Updates the instance mask of a ray tracing instance. */
    UpdateInstanceMask(handle: number, mask: number): void;
    /** Updates per ray tracing instance Material properties. */
    UpdateInstancePropertyBlock(handle: number, properties: MaterialPropertyBlock): void;
    /** Updates the transformation of a ray tracing instance. */
    UpdateInstanceTransform(renderer: Renderer): void;
    /** Updates the transformation of a ray tracing instance. */
    UpdateInstanceTransform(handle: number, matrix: Matrix4x4): void;

}
    
interface Renderer extends Component {
    lightmapTilingOffset: Vector4;
    lightProbeAnchor: Transform;
    castShadows: boolean;
    motionVectors: boolean;
    useLightProbes: boolean;
    bounds: Bounds;
    localBounds: Bounds;
    enabled: boolean;
    isVisible: boolean;
    shadowCastingMode: ShadowCastingMode;
    receiveShadows: boolean;
    forceRenderingOff: boolean;
    staticShadowCaster: boolean;
    motionVectorGenerationMode: MotionVectorGenerationMode;
    lightProbeUsage: LightProbeUsage;
    reflectionProbeUsage: ReflectionProbeUsage;
    renderingLayerMask: number;
    rendererPriority: number;
    rayTracingMode: RayTracingMode;
    rayTracingAccelerationStructureBuildFlags: RayTracingAccelerationStructureBuildFlags;
    rayTracingAccelerationStructureBuildFlagsOverride: boolean;
    sortingLayerName: string;
    sortingLayerID: number;
    sortingOrder: number;
    allowOcclusionWhenDynamic: boolean;
    isPartOfStaticBatch: boolean;
    worldToLocalMatrix: Matrix4x4;
    localToWorldMatrix: Matrix4x4;
    lightProbeProxyVolumeOverride: GameObject;
    probeAnchor: Transform;
    lightmapIndex: number;
    realtimeLightmapIndex: number;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;
    materials: CSArray<Material>;
    material: Material;
    sharedMaterial: Material;
    sharedMaterials: CSArray<Material>;


    GetClosestReflectionProbes(result: CSArray<ReflectionProbeBlendInfo>): void;
    GetMaterials(m: CSArray<Material>): void;
    /** Get per-Renderer or per-Material property block. */
    GetPropertyBlock(properties: MaterialPropertyBlock): void;
    /** Get per-Renderer or per-Material property block. */
    GetPropertyBlock(properties: MaterialPropertyBlock, materialIndex: number): void;
    GetSharedMaterials(m: CSArray<Material>): void;
    /** Returns true if the Renderer has a material property block attached via SetPropertyBlock. */
    HasPropertyBlock(): boolean;
    /** Reset custom world space bounds. */
    ResetBounds(): void;
    /** Reset custom local space bounds. */
    ResetLocalBounds(): void;
    SetMaterials(materials: CSArray<Material>): void;
    /** Lets you set or clear per-renderer or per-material parameter overrides. */
    SetPropertyBlock(properties: MaterialPropertyBlock): void;
    /** Lets you set or clear per-renderer or per-material parameter overrides. */
    SetPropertyBlock(properties: MaterialPropertyBlock, materialIndex: number): void;
    SetSharedMaterials(materials: CSArray<Material>): void;

}
    
interface ReflectionProbeBlendInfo {
    probe: ReflectionProbe;
    weight: number;



}
    
interface ReflectionProbe extends Behaviour {
    type: ReflectionProbeType;
    size: Vector3;
    center: Vector3;
    nearClipPlane: number;
    farClipPlane: number;
    intensity: number;
    bounds: Bounds;
    hdr: boolean;
    renderDynamicObjects: boolean;
    shadowDistance: number;
    resolution: number;
    cullingMask: number;
    clearFlags: ReflectionProbeClearFlags;
    backgroundColor: Color;
    blendDistance: number;
    boxProjection: boolean;
    mode: ReflectionProbeMode;
    importance: number;
    refreshMode: ReflectionProbeRefreshMode;
    timeSlicingMode: ReflectionProbeTimeSlicingMode;
    bakedTexture: Texture;
    customBakedTexture: Texture;
    realtimeTexture: RenderTexture;
    texture: Texture;
    textureHDRDecodeValues: Vector4;


    /** Checks if a probe has finished a time-sliced render. */
    IsFinishedRendering(renderId: number): boolean;
    RenderProbe(): number;
    /** Refreshes the probe&#x27;s cubemap. */
    RenderProbe(targetTexture: RenderTexture): number;
    /** Revert all ReflectionProbe parameters to default. */
    Reset(): void;

}
    
interface ReflectionProbeConstructor {
    minBakedCubemapResolution: number;
    maxBakedCubemapResolution: number;
    defaultTextureHDRDecodeValues: Vector4;
    defaultTexture: Texture;

    new(): ReflectionProbe;


    BlendCubemap(src: Texture, dst: Texture, blend: number, target: RenderTexture): boolean;
    UpdateCachedState(): void;
}
declare const ReflectionProbe: ReflectionProbeConstructor;
    
interface MaterialPropertyBlock {
    isEmpty: boolean;


    AddColor(name: string, value: Color): void;
    AddColor(nameID: number, value: Color): void;
    AddFloat(name: string, value: number): void;
    AddFloat(nameID: number, value: number): void;
    AddMatrix(name: string, value: Matrix4x4): void;
    AddMatrix(nameID: number, value: Matrix4x4): void;
    AddTexture(name: string, value: Texture): void;
    AddTexture(nameID: number, value: Texture): void;
    AddVector(name: string, value: Vector4): void;
    AddVector(nameID: number, value: Vector4): void;
    /** Clear material property values. */
    Clear(): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>): void;
    /** This function copies the entire source array into a Vector4 property array named unity_ProbesOcclusion for use with instanced rendering. */
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>, sourceStart: number, destStart: number, count: number): void;
    /** This function copies the source array into a Vector4 property array named unity_ProbesOcclusion with the specified source and destination range for use with instanced rendering. */
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>, sourceStart: number, destStart: number, count: number): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>): void;
    /** This function converts and copies the entire source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC for use with instanced rendering. */
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>, sourceStart: number, destStart: number, count: number): void;
    /** This function converts and copies the source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC with the specified source and destination range for use with instanced rendering. */
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>, sourceStart: number, destStart: number, count: number): void;
    /** Get a color from the property block. */
    GetColor(name: string): Color;
    /** Get a color from the property block. */
    GetColor(nameID: number): Color;
    /** Get a float from the property block. */
    GetFloat(name: string): number;
    /** Get a float from the property block. */
    GetFloat(nameID: number): number;
    /** Get a float array from the property block. */
    GetFloatArray(name: string): CSArray<number>;
    /** Get a float array from the property block. */
    GetFloatArray(nameID: number): CSArray<number>;
    GetFloatArray(name: string, values: CSArray<number>): void;
    GetFloatArray(nameID: number, values: CSArray<number>): void;
    /** This method is deprecated. Use GetFloat or GetInteger instead. */
    GetInt(name: string): number;
    /** This method is deprecated. Use GetFloat or GetInteger instead. */
    GetInt(nameID: number): number;
    /** Get an integer from the property block. */
    GetInteger(name: string): number;
    /** Get an integer from the property block. */
    GetInteger(nameID: number): number;
    /** Get a matrix from the property block. */
    GetMatrix(name: string): Matrix4x4;
    /** Get a matrix from the property block. */
    GetMatrix(nameID: number): Matrix4x4;
    /** Get a matrix array from the property block. */
    GetMatrixArray(name: string): CSArray<Matrix4x4>;
    /** Get a matrix array from the property block. */
    GetMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Get a texture from the property block. */
    GetTexture(name: string): Texture;
    /** Get a texture from the property block. */
    GetTexture(nameID: number): Texture;
    /** Get a vector from the property block. */
    GetVector(name: string): Vector4;
    /** Get a vector from the property block. */
    GetVector(nameID: number): Vector4;
    /** Get a vector array from the property block. */
    GetVectorArray(name: string): CSArray<Vector4>;
    /** Get a vector array from the property block. */
    GetVectorArray(nameID: number): CSArray<Vector4>;
    GetVectorArray(name: string, values: CSArray<Vector4>): void;
    GetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    /** Checks if MaterialPropertyBlock has the ComputeBuffer property with the given name or name ID. To set the property, use SetBuffer. */
    HasBuffer(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the ComputeBuffer property with the given name or name ID. To set the property, use SetBuffer. */
    HasBuffer(nameID: number): boolean;
    /** Checks if MaterialPropertyBlock has the Color property with the given name or name ID. To set the property, use SetColor. */
    HasColor(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the Color property with the given name or name ID. To set the property, use SetColor. */
    HasColor(nameID: number): boolean;
    /** Checks if MaterialPropertyBlock has the ConstantBuffer property with the given name or name ID. To set the property, use SetConstantBuffer. */
    HasConstantBuffer(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the ConstantBuffer property with the given name or name ID. To set the property, use SetConstantBuffer. */
    HasConstantBuffer(nameID: number): boolean;
    /** Checks if MaterialPropertyBlock has the Float property with the given name or name ID. To set the property, use SetFloat. */
    HasFloat(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the Float property with the given name or name ID. To set the property, use SetFloat. */
    HasFloat(nameID: number): boolean;
    /** This method is deprecated. Use HasFloat or HasInteger instead. */
    HasInt(name: string): boolean;
    /** This method is deprecated. Use HasFloat or HasInteger instead. */
    HasInt(nameID: number): boolean;
    /** Checks if MaterialPropertyBlock has the Integer property with the given name or name ID. To set the property, use SetInteger. */
    HasInteger(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the Integer property with the given name or name ID. To set the property, use SetInteger. */
    HasInteger(nameID: number): boolean;
    /** Checks if MaterialPropertyBlock has the Matrix property with the given name or name ID. This also works with the Matrix Array property. To set the property, use SetMatrix. */
    HasMatrix(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the Matrix property with the given name or name ID. This also works with the Matrix Array property. To set the property, use SetMatrix. */
    HasMatrix(nameID: number): boolean;
    /** Checks if MaterialPropertyBlock has the property with the given name or name ID. To set the property, use one of the Set methods for MaterialPropertyBlock. */
    HasProperty(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the property with the given name or name ID. To set the property, use one of the Set methods for MaterialPropertyBlock. */
    HasProperty(nameID: number): boolean;
    /** Checks if MaterialPropertyBlock has the Texture property with the given name or name ID. To set the property, use SetTexture. */
    HasTexture(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the Texture property with the given name or name ID. To set the property, use SetTexture. */
    HasTexture(nameID: number): boolean;
    /** Checks if MaterialPropertyBlock has the Vector property with the given name or name ID. This also works with the Vector Array property. To set the property, use SetVector. */
    HasVector(name: string): boolean;
    /** Checks if MaterialPropertyBlock has the Vector property with the given name or name ID. This also works with the Vector Array property. To set the property, use SetVector. */
    HasVector(nameID: number): boolean;
    /** Set a buffer property. */
    SetBuffer(name: string, value: ComputeBuffer): void;
    /** Set a buffer property. */
    SetBuffer(nameID: number, value: ComputeBuffer): void;
    /** Set a buffer property. */
    SetBuffer(name: string, value: GraphicsBuffer): void;
    /** Set a buffer property. */
    SetBuffer(nameID: number, value: GraphicsBuffer): void;
    /** Set a color property. */
    SetColor(name: string, value: Color): void;
    /** Set a color property. */
    SetColor(nameID: number, value: Color): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock. */
    SetConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock. */
    SetConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock. */
    SetConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the MaterialPropertyBlock. */
    SetConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    /** Set a float property. */
    SetFloat(name: string, value: number): void;
    /** Set a float property. */
    SetFloat(nameID: number, value: number): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    /** Set a float array property. */
    SetFloatArray(name: string, values: CSArray<number>): void;
    /** Set a float array property. */
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    /** This method is deprecated. Use SetFloat or SetInteger instead. */
    SetInt(name: string, value: number): void;
    /** This method is deprecated. Use SetFloat or SetInteger instead. */
    SetInt(nameID: number, value: number): void;
    /** Adds a property to the block. If an integer property with the given name already exists, the old value is replaced. */
    SetInteger(name: string, value: number): void;
    /** Adds a property to the block. If an integer property with the given name already exists, the old value is replaced. */
    SetInteger(nameID: number, value: number): void;
    /** Set a matrix property. */
    SetMatrix(name: string, value: Matrix4x4): void;
    /** Set a matrix property. */
    SetMatrix(nameID: number, value: Matrix4x4): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Set a matrix array property. */
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    /** Set a matrix array property. */
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Set a texture property. */
    SetTexture(name: string, value: Texture): void;
    /** Set a texture property. */
    SetTexture(nameID: number, value: Texture): void;
    /** Set a texture property. */
    SetTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    /** Set a texture property. */
    SetTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    /** Set a vector property. */
    SetVector(name: string, value: Vector4): void;
    /** Set a vector property. */
    SetVector(nameID: number, value: Vector4): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    /** Set a vector array property. */
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    /** Set a vector array property. */
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;

}
    
interface SphericalHarmonicsL2 {
    Item: number;


    /** Add an ambient light to the spherical harmonics. */
    AddAmbientLight(color: Color): void;
    /** Add a directional light to the spherical harmonics. */
    AddDirectionalLight(direction: Vector3, color: Color, intensity: number): void;
    /** Clears the spherical harmonics coefficients to zero. */
    Clear(): void;
    Equals(other: unknown): boolean;
    Equals(other: SphericalHarmonicsL2): boolean;
    /** Evaluates the spherical harmonics for each given direction. The directions and results arrays must have the same size. */
    Evaluate(directions: CSArray<Vector3>, results: CSArray<Color>): void;
    GetHashCode(): number;

}
    
interface MaterialPropertyBlockConstructor {

    new(): MaterialPropertyBlock;


}
declare const MaterialPropertyBlock: MaterialPropertyBlockConstructor;
    
interface RendererConstructor {

    new(): Renderer;


}
declare const Renderer: RendererConstructor;
    
interface RayTracingAABBsInstanceConfig {
    aabbBuffer: GraphicsBuffer;
    aabbCount: number;
    aabbOffset: number;
    dynamicGeometry: boolean;
    opaqueMaterial: boolean;
    material: Material;
    materialProperties: MaterialPropertyBlock;
    layer: number;
    mask: number;
    accelerationStructureBuildFlags: RayTracingAccelerationStructureBuildFlags;
    accelerationStructureBuildFlagsOverride: boolean;



}
    
interface RayTracingAABBsInstanceConfigConstructor {

    new(): RayTracingAABBsInstanceConfig;
    new(aabbBuffer: GraphicsBuffer, aabbCount: number, dynamicGeometry: boolean, material: Material): RayTracingAABBsInstanceConfig;


}
declare const RayTracingAABBsInstanceConfig: RayTracingAABBsInstanceConfigConstructor;
    
interface BuildSettings {
    buildFlags: RayTracingAccelerationStructureBuildFlags;
    relativeOrigin: Vector3;



}
    
interface BuildSettingsConstructor {

    new(): BuildSettings;
    new(buildFlags: RayTracingAccelerationStructureBuildFlags, relativeOrigin: Vector3): BuildSettings;


}
declare const BuildSettings: BuildSettingsConstructor;
    
interface RayTracingInstanceCullingResults {
    materialsCRC: CSArray<RayTracingInstanceMaterialCRC>;
    transformsChanged: boolean;



}
    
interface RayTracingInstanceMaterialCRC {
    instanceID: number;
    crc: number;



}
    
interface RayTracingAccelerationStructureConstructor {

    new(settings: Settings): RayTracingAccelerationStructure;
    new(): RayTracingAccelerationStructure;


}
declare const RayTracingAccelerationStructure: RayTracingAccelerationStructureConstructor;
    
interface ShaderConstructor {
    globalShaderHardwareTier: ShaderHardwareTier;
    maximumChunksOverride: number;
    globalMaximumLOD: number;
    globalRenderPipeline: string;
    enabledGlobalKeywords: CSArray<GlobalKeyword>;
    globalKeywords: CSArray<GlobalKeyword>;



    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    Find(name: string): Shader;
    GetGlobalColor(name: string): Color;
    GetGlobalColor(nameID: number): Color;
    GetGlobalFloat(name: string): number;
    GetGlobalFloat(nameID: number): number;
    GetGlobalFloatArray(name: string): CSArray<number>;
    GetGlobalFloatArray(nameID: number): CSArray<number>;
    GetGlobalFloatArray(name: string, values: CSArray<number>): void;
    GetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    GetGlobalInt(name: string): number;
    GetGlobalInt(nameID: number): number;
    GetGlobalInteger(name: string): number;
    GetGlobalInteger(nameID: number): number;
    GetGlobalMatrix(name: string): Matrix4x4;
    GetGlobalMatrix(nameID: number): Matrix4x4;
    GetGlobalMatrixArray(name: string): CSArray<Matrix4x4>;
    GetGlobalMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetGlobalTexture(name: string): Texture;
    GetGlobalTexture(nameID: number): Texture;
    GetGlobalVector(name: string): Vector4;
    GetGlobalVector(nameID: number): Vector4;
    GetGlobalVectorArray(name: string): CSArray<Vector4>;
    GetGlobalVectorArray(nameID: number): CSArray<Vector4>;
    GetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    GetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    PropertyToID(name: string): number;
    SetGlobalBuffer(name: string, value: ComputeBuffer): void;
    SetGlobalBuffer(nameID: number, value: ComputeBuffer): void;
    SetGlobalBuffer(name: string, value: GraphicsBuffer): void;
    SetGlobalBuffer(nameID: number, value: GraphicsBuffer): void;
    SetGlobalColor(name: string, value: Color): void;
    SetGlobalColor(nameID: number, value: Color): void;
    SetGlobalConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetGlobalFloat(name: string, value: number): void;
    SetGlobalFloat(nameID: number, value: number): void;
    SetGlobalFloatArray(name: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(name: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalInt(name: string, value: number): void;
    SetGlobalInt(nameID: number, value: number): void;
    SetGlobalInteger(name: string, value: number): void;
    SetGlobalInteger(nameID: number, value: number): void;
    SetGlobalMatrix(name: string, value: Matrix4x4): void;
    SetGlobalMatrix(nameID: number, value: Matrix4x4): void;
    SetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalRayTracingAccelerationStructure(name: string, value: RayTracingAccelerationStructure): void;
    SetGlobalRayTracingAccelerationStructure(nameID: number, value: RayTracingAccelerationStructure): void;
    SetGlobalTexGenMode(propertyName: string, mode: TexGenMode): void;
    SetGlobalTexture(name: string, value: Texture): void;
    SetGlobalTexture(nameID: number, value: Texture): void;
    SetGlobalTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetGlobalTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetGlobalTextureMatrixName(propertyName: string, matrixName: string): void;
    SetGlobalVector(name: string, value: Vector4): void;
    SetGlobalVector(nameID: number, value: Vector4): void;
    SetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    WarmupAllShaders(): void;
}
declare const Shader: ShaderConstructor;
    
interface MaterialConstructor {

    new(shader: Shader): Material;
    new(source: Material): Material;
    new(contents: string): Material;


    Create(scriptContents: string): Material;
}
declare const Material: MaterialConstructor;
    
interface GraphicsFence {
    passed: boolean;



}
    
interface GPUFence {
    passed: boolean;



}
    
interface ComputeShader extends Object {
    keywordSpace: LocalKeywordSpace;
    shaderKeywords: CSArray<string>;
    enabledKeywords: CSArray<LocalKeyword>;


    /** Disables a local shader keyword for this compute shader. */
    DisableKeyword(keyword: string): void;
    /** Disables a local shader keyword for this compute shader. */
    DisableKeyword(keyword: unknown): void;
    /** Execute a compute shader. */
    Dispatch(kernelIndex: number, threadGroupsX: number, threadGroupsY: number, threadGroupsZ: number): void;
    /** Execute a compute shader. */
    DispatchIndirect(kernelIndex: number, argsBuffer: ComputeBuffer, argsOffset: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: ComputeBuffer): void;
    /** Execute a compute shader. */
    DispatchIndirect(kernelIndex: number, argsBuffer: GraphicsBuffer, argsOffset: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: GraphicsBuffer): void;
    /** Enables a local shader keyword for this compute shader. */
    EnableKeyword(keyword: string): void;
    /** Enables a local shader keyword for this compute shader. */
    EnableKeyword(keyword: unknown): void;
    /** Find ComputeShader kernel index. */
    FindKernel(name: string): number;
    /** Get kernel thread group sizes. */
    GetKernelThreadGroupSizes(kernelIndex: number, x: unknown, y: unknown, z: unknown): void;
    /** Checks whether a shader contains a given kernel. */
    HasKernel(name: string): boolean;
    /** Checks whether a local shader keyword is enabled for this compute shader. */
    IsKeywordEnabled(keyword: string): boolean;
    /** Checks whether a local shader keyword is enabled for this compute shader. */
    IsKeywordEnabled(keyword: unknown): boolean;
    /** Allows you to check whether the current end user device supports the features required to run the specified compute shader kernel. */
    IsSupported(kernelIndex: number): boolean;
    /** Set a bool parameter. */
    SetBool(name: string, val: boolean): void;
    /** Set a bool parameter. */
    SetBool(nameID: number, val: boolean): void;
    /** Sets an input or output compute buffer. */
    SetBuffer(kernelIndex: number, nameID: number, buffer: ComputeBuffer): void;
    /** Sets an input or output compute buffer. */
    SetBuffer(kernelIndex: number, nameID: number, buffer: GraphicsBuffer): void;
    /** Sets an input or output compute buffer. */
    SetBuffer(kernelIndex: number, name: string, buffer: ComputeBuffer): void;
    /** Sets an input or output compute buffer. */
    SetBuffer(kernelIndex: number, name: string, buffer: GraphicsBuffer): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader. */
    SetConstantBuffer(nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader. */
    SetConstantBuffer(name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader. */
    SetConstantBuffer(nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the ComputeShader. */
    SetConstantBuffer(name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    /** Set a float parameter. */
    SetFloat(nameID: number, val: number): void;
    /** Set a float parameter. */
    SetFloat(name: string, val: number): void;
    /** Set multiple consecutive float parameters at once. */
    SetFloats(name: string, values: CSArray<number>): void;
    /** Set multiple consecutive float parameters at once. */
    SetFloats(nameID: number, values: CSArray<number>): void;
    /** Set an integer parameter. */
    SetInt(nameID: number, val: number): void;
    /** Set an integer parameter. */
    SetInt(name: string, val: number): void;
    /** Set multiple consecutive integer parameters at once. */
    SetInts(name: string, values: CSArray<number>): void;
    /** Set multiple consecutive integer parameters at once. */
    SetInts(nameID: number, values: CSArray<number>): void;
    /** Sets the state of a local shader keyword for this compute shader. */
    SetKeyword(keyword: unknown, value: boolean): void;
    /** Set a Matrix parameter. */
    SetMatrix(nameID: number, val: Matrix4x4): void;
    /** Set a Matrix parameter. */
    SetMatrix(name: string, val: Matrix4x4): void;
    /** Set a Matrix array parameter. */
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Set a Matrix array parameter. */
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    /** Sets a RayTracingAccelerationStructure to be used for Inline Ray Tracing (Ray Queries). */
    SetRayTracingAccelerationStructure(kernelIndex: number, nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    /** Sets a RayTracingAccelerationStructure to be used for Inline Ray Tracing (Ray Queries). */
    SetRayTracingAccelerationStructure(kernelIndex: number, name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    /** Set a texture parameter. */
    SetTexture(kernelIndex: number, nameID: number, texture: Texture, mipLevel: number): void;
    /** Set a texture parameter. */
    SetTexture(kernelIndex: number, nameID: number, texture: Texture): void;
    /** Set a texture parameter. */
    SetTexture(kernelIndex: number, name: string, texture: Texture): void;
    /** Set a texture parameter. */
    SetTexture(kernelIndex: number, name: string, texture: Texture, mipLevel: number): void;
    /** Set a texture parameter. */
    SetTexture(kernelIndex: number, nameID: number, texture: RenderTexture, mipLevel: number, element: RenderTextureSubElement): void;
    /** Set a texture parameter. */
    SetTexture(kernelIndex: number, name: string, texture: RenderTexture, mipLevel: number, element: RenderTextureSubElement): void;
    /** Set a texture parameter from a global texture property. */
    SetTextureFromGlobal(kernelIndex: number, nameID: number, globalTextureNameID: number): void;
    /** Set a texture parameter from a global texture property. */
    SetTextureFromGlobal(kernelIndex: number, name: string, globalTextureName: string): void;
    /** Set a vector parameter. */
    SetVector(nameID: number, val: Vector4): void;
    /** Set a vector parameter. */
    SetVector(name: string, val: Vector4): void;
    /** Set a vector array parameter. */
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    /** Set a vector array parameter. */
    SetVectorArray(name: string, values: CSArray<Vector4>): void;

}
    
interface RayTracingShader extends Object {
    maxRecursionDepth: number;


    /** Dispatches this RayTracingShader. */
    Dispatch(rayGenFunctionName: string, width: number, height: number, depth: number, camera: Camera): void;
    /** Sets the value for RayTracingAccelerationStructure property of this RayTracingShader. */
    SetAccelerationStructure(nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    /** Sets the value for RayTracingAccelerationStructure property of this RayTracingShader. */
    SetAccelerationStructure(name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    /** Sets the value of a boolean uniform. */
    SetBool(name: string, val: boolean): void;
    /** Sets the value of a boolean uniform. */
    SetBool(nameID: number, val: boolean): void;
    /** Binds an input or output compute buffer. */
    SetBuffer(nameID: number, buffer: ComputeBuffer): void;
    /** Binds an input or output compute buffer. */
    SetBuffer(nameID: number, buffer: GraphicsBuffer): void;
    /** Binds an input or output compute buffer. */
    SetBuffer(nameID: number, bufferHandle: GraphicsBufferHandle): void;
    /** Binds an input or output compute buffer. */
    SetBuffer(name: string, buffer: ComputeBuffer): void;
    /** Binds an input or output compute buffer. */
    SetBuffer(name: string, buffer: GraphicsBuffer): void;
    /** Binds an input or output compute buffer. */
    SetBuffer(name: string, bufferHandle: GraphicsBufferHandle): void;
    /** Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer. */
    SetConstantBuffer(nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    /** Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer. */
    SetConstantBuffer(name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    /** Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer. */
    SetConstantBuffer(nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    /** Binds a constant buffer created through a ComputeBuffer or a GraphicsBuffer. */
    SetConstantBuffer(name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    /** Sets the value of a float uniform. */
    SetFloat(nameID: number, val: number): void;
    /** Sets the value of a float uniform. */
    SetFloat(name: string, val: number): void;
    /** Sets the values for a float array uniform. */
    SetFloats(name: string, values: CSArray<number>): void;
    /** Sets the values for a float array uniform. */
    SetFloats(nameID: number, values: CSArray<number>): void;
    /** Sets the value of a int uniform. */
    SetInt(nameID: number, val: number): void;
    /** Sets the value of a int uniform. */
    SetInt(name: string, val: number): void;
    /** Sets the values for a int array uniform. */
    SetInts(name: string, values: CSArray<number>): void;
    /** Sets the values for a int array uniform. */
    SetInts(nameID: number, values: CSArray<number>): void;
    /** Sets the value of a matrix uniform. */
    SetMatrix(nameID: number, val: Matrix4x4): void;
    /** Sets the value of a matrix uniform. */
    SetMatrix(name: string, val: Matrix4x4): void;
    /** Sets a matrix array uniform. */
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    /** Sets a matrix array uniform. */
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    /** Selects which Shader Pass to use when executing ray/geometry intersection shaders. */
    SetShaderPass(passName: string): void;
    /** Binds a texture resource. This can be a input or an output texture (UAV). */
    SetTexture(nameID: number, texture: Texture): void;
    /** Binds a texture resource. This can be a input or an output texture (UAV). */
    SetTexture(name: string, texture: Texture): void;
    /** Binds a global texture to a RayTracingShader. */
    SetTextureFromGlobal(nameID: number, globalTextureNameID: number): void;
    /** Binds a global texture to a RayTracingShader. */
    SetTextureFromGlobal(name: string, globalTextureName: string): void;
    /** Sets the value for a vector uniform. */
    SetVector(nameID: number, val: Vector4): void;
    /** Sets the value for a vector uniform. */
    SetVector(name: string, val: Vector4): void;
    /** Sets a vector array uniform. */
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    /** Sets a vector array uniform. */
    SetVectorArray(name: string, values: CSArray<Vector4>): void;

}
    
interface RectInt {
    x: number;
    y: number;
    center: Vector2;
    min: Vector2Int;
    max: Vector2Int;
    width: number;
    height: number;
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
    position: Vector2Int;
    size: Vector2Int;
    allPositionsWithin: PositionEnumerator;


    /** Clamps the position and size of the RectInt to the given bounds. */
    ClampToBounds(bounds: RectInt): void;
    /** Returns true if the given position is within the RectInt. */
    Contains(position: Vector2Int): boolean;
    Equals(other: unknown): boolean;
    /** Returns true if the given RectInt is equal to this RectInt. */
    Equals(other: RectInt): boolean;
    GetHashCode(): number;
    /** RectInts overlap if each RectInt Contains a shared point. */
    Overlaps(other: RectInt): boolean;
    /** Sets the bounds to the min and max value of the rect. */
    SetMinMax(minPosition: Vector2Int, maxPosition: Vector2Int): void;
    /** Returns the x, y, width and height of the RectInt. */
    ToString(): string;
    /** Returns the x, y, width and height of the RectInt. */
    ToString(format: string): string;
    /** Returns the x, y, width and height of the RectInt. */
    ToString(format: string, formatProvider: unknown): string;

}
    
interface PositionEnumerator {
    Current: Vector2Int;


    GetEnumerator(): PositionEnumerator;
    MoveNext(): boolean;
    Reset(): void;

}
    
interface PositionEnumeratorConstructor {

    new(min: Vector2Int, max: Vector2Int): PositionEnumerator;


}
declare const PositionEnumerator: PositionEnumeratorConstructor;
    
interface RectIntConstructor {
    zero: RectInt;

    new(xMin: number, yMin: number, width: number, height: number): RectInt;
    new(position: Vector2Int, size: Vector2Int): RectInt;


}
declare const RectInt: RectIntConstructor;
    
interface RendererList {
    isValid: boolean;



}
    
interface RendererListConstructor {
    nullRendererList: RendererList;



}
declare const RendererList: RendererListConstructor;
    
interface RenderTargetBinding {
    colorRenderTargets: CSArray<RenderTargetIdentifier>;
    depthRenderTarget: RenderTargetIdentifier;
    colorLoadActions: CSArray<number>;
    colorStoreActions: CSArray<number>;
    depthLoadAction: RenderBufferLoadAction;
    depthStoreAction: RenderBufferStoreAction;
    flags: RenderTargetFlags;



}
    
interface RenderTargetBindingConstructor {

    new(colorRenderTargets: CSArray<RenderTargetIdentifier>, colorLoadActions: CSArray<number>, colorStoreActions: CSArray<number>, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): RenderTargetBinding;
    new(colorRenderTarget: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): RenderTargetBinding;
    new(setup: RenderTargetSetup): RenderTargetBinding;


}
declare const RenderTargetBinding: RenderTargetBindingConstructor;
    
interface CommandBufferConstructor {
    ThrowOnSetRenderTarget: boolean;

    new(): CommandBuffer;


}
declare const CommandBuffer: CommandBufferConstructor;
    
interface Cubemap extends Texture {
    format: TextureFormat;
    isReadable: boolean;
    streamingMipmaps: boolean;
    streamingMipmapsPriority: number;
    requestedMipmapLevel: number;
    desiredMipmapLevel: number;
    loadingMipmapLevel: number;
    loadedMipmapLevel: number;


    /** Copies changes you&#x27;ve made in a CPU texture to the GPU. */
    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    /** Resets the requestedMipmapLevel field. */
    ClearRequestedMipmapLevel(): void;
    /** Gets the pixel color at coordinates (x, y). */
    GetPixel(face: CubemapFace, x: number, y: number): Color;
    /** Gets the pixel color at coordinates (x, y). */
    GetPixel(face: CubemapFace, x: number, y: number, mip: number): Color;
    /** Gets the raw data from a texture. */
    GetPixelData<T>(mipLevel: number, face: CubemapFace): CSArray<T>;
    /** Gets the pixel color data for a mipmap level of a face as Color structs. */
    GetPixels(face: CubemapFace, miplevel: number): CSArray<Color>;
    /** Gets the pixel color data for a mipmap level of a face as Color structs. */
    GetPixels(face: CubemapFace): CSArray<Color>;
    /** Checks to see whether the mipmap level set by requestedMipmapLevel has finished loading. */
    IsRequestedMipmapLevelLoaded(): boolean;
    /** Sets the pixel color at coordinates (x,y). */
    SetPixel(face: CubemapFace, x: number, y: number, color: Color): void;
    /** Sets the pixel color at coordinates (x,y). */
    SetPixel(face: CubemapFace, x: number, y: number, color: Color, mip: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, face: CubemapFace, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, face: CubemapFace, sourceDataStartIndex: number): void;
    /** Sets the pixel colors of an entire mipmap level of a face. */
    SetPixels(colors: CSArray<Color>, face: CubemapFace, miplevel: number): void;
    /** Sets the pixel colors of an entire mipmap level of a face. */
    SetPixels(colors: CSArray<Color>, face: CubemapFace): void;
    /** Performs smoothing of near edge regions. */
    SmoothEdges(smoothRegionWidthInPixels: number): void;
    SmoothEdges(): void;
    /** Updates Unity cubemap to use different native cubemap texture object. */
    UpdateExternalTexture(nativeTexture: unknown): void;

}
    
interface CubemapConstructor {

    new(width: number, format: DefaultFormat, flags: TextureCreationFlags): Cubemap;
    new(width: number, format: DefaultFormat, flags: TextureCreationFlags, mipCount: number): Cubemap;
    new(width: number, format: GraphicsFormat, flags: TextureCreationFlags): Cubemap;
    new(width: number, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: number): Cubemap;
    new(width: number, textureFormat: TextureFormat, mipChain: boolean): Cubemap;
    new(width: number, textureFormat: TextureFormat, mipChain: boolean, createUninitialized: boolean): Cubemap;
    new(width: number, format: TextureFormat, mipCount: number): Cubemap;
    new(width: number, format: TextureFormat, mipCount: number, createUninitialized: boolean): Cubemap;


    CreateExternalTexture(width: number, format: TextureFormat, mipmap: boolean, nativeTex: unknown): Cubemap;
}
declare const Cubemap: CubemapConstructor;
    
interface RenderRequest {
    isValid: boolean;
    mode: RenderRequestMode;
    result: RenderTexture;
    outputSpace: RenderRequestOutputSpace;



}
    
interface RenderRequestConstructor {

    new(mode: RenderRequestMode, rt: RenderTexture): RenderRequest;
    new(mode: RenderRequestMode, space: RenderRequestOutputSpace, rt: RenderTexture): RenderRequest;


}
declare const RenderRequest: RenderRequestConstructor;
    
interface CameraCallback {


    BeginInvoke(cam: Camera, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(cam: Camera): void;

}
    
interface CameraCallbackConstructor {

    new(object: unknown, method: unknown): CameraCallback;


}
declare const CameraCallback: CameraCallbackConstructor;
    
interface GateFitParameters {
    mode: GateFitMode;
    aspect: number;



}
    
interface GateFitParametersConstructor {

    new(mode: GateFitMode, aspect: number): GateFitParameters;


}
declare const GateFitParameters: GateFitParametersConstructor;
    
interface CameraConstructor {
    kMinAperture: number;
    kMaxAperture: number;
    kMinBladeCount: number;
    kMaxBladeCount: number;
    onPreCull: CameraCallback;
    onPreRender: CameraCallback;
    onPostRender: CameraCallback;
    main: Camera;
    current: Camera;
    allCamerasCount: number;
    allCameras: CSArray<Camera>;
    mainCamera: Camera;

    new(): Camera;


    CalculateProjectionMatrixFromPhysicalProperties(output: unknown, focalLength: number, sensorSize: Vector2, lensShift: Vector2, nearClip: number, farClip: number, gateFitParameters: GateFitParameters): void;
    FieldOfViewToFocalLength(fieldOfView: number, sensorSize: number): number;
    FocalLengthToFieldOfView(focalLength: number, sensorSize: number): number;
    GetAllCameras(cameras: CSArray<Camera>): number;
    HorizontalToVerticalFieldOfView(horizontalFieldOfView: number, aspectRatio: number): number;
    SetupCurrent(cur: Camera): void;
    VerticalToHorizontalFieldOfView(verticalFieldOfView: number, aspectRatio: number): number;
}
declare const Camera: CameraConstructor;
    
interface Input {



}
    
interface LocationService {
    isEnabledByUser: boolean;
    status: LocationServiceStatus;
    lastData: LocationInfo;


    /** Starts location service updates. */
    Start(desiredAccuracyInMeters: number, updateDistanceInMeters: number): void;
    /** Starts location service updates. */
    Start(desiredAccuracyInMeters: number): void;
    /** Starts location service updates. */
    Start(): void;
    /** Stops location service updates. This is useful to save battery power when the application doesn&#x27;t require the location service. */
    Stop(): void;

}
    
interface LocationInfo {
    latitude: number;
    longitude: number;
    altitude: number;
    horizontalAccuracy: number;
    verticalAccuracy: number;
    timestamp: number;



}
    
interface LocationServiceConstructor {

    new(): LocationService;


}
declare const LocationService: LocationServiceConstructor;
    
interface Compass {
    magneticHeading: number;
    trueHeading: number;
    headingAccuracy: number;
    rawVector: Vector3;
    timestamp: number;
    enabled: boolean;



}
    
interface CompassConstructor {

    new(): Compass;


}
declare const Compass: CompassConstructor;
    
interface Gyroscope {
    rotationRate: Vector3;
    rotationRateUnbiased: Vector3;
    gravity: Vector3;
    userAcceleration: Vector3;
    attitude: Quaternion;
    enabled: boolean;
    updateInterval: number;



}
    
interface Touch {
    fingerId: number;
    position: Vector2;
    rawPosition: Vector2;
    deltaPosition: Vector2;
    deltaTime: number;
    tapCount: number;
    phase: TouchPhase;
    pressure: number;
    maximumPossiblePressure: number;
    type: TouchType;
    altitudeAngle: number;
    azimuthAngle: number;
    radius: number;
    radiusVariance: number;



}
    
interface AccelerationEvent {
    acceleration: Vector3;
    deltaTime: number;



}
    
interface PenData {
    position: Vector2;
    tilt: Vector2;
    penStatus: PenStatus;
    twist: number;
    pressure: number;
    contactType: PenEventType;
    deltaPos: Vector2;



}
    
interface InputConstructor {
    simulateMouseWithTouches: boolean;
    anyKey: boolean;
    anyKeyDown: boolean;
    inputString: string;
    mousePosition: Vector3;
    mousePositionDelta: Vector3;
    mouseScrollDelta: Vector2;
    imeCompositionMode: IMECompositionMode;
    compositionString: string;
    imeIsSelected: boolean;
    compositionCursorPos: Vector2;
    eatKeyPressOnTextFieldFocus: boolean;
    mousePresent: boolean;
    penEventCount: number;
    touchCount: number;
    touchPressureSupported: boolean;
    stylusTouchSupported: boolean;
    touchSupported: boolean;
    multiTouchEnabled: boolean;
    isGyroAvailable: boolean;
    deviceOrientation: DeviceOrientation;
    acceleration: Vector3;
    compensateSensors: boolean;
    accelerationEventCount: number;
    backButtonLeavesApp: boolean;
    location: LocationService;
    compass: Compass;
    gyro: Gyroscope;
    touches: CSArray<Touch>;
    accelerationEvents: CSArray<AccelerationEvent>;

    new(): Input;


    ClearLastPenContactEvent(): void;
    GetAccelerationEvent(index: number): AccelerationEvent;
    GetAxis(axisName: string): number;
    GetAxisRaw(axisName: string): number;
    GetButton(buttonName: string): boolean;
    GetButtonDown(buttonName: string): boolean;
    GetButtonUp(buttonName: string): boolean;
    GetJoystickNames(): CSArray<string>;
    GetKey(key: KeyCode): boolean;
    GetKey(name: string): boolean;
    GetKeyDown(key: KeyCode): boolean;
    GetKeyDown(name: string): boolean;
    GetKeyUp(key: KeyCode): boolean;
    GetKeyUp(name: string): boolean;
    GetLastPenContactEvent(): PenData;
    GetMouseButton(button: number): boolean;
    GetMouseButtonDown(button: number): boolean;
    GetMouseButtonUp(button: number): boolean;
    GetPenEvent(index: number): PenData;
    GetTouch(index: number): Touch;
    IsJoystickPreconfigured(joystickName: string): boolean;
    ResetInputAxes(): void;
    ResetPenEvents(): void;
}
declare const Input: InputConstructor;
    
interface InstanceFinder {



}
    
interface InstanceFinderConstructor {
    NetworkManager: NetworkManager;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    RollbackManager: RollbackManager;
    PredictionManager: PredictionManager;
    StatisticsManager: StatisticsManager;
    IsClientOnly: boolean;
    IsServerOnly: boolean;
    IsHost: boolean;
    IsClient: boolean;
    IsServer: boolean;
    IsServerStarted: boolean;
    IsServerOnlyStarted: boolean;
    IsClientStarted: boolean;
    IsClientOnlyStarted: boolean;
    IsHostStarted: boolean;
    IsOffline: boolean;



    GetInstance<T>(): T;
    HasInstance<T>(): boolean;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    TryGetInstance<T>(component: unknown): boolean;
    TryRegisterInstance<T>(component: T): boolean;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
}
declare const InstanceFinder: InstanceFinderConstructor;
    
interface IEventSystemHandler {



}
    
interface ISubmitHandler extends IEventSystemHandler {


    OnSubmit(eventData: BaseEventData): void;

}
    
interface AbstractEventData {
    used: boolean;


    Reset(): void;
    Use(): void;

}
    
interface BaseEventData extends AbstractEventData {
    currentInputModule: BaseInputModule;
    selectedObject: GameObject;



}
    
interface UIBehaviour extends MonoBehaviour {


    IsActive(): boolean;
    IsDestroyed(): boolean;

}
    
interface BaseInputModule extends UIBehaviour {
    input: BaseInput;
    inputOverride: BaseInput;


    ActivateModule(): void;
    ConvertUIToolkitPointerId(sourcePointerData: PointerEventData): number;
    DeactivateModule(): void;
    IsModuleSupported(): boolean;
    IsPointerOverGameObject(pointerId: number): boolean;
    Process(): void;
    ShouldActivateModule(): boolean;
    UpdateModule(): void;

}
    
interface BaseInput extends UIBehaviour {
    compositionString: string;
    imeCompositionMode: IMECompositionMode;
    compositionCursorPos: Vector2;
    mousePresent: boolean;
    mousePosition: Vector2;
    mouseScrollDelta: Vector2;
    touchSupported: boolean;
    touchCount: number;


    GetAxisRaw(axisName: string): number;
    GetButtonDown(buttonName: string): boolean;
    GetMouseButton(button: number): boolean;
    GetMouseButtonDown(button: number): boolean;
    GetMouseButtonUp(button: number): boolean;
    GetTouch(index: number): Touch;

}
    
interface BaseInputConstructor {

    new(): BaseInput;


}
declare const BaseInput: BaseInputConstructor;
    
interface PointerEventData extends BaseEventData {
    hovered: CSArray<GameObject>;
    pointerEnter: GameObject;
    lastPress: GameObject;
    rawPointerPress: GameObject;
    pointerDrag: GameObject;
    pointerClick: GameObject;
    pointerCurrentRaycast: RaycastResult;
    pointerPressRaycast: RaycastResult;
    eligibleForClick: boolean;
    displayIndex: number;
    pointerId: number;
    position: Vector2;
    delta: Vector2;
    pressPosition: Vector2;
    worldPosition: Vector3;
    worldNormal: Vector3;
    clickTime: number;
    clickCount: number;
    scrollDelta: Vector2;
    useDragThreshold: boolean;
    dragging: boolean;
    button: InputButton;
    pressure: number;
    tangentialPressure: number;
    altitudeAngle: number;
    azimuthAngle: number;
    twist: number;
    tilt: Vector2;
    penStatus: PenStatus;
    radius: Vector2;
    radiusVariance: Vector2;
    fullyExited: boolean;
    reentered: boolean;
    enterEventCamera: Camera;
    pressEventCamera: Camera;
    pointerPress: GameObject;


    IsPointerMoving(): boolean;
    IsScrolling(): boolean;
    ToString(): string;

}
    
interface RaycastResult {
    module: BaseRaycaster;
    distance: number;
    index: number;
    depth: number;
    sortingGroupID: number;
    sortingGroupOrder: number;
    sortingLayer: number;
    sortingOrder: number;
    worldPosition: Vector3;
    worldNormal: Vector3;
    screenPosition: Vector2;
    displayIndex: number;
    gameObject: GameObject;
    isValid: boolean;


    Clear(): void;
    ToString(): string;

}
    
interface BaseRaycaster extends UIBehaviour {
    eventCamera: Camera;
    priority: number;
    sortOrderPriority: number;
    renderOrderPriority: number;
    rootRaycaster: BaseRaycaster;


    Raycast(eventData: PointerEventData, resultAppendList: CSArray<RaycastResult>): void;
    ToString(): string;

}
    
interface PointerEventDataConstructor {

    new(eventSystem: EventSystem): PointerEventData;


}
declare const PointerEventData: PointerEventDataConstructor;
    
interface BaseEventDataConstructor {

    new(eventSystem: EventSystem): BaseEventData;


}
declare const BaseEventData: BaseEventDataConstructor;
    
interface IPointerClickHandler extends IEventSystemHandler {


    OnPointerClick(eventData: PointerEventData): void;

}
    
interface IPointerEnterHandler extends IEventSystemHandler {


    OnPointerEnter(eventData: PointerEventData): void;

}
    
interface ISelectHandler extends IEventSystemHandler {


    OnSelect(eventData: BaseEventData): void;

}
    
interface IPointerExitHandler extends IEventSystemHandler {


    OnPointerExit(eventData: PointerEventData): void;

}
    
interface IDeselectHandler extends IEventSystemHandler {


    OnDeselect(eventData: BaseEventData): void;

}
    
interface IPointerDownHandler extends IEventSystemHandler {


    OnPointerDown(eventData: PointerEventData): void;

}
    
interface IPointerUpHandler extends IEventSystemHandler {


    OnPointerUp(eventData: PointerEventData): void;

}
    
interface IMoveHandler extends IEventSystemHandler {


    OnMove(eventData: AxisEventData): void;

}
    
interface AxisEventData extends BaseEventData {
    moveVector: Vector2;
    moveDir: MoveDirection;



}
    
interface AxisEventDataConstructor {

    new(eventSystem: EventSystem): AxisEventData;


}
declare const AxisEventData: AxisEventDataConstructor;
    
interface Selectable extends UIBehaviour, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
    navigation: Navigation;
    transition: Transition;
    colors: ColorBlock;
    spriteState: SpriteState;
    animationTriggers: AnimationTriggers;
    targetGraphic: Graphic;
    interactable: boolean;
    image: Image;
    animator: Animator;


    FindSelectable(dir: Vector3): Selectable;
    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    IsInteractable(): boolean;
    OnDeselect(eventData: BaseEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    Select(): void;

}
    
interface Navigation {
    mode: Mode;
    wrapAround: boolean;
    selectOnUp: Selectable;
    selectOnDown: Selectable;
    selectOnLeft: Selectable;
    selectOnRight: Selectable;


    Equals(other: Navigation): boolean;

}
    
interface NavigationConstructor {
    defaultNavigation: Navigation;



}
declare const Navigation: NavigationConstructor;
    
interface ColorBlock {
    normalColor: Color;
    highlightedColor: Color;
    pressedColor: Color;
    selectedColor: Color;
    disabledColor: Color;
    colorMultiplier: number;
    fadeDuration: number;


    Equals(obj: unknown): boolean;
    Equals(other: ColorBlock): boolean;
    GetHashCode(): number;

}
    
interface ColorBlockConstructor {
    defaultColorBlock: ColorBlock;



}
declare const ColorBlock: ColorBlockConstructor;
    
interface SpriteState {
    highlightedSprite: Sprite;
    pressedSprite: Sprite;
    selectedSprite: Sprite;
    disabledSprite: Sprite;


    Equals(other: SpriteState): boolean;

}
    
interface AnimationTriggers {
    normalTrigger: string;
    highlightedTrigger: string;
    pressedTrigger: string;
    selectedTrigger: string;
    disabledTrigger: string;



}
    
interface AnimationTriggersConstructor {

    new(): AnimationTriggers;


}
declare const AnimationTriggers: AnimationTriggersConstructor;
    
interface ICanvasElement {
    transform: Transform;


    GraphicUpdateComplete(): void;
    IsDestroyed(): boolean;
    LayoutComplete(): void;
    Rebuild(executing: CanvasUpdate): void;

}
    
interface Graphic extends UIBehaviour, ICanvasElement {
    color: Color;
    raycastTarget: boolean;
    raycastPadding: Vector4;
    depth: number;
    rectTransform: RectTransform;
    canvas: Canvas;
    canvasRenderer: CanvasRenderer;
    defaultMaterial: Material;
    material: Material;
    materialForRendering: Material;
    mainTexture: Texture;


    CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean, useRGB: boolean): void;
    GetPixelAdjustedRect(): Rect;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnCullingChanged(): void;
    OnRebuildRequested(): void;
    PixelAdjustPoint(point: Vector2): Vector2;
    Raycast(sp: Vector2, eventCamera: Camera): boolean;
    Rebuild(update: CanvasUpdate): void;
    RegisterDirtyLayoutCallback(action: UnityAction): void;
    RegisterDirtyMaterialCallback(action: UnityAction): void;
    RegisterDirtyVerticesCallback(action: UnityAction): void;
    SetAllDirty(): void;
    SetLayoutDirty(): void;
    SetMaterialDirty(): void;
    SetNativeSize(): void;
    SetRaycastDirty(): void;
    SetVerticesDirty(): void;
    UnregisterDirtyLayoutCallback(action: UnityAction): void;
    UnregisterDirtyMaterialCallback(action: UnityAction): void;
    UnregisterDirtyVerticesCallback(action: UnityAction): void;

}
    
interface RectTransform extends Transform {
    rect: Rect;
    anchorMin: Vector2;
    anchorMax: Vector2;
    anchoredPosition: Vector2;
    sizeDelta: Vector2;
    pivot: Vector2;
    anchoredPosition3D: Vector3;
    offsetMin: Vector2;
    offsetMax: Vector2;
    drivenByObject: Object;


    /** Force the recalculation of RectTransforms internal data. */
    ForceUpdateRectTransforms(): void;
    /** Get the corners of the calculated rectangle in the local space of its Transform. */
    GetLocalCorners(fourCornersArray: CSArray<Vector3>): void;
    /** Get the corners of the calculated rectangle in world space. */
    GetWorldCorners(fourCornersArray: CSArray<Vector3>): void;
    SetInsetAndSizeFromParentEdge(edge: Edge, inset: number, size: number): void;
    SetSizeWithCurrentAnchors(axis: Axis, size: number): void;

}
    
interface RectTransformConstructor {

    new(): RectTransform;


}
declare const RectTransform: RectTransformConstructor;
    
interface Canvas extends Behaviour {
    renderMode: RenderMode;
    isRootCanvas: boolean;
    pixelRect: Rect;
    scaleFactor: number;
    referencePixelsPerUnit: number;
    overridePixelPerfect: boolean;
    vertexColorAlwaysGammaSpace: boolean;
    pixelPerfect: boolean;
    planeDistance: number;
    renderOrder: number;
    overrideSorting: boolean;
    sortingOrder: number;
    targetDisplay: number;
    sortingLayerID: number;
    cachedSortingLayerValue: number;
    additionalShaderChannels: AdditionalCanvasShaderChannels;
    sortingLayerName: string;
    rootCanvas: Canvas;
    renderingDisplaySize: Vector2;
    updateRectTransformForStandalone: StandaloneRenderResize;
    worldCamera: Camera;
    normalizedSortingGridSize: number;
    sortingGridNormalizedSize: number;



}
    
interface CanvasConstructor {

    new(): Canvas;


    ForceUpdateCanvases(): void;
    GetDefaultCanvasMaterial(): Material;
    GetDefaultCanvasTextMaterial(): Material;
    GetETC1SupportedCanvasMaterial(): Material;
}
declare const Canvas: CanvasConstructor;
    
interface CanvasRenderer extends Component {
    hasPopInstruction: boolean;
    materialCount: number;
    popMaterialCount: number;
    absoluteDepth: number;
    hasMoved: boolean;
    cullTransparentMesh: boolean;
    hasRectClipping: boolean;
    relativeDepth: number;
    cull: boolean;
    isMask: boolean;
    clippingSoftness: Vector2;


    /** Remove all cached vertices. */
    Clear(): void;
    /** Disables rectangle clipping for this CanvasRenderer. */
    DisableRectClipping(): void;
    /** Enables rect clipping on the CanvasRendered. Geometry outside of the specified rect will be clipped (not rendered). */
    EnableRectClipping(rect: Rect): void;
    /** Get the current alpha of the renderer. */
    GetAlpha(): number;
    /** Get the current color of the renderer. */
    GetColor(): Color;
    /** Get the final inherited alpha calculated by including all the parent alphas from included parent CanvasGroups. */
    GetInheritedAlpha(): number;
    /** Gets the current Material assigned to the CanvasRenderer. */
    GetMaterial(index: number): Material;
    /** Gets the current Material assigned to the CanvasRenderer. */
    GetMaterial(): Material;
    /** Returns the current mesh used to render the canvas content into. */
    GetMesh(): Mesh;
    /** Gets the current Material assigned to the CanvasRenderer. Used internally for masking. */
    GetPopMaterial(index: number): Material;
    /** Set the alpha of the renderer. Will be multiplied with the UIVertex alpha and the Canvas alpha. */
    SetAlpha(alpha: number): void;
    /** The Alpha Texture that will be passed to the Shader under the _AlphaTex property. */
    SetAlphaTexture(texture: Texture): void;
    /** Set the color of the renderer. Will be multiplied with the UIVertex color and the Canvas color. */
    SetColor(color: Color): void;
    /** Set the material for the canvas renderer. If a texture is specified then it will be used as the &#x27;MainTex&#x27; instead of the material&#x27;s &#x27;MainTex&#x27;.
See Also: CanvasRenderer.materialCount, CanvasRenderer.SetTexture. */
    SetMaterial(material: Material, index: number): void;
    /** Set the material for the canvas renderer. If a texture is specified then it will be used as the &#x27;MainTex&#x27; instead of the material&#x27;s &#x27;MainTex&#x27;.
See Also: CanvasRenderer.materialCount, CanvasRenderer.SetTexture. */
    SetMaterial(material: Material, texture: Texture): void;
    /** Sets the Mesh used by this renderer. Note the Mesh must be read/write enabled. */
    SetMesh(mesh: Mesh): void;
    /** Set the material for the canvas renderer. Used internally for masking. */
    SetPopMaterial(material: Material, index: number): void;
    /** Sets the texture used by this renderer&#x27;s material. */
    SetTexture(texture: Texture): void;
    SetVertices(vertices: CSArray<UIVertex>): void;
    /** Set the vertices for the UIRenderer. */
    SetVertices(vertices: CSArray<UIVertex>, size: number): void;

}
    
interface UIVertex {
    position: Vector3;
    normal: Vector3;
    tangent: Vector4;
    color: Color32;
    uv0: Vector4;
    uv1: Vector4;
    uv2: Vector4;
    uv3: Vector4;



}
    
interface UIVertexConstructor {
    simpleVert: UIVertex;



}
declare const UIVertex: UIVertexConstructor;
    
interface CanvasRendererConstructor {

    new(): CanvasRenderer;


    AddUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>): void;
    AddUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>): void;
    CreateUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    CreateUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    SplitUIVertexStreams(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    SplitUIVertexStreams(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
}
declare const CanvasRenderer: CanvasRendererConstructor;
    
interface UnityAction {


    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;

}
    
interface UnityActionConstructor {

    new(object: unknown, method: unknown): UnityAction;


}
declare const UnityAction: UnityActionConstructor;
    
interface GraphicConstructor {
    defaultGraphicMaterial: Material;



}
declare const Graphic: GraphicConstructor;
    
interface ISerializationCallbackReceiver {


    /** Implement this method to receive a callback after Unity deserializes your object. */
    OnAfterDeserialize(): void;
    /** Implement this method to receive a callback before Unity serializes your object. */
    OnBeforeSerialize(): void;

}
    
interface ICanvasRaycastFilter {


    /** Given a point and a camera is the raycast valid. */
    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;

}
    
interface ILayoutElement {
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;

}
    
interface IClippable {
    gameObject: GameObject;
    rectTransform: RectTransform;


    Cull(clipRect: Rect, validRect: boolean): void;
    RecalculateClipping(): void;
    SetClipRect(value: Rect, validRect: boolean): void;
    SetClipSoftness(clipSoftness: Vector2): void;

}
    
interface IMaterialModifier {


    GetModifiedMaterial(baseMaterial: Material): Material;

}
    
interface IMaskable {


    RecalculateMasking(): void;

}
    
interface MaskableGraphic extends Graphic, IClippable, IMaterialModifier, IMaskable {
    onCullStateChanged: CullStateChangedEvent;
    maskable: boolean;
    isMaskingGraphic: boolean;


    Cull(clipRect: Rect, validRect: boolean): void;
    GetModifiedMaterial(baseMaterial: Material): Material;
    ParentMaskStateChanged(): void;
    RecalculateClipping(): void;
    RecalculateMasking(): void;
    SetClipRect(clipRect: Rect, validRect: boolean): void;
    SetClipSoftness(clipSoftness: Vector2): void;

}
    
interface CullStateChangedEvent {



}
    
interface CullStateChangedEventConstructor {

    new(): CullStateChangedEvent;


}
declare const CullStateChangedEvent: CullStateChangedEventConstructor;
    
interface Image extends MaskableGraphic, ISerializationCallbackReceiver, ICanvasRaycastFilter, ILayoutElement {
    sprite: Sprite;
    overrideSprite: Sprite;
    type: Type;
    preserveAspect: boolean;
    fillCenter: boolean;
    fillMethod: FillMethod;
    fillAmount: number;
    fillClockwise: boolean;
    fillOrigin: number;
    eventAlphaThreshold: number;
    alphaHitTestMinimumThreshold: number;
    useSpriteMesh: boolean;
    mainTexture: Texture;
    hasBorder: boolean;
    pixelsPerUnitMultiplier: number;
    pixelsPerUnit: number;
    material: Material;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    DisableSpriteOptimizations(): void;
    IsRaycastLocationValid(screenPoint: Vector2, eventCamera: Camera): boolean;
    OnAfterDeserialize(): void;
    OnBeforeSerialize(): void;
    SetNativeSize(): void;

}
    
interface ImageConstructor {
    defaultETC1GraphicMaterial: Material;



}
declare const Image: ImageConstructor;
    
interface Animator extends Behaviour {
    isOptimizable: boolean;
    isHuman: boolean;
    hasRootMotion: boolean;
    humanScale: number;
    isInitialized: boolean;
    deltaPosition: Vector3;
    deltaRotation: Quaternion;
    velocity: Vector3;
    angularVelocity: Vector3;
    rootPosition: Vector3;
    rootRotation: Quaternion;
    applyRootMotion: boolean;
    linearVelocityBlending: boolean;
    animatePhysics: boolean;
    updateMode: AnimatorUpdateMode;
    hasTransformHierarchy: boolean;
    gravityWeight: number;
    bodyPosition: Vector3;
    bodyRotation: Quaternion;
    stabilizeFeet: boolean;
    layerCount: number;
    parameters: CSArray<AnimatorControllerParameter>;
    parameterCount: number;
    feetPivotActive: number;
    pivotWeight: number;
    pivotPosition: Vector3;
    isMatchingTarget: boolean;
    speed: number;
    targetPosition: Vector3;
    targetRotation: Quaternion;
    avatarRoot: Transform;
    cullingMode: AnimatorCullingMode;
    playbackTime: number;
    recorderStartTime: number;
    recorderStopTime: number;
    recorderMode: AnimatorRecorderMode;
    runtimeAnimatorController: RuntimeAnimatorController;
    hasBoundPlayables: boolean;
    avatar: Avatar;
    playableGraph: PlayableGraph;
    layersAffectMassCenter: boolean;
    leftFeetBottomHeight: number;
    rightFeetBottomHeight: number;
    logWarnings: boolean;
    fireEvents: boolean;
    keepAnimatorControllerStateOnDisable: boolean;
    keepAnimatorStateOnDisable: boolean;
    writeDefaultValuesOnDisable: boolean;


    /** Apply the default Root Motion. */
    ApplyBuiltinRootMotion(): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number): void;
    /** Creates a crossfade from the current state to any other state using normalized times. */
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void;
    /** Creates a crossfade from the current state to any other state using normalized times. */
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void;
    /** Creates a crossfade from the current state to any other state using times in seconds. */
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number): void;
    /** Creates a crossfade from the current state to any other state using times in seconds. */
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void;
    ForceStateNormalizedTime(normalizedTime: number): void;
    /** Returns an AnimatorTransitionInfo with the informations on the current transition. */
    GetAnimatorTransitionInfo(layerIndex: number): AnimatorTransitionInfo;
    /** Returns the first StateMachineBehaviour that matches type T or is derived from T. Returns null if none are found. */
    GetBehaviour<T>(): T;
    /** Returns all StateMachineBehaviour that match type T or are derived from T. Returns null if none are found. */
    GetBehaviours<T>(): CSArray<T>;
    GetBehaviours(fullPathHash: number, layerIndex: number): CSArray<StateMachineBehaviour>;
    /** Retrieves the Transform mapped to a human bone based on its id. */
    GetBoneTransform(humanBoneId: HumanBodyBones): Transform;
    /** Returns the value of the given boolean parameter. */
    GetBool(name: string): boolean;
    /** Returns the value of the given boolean parameter. */
    GetBool(id: number): boolean;
    /** Gets the list of AnimatorClipInfo currently played by the current state. */
    GetCurrentAnimationClipState(layerIndex: number): CSArray<AnimationInfo>;
    /** Returns an array of all the AnimatorClipInfo in the current state of the given layer. */
    GetCurrentAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    /** Returns the number of AnimatorClipInfo in the current state. */
    GetCurrentAnimatorClipInfoCount(layerIndex: number): number;
    /** Returns an AnimatorStateInfo with the information on the current state. */
    GetCurrentAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    /** Returns the value of the given float parameter. */
    GetFloat(name: string): number;
    /** Returns the value of the given float parameter. */
    GetFloat(id: number): number;
    /** Gets the position of an IK hint. */
    GetIKHintPosition(hint: AvatarIKHint): Vector3;
    /** Gets the translative weight of an IK Hint (0 &#x3D; at the original animation before IK, 1 &#x3D; at the hint). */
    GetIKHintPositionWeight(hint: AvatarIKHint): number;
    /** Gets the position of an IK goal. */
    GetIKPosition(goal: AvatarIKGoal): Vector3;
    /** Gets the translative weight of an IK goal (0 &#x3D; at the original animation before IK, 1 &#x3D; at the goal). */
    GetIKPositionWeight(goal: AvatarIKGoal): number;
    /** Gets the rotation of an IK goal. */
    GetIKRotation(goal: AvatarIKGoal): Quaternion;
    /** Gets the rotational weight of an IK goal (0 &#x3D; rotation before IK, 1 &#x3D; rotation at the IK goal). */
    GetIKRotationWeight(goal: AvatarIKGoal): number;
    /** Returns the value of the given integer parameter. */
    GetInteger(name: string): number;
    /** Returns the value of the given integer parameter. */
    GetInteger(id: number): number;
    /** Returns the index of the layer with the given name. */
    GetLayerIndex(layerName: string): number;
    /** Returns the layer name. */
    GetLayerName(layerIndex: number): string;
    /** Returns the weight of the layer at the specified index. */
    GetLayerWeight(layerIndex: number): number;
    /** Gets the list of AnimatorClipInfo currently played by the next state. */
    GetNextAnimationClipState(layerIndex: number): CSArray<AnimationInfo>;
    /** Returns an array of all the AnimatorClipInfo in the next state of the given layer. */
    GetNextAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetNextAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    /** Returns the number of AnimatorClipInfo in the next state. */
    GetNextAnimatorClipInfoCount(layerIndex: number): number;
    /** Returns an AnimatorStateInfo with the information on the next state. */
    GetNextAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    /** See AnimatorController.parameters. */
    GetParameter(index: number): AnimatorControllerParameter;
    /** Gets the value of a quaternion parameter. */
    GetQuaternion(name: string): Quaternion;
    /** Gets the value of a quaternion parameter. */
    GetQuaternion(id: number): Quaternion;
    /** Gets the value of a vector parameter. */
    GetVector(name: string): Vector3;
    /** Gets the value of a vector parameter. */
    GetVector(id: number): Vector3;
    /** Returns true if the state exists in this layer, false otherwise. */
    HasState(layerIndex: number, stateID: number): boolean;
    /** Interrupts the automatic target matching. */
    InterruptMatchTarget(): void;
    /** Interrupts the automatic target matching. */
    InterruptMatchTarget(completeMatch: boolean): void;
    /** Returns true if the transform is controlled by the Animator\. */
    IsControlled(transform: Transform): boolean;
    /** Returns true if there is a transition on the given layer, false otherwise. */
    IsInTransition(layerIndex: number): boolean;
    /** Returns true if the parameter is controlled by a curve, false otherwise. */
    IsParameterControlledByCurve(name: string): boolean;
    /** Returns true if the parameter is controlled by a curve, false otherwise. */
    IsParameterControlledByCurve(id: number): boolean;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number): void;
    /** Automatically adjust the GameObject position and rotation. */
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number, targetNormalizedTime: number): void;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number, targetNormalizedTime: number, completeMatch: boolean): void;
    Play(stateName: string, layer: number): void;
    Play(stateName: string): void;
    /** Plays a state. */
    Play(stateName: string, layer: number, normalizedTime: number): void;
    /** Plays a state. */
    Play(stateNameHash: number, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number, layer: number): void;
    Play(stateNameHash: number): void;
    PlayInFixedTime(stateName: string, layer: number): void;
    PlayInFixedTime(stateName: string): void;
    /** Plays a state. */
    PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void;
    /** Plays a state. */
    PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number): void;
    PlayInFixedTime(stateNameHash: number): void;
    /** Rebind all the animated properties and mesh data with the Animator. */
    Rebind(): void;
    /** Resets the value of the given trigger parameter. */
    ResetTrigger(name: string): void;
    /** Resets the value of the given trigger parameter. */
    ResetTrigger(id: number): void;
    /** Sets local rotation of a human bone during a IK pass. */
    SetBoneLocalRotation(humanBoneId: HumanBodyBones, rotation: Quaternion): void;
    /** Sets the value of the given boolean parameter. */
    SetBool(name: string, value: boolean): void;
    /** Sets the value of the given boolean parameter. */
    SetBool(id: number, value: boolean): void;
    /** Send float values to the Animator to affect transitions. */
    SetFloat(name: string, value: number): void;
    /** Send float values to the Animator to affect transitions. */
    SetFloat(name: string, value: number, dampTime: number, deltaTime: number): void;
    /** Send float values to the Animator to affect transitions. */
    SetFloat(id: number, value: number): void;
    /** Send float values to the Animator to affect transitions. */
    SetFloat(id: number, value: number, dampTime: number, deltaTime: number): void;
    /** Sets the position of an IK hint. */
    SetIKHintPosition(hint: AvatarIKHint, hintPosition: Vector3): void;
    /** Sets the translative weight of an IK hint (0 &#x3D; at the original animation before IK, 1 &#x3D; at the hint). */
    SetIKHintPositionWeight(hint: AvatarIKHint, value: number): void;
    /** Sets the position of an IK goal. */
    SetIKPosition(goal: AvatarIKGoal, goalPosition: Vector3): void;
    /** Sets the translative weight of an IK goal (0 &#x3D; at the original animation before IK, 1 &#x3D; at the goal). */
    SetIKPositionWeight(goal: AvatarIKGoal, value: number): void;
    /** Sets the rotation of an IK goal. */
    SetIKRotation(goal: AvatarIKGoal, goalRotation: Quaternion): void;
    /** Sets the rotational weight of an IK goal (0 &#x3D; rotation before IK, 1 &#x3D; rotation at the IK goal). */
    SetIKRotationWeight(goal: AvatarIKGoal, value: number): void;
    /** Sets the value of the given integer parameter. */
    SetInteger(name: string, value: number): void;
    /** Sets the value of the given integer parameter. */
    SetInteger(id: number, value: number): void;
    /** Sets the weight of the layer at the given index. */
    SetLayerWeight(layerIndex: number, weight: number): void;
    /** Sets the look at position. */
    SetLookAtPosition(lookAtPosition: Vector3): void;
    /** Set look at weights. */
    SetLookAtWeight(weight: number): void;
    /** Set look at weights. */
    SetLookAtWeight(weight: number, bodyWeight: number): void;
    /** Set look at weights. */
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number): void;
    /** Set look at weights. */
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number): void;
    /** Set look at weights. */
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number, clampWeight: number): void;
    /** Sets the value of a quaternion parameter. */
    SetQuaternion(name: string, value: Quaternion): void;
    /** Sets the value of a quaternion parameter. */
    SetQuaternion(id: number, value: Quaternion): void;
    /** Sets an AvatarTarget and a targetNormalizedTime for the current state. */
    SetTarget(targetIndex: AvatarTarget, targetNormalizedTime: number): void;
    /** Sets the value of the given trigger parameter. */
    SetTrigger(name: string): void;
    /** Sets the value of the given trigger parameter. */
    SetTrigger(id: number): void;
    /** Sets the value of a vector parameter. */
    SetVector(name: string, value: Vector3): void;
    /** Sets the value of a vector parameter. */
    SetVector(id: number, value: Vector3): void;
    /** Sets the animator in playback mode. */
    StartPlayback(): void;
    /** Sets the animator in recording mode, and allocates a circular buffer of size frameCount. */
    StartRecording(frameCount: number): void;
    Stop(): void;
    /** Stops the animator playback mode. When playback stops, the avatar resumes getting control from game logic. */
    StopPlayback(): void;
    /** Stops animator record mode. */
    StopRecording(): void;
    /** Evaluates the animator based on deltaTime. */
    Update(deltaTime: number): void;
    /** Forces a write of the default values stored in the animator. */
    WriteDefaultValues(): void;

}
    
interface AnimatorControllerParameter {
    name: string;
    nameHash: number;
    type: AnimatorControllerParameterType;
    defaultFloat: number;
    defaultInt: number;
    defaultBool: boolean;


    Equals(o: unknown): boolean;
    GetHashCode(): number;

}
    
interface AnimatorControllerParameterConstructor {

    new(): AnimatorControllerParameter;


}
declare const AnimatorControllerParameter: AnimatorControllerParameterConstructor;
    
interface RuntimeAnimatorController extends Object {
    animationClips: CSArray<AnimationClip>;



}
    
interface Motion extends Object {
    averageDuration: number;
    averageAngularSpeed: number;
    averageSpeed: Vector3;
    apparentSpeed: number;
    isLooping: boolean;
    legacy: boolean;
    isHumanMotion: boolean;
    isAnimatorMotion: boolean;


    ValidateIfRetargetable(val: boolean): boolean;

}
    
interface AnimationClip extends Motion {
    length: number;
    frameRate: number;
    wrapMode: WrapMode;
    localBounds: Bounds;
    legacy: boolean;
    humanMotion: boolean;
    empty: boolean;
    hasGenericRootTransform: boolean;
    hasMotionFloatCurves: boolean;
    hasMotionCurves: boolean;
    hasRootCurves: boolean;
    events: CSArray<AnimationEvent>;


    /** Adds an animation event to the clip. */
    AddEvent(evt: AnimationEvent): void;
    /** Clears all curves from the clip. */
    ClearCurves(): void;
    /** Realigns quaternion keys to ensure shortest interpolation paths. */
    EnsureQuaternionContinuity(): void;
    /** Samples an animation at a given time for any animated properties. */
    SampleAnimation(go: GameObject, time: number): void;
    /** Assigns the curve to animate a specific property. */
    SetCurve(relativePath: string, type: unknown, propertyName: string, curve: AnimationCurve): void;

}
    
interface AnimationEvent {
    data: string;
    stringParameter: string;
    floatParameter: number;
    intParameter: number;
    objectReferenceParameter: Object;
    functionName: string;
    time: number;
    messageOptions: SendMessageOptions;
    isFiredByLegacy: boolean;
    isFiredByAnimator: boolean;
    animationState: AnimationState;
    animatorStateInfo: AnimatorStateInfo;
    animatorClipInfo: AnimatorClipInfo;



}
    
interface TrackedReference {


    Equals(o: unknown): boolean;
    GetHashCode(): number;

}
    
interface AnimationState extends TrackedReference {
    enabled: boolean;
    weight: number;
    wrapMode: WrapMode;
    time: number;
    normalizedTime: number;
    speed: number;
    normalizedSpeed: number;
    length: number;
    layer: number;
    clip: AnimationClip;
    name: string;
    blendMode: AnimationBlendMode;


    /** Adds a transform which should be animated. This allows you to reduce the number of animations you have to create. */
    AddMixingTransform(mix: Transform): void;
    /** Adds a transform which should be animated. This allows you to reduce the number of animations you have to create. */
    AddMixingTransform(mix: Transform, recursive: boolean): void;
    /** Removes a transform which should be animated. */
    RemoveMixingTransform(mix: Transform): void;

}
    
interface AnimationStateConstructor {

    new(): AnimationState;


}
declare const AnimationState: AnimationStateConstructor;
    
interface AnimatorStateInfo {
    fullPathHash: number;
    nameHash: number;
    shortNameHash: number;
    normalizedTime: number;
    length: number;
    speed: number;
    speedMultiplier: number;
    tagHash: number;
    loop: boolean;


    /** Does name match the name of the active state in the statemachine? */
    IsName(name: string): boolean;
    /** Does tag match the tag of the active state in the statemachine. */
    IsTag(tag: string): boolean;

}
    
interface AnimatorClipInfo {
    clip: AnimationClip;
    weight: number;



}
    
interface AnimationEventConstructor {

    new(): AnimationEvent;


}
declare const AnimationEvent: AnimationEventConstructor;
    
interface AnimationCurve {
    keys: CSArray<Keyframe>;
    Item: Keyframe;
    length: number;
    preWrapMode: WrapMode;
    postWrapMode: WrapMode;


    /** Add a new key to the curve. */
    AddKey(time: number, value: number): number;
    /** Add a new key to the curve. */
    AddKey(key: Keyframe): number;
    /** Erases all KeyFrame from this instance of the AnimationCurve. */
    ClearKeys(): void;
    /** Copies the keys and properties of the specified AnimationCurve object into this instance of the  AnimationCurve class. */
    CopyFrom(other: AnimationCurve): void;
    Equals(o: unknown): boolean;
    Equals(other: AnimationCurve): boolean;
    /** Evaluate the curve at time. */
    Evaluate(time: number): number;
    /** A HashCode for the animation curve, computed using all individual Keyframe. */
    GetHashCode(): number;
    /** Removes the keyframe at index and inserts key. */
    MoveKey(index: number, key: Keyframe): number;
    /** Removes a key. */
    RemoveKey(index: number): void;
    /** Smooth the in and out tangents of the keyframe at index. */
    SmoothTangents(index: number, weight: number): void;

}
    
interface Keyframe {
    time: number;
    value: number;
    inTangent: number;
    outTangent: number;
    inWeight: number;
    outWeight: number;
    weightedMode: WeightedMode;
    tangentMode: number;



}
    
interface KeyframeConstructor {

    new(time: number, value: number): Keyframe;
    new(time: number, value: number, inTangent: number, outTangent: number): Keyframe;
    new(time: number, value: number, inTangent: number, outTangent: number, inWeight: number, outWeight: number): Keyframe;


}
declare const Keyframe: KeyframeConstructor;
    
interface AnimationCurveConstructor {

    new(keys: CSArray<Keyframe>): AnimationCurve;
    new(): AnimationCurve;


    Constant(timeStart: number, timeEnd: number, value: number): AnimationCurve;
    EaseInOut(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve;
    Linear(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve;
}
declare const AnimationCurve: AnimationCurveConstructor;
    
interface AnimationClipConstructor {

    new(): AnimationClip;


}
declare const AnimationClip: AnimationClipConstructor;
    
interface Avatar extends Object {
    isValid: boolean;
    isHuman: boolean;
    humanDescription: HumanDescription;



}
    
interface HumanDescription {
    human: CSArray<HumanBone>;
    skeleton: CSArray<SkeletonBone>;
    upperArmTwist: number;
    lowerArmTwist: number;
    upperLegTwist: number;
    lowerLegTwist: number;
    armStretch: number;
    legStretch: number;
    feetSpacing: number;
    hasTranslationDoF: boolean;



}
    
interface HumanBone {
    limit: HumanLimit;
    boneName: string;
    humanName: string;



}
    
interface HumanLimit {
    useDefaultValues: boolean;
    min: Vector3;
    max: Vector3;
    center: Vector3;
    axisLength: number;



}
    
interface SkeletonBone {
    name: string;
    position: Vector3;
    rotation: Quaternion;
    scale: Vector3;
    transformModified: number;



}
    
interface PlayableGraph {


    Connect<U, V>(source: U, sourceOutputPort: number, destination: V, destinationInputPort: number): boolean;
    /** Destroys the graph. */
    Destroy(): void;
    DestroyOutput<U>(output: U): void;
    DestroyPlayable<U>(playable: U): void;
    DestroySubgraph<U>(playable: U): void;
    Disconnect<U>(input: U, inputPort: number): void;
    /** Evaluates all the PlayableOutputs in the graph, and updates all the connected Playables in the graph. */
    Evaluate(): void;
    /** Evaluates all the PlayableOutputs in the graph, and updates all the connected Playables in the graph. */
    Evaluate(deltaTime: number): void;
    /** Returns the name of the PlayableGraph. */
    GetEditorName(): string;
    /** Get PlayableOutput at the given index in the graph. */
    GetOutput(index: number): PlayableOutput;
    /** Get PlayableOutput of the requested type at the given index in the graph. */
    GetOutputByType<T>(index: number): PlayableOutput;
    /** Returns the number of PlayableOutput in the graph. */
    GetOutputCount(): number;
    /** Get the number of PlayableOutput of the requested type in the graph. */
    GetOutputCountByType<T>(): number;
    /** Returns the number of Playable owned by the Graph. */
    GetPlayableCount(): number;
    /** Returns the table used by the graph to resolve ExposedReferences. */
    GetResolver(): IExposedPropertyTable;
    /** Returns the Playable with no output connections at the given index. */
    GetRootPlayable(index: number): Playable;
    /** Returns the number of Playable owned by the Graph that have no connected outputs. */
    GetRootPlayableCount(): number;
    /** Returns how time is incremented when playing back. */
    GetTimeUpdateMode(): DirectorUpdateMode;
    /** Indicates that a graph has completed its operations. */
    IsDone(): boolean;
    /** Indicates that a graph is presently running. */
    IsPlaying(): boolean;
    /** Returns true if the PlayableGraph has been properly constructed using PlayableGraph.CreateGraph and is not deleted. */
    IsValid(): boolean;
    /** Plays the graph. */
    Play(): void;
    /** Changes the table used by the graph to resolve ExposedReferences. */
    SetResolver(value: IExposedPropertyTable): void;
    /** Changes how time is incremented when playing back. */
    SetTimeUpdateMode(value: DirectorUpdateMode): void;
    /** Stops the graph, if it is playing. */
    Stop(): void;

}
    
interface IPlayableOutput {


    GetHandle(): PlayableOutputHandle;

}
    
interface PlayableOutputHandle {


    Equals(p: unknown): boolean;
    Equals(other: PlayableOutputHandle): boolean;
    GetHashCode(): number;

}
    
interface PlayableOutputHandleConstructor {
    Null: PlayableOutputHandle;



}
declare const PlayableOutputHandle: PlayableOutputHandleConstructor;
    
interface PlayableOutput extends IPlayableOutput {


    Equals(other: PlayableOutput): boolean;
    GetHandle(): PlayableOutputHandle;
    GetPlayableOutputType(): unknown;
    IsPlayableOutputOfType<T>(): boolean;

}
    
interface PlayableOutputConstructor {
    Null: PlayableOutput;



}
declare const PlayableOutput: PlayableOutputConstructor;
    
interface IExposedPropertyTable {


    /** Remove a value for the given reference. */
    ClearReferenceValue(id: PropertyName): void;
    /** Retrieves a value for the given identifier. */
    GetReferenceValue(id: PropertyName, idValid: unknown): Object;
    /** Assigns a value for an ExposedReference. */
    SetReferenceValue(id: PropertyName, value: Object): void;

}
    
interface PropertyName {


    /** Determines whether this instance and a specified object, which must also be a PropertyName object, have the same value. */
    Equals(other: unknown): boolean;
    Equals(other: PropertyName): boolean;
    /** Returns the hash code for this PropertyName. */
    GetHashCode(): number;
    /** For debugging purposes only. Returns the string value representing the string in the Editor.
Returns &quot;UnityEngine.PropertyName&quot; in the player. */
    ToString(): string;

}
    
interface PropertyNameConstructor {

    new(name: string): PropertyName;
    new(other: PropertyName): PropertyName;
    new(id: number): PropertyName;


    IsNullOrEmpty(prop: PropertyName): boolean;
}
declare const PropertyName: PropertyNameConstructor;
    
interface IPlayable {


    GetHandle(): PlayableHandle;

}
    
interface PlayableHandle {


    Equals(p: unknown): boolean;
    Equals(other: PlayableHandle): boolean;
    GetHashCode(): number;

}
    
interface PlayableHandleConstructor {
    Null: PlayableHandle;



}
declare const PlayableHandle: PlayableHandleConstructor;
    
interface Playable extends IPlayable {


    Equals(other: Playable): boolean;
    GetHandle(): PlayableHandle;
    GetPlayableType(): unknown;
    IsPlayableOfType<T>(): boolean;

}
    
interface PlayableConstructor {
    Null: Playable;



    Create(graph: PlayableGraph, inputCount: number): Playable;
}
declare const Playable: PlayableConstructor;
    
interface PlayableGraphConstructor {



    Create(): PlayableGraph;
    Create(name: string): PlayableGraph;
}
declare const PlayableGraph: PlayableGraphConstructor;
    
interface AnimatorTransitionInfo {
    fullPathHash: number;
    nameHash: number;
    userNameHash: number;
    durationUnit: DurationUnit;
    duration: number;
    normalizedTime: number;
    anyState: boolean;


    /** Does name match the name of the active Transition. */
    IsName(name: string): boolean;
    /** Does userName match the name of the active Transition. */
    IsUserName(name: string): boolean;

}
    
interface StateMachineBehaviour extends ScriptableObject {


    OnStateEnter(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateEnter(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateExit(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateExit(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateIK(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateIK(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    /** Called on the first Update frame when making a transition to a state machine. This is not called when making a transition into a state machine sub-state. */
    OnStateMachineEnter(animator: Animator, stateMachinePathHash: number): void;
    OnStateMachineEnter(animator: Animator, stateMachinePathHash: number, controller: AnimatorControllerPlayable): void;
    /** Called on the last Update frame when making a transition out of a StateMachine. This is not called when making a transition into a StateMachine sub-state. */
    OnStateMachineExit(animator: Animator, stateMachinePathHash: number): void;
    OnStateMachineExit(animator: Animator, stateMachinePathHash: number, controller: AnimatorControllerPlayable): void;
    OnStateMove(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateMove(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateUpdate(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateUpdate(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;

}
    
interface AnimatorControllerPlayable extends IPlayable {


    CrossFade(stateName: string, transitionDuration: number): void;
    CrossFade(stateName: string, transitionDuration: number, layer: number): void;
    CrossFade(stateName: string, transitionDuration: number, layer: number, normalizedTime: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number, layer: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number, layer: number, normalizedTime: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number, layer: number, fixedTime: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number, layer: number, fixedTime: number): void;
    Equals(other: AnimatorControllerPlayable): boolean;
    /** Returns an AnimatorTransitionInfo with the informations on the current transition. */
    GetAnimatorTransitionInfo(layerIndex: number): AnimatorTransitionInfo;
    /** Returns the value of the given boolean parameter. */
    GetBool(name: string): boolean;
    /** Returns the value of the given boolean parameter. */
    GetBool(id: number): boolean;
    /** Returns an array of all the AnimatorClipInfo in the current state of the given layer. */
    GetCurrentAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    /** Returns the number of AnimatorClipInfo in the current state. */
    GetCurrentAnimatorClipInfoCount(layerIndex: number): number;
    /** Returns an AnimatorStateInfo with the information on the current state. */
    GetCurrentAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    /** Returns the value of the given float parameter. */
    GetFloat(name: string): number;
    /** Returns the value of the given float parameter. */
    GetFloat(id: number): number;
    GetHandle(): PlayableHandle;
    /** Returns the value of the given integer parameter. */
    GetInteger(name: string): number;
    /** Returns the value of the given integer parameter. */
    GetInteger(id: number): number;
    GetLayerCount(): number;
    /** Returns the index of the layer with the given name. */
    GetLayerIndex(layerName: string): number;
    /** Returns the layer name. */
    GetLayerName(layerIndex: number): string;
    /** Returns the weight of the layer at the specified index. */
    GetLayerWeight(layerIndex: number): number;
    GetNextAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    /** Returns an array of all the AnimatorClipInfo in the next state of the given layer. */
    GetNextAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    /** Returns the number of AnimatorClipInfo in the next state. */
    GetNextAnimatorClipInfoCount(layerIndex: number): number;
    /** Returns an AnimatorStateInfo with the information on the next state. */
    GetNextAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    /** See AnimatorController.parameters. */
    GetParameter(index: number): AnimatorControllerParameter;
    GetParameterCount(): number;
    /** Returns true if the state exists in this layer, false otherwise. */
    HasState(layerIndex: number, stateID: number): boolean;
    /** Returns true if there is a transition on the given layer, false otherwise. */
    IsInTransition(layerIndex: number): boolean;
    /** Returns true if the parameter is controlled by a curve, false otherwise. */
    IsParameterControlledByCurve(name: string): boolean;
    /** Returns true if the parameter is controlled by a curve, false otherwise. */
    IsParameterControlledByCurve(id: number): boolean;
    Play(stateName: string): void;
    Play(stateName: string, layer: number): void;
    /** Plays a state. */
    Play(stateName: string, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number): void;
    Play(stateNameHash: number, layer: number): void;
    /** Plays a state. */
    Play(stateNameHash: number, layer: number, normalizedTime: number): void;
    PlayInFixedTime(stateName: string): void;
    PlayInFixedTime(stateName: string, layer: number): void;
    /** Plays a state. */
    PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number): void;
    /** Plays a state. */
    PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void;
    /** Resets the value of the given trigger parameter. */
    ResetTrigger(name: string): void;
    /** Resets the value of the given trigger parameter. */
    ResetTrigger(id: number): void;
    /** Sets the value of the given boolean parameter. */
    SetBool(name: string, value: boolean): void;
    /** Sets the value of the given boolean parameter. */
    SetBool(id: number, value: boolean): void;
    /** Send float values to the AnimatorController to affect transitions. */
    SetFloat(name: string, value: number): void;
    /** Send float values to the AnimatorController to affect transitions. */
    SetFloat(id: number, value: number): void;
    SetHandle(handle: PlayableHandle): void;
    /** Sets the value of the given integer parameter. */
    SetInteger(name: string, value: number): void;
    /** Sets the value of the given integer parameter. */
    SetInteger(id: number, value: number): void;
    /** Sets the weight of the layer at the given index. */
    SetLayerWeight(layerIndex: number, weight: number): void;
    /** Sets the value of the given trigger parameter. */
    SetTrigger(name: string): void;
    /** Sets the value of the given trigger parameter. */
    SetTrigger(id: number): void;

}
    
interface AnimatorControllerPlayableConstructor {
    Null: AnimatorControllerPlayable;



    Create(graph: PlayableGraph, controller: RuntimeAnimatorController): AnimatorControllerPlayable;
}
declare const AnimatorControllerPlayable: AnimatorControllerPlayableConstructor;
    
interface AnimationInfo {
    clip: AnimationClip;
    weight: number;



}
    
interface MatchTargetWeightMask {
    positionXYZWeight: Vector3;
    rotationWeight: number;



}
    
interface MatchTargetWeightMaskConstructor {

    new(positionXYZWeight: Vector3, rotationWeight: number): MatchTargetWeightMask;


}
declare const MatchTargetWeightMask: MatchTargetWeightMaskConstructor;
    
interface AnimatorConstructor {

    new(): Animator;


    StringToHash(name: string): number;
}
declare const Animator: AnimatorConstructor;
    
interface SelectableConstructor {
    allSelectablesArray: CSArray<Selectable>;
    allSelectableCount: number;
    allSelectables: CSArray<Selectable>;



    AllSelectablesNoAlloc(selectables: CSArray<Selectable>): number;
}
declare const Selectable: SelectableConstructor;
    
interface Button extends Selectable, ISubmitHandler, IPointerClickHandler {
    onClick: ButtonClickedEvent;


    OnPointerClick(eventData: PointerEventData): void;
    OnSubmit(eventData: BaseEventData): void;

}
    
interface UnityEventBase extends ISerializationCallbackReceiver {


    /** Get the number of registered persistent listeners. */
    GetPersistentEventCount(): number;
    /** Returns the execution state of a persistent listener. */
    GetPersistentListenerState(index: number): UnityEventCallState;
    /** Get the target method name of the listener at index index. */
    GetPersistentMethodName(index: number): string;
    /** Get the target component of the listener at index index. */
    GetPersistentTarget(index: number): Object;
    /** Remove all non-persistent (ie created from script) listeners  from the event. */
    RemoveAllListeners(): void;
    /** Modify the execution state of a persistent listener. */
    SetPersistentListenerState(index: number, state: UnityEventCallState): void;
    ToString(): string;

}
    
interface UnityEventBaseConstructor {



    GetValidMethodInfo(obj: unknown, functionName: string, argumentTypes: CSArray<unknown>): unknown;
    GetValidMethodInfo(objectType: unknown, functionName: string, argumentTypes: CSArray<unknown>): unknown;
}
declare const UnityEventBase: UnityEventBaseConstructor;
    
interface UnityEvent extends UnityEventBase {


    /** Add a non persistent listener to the UnityEvent. */
    AddListener(call: UnityAction): void;
    /** Invoke all registered callbacks (runtime and persistent). */
    Invoke(): void;
    /** Remove a non persistent listener from the UnityEvent. If you have added the same listener multiple times, this method will remove all occurrences of it. */
    RemoveListener(call: UnityAction): void;

}
    
interface UnityEventConstructor {

    new(): UnityEvent;


}
declare const UnityEvent: UnityEventConstructor;
    
interface ButtonClickedEvent extends UnityEvent {



}
    
interface ButtonClickedEventConstructor {

    new(): ButtonClickedEvent;


}
declare const ButtonClickedEvent: ButtonClickedEventConstructor;
    
interface MeshRenderer extends Renderer {
    additionalVertexStreams: Mesh;
    enlightenVertexStream: Mesh;
    subMeshStartIndex: number;
    scaleInLightmap: number;
    receiveGI: ReceiveGI;
    stitchLightmapSeams: boolean;



}
    
interface MeshRendererConstructor {

    new(): MeshRenderer;


}
declare const MeshRenderer: MeshRendererConstructor;
    
interface MeshFilter extends Component {
    sharedMesh: Mesh;
    mesh: Mesh;



}
    
interface MeshFilterConstructor {

    new(): MeshFilter;


}
declare const MeshFilter: MeshFilterConstructor;
    
interface TMP_Text extends MaskableGraphic {
    text: string;
    textPreprocessor: ITextPreprocessor;
    isRightToLeftText: boolean;
    font: TMP_FontAsset;
    fontSharedMaterial: Material;
    fontSharedMaterials: CSArray<Material>;
    fontMaterial: Material;
    fontMaterials: CSArray<Material>;
    color: Color;
    alpha: number;
    enableVertexGradient: boolean;
    colorGradient: VertexGradient;
    colorGradientPreset: TMP_ColorGradient;
    spriteAsset: TMP_SpriteAsset;
    tintAllSprites: boolean;
    styleSheet: TMP_StyleSheet;
    textStyle: TMP_Style;
    overrideColorTags: boolean;
    faceColor: Color32;
    outlineColor: Color32;
    outlineWidth: number;
    fontSize: number;
    fontWeight: FontWeight;
    pixelsPerUnit: number;
    enableAutoSizing: boolean;
    fontSizeMin: number;
    fontSizeMax: number;
    fontStyle: FontStyles;
    isUsingBold: boolean;
    horizontalAlignment: HorizontalAlignmentOptions;
    verticalAlignment: VerticalAlignmentOptions;
    alignment: TextAlignmentOptions;
    characterSpacing: number;
    wordSpacing: number;
    lineSpacing: number;
    lineSpacingAdjustment: number;
    paragraphSpacing: number;
    characterWidthAdjustment: number;
    textWrappingMode: TextWrappingModes;
    enableWordWrapping: boolean;
    wordWrappingRatios: number;
    overflowMode: TextOverflowModes;
    isTextOverflowing: boolean;
    firstOverflowCharacterIndex: number;
    linkedTextComponent: TMP_Text;
    isTextTruncated: boolean;
    enableKerning: boolean;
    fontFeatures: CSArray<OTL_FeatureTag>;
    extraPadding: boolean;
    richText: boolean;
    emojiFallbackSupport: boolean;
    parseCtrlCharacters: boolean;
    isOverlay: boolean;
    isOrthographic: boolean;
    enableCulling: boolean;
    ignoreVisibility: boolean;
    horizontalMapping: TextureMappingOptions;
    verticalMapping: TextureMappingOptions;
    mappingUvLineOffset: number;
    renderMode: TextRenderFlags;
    geometrySortingOrder: VertexSortingOrder;
    isTextObjectScaleStatic: boolean;
    vertexBufferAutoSizeReduction: boolean;
    firstVisibleCharacter: number;
    maxVisibleCharacters: number;
    maxVisibleWords: number;
    maxVisibleLines: number;
    useMaxVisibleDescender: boolean;
    pageToDisplay: number;
    margin: Vector4;
    textInfo: TMP_TextInfo;
    havePropertiesChanged: boolean;
    isUsingLegacyAnimationComponent: boolean;
    transform: Transform;
    rectTransform: RectTransform;
    autoSizeTextContainer: boolean;
    mesh: Mesh;
    isVolumetricText: boolean;
    bounds: Bounds;
    textBounds: Bounds;
    flexibleHeight: number;
    flexibleWidth: number;
    minWidth: number;
    minHeight: number;
    maxWidth: number;
    maxHeight: number;
    preferredWidth: number;
    preferredHeight: number;
    renderedWidth: number;
    renderedHeight: number;
    layoutPriority: number;


    ClearMesh(): void;
    ClearMesh(uploadGeometry: boolean): void;
    ComputeMarginSize(): void;
    CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void;
    ForceMeshUpdate(ignoreActiveState: boolean, forceTextReparsing: boolean): void;
    GetParsedText(): string;
    GetPreferredValues(): Vector2;
    GetPreferredValues(width: number, height: number): Vector2;
    GetPreferredValues(text: string): Vector2;
    GetPreferredValues(text: string, width: number, height: number): Vector2;
    GetRenderedValues(): Vector2;
    GetRenderedValues(onlyVisibleCharacters: boolean): Vector2;
    GetTextInfo(text: string): TMP_TextInfo;
    SetCharArray(sourceText: CSArray<string>): void;
    SetCharArray(sourceText: CSArray<string>, start: number, length: number): void;
    SetText(sourceText: string): void;
    SetText(sourceText: string, syncTextInputBox: boolean): void;
    SetText(sourceText: string, arg0: number): void;
    SetText(sourceText: string, arg0: number, arg1: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
    SetText(sourceText: unknown): void;
    SetText(sourceText: CSArray<string>): void;
    SetText(sourceText: CSArray<string>, start: number, length: number): void;
    SetVertices(vertices: CSArray<Vector3>): void;
    UpdateGeometry(mesh: Mesh, index: number): void;
    UpdateMeshPadding(): void;
    UpdateVertexData(flags: TMP_VertexDataUpdateFlags): void;
    UpdateVertexData(): void;

}
    
interface ITextPreprocessor {


    PreprocessText(text: string): string;

}
    
interface TMP_Asset extends ScriptableObject {
    version: string;
    instanceID: number;
    hashCode: number;
    faceInfo: FaceInfo;
    material: Material;
    materialHashCode: number;



}
    
interface FaceInfo {
    familyName: string;
    styleName: string;
    pointSize: number;
    scale: number;
    lineHeight: number;
    ascentLine: number;
    capLine: number;
    meanLine: number;
    baseline: number;
    descentLine: number;
    superscriptOffset: number;
    superscriptSize: number;
    subscriptOffset: number;
    subscriptSize: number;
    underlineOffset: number;
    underlineThickness: number;
    strikethroughOffset: number;
    strikethroughThickness: number;
    tabWidth: number;


    /** Compares the information in this FaceInfo structure with the information in the given FaceInfo structure to determine whether they have the same values. */
    Compare(other: FaceInfo): boolean;

}
    
interface TMP_FontAsset extends TMP_Asset {
    normalStyle: number;
    normalSpacingOffset: number;
    boldStyle: number;
    boldSpacing: number;
    italicStyle: number;
    tabSize: number;
    atlas: Texture2D;
    creationSettings: FontAssetCreationSettings;
    sourceFontFile: Font;
    atlasPopulationMode: AtlasPopulationMode;
    glyphTable: CSArray<Glyph>;
    glyphLookupTable: CSDictionary<number, Glyph>;
    characterTable: CSArray<TMP_Character>;
    characterLookupTable: CSDictionary<number, TMP_Character>;
    atlasTexture: Texture2D;
    atlasTextures: CSArray<Texture2D>;
    atlasTextureCount: number;
    isMultiAtlasTexturesEnabled: boolean;
    getFontFeatures: boolean;
    atlasWidth: number;
    atlasHeight: number;
    atlasPadding: number;
    atlasRenderMode: GlyphRenderMode;
    fontFeatureTable: TMP_FontFeatureTable;
    fallbackFontAssetTable: CSArray<TMP_FontAsset>;
    fontWeightTable: CSArray<TMP_FontWeightPair>;
    fontInfo: FaceInfo_Legacy;


    ClearFontAssetData(setAtlasSizeToZero: boolean): void;
    HasCharacter(character: number): boolean;
    HasCharacter(character: string, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<string>): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<number>, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string): boolean;
    ReadFontAssetDefinition(): void;
    TryAddCharacters(unicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(unicodes: CSArray<number>, missingUnicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, missingCharacters: CSArray<string>, includeFontFeatures: boolean): boolean;

}
    
interface FontAssetCreationSettings {
    sourceFontFileName: string;
    sourceFontFileGUID: string;
    faceIndex: number;
    pointSizeSamplingMode: number;
    pointSize: number;
    padding: number;
    paddingMode: number;
    packingMode: number;
    atlasWidth: number;
    atlasHeight: number;
    characterSetSelectionMode: number;
    characterSequence: string;
    referencedFontAssetGUID: string;
    referencedTextAssetGUID: string;
    fontStyle: number;
    fontStyleModifier: number;
    renderMode: number;
    includeFontFeatures: boolean;



}
    
interface Font extends Object {
    material: Material;
    fontNames: CSArray<string>;
    dynamic: boolean;
    ascent: number;
    fontSize: number;
    characterInfo: CSArray<CharacterInfo>;
    lineHeight: number;
    textureRebuildCallback: FontTextureRebuildCallback;


    /** Get rendering info for a specific character. */
    GetCharacterInfo(ch: string, info: unknown, size: number, style: FontStyle): boolean;
    /** Get rendering info for a specific character. */
    GetCharacterInfo(ch: string, info: unknown, size: number): boolean;
    /** Get rendering info for a specific character. */
    GetCharacterInfo(ch: string, info: unknown): boolean;
    /** Does this font have a specific character? */
    HasCharacter(c: string): boolean;
    /** Request characters to be added to the font texture (dynamic fonts only). */
    RequestCharactersInTexture(characters: string, size: number, style: FontStyle): void;
    RequestCharactersInTexture(characters: string, size: number): void;
    RequestCharactersInTexture(characters: string): void;

}
    
interface CharacterInfo {
    index: number;
    uv: Rect;
    vert: Rect;
    width: number;
    size: number;
    style: FontStyle;
    flipped: boolean;
    advance: number;
    glyphWidth: number;
    glyphHeight: number;
    bearing: number;
    minY: number;
    maxY: number;
    minX: number;
    maxX: number;
    uvBottomLeft: Vector2;
    uvBottomRight: Vector2;
    uvTopRight: Vector2;
    uvTopLeft: Vector2;



}
    
interface FontTextureRebuildCallback {


    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;

}
    
interface FontTextureRebuildCallbackConstructor {

    new(object: unknown, method: unknown): FontTextureRebuildCallback;


}
declare const FontTextureRebuildCallback: FontTextureRebuildCallbackConstructor;
    
interface FontConstructor {

    new(): Font;
    new(name: string): Font;


    CreateDynamicFontFromOSFont(fontname: string, size: number): Font;
    CreateDynamicFontFromOSFont(fontnames: CSArray<string>, size: number): Font;
    GetMaxVertsForString(str: string): number;
    GetOSInstalledFontNames(): CSArray<string>;
    GetPathsToOSFonts(): CSArray<string>;
}
declare const Font: FontConstructor;
    
interface Glyph {
    index: number;
    metrics: GlyphMetrics;
    glyphRect: GlyphRect;
    scale: number;
    atlasIndex: number;
    classDefinitionType: GlyphClassDefinitionType;


    /** Compares two glyphs to determine if they have the same values. */
    Compare(other: Glyph): boolean;

}
    
interface GlyphMetrics {
    width: number;
    height: number;
    horizontalBearingX: number;
    horizontalBearingY: number;
    horizontalAdvance: number;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphMetrics): boolean;
    GetHashCode(): number;

}
    
interface GlyphMetricsConstructor {

    new(width: number, height: number, bearingX: number, bearingY: number, advance: number): GlyphMetrics;


}
declare const GlyphMetrics: GlyphMetricsConstructor;
    
interface GlyphRect {
    x: number;
    y: number;
    width: number;
    height: number;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphRect): boolean;
    GetHashCode(): number;

}
    
interface GlyphRectConstructor {
    zero: GlyphRect;

    new(x: number, y: number, width: number, height: number): GlyphRect;
    new(rect: Rect): GlyphRect;


}
declare const GlyphRect: GlyphRectConstructor;
    
interface GlyphConstructor {

    new(): Glyph;
    new(glyph: Glyph): Glyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect): Glyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number): Glyph;


}
declare const Glyph: GlyphConstructor;
    
interface TMP_TextElement {
    elementType: TextElementType;
    unicode: number;
    textAsset: TMP_Asset;
    glyph: Glyph;
    glyphIndex: number;
    scale: number;



}
    
interface TMP_TextElementConstructor {

    new(): TMP_TextElement;


}
declare const TMP_TextElement: TMP_TextElementConstructor;
    
interface TMP_Character extends TMP_TextElement {



}
    
interface TMP_CharacterConstructor {

    new(): TMP_Character;
    new(unicode: number, glyph: Glyph): TMP_Character;
    new(unicode: number, fontAsset: TMP_FontAsset, glyph: Glyph): TMP_Character;


}
declare const TMP_Character: TMP_CharacterConstructor;
    
interface TMP_FontFeatureTable {
    multipleSubstitutionRecords: CSArray<MultipleSubstitutionRecord>;
    ligatureRecords: CSArray<LigatureSubstitutionRecord>;
    glyphPairAdjustmentRecords: CSArray<GlyphPairAdjustmentRecord>;
    MarkToBaseAdjustmentRecords: CSArray<MarkToBaseAdjustmentRecord>;
    MarkToMarkAdjustmentRecords: CSArray<MarkToMarkAdjustmentRecord>;


    SortGlyphPairAdjustmentRecords(): void;
    SortMarkToBaseAdjustmentRecords(): void;
    SortMarkToMarkAdjustmentRecords(): void;

}
    
interface MultipleSubstitutionRecord {
    targetGlyphID: number;
    substituteGlyphIDs: CSArray<number>;



}
    
interface LigatureSubstitutionRecord {
    componentGlyphIDs: CSArray<number>;
    ligatureGlyphID: number;



}
    
interface GlyphPairAdjustmentRecord {
    firstAdjustmentRecord: GlyphAdjustmentRecord;
    secondAdjustmentRecord: GlyphAdjustmentRecord;
    featureLookupFlags: FontFeatureLookupFlags;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphPairAdjustmentRecord): boolean;
    GetHashCode(): number;

}
    
interface GlyphAdjustmentRecord {
    glyphIndex: number;
    glyphValueRecord: GlyphValueRecord;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphAdjustmentRecord): boolean;
    GetHashCode(): number;

}
    
interface GlyphValueRecord {
    xPlacement: number;
    yPlacement: number;
    xAdvance: number;
    yAdvance: number;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphValueRecord): boolean;
    GetHashCode(): number;

}
    
interface GlyphValueRecordConstructor {

    new(xPlacement: number, yPlacement: number, xAdvance: number, yAdvance: number): GlyphValueRecord;


}
declare const GlyphValueRecord: GlyphValueRecordConstructor;
    
interface GlyphAdjustmentRecordConstructor {

    new(glyphIndex: number, glyphValueRecord: GlyphValueRecord): GlyphAdjustmentRecord;


}
declare const GlyphAdjustmentRecord: GlyphAdjustmentRecordConstructor;
    
interface GlyphPairAdjustmentRecordConstructor {

    new(firstAdjustmentRecord: GlyphAdjustmentRecord, secondAdjustmentRecord: GlyphAdjustmentRecord): GlyphPairAdjustmentRecord;


}
declare const GlyphPairAdjustmentRecord: GlyphPairAdjustmentRecordConstructor;
    
interface MarkToBaseAdjustmentRecord {
    baseGlyphID: number;
    baseGlyphAnchorPoint: GlyphAnchorPoint;
    markGlyphID: number;
    markPositionAdjustment: MarkPositionAdjustment;



}
    
interface GlyphAnchorPoint {
    xCoordinate: number;
    yCoordinate: number;



}
    
interface MarkPositionAdjustment {
    xPositionAdjustment: number;
    yPositionAdjustment: number;



}
    
interface MarkPositionAdjustmentConstructor {

    new(x: number, y: number): MarkPositionAdjustment;


}
declare const MarkPositionAdjustment: MarkPositionAdjustmentConstructor;
    
interface MarkToMarkAdjustmentRecord {
    baseMarkGlyphID: number;
    baseMarkGlyphAnchorPoint: GlyphAnchorPoint;
    combiningMarkGlyphID: number;
    combiningMarkPositionAdjustment: MarkPositionAdjustment;



}
    
interface TMP_FontFeatureTableConstructor {

    new(): TMP_FontFeatureTable;


}
declare const TMP_FontFeatureTable: TMP_FontFeatureTableConstructor;
    
interface TMP_FontWeightPair {
    regularTypeface: TMP_FontAsset;
    italicTypeface: TMP_FontAsset;



}
    
interface FaceInfo_Legacy {
    Name: string;
    PointSize: number;
    Scale: number;
    CharacterCount: number;
    LineHeight: number;
    Baseline: number;
    Ascender: number;
    CapHeight: number;
    Descender: number;
    CenterLine: number;
    SuperscriptOffset: number;
    SubscriptOffset: number;
    SubSize: number;
    Underline: number;
    UnderlineThickness: number;
    strikethrough: number;
    strikethroughThickness: number;
    TabWidth: number;
    Padding: number;
    AtlasWidth: number;
    AtlasHeight: number;



}
    
interface FaceInfo_LegacyConstructor {

    new(): FaceInfo_Legacy;


}
declare const FaceInfo_Legacy: FaceInfo_LegacyConstructor;
    
interface TMP_FontAssetConstructor {

    new(): TMP_FontAsset;


    CreateFontAsset(familyName: string, styleName: string, pointSize: number): TMP_FontAsset;
    CreateFontAsset(fontFilePath: string, faceIndex: number, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number): TMP_FontAsset;
    CreateFontAsset(font: Font): TMP_FontAsset;
    CreateFontAsset(font: Font, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number, atlasPopulationMode: AtlasPopulationMode, enableMultiAtlasSupport: boolean): TMP_FontAsset;
    GetCharacters(fontAsset: TMP_FontAsset): string;
    GetCharactersArray(fontAsset: TMP_FontAsset): CSArray<number>;
}
declare const TMP_FontAsset: TMP_FontAssetConstructor;
    
interface VertexGradient {
    topLeft: Color;
    topRight: Color;
    bottomLeft: Color;
    bottomRight: Color;



}
    
interface VertexGradientConstructor {

    new(color: Color): VertexGradient;
    new(color0: Color, color1: Color, color2: Color, color3: Color): VertexGradient;


}
declare const VertexGradient: VertexGradientConstructor;
    
interface TMP_ColorGradient extends ScriptableObject {
    colorMode: ColorMode;
    topLeft: Color;
    topRight: Color;
    bottomLeft: Color;
    bottomRight: Color;



}
    
interface TMP_ColorGradientConstructor {

    new(): TMP_ColorGradient;
    new(color: Color): TMP_ColorGradient;
    new(color0: Color, color1: Color, color2: Color, color3: Color): TMP_ColorGradient;


}
declare const TMP_ColorGradient: TMP_ColorGradientConstructor;
    
interface TMP_SpriteAsset extends TMP_Asset {
    spriteSheet: Texture;
    spriteInfoList: CSArray<TMP_Sprite>;
    fallbackSpriteAssets: CSArray<TMP_SpriteAsset>;
    spriteCharacterTable: CSArray<TMP_SpriteCharacter>;
    spriteCharacterLookupTable: CSDictionary<number, TMP_SpriteCharacter>;
    spriteGlyphTable: CSArray<TMP_SpriteGlyph>;


    GetSpriteIndexFromHashcode(hashCode: number): number;
    GetSpriteIndexFromName(name: string): number;
    GetSpriteIndexFromUnicode(unicode: number): number;
    SortGlyphTable(): void;
    UpdateLookupTables(): void;

}
    
interface TMP_TextElement_Legacy {
    id: number;
    x: number;
    y: number;
    width: number;
    height: number;
    xOffset: number;
    yOffset: number;
    xAdvance: number;
    scale: number;



}
    
interface TMP_TextElement_LegacyConstructor {

    new(): TMP_TextElement_Legacy;


}
declare const TMP_TextElement_Legacy: TMP_TextElement_LegacyConstructor;
    
interface TMP_Sprite extends TMP_TextElement_Legacy {
    name: string;
    hashCode: number;
    unicode: number;
    pivot: Vector2;
    sprite: Sprite;



}
    
interface TMP_SpriteConstructor {

    new(): TMP_Sprite;


}
declare const TMP_Sprite: TMP_SpriteConstructor;
    
interface TMP_SpriteCharacter extends TMP_TextElement {
    name: string;



}
    
interface TMP_SpriteCharacterConstructor {

    new(): TMP_SpriteCharacter;
    new(unicode: number, glyph: TMP_SpriteGlyph): TMP_SpriteCharacter;
    new(unicode: number, spriteAsset: TMP_SpriteAsset, glyph: TMP_SpriteGlyph): TMP_SpriteCharacter;


}
declare const TMP_SpriteCharacter: TMP_SpriteCharacterConstructor;
    
interface TMP_SpriteGlyph extends Glyph {
    sprite: Sprite;



}
    
interface TMP_SpriteGlyphConstructor {

    new(): TMP_SpriteGlyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number): TMP_SpriteGlyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number, sprite: Sprite): TMP_SpriteGlyph;


}
declare const TMP_SpriteGlyph: TMP_SpriteGlyphConstructor;
    
interface TMP_SpriteAssetConstructor {

    new(): TMP_SpriteAsset;


    SearchForSpriteByHashCode(spriteAsset: TMP_SpriteAsset, hashCode: number, includeFallbacks: boolean, spriteIndex: unknown): TMP_SpriteAsset;
    SearchForSpriteByUnicode(spriteAsset: TMP_SpriteAsset, unicode: number, includeFallbacks: boolean, spriteIndex: unknown): TMP_SpriteAsset;
}
declare const TMP_SpriteAsset: TMP_SpriteAssetConstructor;
    
interface TMP_StyleSheet extends ScriptableObject {


    GetStyle(hashCode: number): TMP_Style;
    GetStyle(name: string): TMP_Style;
    RefreshStyles(): void;

}
    
interface TMP_Style {
    name: string;
    hashCode: number;
    styleOpeningDefinition: string;
    styleClosingDefinition: string;
    styleOpeningTagArray: CSArray<number>;
    styleClosingTagArray: CSArray<number>;


    RefreshStyle(): void;

}
    
interface TMP_StyleConstructor {
    NormalStyle: TMP_Style;



}
declare const TMP_Style: TMP_StyleConstructor;
    
interface TMP_StyleSheetConstructor {

    new(): TMP_StyleSheet;


}
declare const TMP_StyleSheet: TMP_StyleSheetConstructor;
    
interface TMP_TextInfo {
    textComponent: TMP_Text;
    characterCount: number;
    spriteCount: number;
    spaceCount: number;
    wordCount: number;
    linkCount: number;
    lineCount: number;
    pageCount: number;
    materialCount: number;
    characterInfo: CSArray<TMP_CharacterInfo>;
    wordInfo: CSArray<TMP_WordInfo>;
    linkInfo: CSArray<TMP_LinkInfo>;
    lineInfo: CSArray<TMP_LineInfo>;
    pageInfo: CSArray<TMP_PageInfo>;
    meshInfo: CSArray<TMP_MeshInfo>;


    ClearAllMeshInfo(): void;
    ClearMeshInfo(updateMesh: boolean): void;
    ClearUnusedVertices(materials: CSArray<MaterialReference>): void;
    CopyMeshInfoVertexData(): CSArray<TMP_MeshInfo>;
    ResetVertexLayout(isVolumetric: boolean): void;

}
    
interface TMP_CharacterInfo {
    elementType: TMP_TextElementType;
    character: string;
    index: number;
    stringLength: number;
    textElement: TMP_TextElement;
    alternativeGlyph: Glyph;
    fontAsset: TMP_FontAsset;
    material: Material;
    materialReferenceIndex: number;
    isUsingAlternateTypeface: boolean;
    pointSize: number;
    lineNumber: number;
    pageNumber: number;
    vertexIndex: number;
    vertex_BL: TMP_Vertex;
    vertex_TL: TMP_Vertex;
    vertex_TR: TMP_Vertex;
    vertex_BR: TMP_Vertex;
    topLeft: Vector3;
    bottomLeft: Vector3;
    topRight: Vector3;
    bottomRight: Vector3;
    origin: number;
    xAdvance: number;
    ascender: number;
    baseLine: number;
    descender: number;
    aspectRatio: number;
    scale: number;
    color: Color32;
    underlineColor: Color32;
    underlineVertexIndex: number;
    strikethroughColor: Color32;
    strikethroughVertexIndex: number;
    highlightColor: Color32;
    highlightState: HighlightState;
    style: FontStyles;
    isVisible: boolean;



}
    
interface TMP_Vertex {
    position: Vector3;
    uv: Vector4;
    uv2: Vector2;
    color: Color32;



}
    
interface TMP_VertexConstructor {
    zero: TMP_Vertex;



}
declare const TMP_Vertex: TMP_VertexConstructor;
    
interface HighlightState {
    color: Color32;
    padding: TMP_Offset;


    Equals(obj: unknown): boolean;
    Equals(other: HighlightState): boolean;
    GetHashCode(): number;

}
    
interface TMP_Offset {
    left: number;
    right: number;
    top: number;
    bottom: number;
    horizontal: number;
    vertical: number;


    Equals(obj: unknown): boolean;
    Equals(other: TMP_Offset): boolean;
    GetHashCode(): number;

}
    
interface TMP_OffsetConstructor {
    zero: TMP_Offset;

    new(left: number, right: number, top: number, bottom: number): TMP_Offset;
    new(horizontal: number, vertical: number): TMP_Offset;


}
declare const TMP_Offset: TMP_OffsetConstructor;
    
interface HighlightStateConstructor {

    new(color: Color32, padding: TMP_Offset): HighlightState;


}
declare const HighlightState: HighlightStateConstructor;
    
interface TMP_WordInfo {
    textComponent: TMP_Text;
    firstCharacterIndex: number;
    lastCharacterIndex: number;
    characterCount: number;


    GetWord(): string;

}
    
interface TMP_LinkInfo {
    textComponent: TMP_Text;
    hashCode: number;
    linkIdFirstCharacterIndex: number;
    linkIdLength: number;
    linkTextfirstCharacterIndex: number;
    linkTextLength: number;


    GetLink(): string;
    GetLinkID(): string;
    GetLinkText(): string;

}
    
interface TMP_LineInfo {
    characterCount: number;
    visibleCharacterCount: number;
    spaceCount: number;
    visibleSpaceCount: number;
    wordCount: number;
    firstCharacterIndex: number;
    firstVisibleCharacterIndex: number;
    lastCharacterIndex: number;
    lastVisibleCharacterIndex: number;
    length: number;
    lineHeight: number;
    ascender: number;
    baseline: number;
    descender: number;
    maxAdvance: number;
    width: number;
    marginLeft: number;
    marginRight: number;
    alignment: HorizontalAlignmentOptions;
    lineExtents: Extents;



}
    
interface Extents {
    min: Vector2;
    max: Vector2;


    ToString(): string;

}
    
interface ExtentsConstructor {

    new(min: Vector2, max: Vector2): Extents;


}
declare const Extents: ExtentsConstructor;
    
interface TMP_PageInfo {
    firstCharacterIndex: number;
    lastCharacterIndex: number;
    ascender: number;
    baseLine: number;
    descender: number;



}
    
interface TMP_MeshInfo {
    mesh: Mesh;
    vertexCount: number;
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    tangents: CSArray<Vector4>;
    uvs0: CSArray<Vector4>;
    uvs2: CSArray<Vector2>;
    colors32: CSArray<Color32>;
    triangles: CSArray<number>;
    material: Material;


    Clear(): void;
    Clear(uploadChanges: boolean): void;
    ClearUnusedVertices(): void;
    ClearUnusedVertices(startIndex: number): void;
    ClearUnusedVertices(startIndex: number, updateMesh: boolean): void;
    ResizeMeshInfo(size: number): void;
    ResizeMeshInfo(size: number, isVolumetric: boolean): void;
    SortGeometry(order: VertexSortingOrder): void;
    SortGeometry(sortingOrder: CSArray<number>): void;
    SwapVertexData(src: number, dst: number): void;

}
    
interface TMP_MeshInfoConstructor {

    new(mesh: Mesh, size: number): TMP_MeshInfo;
    new(mesh: Mesh, size: number, isVolumetric: boolean): TMP_MeshInfo;


}
declare const TMP_MeshInfo: TMP_MeshInfoConstructor;
    
interface MaterialReference {
    index: number;
    fontAsset: TMP_FontAsset;
    spriteAsset: TMP_SpriteAsset;
    material: Material;
    isDefaultMaterial: boolean;
    isFallbackMaterial: boolean;
    fallbackMaterial: Material;
    padding: number;
    referenceCount: number;



}
    
interface MaterialReferenceConstructor {

    new(index: number, fontAsset: TMP_FontAsset, spriteAsset: TMP_SpriteAsset, material: Material, padding: number): MaterialReference;


    AddMaterialReference(material: Material, fontAsset: TMP_FontAsset, materialReferences: CSArray<MaterialReference>, materialReferenceIndexLookup: CSDictionary<number, number>): number;
    AddMaterialReference(material: Material, spriteAsset: TMP_SpriteAsset, materialReferences: CSArray<MaterialReference>, materialReferenceIndexLookup: CSDictionary<number, number>): number;
    Contains(materialReferences: CSArray<MaterialReference>, fontAsset: TMP_FontAsset): boolean;
}
declare const MaterialReference: MaterialReferenceConstructor;
    
interface TMP_TextInfoConstructor {

    new(): TMP_TextInfo;
    new(textComponent: TMP_Text): TMP_TextInfo;


    Resize<T>(array: CSArray<T>, size: number): void;
    Resize<T>(array: CSArray<T>, size: number, isBlockAllocated: boolean): void;
}
declare const TMP_TextInfo: TMP_TextInfoConstructor;
    
interface TextMeshProUGUI extends TMP_Text, ILayoutElement {
    materialForRendering: Material;
    autoSizeTextContainer: boolean;
    mesh: Mesh;
    canvasRenderer: CanvasRenderer;
    maskOffset: Vector4;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    ClearMesh(): void;
    ComputeMarginSize(): void;
    Cull(clipRect: Rect, validRect: boolean): void;
    ForceMeshUpdate(ignoreActiveState: boolean, forceTextReparsing: boolean): void;
    GetModifiedMaterial(baseMaterial: Material): Material;
    GetTextInfo(text: string): TMP_TextInfo;
    Rebuild(update: CanvasUpdate): void;
    RecalculateClipping(): void;
    SetAllDirty(): void;
    SetLayoutDirty(): void;
    SetMaterialDirty(): void;
    SetVerticesDirty(): void;
    UpdateFontAsset(): void;
    UpdateGeometry(mesh: Mesh, index: number): void;
    UpdateMeshPadding(): void;
    UpdateVertexData(flags: TMP_VertexDataUpdateFlags): void;
    UpdateVertexData(): void;

}
    
interface TextMeshProUGUIConstructor {

    new(): TextMeshProUGUI;


}
declare const TextMeshProUGUI: TextMeshProUGUIConstructor;
    
interface Animation extends Behaviour {
    clip: AnimationClip;
    playAutomatically: boolean;
    wrapMode: WrapMode;
    isPlaying: boolean;
    Item: AnimationState;
    animatePhysics: boolean;
    updateMode: AnimationUpdateMode;
    animateOnlyIfVisible: boolean;
    cullingType: AnimationCullingType;
    localBounds: Bounds;


    /** Adds a clip to the animation with name newName. */
    AddClip(clip: AnimationClip, newName: string): void;
    /** Adds clip to the only play between firstFrame and lastFrame. The new clip will also be added to the animation with name newName. */
    AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number): void;
    /** Adds clip to the only play between firstFrame and lastFrame. The new clip will also be added to the animation with name newName. */
    AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number, addLoopFrame: boolean): void;
    /** Blends the animation named animation towards targetWeight over the next time seconds. */
    Blend(animation: string): void;
    /** Blends the animation named animation towards targetWeight over the next time seconds. */
    Blend(animation: string, targetWeight: number): void;
    /** Blends the animation named animation towards targetWeight over the next time seconds. */
    Blend(animation: string, targetWeight: number, fadeLength: number): void;
    /** Fades in the animation with the name animation over a period of time defined by fadeLength. */
    CrossFade(animation: string): void;
    /** Fades in the animation with the name animation over a period of time defined by fadeLength. */
    CrossFade(animation: string, fadeLength: number): void;
    /** Fades in the animation with the name animation over a period of time defined by fadeLength. */
    CrossFade(animation: string, fadeLength: number, mode: PlayMode): void;
    /** Cross fades an animation after previous animations has finished playing. */
    CrossFadeQueued(animation: string): AnimationState;
    /** Cross fades an animation after previous animations has finished playing. */
    CrossFadeQueued(animation: string, fadeLength: number): AnimationState;
    /** Cross fades an animation after previous animations has finished playing. */
    CrossFadeQueued(animation: string, fadeLength: number, queue: QueueMode): AnimationState;
    /** Cross fades an animation after previous animations has finished playing. */
    CrossFadeQueued(animation: string, fadeLength: number, queue: QueueMode, mode: PlayMode): AnimationState;
    GetClip(name: string): AnimationClip;
    /** Get the number of clips currently assigned to this animation. */
    GetClipCount(): number;
    GetEnumerator(): unknown;
    /** Is the animation named name playing? */
    IsPlaying(name: string): boolean;
    Play(): boolean;
    /** Plays an animation without blending. */
    Play(mode: PlayMode): boolean;
    /** Plays an animation without blending. */
    Play(animation: string): boolean;
    /** Plays an animation without blending. */
    Play(animation: string, mode: PlayMode): boolean;
    Play(mode: AnimationPlayMode): boolean;
    Play(animation: string, mode: AnimationPlayMode): boolean;
    /** Plays an animation after previous animations has finished playing. */
    PlayQueued(animation: string): AnimationState;
    /** Plays an animation after previous animations has finished playing. */
    PlayQueued(animation: string, queue: QueueMode): AnimationState;
    /** Plays an animation after previous animations has finished playing. */
    PlayQueued(animation: string, queue: QueueMode, mode: PlayMode): AnimationState;
    /** Remove clip from the animation list. */
    RemoveClip(clip: AnimationClip): void;
    /** Remove clip from the animation list. */
    RemoveClip(clipName: string): void;
    /** Rewinds all animations. */
    Rewind(): void;
    /** Rewinds the animation named name. */
    Rewind(name: string): void;
    /** Samples animations at the current state. */
    Sample(): void;
    /** Stops all playing animations that were started with this Animation. */
    Stop(): void;
    /** Stops an animation named name. */
    Stop(name: string): void;
    SyncLayer(layer: number): void;

}
    
interface AnimationConstructor {

    new(): Animation;


}
declare const Animation: AnimationConstructor;
    
interface ClientSceneListener extends MonoBehaviour {
    IsGameSceneLoaded: boolean;
    SceneLoadPercent: number;



}
    
interface ClientSceneListenerConstructor {

    new(): ClientSceneListener;


}
declare const ClientSceneListener: ClientSceneListenerConstructor;
    
interface BundleLoadingScreen extends MonoBehaviour {
    showContinueButton: boolean;


    SetError(msg: string): void;
    SetProgress(text: string, percent: number): void;
    SetTotalDownloadSize(sizeBytes: number): void;

}
    
interface CoreLoadingScreen extends BundleLoadingScreen {
    progressText: TMP_Text;
    disconnectButton: Button;
    continueButton: Button;
    spinner: GameObject;


    ClickContinueButton(): void;
    Close(): void;
    SetProgress(text: string, percent: number): void;
    SetTotalDownloadSize(sizeBytes: number): void;

}
    
interface CoreLoadingScreenConstructor {

    new(): CoreLoadingScreen;


}
declare const CoreLoadingScreen: CoreLoadingScreenConstructor;
    
interface TextField {
    multiline: boolean;
    value: string;


    SetValueWithoutNotify(newValue: string): void;

}
    
interface TextFieldConstructor {
    ussClassName: string;
    labelUssClassName: string;
    inputUssClassName: string;

    new(): TextField;
    new(maxLength: number, multiline: boolean, isPasswordField: boolean, maskChar: string): TextField;
    new(label: string): TextField;
    new(label: string, maxLength: number, multiline: boolean, isPasswordField: boolean, maskChar: string): TextField;


}
declare const TextField: TextFieldConstructor;
    
interface GameConfig extends ScriptableObject {
    gameId: string;
    startingSceneName: string;
    gameScenes: CSArray<Object>;
    packages: CSArray<AirshipPackageDocument>;
    tags: CSArray<string>;
    gameLayers: CSArray<string>;


    ToJson(): string;

}
    
interface AirshipPackageDocument {
    id: string;
    assetVersion: string;
    codeVersion: string;
    game: boolean;
    localSource: boolean;
    disabled: boolean;
    defaultPackage: boolean;
    forceLatestVersion: boolean;


    IsDownloaded(): boolean;

}
    
interface AirshipPackageDocumentConstructor {

    new(): AirshipPackageDocument;


    FindPathFromDocument(document: AirshipPackageDocument): string;
}
declare const AirshipPackageDocument: AirshipPackageDocumentConstructor;
    
interface GameConfigConstructor {

    new(): GameConfig;


    Load(): GameConfig;
}
declare const GameConfig: GameConfigConstructor;
    
interface RenderSettings extends Object {



}
    
interface Light extends Behaviour {
    type: LightType;
    shape: LightShape;
    spotAngle: number;
    innerSpotAngle: number;
    color: Color;
    colorTemperature: number;
    useColorTemperature: boolean;
    intensity: number;
    bounceIntensity: number;
    useBoundingSphereOverride: boolean;
    boundingSphereOverride: Vector4;
    useViewFrustumForShadowCasterCull: boolean;
    shadowCustomResolution: number;
    shadowBias: number;
    shadowNormalBias: number;
    shadowNearPlane: number;
    useShadowMatrixOverride: boolean;
    shadowMatrixOverride: Matrix4x4;
    range: number;
    dilatedRange: number;
    flare: Flare;
    bakingOutput: LightBakingOutput;
    cullingMask: number;
    renderingLayerMask: number;
    lightShadowCasterMode: LightShadowCasterMode;
    shadowRadius: number;
    shadowAngle: number;
    shadows: LightShadows;
    shadowStrength: number;
    shadowResolution: LightShadowResolution;
    shadowSoftness: number;
    shadowSoftnessFade: number;
    layerShadowCullDistances: CSArray<number>;
    cookieSize: number;
    cookie: Texture;
    renderMode: LightRenderMode;
    bakedIndex: number;
    areaSize: Vector2;
    lightmapBakeType: LightmapBakeType;
    commandBufferCount: number;
    shadowConstantBias: number;
    shadowObjectSizeBias: number;
    attenuate: boolean;
    lightmappingMode: LightmappingMode;
    isBaked: boolean;
    alreadyLightmapped: boolean;


    /** Add a command buffer to be executed at a specified place. */
    AddCommandBuffer(evt: LightEvent, buffer: CommandBuffer): void;
    /** Add a command buffer to be executed at a specified place. */
    AddCommandBuffer(evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass): void;
    /** Adds a command buffer to the GPU&#x27;s async compute queues and executes that command buffer when graphics processing reaches a given point. */
    AddCommandBufferAsync(evt: LightEvent, buffer: CommandBuffer, queueType: ComputeQueueType): void;
    /** Adds a command buffer to the GPU&#x27;s async compute queues and executes that command buffer when graphics processing reaches a given point. */
    AddCommandBufferAsync(evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass, queueType: ComputeQueueType): void;
    /** Get command buffers to be executed at a specified place. */
    GetCommandBuffers(evt: LightEvent): CSArray<CommandBuffer>;
    /** Remove all command buffers set on this light. */
    RemoveAllCommandBuffers(): void;
    /** Remove command buffer from execution at a specified place. */
    RemoveCommandBuffer(evt: LightEvent, buffer: CommandBuffer): void;
    /** Remove command buffers from execution at a specified place. */
    RemoveCommandBuffers(evt: LightEvent): void;
    /** Revert all light parameters to default. */
    Reset(): void;
    /** Sets a light dirty to notify the light baking backends to update their internal light representation (Editor only). */
    SetLightDirty(): void;

}
    
interface Flare extends Object {



}
    
interface FlareConstructor {

    new(): Flare;


}
declare const Flare: FlareConstructor;
    
interface LightBakingOutput {
    probeOcclusionLightIndex: number;
    occlusionMaskChannel: number;
    lightmapBakeType: LightmapBakeType;
    mixedLightingMode: MixedLightingMode;
    isBaked: boolean;



}
    
interface LightConstructor {
    pixelLightCount: number;

    new(): Light;


    GetLights(type: LightType, layer: number): CSArray<Light>;
}
declare const Light: LightConstructor;
    
interface RenderSettingsConstructor {
    ambientSkyboxAmount: number;
    fog: boolean;
    fogStartDistance: number;
    fogEndDistance: number;
    fogMode: FogMode;
    fogColor: Color;
    fogDensity: number;
    ambientMode: AmbientMode;
    ambientSkyColor: Color;
    ambientEquatorColor: Color;
    ambientGroundColor: Color;
    ambientIntensity: number;
    ambientLight: Color;
    subtractiveShadowColor: Color;
    skybox: Material;
    sun: Light;
    ambientProbe: SphericalHarmonicsL2;
    customReflection: Cubemap;
    customReflectionTexture: Texture;
    reflectionIntensity: number;
    reflectionBounces: number;
    defaultReflectionMode: DefaultReflectionMode;
    defaultReflectionResolution: number;
    haloStrength: number;
    flareStrength: number;
    flareFadeSpeed: number;



}
declare const RenderSettings: RenderSettingsConstructor;
    
interface ServerBootstrap extends MonoBehaviour {
    startupConfig: StartupConfig;
    overrideGameBundleId: string;
    overrideGameBundleVersion: string;
    airshipJWT: string;
    agones: AgonesSdk;
    agonesBeta: AgonesBetaSdk;
    gameId: string;
    serverId: string;
    organizationId: string;
    serverContext: ServerContext;
    editorConfig: AirshipEditorConfig;
    serverReady: boolean;
    isStartupConfigReady: boolean;


    FinishedSetup(): void;
    GetJoinCode(): string;
    IsAgonesEnvironment(): boolean;
    Shutdown(): void;

}
    
interface StartupConfig {
    GameBundleId: string;
    GameAssetVersion: string;
    GameCodeVersion: string;
    StartingSceneName: string;
    CdnUrl: string;
    packages: CSArray<AirshipPackageDocument>;



}
    
interface AgonesSdk extends MonoBehaviour {
    healthIntervalSecond: number;
    healthEnabled: boolean;
    logEnabled: boolean;


    Allocate(): boolean;
    Connect(): boolean;
    GameServer(): GameServer;
    Ready(): boolean;
    Reserve(duration: unknown): boolean;
    SetAnnotation(key: string, value: string): boolean;
    SetLabel(key: string, value: string): boolean;
    Shutdown(): boolean;
    WatchGameServer(callback: WatchGameServerCallback): void;

}
    
interface GameServer {
    ObjectMeta: GameServerObjectMeta;
    Spec: GameServerSpec;
    Status: GameServerStatus;


    Equals(input: unknown): boolean;
    Equals(input: GameServer): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface GameServerObjectMeta {
    Name: string;
    Namespace: string;
    Uid: string;
    ResourceVersion: string;
    Generation: number;
    CreationTimestamp: string;
    DeletionTimestamp?: string;
    Annotations: CSDictionary<string, string>;
    Labels: CSDictionary<string, string>;


    Equals(input: unknown): boolean;
    Equals(input: GameServerObjectMeta): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface GameServerObjectMetaConstructor {

    new(data: CSDictionary<string, unknown>): GameServerObjectMeta;


}
declare const GameServerObjectMeta: GameServerObjectMetaConstructor;
    
interface GameServerSpec {
    Health: SpecHealth;


    Equals(input: unknown): boolean;
    Equals(input: GameServerSpec): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface SpecHealth {
    Disabled: boolean;
    PeriodSeconds: number;
    FailureThreshold: number;
    InitialDelaySeconds: number;


    Equals(input: unknown): boolean;
    Equals(input: SpecHealth): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface SpecHealthConstructor {

    new(data: CSDictionary<string, unknown>): SpecHealth;


}
declare const SpecHealth: SpecHealthConstructor;
    
interface GameServerSpecConstructor {

    new(data: CSDictionary<string, unknown>): GameServerSpec;


}
declare const GameServerSpec: GameServerSpecConstructor;
    
interface GameServerStatus {
    State: string;
    Address: string;
    Addresses: CSArray<StatusAddresses>;
    Ports: CSArray<StatusPort>;


    Equals(input: unknown): boolean;
    Equals(input: GameServerStatus): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StatusAddresses {
    Address: string;
    Type: string;


    Equals(input: unknown): boolean;
    Equals(input: StatusAddresses): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StatusAddressesConstructor {

    new(data: CSDictionary<string, unknown>): StatusAddresses;


}
declare const StatusAddresses: StatusAddressesConstructor;
    
interface StatusPort {
    Name: string;
    Port: number;


    Equals(input: unknown): boolean;
    Equals(input: StatusPort): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StatusPortConstructor {

    new(data: CSDictionary<string, unknown>): StatusPort;


}
declare const StatusPort: StatusPortConstructor;
    
interface GameServerStatusConstructor {

    new(data: CSDictionary<string, unknown>): GameServerStatus;


}
declare const GameServerStatus: GameServerStatusConstructor;
    
interface GameServerConstructor {

    new(data: CSDictionary<string, unknown>): GameServer;


}
declare const GameServer: GameServerConstructor;
    
interface WatchGameServerCallback {


    BeginInvoke(gameServer: GameServer, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(gameServer: GameServer): void;

}
    
interface WatchGameServerCallbackConstructor {

    new(object: unknown, method: unknown): WatchGameServerCallback;


}
declare const WatchGameServerCallback: WatchGameServerCallbackConstructor;
    
interface AgonesSdkConstructor {

    new(): AgonesSdk;


}
declare const AgonesSdk: AgonesSdkConstructor;
    
interface AgonesBetaSdk extends AgonesSdk {


    AppendListValue(key: string, value: string): boolean;
    DecrementCounter(key: string, amount: number): boolean;
    DeleteListValue(key: string, value: string): boolean;
    GetCounterCapacity(key: string): number;
    GetCounterCount(key: string): number;
    GetListCapacity(key: string): number;
    GetListLength(key: string): number;
    GetListValues(key: string): CSArray<string>;
    IncrementCounter(key: string, amount: number): boolean;
    ListContains(key: string, value: string): boolean;
    SetCounterCapacity(key: string, amount: number): boolean;
    SetCounterCount(key: string, amount: number): boolean;
    SetListCapacity(key: string, amount: number): boolean;

}
    
interface AgonesBetaSdkConstructor {

    new(): AgonesBetaSdk;


}
declare const AgonesBetaSdk: AgonesBetaSdkConstructor;
    
interface ServerContext extends NetworkBehaviour {
    serverId: unknown;
    gameId: unknown;
    organizationId: unknown;


    Awake(): void;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;

}
    
interface ServerContextConstructor {

    new(): ServerContext;


}
declare const ServerContext: ServerContextConstructor;
    
interface AirshipEditorConfig extends ScriptableObject {
    useBundlesInEditor: boolean;
    buildBundlesOnPlay: boolean;
    downloadPackages: boolean;



}
    
interface AirshipEditorConfigConstructor {

    new(): AirshipEditorConfig;


    Load(): AirshipEditorConfig;
}
declare const AirshipEditorConfig: AirshipEditorConfigConstructor;
    
interface ServerBootstrapConstructor {
    editorStartingSceneIntent: string;

    new(): ServerBootstrap;


}
declare const ServerBootstrap: ServerBootstrapConstructor;
    
    
interface CreateSceneParameters {
    localPhysicsMode: LocalPhysicsMode;



}
    
interface CreateSceneParametersConstructor {

    new(physicsMode: LocalPhysicsMode): CreateSceneParameters;


}
declare const CreateSceneParameters: CreateSceneParametersConstructor;
    
    
interface AccessoryBuilder extends MonoBehaviour {
    rig: CharacterRig;
    firstPerson: boolean;
    firstPersonLayer: number;
    thirdPersonLayer: number;


    AddAccessories(accessoryTemplates: CSArray<AccessoryComponent>, addMode: AccessoryAddMode, rebuildMeshImmediately: boolean): CSArray<ActiveAccessory>;
    AddSingleAccessory(accessoryTemplate: AccessoryComponent, rebuildMeshImmediately: boolean): ActiveAccessory;
    AddSkinAccessory(skin: AccessorySkin, rebuildMeshImmediately: boolean): void;
    EquipAccessoryOutfit(outfit: AccessoryOutfit, rebuildMeshImmediately: boolean): CSArray<ActiveAccessory>;
    GetAccessoryMeshes(slot: AccessorySlot): CSArray<Renderer>;
    GetAccessoryParticles(slot: AccessorySlot): CSArray<ParticleSystem>;
    GetActiveAccessories(): CSArray<ActiveAccessory>;
    GetActiveAccessoriesBySlot(target: AccessorySlot): CSArray<ActiveAccessory>;
    GetAllAccessoryMeshes(): CSArray<Renderer>;
    GetCombinedSkinnedMesh(): SkinnedMeshRenderer;
    GetCombinedStaticMesh(): MeshRenderer;
    RemoveAccessories(): void;
    RemoveAccessorySlot(slot: AccessorySlot, rebuildMeshImmediately: boolean): void;
    RemoveClothingAccessories(): void;
    SetAccessoryColor(slot: AccessorySlot, color: Color, rebuildMeshImmediately: boolean): void;
    SetFaceTexture(texture: Texture2D): void;
    SetSkinColor(color: Color, rebuildMeshImmediately: boolean): void;
    TryCombineMeshes(): void;
    UpdateAccessoryLayers(): void;

}
    
interface CharacterRig extends MonoBehaviour {
    bodyMesh: SkinnedMeshRenderer;
    headMesh: Renderer;
    faceMesh: Renderer;
    rigHolder: Transform;
    rootMotion: Transform;
    master: Transform;
    hips: Transform;
    spine: Transform;
    head: Transform;
    upperArmL: Transform;
    forearmL: Transform;
    handL: Transform;
    fingersL: Transform;
    thumbL: Transform;
    upperArmR: Transform;
    forearmR: Transform;
    handR: Transform;
    fingersR: Transform;
    thumbR: Transform;
    thighL: Transform;
    shinL: Transform;
    footL: Transform;
    thighR: Transform;
    shinR: Transform;
    footR: Transform;
    headTop: Transform;
    neck: Transform;
    spineChest: Transform;
    heldItemL: Transform;
    heldItemR: Transform;
    baseMeshes: CSArray<Renderer>;


    GetSlotTransform(slot: AccessorySlot): Transform;

}
    
interface SkinnedMeshRenderer extends Renderer {
    quality: SkinQuality;
    updateWhenOffscreen: boolean;
    forceMatrixRecalculationPerRender: boolean;
    rootBone: Transform;
    bones: CSArray<Transform>;
    sharedMesh: Mesh;
    skinnedMotionVectors: boolean;
    vertexBufferTarget: Target;


    /** Creates a snapshot of SkinnedMeshRenderer and stores it in mesh. */
    BakeMesh(mesh: Mesh): void;
    /** Creates a snapshot of SkinnedMeshRenderer and stores it in mesh. */
    BakeMesh(mesh: Mesh, useScale: boolean): void;
    /** Returns the weight of a BlendShape for this Renderer. */
    GetBlendShapeWeight(index: number): number;
    /** Retrieves a GraphicsBuffer that provides direct access to the GPU vertex buffer for this skinned mesh, for the previous frame. */
    GetPreviousVertexBuffer(): GraphicsBuffer;
    /** Retrieves a GraphicsBuffer that provides direct access to the GPU vertex buffer for this skinned mesh, for the current frame. */
    GetVertexBuffer(): GraphicsBuffer;
    /** Sets the weight of a BlendShape for this Renderer. */
    SetBlendShapeWeight(index: number, value: number): void;

}
    
interface SkinnedMeshRendererConstructor {

    new(): SkinnedMeshRenderer;


}
declare const SkinnedMeshRenderer: SkinnedMeshRendererConstructor;
    
interface CharacterRigConstructor {

    new(): CharacterRig;


}
declare const CharacterRig: CharacterRigConstructor;
    
interface ActiveAccessory {
    AccessoryComponent: AccessoryComponent;
    rootTransform: Transform;
    gameObjects: CSArray<GameObject>;
    renderers: CSArray<Renderer>;



}
    
interface AccessoryComponent extends MonoBehaviour {
    serverClassId: string;
    accessorySlot: AccessorySlot;
    visibilityMode: VisibilityMode;
    skinnedToCharacter: boolean;
    localPosition: Vector3;
    localRotation: Quaternion;
    localScale: Vector3;


    Copy(other: AccessoryComponent): void;
    GetServerInstanceId(): string;
    GetSlotNumber(): number;
    SetInstanceId(id: string): void;

}
    
interface AccessoryComponentConstructor {

    new(): AccessoryComponent;


}
declare const AccessoryComponent: AccessoryComponentConstructor;
    
interface AccessorySkin extends ScriptableObject {
    skinTextureDiffuse: Texture2D;
    skinTextureNormal: Texture2D;
    skinTextureORM: Texture2D;
    faceTextureDiffuse: Texture2D;


    ToString(): string;

}
    
interface AccessorySkinConstructor {

    new(): AccessorySkin;


}
declare const AccessorySkin: AccessorySkinConstructor;
    
interface AccessoryOutfit extends ScriptableObject {
    accessories: CSArray<AccessoryComponent>;
    faceDecal: AccessoryFace;
    customSkin: AccessorySkin;
    forceSkinColor: boolean;
    skinColor: Color;



}
    
interface AccessoryFace extends ScriptableObject {
    serverClassId: string;
    serverInstanceId: string;
    decalTexture: Texture2D;



}
    
interface AccessoryFaceConstructor {

    new(): AccessoryFace;


}
declare const AccessoryFace: AccessoryFaceConstructor;
    
interface AccessoryOutfitConstructor {

    new(): AccessoryOutfit;


}
declare const AccessoryOutfit: AccessoryOutfitConstructor;
    
interface ParticleSystem extends Component {
    safeCollisionEventSize: number;
    startDelay: number;
    loop: boolean;
    playOnAwake: boolean;
    duration: number;
    playbackSpeed: number;
    enableEmission: boolean;
    emissionRate: number;
    startSpeed: number;
    startSize: number;
    startColor: Color;
    startRotation: number;
    startRotation3D: Vector3;
    startLifetime: number;
    gravityModifier: number;
    maxParticles: number;
    simulationSpace: ParticleSystemSimulationSpace;
    scalingMode: ParticleSystemScalingMode;
    automaticCullingEnabled: boolean;
    isPlaying: boolean;
    isEmitting: boolean;
    isStopped: boolean;
    isPaused: boolean;
    particleCount: number;
    time: number;
    totalTime: number;
    randomSeed: number;
    useAutoRandomSeed: boolean;
    proceduralSimulationSupported: boolean;
    has3DParticleRotations: boolean;
    hasNonUniformParticleSizes: boolean;
    main: MainModule;
    emission: EmissionModule;
    shape: ShapeModule;
    velocityOverLifetime: VelocityOverLifetimeModule;
    limitVelocityOverLifetime: LimitVelocityOverLifetimeModule;
    inheritVelocity: InheritVelocityModule;
    lifetimeByEmitterSpeed: LifetimeByEmitterSpeedModule;
    forceOverLifetime: ForceOverLifetimeModule;
    colorOverLifetime: ColorOverLifetimeModule;
    colorBySpeed: ColorBySpeedModule;
    sizeOverLifetime: SizeOverLifetimeModule;
    sizeBySpeed: SizeBySpeedModule;
    rotationOverLifetime: RotationOverLifetimeModule;
    rotationBySpeed: RotationBySpeedModule;
    externalForces: ExternalForcesModule;
    noise: NoiseModule;
    collision: CollisionModule;
    trigger: TriggerModule;
    subEmitters: SubEmittersModule;
    textureSheetAnimation: TextureSheetAnimationModule;
    lights: LightsModule;
    trails: TrailModule;
    customData: CustomDataModule;


    /** Ensures that the ParticleSystemJobs.ParticleSystemJobData._axisOfRotations|axisOfRotations particle attribute array is allocated. */
    AllocateAxisOfRotationAttribute(): void;
    /** Ensures that the ParticleSystemJobs.ParticleSystemJobData.customData1|customData1 and ParticleSystemJobs.ParticleSystemJobData.customData1|customData2 particle attribute arrays are allocated. */
    AllocateCustomDataAttribute(stream: ParticleSystemCustomData): void;
    /** Ensures that the ParticleSystemJobs.ParticleSystemJobData._meshIndices|meshIndices particle attribute array is allocated. */
    AllocateMeshIndexAttribute(): void;
    /** Remove all particles in the Particle System. */
    Clear(withChildren: boolean): void;
    /** Remove all particles in the Particle System. */
    Clear(): void;
    Emit(position: Vector3, velocity: Vector3, size: number, lifetime: number, color: Color32): void;
    Emit(particle: Particle): void;
    /** Emit count particles immediately. */
    Emit(count: number): void;
    Emit(emitParams: EmitParams, count: number): void;
    GetCustomParticleData(customData: CSArray<Vector4>, streamIndex: ParticleSystemCustomData): number;
    GetParticles(particles: CSArray<Particle>, size: number, offset: number): number;
    GetParticles(particles: CSArray<Particle>, size: number): number;
    GetParticles(particles: CSArray<Particle>): number;
    GetParticles(particles: CSArray<Particle>, size: number, offset: number): number;
    GetParticles(particles: CSArray<Particle>, size: number): number;
    GetParticles(particles: CSArray<Particle>): number;
    /** Returns all the data that relates to the current internal state of the Particle System. */
    GetPlaybackState(): PlaybackState;
    /** Returns all the data relating to the current internal state of the Particle System Trails. */
    GetTrails(): Trails;
    GetTrails(trailData: unknown): number;
    /** Does the Particle System contain any live particles, or will it produce more? */
    IsAlive(withChildren: boolean): boolean;
    /** Does the Particle System contain any live particles, or will it produce more? */
    IsAlive(): boolean;
    /** Pauses the system so no new particles are emitted and the existing particles are not updated. */
    Pause(withChildren: boolean): void;
    /** Pauses the system so no new particles are emitted and the existing particles are not updated. */
    Pause(): void;
    /** Starts the Particle System. */
    Play(withChildren: boolean): void;
    /** Starts the Particle System. */
    Play(): void;
    SetCustomParticleData(customData: CSArray<Vector4>, streamIndex: ParticleSystemCustomData): void;
    SetParticles(particles: CSArray<Particle>, size: number, offset: number): void;
    SetParticles(particles: CSArray<Particle>, size: number): void;
    SetParticles(particles: CSArray<Particle>): void;
    SetParticles(particles: CSArray<Particle>, size: number, offset: number): void;
    SetParticles(particles: CSArray<Particle>, size: number): void;
    SetParticles(particles: CSArray<Particle>): void;
    SetPlaybackState(playbackState: PlaybackState): void;
    SetTrails(trailData: Trails): void;
    /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it. */
    Simulate(t: number, withChildren: boolean, restart: boolean, fixedTimeStep: boolean): void;
    /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it. */
    Simulate(t: number, withChildren: boolean, restart: boolean): void;
    /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it. */
    Simulate(t: number, withChildren: boolean): void;
    /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it. */
    Simulate(t: number): void;
    /** Stops playing the Particle System using the supplied stop behaviour. */
    Stop(withChildren: boolean, stopBehavior: ParticleSystemStopBehavior): void;
    /** Stops playing the Particle System using the supplied stop behaviour. */
    Stop(withChildren: boolean): void;
    /** Stops playing the Particle System using the supplied stop behaviour. */
    Stop(): void;
    /** Triggers the specified sub emitter on all particles of the Particle System. */
    TriggerSubEmitter(subEmitterIndex: number): void;
    TriggerSubEmitter(subEmitterIndex: number, particle: unknown): void;
    TriggerSubEmitter(subEmitterIndex: number, particles: CSArray<Particle>): void;

}
    
interface MainModule {
    randomizeRotationDirection: number;
    emitterVelocity: Vector3;
    duration: number;
    loop: boolean;
    prewarm: boolean;
    startDelay: MinMaxCurve;
    startDelayMultiplier: number;
    startLifetime: MinMaxCurve;
    startLifetimeMultiplier: number;
    startSpeed: MinMaxCurve;
    startSpeedMultiplier: number;
    startSize3D: boolean;
    startSize: MinMaxCurve;
    startSizeMultiplier: number;
    startSizeX: MinMaxCurve;
    startSizeXMultiplier: number;
    startSizeY: MinMaxCurve;
    startSizeYMultiplier: number;
    startSizeZ: MinMaxCurve;
    startSizeZMultiplier: number;
    startRotation3D: boolean;
    startRotation: MinMaxCurve;
    startRotationMultiplier: number;
    startRotationX: MinMaxCurve;
    startRotationXMultiplier: number;
    startRotationY: MinMaxCurve;
    startRotationYMultiplier: number;
    startRotationZ: MinMaxCurve;
    startRotationZMultiplier: number;
    flipRotation: number;
    startColor: MinMaxGradient;
    gravitySource: ParticleSystemGravitySource;
    gravityModifier: MinMaxCurve;
    gravityModifierMultiplier: number;
    simulationSpace: ParticleSystemSimulationSpace;
    customSimulationSpace: Transform;
    simulationSpeed: number;
    useUnscaledTime: boolean;
    scalingMode: ParticleSystemScalingMode;
    playOnAwake: boolean;
    maxParticles: number;
    emitterVelocityMode: ParticleSystemEmitterVelocityMode;
    stopAction: ParticleSystemStopAction;
    ringBufferMode: ParticleSystemRingBufferMode;
    ringBufferLoopRange: Vector2;
    cullingMode: ParticleSystemCullingMode;



}
    
interface MinMaxCurve {
    curveScalar: number;
    mode: ParticleSystemCurveMode;
    curveMultiplier: number;
    curveMax: AnimationCurve;
    curveMin: AnimationCurve;
    constantMax: number;
    constantMin: number;
    constant: number;
    curve: AnimationCurve;


    Evaluate(time: number): number;
    Evaluate(time: number, lerpFactor: number): number;

}
    
interface MinMaxCurveConstructor {

    new(constant: number): MinMaxCurve;
    new(multiplier: number, curve: AnimationCurve): MinMaxCurve;
    new(multiplier: number, min: AnimationCurve, max: AnimationCurve): MinMaxCurve;
    new(min: number, max: number): MinMaxCurve;


}
declare const MinMaxCurve: MinMaxCurveConstructor;
    
interface MinMaxGradient {
    mode: ParticleSystemGradientMode;
    gradientMax: Gradient;
    gradientMin: Gradient;
    colorMax: Color;
    colorMin: Color;
    color: Color;
    gradient: Gradient;


    Evaluate(time: number): Color;
    Evaluate(time: number, lerpFactor: number): Color;

}
    
interface Gradient {
    colorKeys: CSArray<GradientColorKey>;
    alphaKeys: CSArray<GradientAlphaKey>;
    mode: GradientMode;
    colorSpace: ColorSpace;


    Equals(o: unknown): boolean;
    Equals(other: Gradient): boolean;
    /** Calculate color at a given time. */
    Evaluate(time: number): Color;
    GetHashCode(): number;
    /** Setup Gradient with an array of color keys and alpha keys. */
    SetKeys(colorKeys: CSArray<GradientColorKey>, alphaKeys: CSArray<GradientAlphaKey>): void;

}
    
interface GradientColorKey {
    color: Color;
    time: number;



}
    
interface GradientColorKeyConstructor {

    new(col: Color, time: number): GradientColorKey;


}
declare const GradientColorKey: GradientColorKeyConstructor;
    
interface GradientAlphaKey {
    alpha: number;
    time: number;



}
    
interface GradientAlphaKeyConstructor {

    new(alpha: number, time: number): GradientAlphaKey;


}
declare const GradientAlphaKey: GradientAlphaKeyConstructor;
    
interface GradientConstructor {

    new(): Gradient;


}
declare const Gradient: GradientConstructor;
    
interface MinMaxGradientConstructor {

    new(color: Color): MinMaxGradient;
    new(gradient: Gradient): MinMaxGradient;
    new(min: Color, max: Color): MinMaxGradient;
    new(min: Gradient, max: Gradient): MinMaxGradient;


}
declare const MinMaxGradient: MinMaxGradientConstructor;
    
interface EmissionModule {
    type: ParticleSystemEmissionType;
    rate: MinMaxCurve;
    rateMultiplier: number;
    enabled: boolean;
    rateOverTime: MinMaxCurve;
    rateOverTimeMultiplier: number;
    rateOverDistance: MinMaxCurve;
    rateOverDistanceMultiplier: number;
    burstCount: number;


    GetBurst(index: number): Burst;
    GetBursts(bursts: CSArray<Burst>): number;
    SetBurst(index: number, burst: Burst): void;
    SetBursts(bursts: CSArray<Burst>): void;
    SetBursts(bursts: CSArray<Burst>, size: number): void;

}
    
interface Burst {
    time: number;
    count: MinMaxCurve;
    minCount: number;
    maxCount: number;
    cycleCount: number;
    repeatInterval: number;
    probability: number;



}
    
interface BurstConstructor {

    new(_time: number, _count: number): Burst;
    new(_time: number, _minCount: number, _maxCount: number): Burst;
    new(_time: number, _minCount: number, _maxCount: number, _cycleCount: number, _repeatInterval: number): Burst;
    new(_time: number, _count: MinMaxCurve): Burst;
    new(_time: number, _count: MinMaxCurve, _cycleCount: number, _repeatInterval: number): Burst;


}
declare const Burst: BurstConstructor;
    
interface ShapeModule {
    box: Vector3;
    meshScale: number;
    randomDirection: boolean;
    enabled: boolean;
    shapeType: ParticleSystemShapeType;
    randomDirectionAmount: number;
    sphericalDirectionAmount: number;
    randomPositionAmount: number;
    alignToDirection: boolean;
    radius: number;
    radiusMode: ParticleSystemShapeMultiModeValue;
    radiusSpread: number;
    radiusSpeed: MinMaxCurve;
    radiusSpeedMultiplier: number;
    radiusThickness: number;
    angle: number;
    length: number;
    boxThickness: Vector3;
    meshShapeType: ParticleSystemMeshShapeType;
    mesh: Mesh;
    meshRenderer: MeshRenderer;
    skinnedMeshRenderer: SkinnedMeshRenderer;
    sprite: Sprite;
    spriteRenderer: SpriteRenderer;
    useMeshMaterialIndex: boolean;
    meshMaterialIndex: number;
    useMeshColors: boolean;
    normalOffset: number;
    meshSpawnMode: ParticleSystemShapeMultiModeValue;
    meshSpawnSpread: number;
    meshSpawnSpeed: MinMaxCurve;
    meshSpawnSpeedMultiplier: number;
    arc: number;
    arcMode: ParticleSystemShapeMultiModeValue;
    arcSpread: number;
    arcSpeed: MinMaxCurve;
    arcSpeedMultiplier: number;
    donutRadius: number;
    position: Vector3;
    rotation: Vector3;
    scale: Vector3;
    texture: Texture2D;
    textureClipChannel: ParticleSystemShapeTextureChannel;
    textureClipThreshold: number;
    textureColorAffectsParticles: boolean;
    textureAlphaAffectsParticles: boolean;
    textureBilinearFiltering: boolean;
    textureUVChannel: number;



}
    
interface SpriteRenderer extends Renderer {
    sprite: Sprite;
    drawMode: SpriteDrawMode;
    size: Vector2;
    adaptiveModeThreshold: number;
    tileMode: SpriteTileMode;
    color: Color;
    maskInteraction: SpriteMaskInteraction;
    flipX: boolean;
    flipY: boolean;
    spriteSortPoint: SpriteSortPoint;


    RegisterSpriteChangeCallback(callback: unknown): void;
    UnregisterSpriteChangeCallback(callback: unknown): void;

}
    
interface SpriteRendererConstructor {

    new(): SpriteRenderer;


}
declare const SpriteRenderer: SpriteRendererConstructor;
    
interface VelocityOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    y: MinMaxCurve;
    z: MinMaxCurve;
    xMultiplier: number;
    yMultiplier: number;
    zMultiplier: number;
    orbitalX: MinMaxCurve;
    orbitalY: MinMaxCurve;
    orbitalZ: MinMaxCurve;
    orbitalXMultiplier: number;
    orbitalYMultiplier: number;
    orbitalZMultiplier: number;
    orbitalOffsetX: MinMaxCurve;
    orbitalOffsetY: MinMaxCurve;
    orbitalOffsetZ: MinMaxCurve;
    orbitalOffsetXMultiplier: number;
    orbitalOffsetYMultiplier: number;
    orbitalOffsetZMultiplier: number;
    radial: MinMaxCurve;
    radialMultiplier: number;
    speedModifier: MinMaxCurve;
    speedModifierMultiplier: number;
    space: ParticleSystemSimulationSpace;



}
    
interface LimitVelocityOverLifetimeModule {
    enabled: boolean;
    limitX: MinMaxCurve;
    limitXMultiplier: number;
    limitY: MinMaxCurve;
    limitYMultiplier: number;
    limitZ: MinMaxCurve;
    limitZMultiplier: number;
    limit: MinMaxCurve;
    limitMultiplier: number;
    dampen: number;
    separateAxes: boolean;
    space: ParticleSystemSimulationSpace;
    drag: MinMaxCurve;
    dragMultiplier: number;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;



}
    
interface InheritVelocityModule {
    enabled: boolean;
    mode: ParticleSystemInheritVelocityMode;
    curve: MinMaxCurve;
    curveMultiplier: number;



}
    
interface LifetimeByEmitterSpeedModule {
    enabled: boolean;
    curve: MinMaxCurve;
    curveMultiplier: number;
    range: Vector2;



}
    
interface ForceOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    y: MinMaxCurve;
    z: MinMaxCurve;
    xMultiplier: number;
    yMultiplier: number;
    zMultiplier: number;
    space: ParticleSystemSimulationSpace;
    randomized: boolean;



}
    
interface ColorOverLifetimeModule {
    enabled: boolean;
    color: MinMaxGradient;



}
    
interface ColorBySpeedModule {
    enabled: boolean;
    color: MinMaxGradient;
    range: Vector2;



}
    
interface SizeOverLifetimeModule {
    enabled: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;



}
    
interface SizeBySpeedModule {
    enabled: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;
    range: Vector2;



}
    
interface RotationOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;



}
    
interface RotationBySpeedModule {
    enabled: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;
    range: Vector2;



}
    
interface ExternalForcesModule {
    enabled: boolean;
    multiplier: number;
    multiplierCurve: MinMaxCurve;
    influenceFilter: ParticleSystemGameObjectFilter;
    influenceMask: LayerMask;
    influenceCount: number;


    AddInfluence(field: ParticleSystemForceField): void;
    GetInfluence(index: number): ParticleSystemForceField;
    IsAffectedBy(field: ParticleSystemForceField): boolean;
    RemoveAllInfluences(): void;
    RemoveInfluence(index: number): void;
    RemoveInfluence(field: ParticleSystemForceField): void;
    SetInfluence(index: number, field: ParticleSystemForceField): void;

}
    
interface ParticleSystemForceField extends Behaviour {
    shape: ParticleSystemForceFieldShape;
    startRange: number;
    endRange: number;
    length: number;
    gravityFocus: number;
    rotationRandomness: Vector2;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;
    vectorField: Texture3D;
    directionX: MinMaxCurve;
    directionY: MinMaxCurve;
    directionZ: MinMaxCurve;
    gravity: MinMaxCurve;
    rotationSpeed: MinMaxCurve;
    rotationAttraction: MinMaxCurve;
    drag: MinMaxCurve;
    vectorFieldSpeed: MinMaxCurve;
    vectorFieldAttraction: MinMaxCurve;



}
    
interface Texture3D extends Texture {
    depth: number;
    format: TextureFormat;
    isReadable: boolean;


    /** Copies changes you&#x27;ve made in a CPU texture to the GPU. */
    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    /** Gets the pixel color at coordinates (x, y, z). */
    GetPixel(x: number, y: number, z: number): Color;
    /** Gets the pixel color at coordinates (x, y, z). */
    GetPixel(x: number, y: number, z: number, mipLevel: number): Color;
    /** Gets the filtered pixel color at the normalized coordinates (u, v, w). */
    GetPixelBilinear(u: number, v: number, w: number): Color;
    /** Gets the filtered pixel color at the normalized coordinates (u, v, w). */
    GetPixelBilinear(u: number, v: number, w: number, mipLevel: number): Color;
    /** Gets the raw data from a texture. */
    GetPixelData<T>(mipLevel: number): CSArray<T>;
    /** Gets the pixel color data for a mipmap level as Color structs. */
    GetPixels(miplevel: number): CSArray<Color>;
    /** Gets the pixel color data for a mipmap level as Color structs. */
    GetPixels(): CSArray<Color>;
    /** Gets the pixel color data for a mipmap level as Color32 structs. */
    GetPixels32(miplevel: number): CSArray<Color32>;
    /** Gets the pixel color data for a mipmap level as Color32 structs. */
    GetPixels32(): CSArray<Color32>;
    /** Sets the pixel color at coordinates (x, y, z). */
    SetPixel(x: number, y: number, z: number, color: Color): void;
    /** Sets the pixel color at coordinates (x, y, z). */
    SetPixel(x: number, y: number, z: number, color: Color, mipLevel: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    /** Sets the pixel colors of an entire mipmap level. */
    SetPixels(colors: CSArray<Color>, miplevel: number): void;
    /** Sets the pixel colors of an entire mipmap level. */
    SetPixels(colors: CSArray<Color>): void;
    /** Sets the pixel colors of an entire mipmap level. */
    SetPixels32(colors: CSArray<Color32>, miplevel: number): void;
    /** Sets the pixel colors of an entire mipmap level. */
    SetPixels32(colors: CSArray<Color32>): void;
    /** Updates Unity texture to use different native texture object. */
    UpdateExternalTexture(nativeTex: unknown): void;

}
    
interface Texture3DConstructor {

    new(width: number, height: number, depth: number, format: DefaultFormat, flags: TextureCreationFlags): Texture3D;
    new(width: number, height: number, depth: number, format: DefaultFormat, flags: TextureCreationFlags, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, format: GraphicsFormat, flags: TextureCreationFlags): Texture3D;
    new(width: number, height: number, depth: number, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number, nativeTex: unknown): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number, nativeTex: unknown, createUninitialized: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean, createUninitialized: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean, nativeTex: unknown): Texture3D;


    CreateExternalTexture(width: number, height: number, depth: number, format: TextureFormat, mipChain: boolean, nativeTex: unknown): Texture3D;
}
declare const Texture3D: Texture3DConstructor;
    
interface ParticleSystemForceFieldConstructor {

    new(): ParticleSystemForceField;


    FindAll(): CSArray<ParticleSystemForceField>;
}
declare const ParticleSystemForceField: ParticleSystemForceFieldConstructor;
    
interface NoiseModule {
    enabled: boolean;
    separateAxes: boolean;
    strength: MinMaxCurve;
    strengthMultiplier: number;
    strengthX: MinMaxCurve;
    strengthXMultiplier: number;
    strengthY: MinMaxCurve;
    strengthYMultiplier: number;
    strengthZ: MinMaxCurve;
    strengthZMultiplier: number;
    frequency: number;
    damping: boolean;
    octaveCount: number;
    octaveMultiplier: number;
    octaveScale: number;
    quality: ParticleSystemNoiseQuality;
    scrollSpeed: MinMaxCurve;
    scrollSpeedMultiplier: number;
    remapEnabled: boolean;
    remap: MinMaxCurve;
    remapMultiplier: number;
    remapX: MinMaxCurve;
    remapXMultiplier: number;
    remapY: MinMaxCurve;
    remapYMultiplier: number;
    remapZ: MinMaxCurve;
    remapZMultiplier: number;
    positionAmount: MinMaxCurve;
    rotationAmount: MinMaxCurve;
    sizeAmount: MinMaxCurve;



}
    
interface CollisionModule {
    maxPlaneCount: number;
    enabled: boolean;
    type: ParticleSystemCollisionType;
    mode: ParticleSystemCollisionMode;
    dampen: MinMaxCurve;
    dampenMultiplier: number;
    bounce: MinMaxCurve;
    bounceMultiplier: number;
    lifetimeLoss: MinMaxCurve;
    lifetimeLossMultiplier: number;
    minKillSpeed: number;
    maxKillSpeed: number;
    collidesWith: LayerMask;
    enableDynamicColliders: boolean;
    maxCollisionShapes: number;
    quality: ParticleSystemCollisionQuality;
    voxelSize: number;
    radiusScale: number;
    sendCollisionMessages: boolean;
    colliderForce: number;
    multiplyColliderForceByCollisionAngle: boolean;
    multiplyColliderForceByParticleSpeed: boolean;
    multiplyColliderForceByParticleSize: boolean;
    planeCount: number;
    enableInteriorCollisions: boolean;


    AddPlane(transform: Transform): void;
    GetPlane(index: number): Transform;
    RemovePlane(index: number): void;
    RemovePlane(transform: Transform): void;
    SetPlane(index: number, transform: Transform): void;

}
    
interface TriggerModule {
    maxColliderCount: number;
    enabled: boolean;
    inside: ParticleSystemOverlapAction;
    outside: ParticleSystemOverlapAction;
    enter: ParticleSystemOverlapAction;
    exit: ParticleSystemOverlapAction;
    colliderQueryMode: ParticleSystemColliderQueryMode;
    radiusScale: number;
    colliderCount: number;


    AddCollider(collider: Component): void;
    GetCollider(index: number): Component;
    RemoveCollider(index: number): void;
    RemoveCollider(collider: Component): void;
    SetCollider(index: number, collider: Component): void;

}
    
interface SubEmittersModule {
    birth0: ParticleSystem;
    birth1: ParticleSystem;
    collision0: ParticleSystem;
    collision1: ParticleSystem;
    death0: ParticleSystem;
    death1: ParticleSystem;
    enabled: boolean;
    subEmittersCount: number;


    AddSubEmitter(subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties, emitProbability: number): void;
    AddSubEmitter(subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties): void;
    GetSubEmitterEmitProbability(index: number): number;
    GetSubEmitterProperties(index: number): ParticleSystemSubEmitterProperties;
    GetSubEmitterSystem(index: number): ParticleSystem;
    GetSubEmitterType(index: number): ParticleSystemSubEmitterType;
    RemoveSubEmitter(index: number): void;
    RemoveSubEmitter(subEmitter: ParticleSystem): void;
    SetSubEmitterEmitProbability(index: number, emitProbability: number): void;
    SetSubEmitterProperties(index: number, properties: ParticleSystemSubEmitterProperties): void;
    SetSubEmitterSystem(index: number, subEmitter: ParticleSystem): void;
    SetSubEmitterType(index: number, type: ParticleSystemSubEmitterType): void;

}
    
interface TextureSheetAnimationModule {
    flipU: number;
    flipV: number;
    useRandomRow: boolean;
    enabled: boolean;
    mode: ParticleSystemAnimationMode;
    timeMode: ParticleSystemAnimationTimeMode;
    fps: number;
    numTilesX: number;
    numTilesY: number;
    animation: ParticleSystemAnimationType;
    rowMode: ParticleSystemAnimationRowMode;
    frameOverTime: MinMaxCurve;
    frameOverTimeMultiplier: number;
    startFrame: MinMaxCurve;
    startFrameMultiplier: number;
    cycleCount: number;
    rowIndex: number;
    uvChannelMask: UVChannelFlags;
    spriteCount: number;
    speedRange: Vector2;


    AddSprite(sprite: Sprite): void;
    GetSprite(index: number): Sprite;
    RemoveSprite(index: number): void;
    SetSprite(index: number, sprite: Sprite): void;

}
    
interface LightsModule {
    enabled: boolean;
    ratio: number;
    useRandomDistribution: boolean;
    light: Light;
    useParticleColor: boolean;
    sizeAffectsRange: boolean;
    alphaAffectsIntensity: boolean;
    range: MinMaxCurve;
    rangeMultiplier: number;
    intensity: MinMaxCurve;
    intensityMultiplier: number;
    maxLights: number;



}
    
interface TrailModule {
    enabled: boolean;
    mode: ParticleSystemTrailMode;
    ratio: number;
    lifetime: MinMaxCurve;
    lifetimeMultiplier: number;
    minVertexDistance: number;
    textureMode: ParticleSystemTrailTextureMode;
    textureScale: Vector2;
    worldSpace: boolean;
    dieWithParticles: boolean;
    sizeAffectsWidth: boolean;
    sizeAffectsLifetime: boolean;
    inheritParticleColor: boolean;
    colorOverLifetime: MinMaxGradient;
    widthOverTrail: MinMaxCurve;
    widthOverTrailMultiplier: number;
    colorOverTrail: MinMaxGradient;
    generateLightingData: boolean;
    ribbonCount: number;
    shadowBias: number;
    splitSubEmitterRibbons: boolean;
    attachRibbonsToTransform: boolean;



}
    
interface CustomDataModule {
    enabled: boolean;


    GetColor(stream: ParticleSystemCustomData): MinMaxGradient;
    GetMode(stream: ParticleSystemCustomData): ParticleSystemCustomDataMode;
    GetVector(stream: ParticleSystemCustomData, component: number): MinMaxCurve;
    GetVectorComponentCount(stream: ParticleSystemCustomData): number;
    SetColor(stream: ParticleSystemCustomData, gradient: MinMaxGradient): void;
    SetMode(stream: ParticleSystemCustomData, mode: ParticleSystemCustomDataMode): void;
    SetVector(stream: ParticleSystemCustomData, component: number, curve: MinMaxCurve): void;
    SetVectorComponentCount(stream: ParticleSystemCustomData, count: number): void;

}
    
interface Particle {
    lifetime: number;
    randomValue: number;
    size: number;
    color: Color32;
    position: Vector3;
    velocity: Vector3;
    animatedVelocity: Vector3;
    totalVelocity: Vector3;
    remainingLifetime: number;
    startLifetime: number;
    startColor: Color32;
    randomSeed: number;
    axisOfRotation: Vector3;
    startSize: number;
    startSize3D: Vector3;
    rotation: number;
    rotation3D: Vector3;
    angularVelocity: number;
    angularVelocity3D: Vector3;


    GetCurrentColor(system: ParticleSystem): Color32;
    GetCurrentSize(system: ParticleSystem): number;
    GetCurrentSize3D(system: ParticleSystem): Vector3;
    GetMeshIndex(system: ParticleSystem): number;
    SetMeshIndex(index: number): void;

}
    
interface EmitParams {
    particle: Particle;
    position: Vector3;
    applyShapeToPosition: boolean;
    velocity: Vector3;
    startLifetime: number;
    startSize: number;
    startSize3D: Vector3;
    axisOfRotation: Vector3;
    rotation: number;
    rotation3D: Vector3;
    angularVelocity: number;
    angularVelocity3D: Vector3;
    startColor: Color32;
    randomSeed: number;
    meshIndex: number;


    ResetAngularVelocity(): void;
    ResetAxisOfRotation(): void;
    ResetMeshIndex(): void;
    ResetPosition(): void;
    ResetRandomSeed(): void;
    ResetRotation(): void;
    ResetStartColor(): void;
    ResetStartLifetime(): void;
    ResetStartSize(): void;
    ResetVelocity(): void;

}
    
interface PlaybackState {



}
    
interface Trails {
    capacity: number;



}
    
interface ParticleSystemConstructor {

    new(): ParticleSystem;


    ResetPreMappedBufferMemory(): void;
    SetMaximumPreMappedBufferCounts(vertexBuffersCount: number, indexBuffersCount: number): void;
}
declare const ParticleSystem: ParticleSystemConstructor;
    
interface AccessoryBuilderConstructor {

    new(): AccessoryBuilder;


}
declare const AccessoryBuilder: AccessoryBuilderConstructor;
    
interface AvatarMask extends Object {
    humanoidBodyPartCount: number;
    transformCount: number;


    AddTransformPath(transform: Transform): void;
    /** Adds a transform path into the AvatarMask. */
    AddTransformPath(transform: Transform, recursive: boolean): void;
    /** Returns true if the humanoid body part at the given index is active. */
    GetHumanoidBodyPartActive(index: AvatarMaskBodyPart): boolean;
    /** Returns true if the transform at the given index is active. */
    GetTransformActive(index: number): boolean;
    /** Returns the path of the transform at the given index. */
    GetTransformPath(index: number): string;
    RemoveTransformPath(transform: Transform): void;
    /** Removes a transform path from the AvatarMask. */
    RemoveTransformPath(transform: Transform, recursive: boolean): void;
    /** Sets the humanoid body part at the given index to active or not. */
    SetHumanoidBodyPartActive(index: AvatarMaskBodyPart, value: boolean): void;
    /** Sets the tranform at the given index to active or not. */
    SetTransformActive(index: number, value: boolean): void;
    /** Sets the path of the transform at the given index. */
    SetTransformPath(index: number, path: string): void;

}
    
interface AvatarMaskConstructor {

    new(): AvatarMask;


}
declare const AvatarMask: AvatarMaskConstructor;
    
interface GizmoUtils extends Debug {



}
    
interface GizmoUtilsConstructor {

    new(): GizmoUtils;


    DrawArc(startAngle: number, endAngle: number, position: Vector3, orientation: Quaternion, radius: number, color: Color, drawChord: boolean, drawSector: boolean, arcSegments: number, durationSec: number): void;
    DrawBox(position: Vector3, orientation: Quaternion, halfSize: Vector3, color: Color, durationSec: number): void;
    DrawCircle(position: Vector3, rotation: Quaternion, radius: number, segments: number, color: Color, durationSec: number): void;
    DrawQuad(pointA: Vector3, pointB: Vector3, pointC: Vector3, pointD: Vector3, color: Color, durationSec: number): void;
    DrawRect(origin: Vector3, orientation: Quaternion, extent: Vector2, color: Color, durationSec: number): void;
    DrawSingleLine(startPosition: Vector3, endPosition: Vector3, color: Color, durationSec: number): void;
    DrawSphere(position: Vector3, radius: number, color: Color, segments: number, durationSec: number): void;
    TogglePauseEngine(): void;
}
declare const GizmoUtils: GizmoUtilsConstructor;
    
interface CollisionWatcher extends MonoBehaviour {



}
    
interface CollisionWatcherConstructor {

    new(): CollisionWatcher;


}
declare const CollisionWatcher: CollisionWatcherConstructor;
    
interface TriggerWatcher extends MonoBehaviour {



}
    
interface TriggerWatcherConstructor {

    new(): TriggerWatcher;


}
declare const TriggerWatcher: TriggerWatcherConstructor;
    
interface PhysicsExt {



}
    
interface SphereCastReturnData {
    HitCount: number;
    RaycastHits: CSArray<RaycastHit>;



}
    
interface SphereCastReturnDataConstructor {

    new(hitCount: number, raycastHits: CSArray<RaycastHit>): SphereCastReturnData;


}
declare const SphereCastReturnData: SphereCastReturnDataConstructor;
    
interface PhysicsExtConstructor {

    new(): PhysicsExt;


    EasySphereCast(start: Vector3, direction: Vector3, radius: number, distance: number, layerMask: number): SphereCastReturnData;
}
declare const PhysicsExt: PhysicsExtConstructor;
    
interface ServerConsole extends MonoBehaviour {
    RemoteLogging: boolean;



}
    
interface ServerConsoleConstructor {

    new(): ServerConsole;


}
declare const ServerConsole: ServerConsoleConstructor;
    
interface RawImage extends MaskableGraphic {
    mainTexture: Texture;
    texture: Texture;
    uvRect: Rect;


    SetNativeSize(): void;

}
    
interface Application {



}
    
interface LogCallback {


    BeginInvoke(condition: string, stackTrace: string, type: LogType, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(condition: string, stackTrace: string, type: LogType): void;

}
    
interface LogCallbackConstructor {

    new(object: unknown, method: unknown): LogCallback;


}
declare const LogCallback: LogCallbackConstructor;
    
interface AdvertisingIdentifierCallback {


    BeginInvoke(advertisingId: string, trackingEnabled: boolean, errorMsg: string, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(advertisingId: string, trackingEnabled: boolean, errorMsg: string): void;

}
    
interface AdvertisingIdentifierCallbackConstructor {

    new(object: unknown, method: unknown): AdvertisingIdentifierCallback;


}
declare const AdvertisingIdentifierCallback: AdvertisingIdentifierCallbackConstructor;
    
interface ApplicationConstructor {
    isLoadingLevel: boolean;
    streamedBytes: number;
    webSecurityEnabled: boolean;
    isPlaying: boolean;
    isFocused: boolean;
    buildGUID: string;
    runInBackground: boolean;
    isBatchMode: boolean;
    dataPath: string;
    streamingAssetsPath: string;
    persistentDataPath: string;
    temporaryCachePath: string;
    absoluteURL: string;
    unityVersion: string;
    version: string;
    installerName: string;
    identifier: string;
    installMode: ApplicationInstallMode;
    sandboxType: ApplicationSandboxType;
    productName: string;
    companyName: string;
    cloudProjectId: string;
    targetFrameRate: number;
    stackTraceLogType: StackTraceLogType;
    consoleLogPath: string;
    backgroundLoadingPriority: ThreadPriority;
    genuine: boolean;
    genuineCheckAvailable: boolean;
    isShowingSplashScreen: boolean;
    platform: RuntimePlatform;
    isMobilePlatform: boolean;
    isConsolePlatform: boolean;
    systemLanguage: SystemLanguage;
    internetReachability: NetworkReachability;
    isPlayer: boolean;
    exitCancellationToken: unknown;
    levelCount: number;
    loadedLevel: number;
    loadedLevelName: string;
    isEditor: boolean;

    new(): Application;


    CancelQuit(): void;
    CanStreamedLevelBeLoaded(levelIndex: number): boolean;
    CanStreamedLevelBeLoaded(levelName: string): boolean;
    CaptureScreenshot(filename: string, superSize: number): void;
    CaptureScreenshot(filename: string): void;
    DontDestroyOnLoad(o: Object): void;
    ExternalCall(functionName: string, args: CSArray<unknown>): void;
    ExternalEval(script: string): void;
    ForceCrash(mode: number): void;
    GetBuildTags(): CSArray<string>;
    GetStackTraceLogType(logType: LogType): StackTraceLogType;
    GetStreamProgressForLevel(levelIndex: number): number;
    GetStreamProgressForLevel(levelName: string): number;
    HasProLicense(): boolean;
    HasUserAuthorization(mode: UserAuthorization): boolean;
    IsPlaying(obj: Object): boolean;
    LoadLevel(index: number): void;
    LoadLevel(name: string): void;
    LoadLevelAdditive(index: number): void;
    LoadLevelAdditive(name: string): void;
    LoadLevelAdditiveAsync(index: number): AsyncOperation;
    LoadLevelAdditiveAsync(levelName: string): AsyncOperation;
    LoadLevelAsync(index: number): AsyncOperation;
    LoadLevelAsync(levelName: string): AsyncOperation;
    OpenURL(url: string): void;
    Quit(exitCode: number): void;
    Quit(): void;
    RegisterLogCallback(handler: LogCallback): void;
    RegisterLogCallbackThreaded(handler: LogCallback): void;
    RequestAdvertisingIdentifierAsync(delegateMethod: AdvertisingIdentifierCallback): boolean;
    RequestUserAuthorization(mode: UserAuthorization): AsyncOperation;
    SetBuildTags(buildTags: CSArray<string>): void;
    SetStackTraceLogType(logType: LogType, stackTraceType: StackTraceLogType): void;
    Unload(): void;
    UnloadLevel(index: number): boolean;
    UnloadLevel(scenePath: string): boolean;
}
declare const Application: ApplicationConstructor;
    
interface ClientNetworkConnector extends MonoBehaviour {
    expectingDisconnect: boolean;



}
    
interface ClientNetworkConnectorConstructor {

    new(): ClientNetworkConnector;


}
declare const ClientNetworkConnector: ClientNetworkConnectorConstructor;
    
interface ParticleSystemRenderer extends Renderer {
    alignment: ParticleSystemRenderSpace;
    renderMode: ParticleSystemRenderMode;
    meshDistribution: ParticleSystemMeshDistribution;
    sortMode: ParticleSystemSortMode;
    lengthScale: number;
    velocityScale: number;
    cameraVelocityScale: number;
    normalDirection: number;
    shadowBias: number;
    sortingFudge: number;
    minParticleSize: number;
    maxParticleSize: number;
    pivot: Vector3;
    flip: Vector3;
    maskInteraction: SpriteMaskInteraction;
    trailMaterial: Material;
    enableGPUInstancing: boolean;
    allowRoll: boolean;
    freeformStretching: boolean;
    rotateWithStretchDirection: boolean;
    mesh: Mesh;
    meshCount: number;
    activeVertexStreamsCount: number;
    activeTrailVertexStreamsCount: number;
    supportsMeshInstancing: boolean;


    /** Query whether the Particle System Renderer uses a particular set of vertex streams. */
    AreVertexStreamsEnabled(streams: ParticleSystemVertexStreams): boolean;
    /** Creates a snapshot of ParticleSystemRenderer and stores it in a mesh. */
    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    /** Creates a snapshot of ParticleSystemRenderer and stores it in a mesh. */
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    /** Creates a snapshot of ParticleSystemRenderer and stores it in a mesh. */
    BakeMesh(mesh: Mesh, options: ParticleSystemBakeMeshOptions): void;
    /** Creates a snapshot of ParticleSystemRenderer and stores it in a mesh. */
    BakeMesh(mesh: Mesh, camera: Camera, options: ParticleSystemBakeMeshOptions): void;
    /** Creates a snapshot of ParticleSystemRenderer and stores it in a Texture2D. */
    BakeTexture(verticesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    /** Creates a snapshot of ParticleSystemRenderer and stores it in a Texture2D. */
    BakeTexture(verticesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    /** Creates a snapshot of ParticleSystemRenderer and stores it in a Texture2D. */
    BakeTexture(verticesTexture: unknown, indicesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    /** Creates a snapshot of ParticleSystemRenderer and stores it in a Texture2D. */
    BakeTexture(verticesTexture: unknown, indicesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    /** Creates a snapshot of ParticleSystem Trails and stores them in a mesh. */
    BakeTrailsMesh(mesh: Mesh, useTransform: boolean): void;
    /** Creates a snapshot of ParticleSystem Trails and stores them in a mesh. */
    BakeTrailsMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    /** Creates a snapshot of ParticleSystem Trails and stores them in a mesh. */
    BakeTrailsMesh(mesh: Mesh, options: ParticleSystemBakeMeshOptions): void;
    /** Creates a snapshot of ParticleSystem Trails and stores them in a mesh. */
    BakeTrailsMesh(mesh: Mesh, camera: Camera, options: ParticleSystemBakeMeshOptions): void;
    /** Creates a snapshot of ParticleSystem Trails and stores them in a Texture2D. */
    BakeTrailsTexture(verticesTexture: unknown, indicesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    /** Creates a snapshot of ParticleSystem Trails and stores them in a Texture2D. */
    BakeTrailsTexture(verticesTexture: unknown, indicesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    /** Disable a set of vertex Shader streams on the Particle System Renderer.
The position stream is always enabled, and any attempts to remove it are ignored. */
    DisableVertexStreams(streams: ParticleSystemVertexStreams): void;
    /** Enable a set of vertex Shader streams on the Particle System renderer. */
    EnableVertexStreams(streams: ParticleSystemVertexStreams): void;
    GetActiveTrailVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    GetActiveVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    /** Queries whether the Particle System renderer uses a particular set of vertex streams. */
    GetEnabledVertexStreams(streams: ParticleSystemVertexStreams): ParticleSystemVertexStreams;
    /** Gets the array of Meshes to use when selecting particle meshes. */
    GetMeshes(meshes: CSArray<Mesh>): number;
    /** Gets the array of Mesh weightings to use when randomly selecting particle meshes. */
    GetMeshWeightings(weightings: CSArray<number>): number;
    SetActiveTrailVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    SetActiveVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    /** Sets the Meshes that the ParticleSystemRenderer uses to display particles when the ParticleSystemRenderer.renderMode is set to ParticleSystemRenderMode.Mesh. */
    SetMeshes(meshes: CSArray<Mesh>, size: number): void;
    /** Sets the Meshes that the ParticleSystemRenderer uses to display particles when the ParticleSystemRenderer.renderMode is set to ParticleSystemRenderMode.Mesh. */
    SetMeshes(meshes: CSArray<Mesh>): void;
    /** Sets the weights that the ParticleSystemRenderer uses to assign Meshes to particles. */
    SetMeshWeightings(weightings: CSArray<number>, size: number): void;
    /** Sets the weights that the ParticleSystemRenderer uses to assign Meshes to particles. */
    SetMeshWeightings(weightings: CSArray<number>): void;

}
    
interface ParticleSystemRendererConstructor {

    new(): ParticleSystemRenderer;


}
declare const ParticleSystemRenderer: ParticleSystemRendererConstructor;
    
interface Profiler {



}
    
interface ProfilerCategory {
    Name: string;
    Color: Color32;


    ToString(): string;

}
    
interface ProfilerCategoryConstructor {
    Render: ProfilerCategory;
    Scripts: ProfilerCategory;
    Gui: ProfilerCategory;
    Physics: ProfilerCategory;
    Physics2D: ProfilerCategory;
    Animation: ProfilerCategory;
    Ai: ProfilerCategory;
    Audio: ProfilerCategory;
    Video: ProfilerCategory;
    Particles: ProfilerCategory;
    Lighting: ProfilerCategory;
    Network: ProfilerCategory;
    Loading: ProfilerCategory;
    Vr: ProfilerCategory;
    Input: ProfilerCategory;
    Memory: ProfilerCategory;
    VirtualTexturing: ProfilerCategory;
    FileIO: ProfilerCategory;
    Internal: ProfilerCategory;

    new(categoryName: string): ProfilerCategory;
    new(categoryName: string, color: ProfilerCategoryColor): ProfilerCategory;


}
declare const ProfilerCategory: ProfilerCategoryConstructor;
    
interface ProfilerConstructor {
    supported: boolean;
    logFile: string;
    enableBinaryLog: boolean;
    maxUsedMemory: number;
    enabled: boolean;
    enableAllocationCallstacks: boolean;
    areaCount: number;
    maxNumberOfSamplesPerFrame: number;
    usedHeapSize: number;
    usedHeapSizeLong: number;



    AddFramesFromFile(file: string): void;
    BeginSample(name: string): void;
    BeginSample(name: string, targetObject: Object): void;
    BeginThreadProfiling(threadGroupName: string, threadName: string): void;
    EmitFrameMetaData(id: unknown, tag: number, data: unknown): void;
    EmitFrameMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitFrameMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitSessionMetaData(id: unknown, tag: number, data: unknown): void;
    EmitSessionMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitSessionMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EndSample(): void;
    EndThreadProfiling(): void;
    GetAllCategories(categories: CSArray<ProfilerCategory>): void;
    GetAllCategories(categories: CSArray<ProfilerCategory>): void;
    GetAllocatedMemoryForGraphicsDriver(): number;
    GetAreaEnabled(area: ProfilerArea): boolean;
    GetCategoriesCount(): number;
    GetMonoHeapSize(): number;
    GetMonoHeapSizeLong(): number;
    GetMonoUsedSize(): number;
    GetMonoUsedSizeLong(): number;
    GetRuntimeMemorySize(o: Object): number;
    GetRuntimeMemorySizeLong(o: Object): number;
    GetTempAllocatorSize(): number;
    GetTotalAllocatedMemory(): number;
    GetTotalAllocatedMemoryLong(): number;
    GetTotalFragmentationInfo(stats: CSArray<number>): number;
    GetTotalReservedMemory(): number;
    GetTotalReservedMemoryLong(): number;
    GetTotalUnusedReservedMemory(): number;
    GetTotalUnusedReservedMemoryLong(): number;
    IsCategoryEnabled(category: ProfilerCategory): boolean;
    SetAreaEnabled(area: ProfilerArea, enabled: boolean): void;
    SetCategoryEnabled(category: ProfilerCategory, enabled: boolean): void;
    SetTempAllocatorRequestedSize(size: number): boolean;
}
declare const Profiler: ProfilerConstructor;
    
interface ICancelHandler extends IEventSystemHandler {


    OnCancel(eventData: BaseEventData): void;

}
    
interface IBeginDragHandler extends IEventSystemHandler {


    OnBeginDrag(eventData: PointerEventData): void;

}
    
interface IDragHandler extends IEventSystemHandler {


    OnDrag(eventData: PointerEventData): void;

}
    
interface IEndDragHandler extends IEventSystemHandler {


    OnEndDrag(eventData: PointerEventData): void;

}
    
interface IScrollHandler extends IEventSystemHandler {


    OnScroll(eventData: PointerEventData): void;

}
    
interface IUpdateSelectedHandler extends IEventSystemHandler {


    OnUpdateSelected(eventData: BaseEventData): void;

}
    
interface TMP_InputField extends Selectable, ISubmitHandler, IPointerClickHandler, ICancelHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, IUpdateSelectedHandler, ILayoutElement {
    isAlert: boolean;
    shouldActivateOnSelect: boolean;
    shouldHideMobileInput: boolean;
    shouldHideSoftKeyboard: boolean;
    text: string;
    isFocused: boolean;
    caretBlinkRate: number;
    caretWidth: number;
    textViewport: RectTransform;
    textComponent: TMP_Text;
    placeholder: Graphic;
    verticalScrollbar: Scrollbar;
    scrollSensitivity: number;
    caretColor: Color;
    customCaretColor: boolean;
    selectionColor: Color;
    onEndEdit: SubmitEvent;
    onSubmit: SubmitEvent;
    onSelect: SelectionEvent;
    onDeselect: SelectionEvent;
    onTextSelection: TextSelectionEvent;
    onEndTextSelection: TextSelectionEvent;
    onValueChanged: OnChangeEvent;
    onTouchScreenKeyboardStatusChanged: TouchScreenKeyboardEvent;
    onValidateInput: OnValidateInput;
    characterLimit: number;
    pointSize: number;
    fontAsset: TMP_FontAsset;
    onFocusSelectAll: boolean;
    resetOnDeActivation: boolean;
    keepTextSelectionVisible: boolean;
    restoreOriginalTextOnEscape: boolean;
    isRichTextEditingAllowed: boolean;
    contentType: ContentType;
    lineType: LineType;
    lineLimit: number;
    inputType: InputType;
    touchScreenKeyboard: TouchScreenKeyboard;
    keyboardType: TouchScreenKeyboardType;
    characterValidation: CharacterValidation;
    inputValidator: TMP_InputValidator;
    readOnly: boolean;
    richText: boolean;
    multiLine: boolean;
    asteriskChar: string;
    wasCanceled: boolean;
    caretPosition: number;
    selectionAnchorPosition: number;
    selectionFocusPosition: number;
    stringPosition: number;
    selectionStringAnchorPosition: number;
    selectionStringFocusPosition: number;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    ActivateInputField(): void;
    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    DeactivateInputField(clearSelection: boolean): void;
    ForceLabelUpdate(): void;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    MoveTextEnd(shift: boolean): void;
    MoveTextStart(shift: boolean): void;
    MoveToEndOfLine(shift: boolean, ctrl: boolean): void;
    MoveToStartOfLine(shift: boolean, ctrl: boolean): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnCancel(eventData: BaseEventData): void;
    OnControlClick(): void;
    OnDeselect(eventData: BaseEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnScroll(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    OnUpdateSelected(eventData: BaseEventData): void;
    ProcessEvent(e: Event): void;
    Rebuild(update: CanvasUpdate): void;
    ReleaseSelection(): void;
    SetGlobalFontAsset(fontAsset: TMP_FontAsset): void;
    SetGlobalPointSize(pointSize: number): void;
    SetTextWithoutNotify(input: string): void;

}
    
interface IInitializePotentialDragHandler extends IEventSystemHandler {


    OnInitializePotentialDrag(eventData: PointerEventData): void;

}
    
interface Scrollbar extends Selectable, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, ICanvasElement {
    handleRect: RectTransform;
    direction: Direction;
    value: number;
    size: number;
    numberOfSteps: number;
    onValueChanged: ScrollEvent;


    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetDirection(direction: Direction, includeRectLayouts: boolean): void;
    SetValueWithoutNotify(input: number): void;

}
    
interface ScrollEvent {



}
    
interface ScrollEventConstructor {

    new(): ScrollEvent;


}
declare const ScrollEvent: ScrollEventConstructor;
    
interface SubmitEvent {



}
    
interface SubmitEventConstructor {

    new(): SubmitEvent;


}
declare const SubmitEvent: SubmitEventConstructor;
    
interface SelectionEvent {



}
    
interface SelectionEventConstructor {

    new(): SelectionEvent;


}
declare const SelectionEvent: SelectionEventConstructor;
    
interface TextSelectionEvent {



}
    
interface TextSelectionEventConstructor {

    new(): TextSelectionEvent;


}
declare const TextSelectionEvent: TextSelectionEventConstructor;
    
interface OnChangeEvent {



}
    
interface OnChangeEventConstructor {

    new(): OnChangeEvent;


}
declare const OnChangeEvent: OnChangeEventConstructor;
    
interface TouchScreenKeyboardEvent {



}
    
interface TouchScreenKeyboardEventConstructor {

    new(): TouchScreenKeyboardEvent;


}
declare const TouchScreenKeyboardEvent: TouchScreenKeyboardEventConstructor;
    
interface OnValidateInput {


    BeginInvoke(text: string, charIndex: number, addedChar: string, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): string;
    Invoke(text: string, charIndex: number, addedChar: string): string;

}
    
interface OnValidateInputConstructor {

    new(object: unknown, method: unknown): OnValidateInput;


}
declare const OnValidateInput: OnValidateInputConstructor;
    
interface TouchScreenKeyboard {
    text: string;
    active: boolean;
    done: boolean;
    wasCanceled: boolean;
    status: Status;
    characterLimit: number;
    canGetSelection: boolean;
    canSetSelection: boolean;
    selection: RangeInt;
    type: TouchScreenKeyboardType;
    targetDisplay: number;



}
    
interface RangeInt {
    start: number;
    length: number;
    end: number;



}
    
interface RangeIntConstructor {

    new(start: number, length: number): RangeInt;


}
declare const RangeInt: RangeIntConstructor;
    
interface TouchScreenKeyboardConstructor {
    isSupported: boolean;
    isInPlaceEditingAllowed: boolean;
    hideInput: boolean;
    area: Rect;
    visible: boolean;

    new(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string, characterLimit: number): TouchScreenKeyboard;


    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string, characterLimit: number): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType): TouchScreenKeyboard;
    Open(text: string): TouchScreenKeyboard;
}
declare const TouchScreenKeyboard: TouchScreenKeyboardConstructor;
    
interface TMP_InputValidator extends ScriptableObject {


    Validate(text: CSArray<string>, pos: unknown, ch: string): string;

}
    
interface Event {
    rawType: EventType;
    mousePosition: Vector2;
    delta: Vector2;
    pointerType: PointerType;
    button: number;
    modifiers: EventModifiers;
    pressure: number;
    twist: number;
    tilt: Vector2;
    penStatus: PenStatus;
    clickCount: number;
    character: string;
    keyCode: KeyCode;
    displayIndex: number;
    type: EventType;
    commandName: string;
    mouseRay: Ray;
    shift: boolean;
    control: boolean;
    alt: boolean;
    command: boolean;
    capsLock: boolean;
    numeric: boolean;
    functionKey: boolean;
    isKey: boolean;
    isMouse: boolean;
    isScrollWheel: boolean;


    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    /** Get a filtered event type for a given control ID. */
    GetTypeForControl(controlID: number): EventType;
    ToString(): string;
    /** Use this event. */
    Use(): void;

}
    
interface EventConstructor {
    current: Event;

    new(): Event;
    new(displayIndex: number): Event;
    new(other: Event): Event;


    GetEventCount(): number;
    KeyboardEvent(key: string): Event;
    PopEvent(outEvent: Event): boolean;
}
declare const Event: EventConstructor;
    
interface Slider extends Selectable, IInitializePotentialDragHandler, IDragHandler, ICanvasElement {
    fillRect: RectTransform;
    handleRect: RectTransform;
    direction: Direction;
    minValue: number;
    maxValue: number;
    wholeNumbers: boolean;
    value: number;
    normalizedValue: number;
    onValueChanged: SliderEvent;


    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetDirection(direction: Direction, includeRectLayouts: boolean): void;
    SetValueWithoutNotify(input: number): void;

}
    
interface SliderEvent {



}
    
interface SliderEventConstructor {

    new(): SliderEvent;


}
declare const SliderEvent: SliderEventConstructor;
    
interface CanvasHitDetector extends MonoBehaviour {


    IsPointerOverTarget(target: GameObject): boolean;
    IsPointerOverUI(): boolean;

}
    
interface CanvasHitDetectorConstructor {

    new(): CanvasHitDetector;


}
declare const CanvasHitDetector: CanvasHitDetectorConstructor;
    
interface AudioBehaviour extends Behaviour {



}
    
interface AudioBehaviourConstructor {

    new(): AudioBehaviour;


}
declare const AudioBehaviour: AudioBehaviourConstructor;
    
interface AudioSource extends AudioBehaviour {
    panLevel: number;
    pan: number;
    volume: number;
    pitch: number;
    time: number;
    timeSamples: number;
    clip: AudioClip;
    resource: AudioResource;
    outputAudioMixerGroup: AudioMixerGroup;
    gamepadSpeakerOutputType: GamepadSpeakerOutputType;
    isPlaying: boolean;
    isVirtual: boolean;
    loop: boolean;
    ignoreListenerVolume: boolean;
    playOnAwake: boolean;
    ignoreListenerPause: boolean;
    velocityUpdateMode: AudioVelocityUpdateMode;
    panStereo: number;
    spatialBlend: number;
    spatialize: boolean;
    spatializePostEffects: boolean;
    reverbZoneMix: number;
    bypassEffects: boolean;
    bypassListenerEffects: boolean;
    bypassReverbZones: boolean;
    dopplerLevel: number;
    spread: number;
    priority: number;
    mute: boolean;
    minDistance: number;
    maxDistance: number;
    rolloffMode: AudioRolloffMode;
    minVolume: number;
    maxVolume: number;
    rolloffFactor: number;


    /** Disables audio output to a gamepad for this audio source. */
    DisableGamepadOutput(): boolean;
    /** Reads a user-defined parameter of a custom ambisonic decoder effect that is attached to an AudioSource. */
    GetAmbisonicDecoderFloat(index: number, value: unknown): boolean;
    /** Get the current custom curve for the given AudioSourceCurveType. */
    GetCustomCurve(type: AudioSourceCurveType): AnimationCurve;
    /** Deprecated Version. Returns a block of the currently playing source&#x27;s output data. */
    GetOutputData(numSamples: number, channel: number): CSArray<number>;
    /** Provides a block of the currently playing source&#x27;s output data. */
    GetOutputData(samples: CSArray<number>, channel: number): void;
    /** Reads a user-defined parameter of a custom spatializer effect that is attached to an AudioSource. */
    GetSpatializerFloat(index: number, value: unknown): boolean;
    /** Deprecated Version. Returns a block of the currently playing source&#x27;s spectrum data. */
    GetSpectrumData(numSamples: number, channel: number, window: FFTWindow): CSArray<number>;
    /** Provides a block of the currently playing audio source&#x27;s spectrum data. */
    GetSpectrumData(samples: CSArray<number>, channel: number, window: FFTWindow): void;
    /** Pauses playing the clip. */
    Pause(): void;
    Play(): void;
    /** Plays the clip. */
    Play(delay: number): void;
    /** Plays the clip with a delay specified in seconds. Users are advised to use this function instead of the old Play(delay) function that took a delay specified in samples relative to a reference rate of 44.1 kHz as an argument. */
    PlayDelayed(delay: number): void;
    /** Plays an AudioClip, and scales the AudioSource volume by volumeScale. */
    PlayOneShot(clip: AudioClip): void;
    /** Plays an AudioClip, and scales the AudioSource volume by volumeScale. */
    PlayOneShot(clip: AudioClip, volumeScale: number): void;
    /** Enable playing of audio source though a specfic gamepad. */
    PlayOnGamepad(slot: number): boolean;
    /** Plays the clip at a specific time on the absolute time-line that AudioSettings.dspTime reads from. */
    PlayScheduled(time: number): void;
    /** Sets a user-defined parameter of a custom ambisonic decoder effect that is attached to an AudioSource. */
    SetAmbisonicDecoderFloat(index: number, value: number): boolean;
    /** Set the custom curve for the given AudioSourceCurveType. */
    SetCustomCurve(type: AudioSourceCurveType, curve: AnimationCurve): void;
    SetGamepadSpeakerMixLevel(slot: number, mixLevel: number): boolean;
    SetGamepadSpeakerMixLevelDefault(slot: number): boolean;
    SetGamepadSpeakerRestrictedAudio(slot: number, restricted: boolean): boolean;
    /** Changes the time at which a sound that has already been scheduled to play will end. Notice that depending on the timing not all rescheduling requests can be fulfilled. */
    SetScheduledEndTime(time: number): void;
    /** Changes the time at which a sound that has already been scheduled to play will start. */
    SetScheduledStartTime(time: number): void;
    /** Sets a user-defined parameter of a custom spatializer effect that is attached to an AudioSource. */
    SetSpatializerFloat(index: number, value: number): boolean;
    /** Stops playing the clip. */
    Stop(): void;
    /** Unpause the paused playback of this AudioSource. */
    UnPause(): void;

}
    
interface AudioResource extends Object {



}
    
interface AudioClip extends AudioResource {
    length: number;
    samples: number;
    channels: number;
    frequency: number;
    isReadyToPlay: boolean;
    loadType: AudioClipLoadType;
    preloadAudioData: boolean;
    ambisonic: boolean;
    loadInBackground: boolean;
    loadState: AudioDataLoadState;


    GetData(data: unknown, offsetSamples: number): boolean;
    /** Fills an array with sample data from the clip. */
    GetData(data: CSArray<number>, offsetSamples: number): boolean;
    /** Loads the audio data of a clip. Clips that have &quot;Preload Audio Data&quot; set will load the audio data automatically. */
    LoadAudioData(): boolean;
    /** Set sample data in a clip. */
    SetData(data: CSArray<number>, offsetSamples: number): boolean;
    SetData(data: unknown, offsetSamples: number): boolean;
    /** Unloads the audio data associated with the clip. This works only for AudioClips that are based on actual sound file assets. */
    UnloadAudioData(): boolean;

}
    
interface PCMReaderCallback {


    BeginInvoke(data: CSArray<number>, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(data: CSArray<number>): void;

}
    
interface PCMReaderCallbackConstructor {

    new(object: unknown, method: unknown): PCMReaderCallback;


}
declare const PCMReaderCallback: PCMReaderCallbackConstructor;
    
interface PCMSetPositionCallback {


    BeginInvoke(position: number, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(position: number): void;

}
    
interface PCMSetPositionCallbackConstructor {

    new(object: unknown, method: unknown): PCMSetPositionCallback;


}
declare const PCMSetPositionCallback: PCMSetPositionCallbackConstructor;
    
interface AudioClipConstructor {



    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean, pcmreadercallback: PCMReaderCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean, pcmreadercallback: PCMReaderCallback, pcmsetpositioncallback: PCMSetPositionCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: PCMReaderCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: PCMReaderCallback, pcmsetpositioncallback: PCMSetPositionCallback): AudioClip;
}
declare const AudioClip: AudioClipConstructor;
    
interface ISubAssetNotDuplicatable {



}
    
interface AudioMixerGroup extends Object, ISubAssetNotDuplicatable {
    audioMixer: AudioMixer;



}
    
interface AudioMixer extends Object {
    outputAudioMixerGroup: AudioMixerGroup;
    updateMode: AudioMixerUpdateMode;


    /** Resets an exposed parameter to its initial value. */
    ClearFloat(name: string): boolean;
    /** Connected groups in the mixer form a path from the mixer&#x27;s master group to the leaves. This path has the format Master GroupChild of Master GroupGrandchild of Master Group, and so on. For example, in the hierarchy below, the group DROPS has the path MasterWATERDROPS.  To return only the group called DROPS, enter DROPS. The substring MasterAMBIENCE returns three groups, AMBIENCECROWD, AMBIENCEROAD, and AMBIENCE. The substring R would return both ROAD and RIVER. */
    FindMatchingGroups(subPath: string): CSArray<AudioMixerGroup>;
    /** The name must be an exact match. */
    FindSnapshot(name: string): AudioMixerSnapshot;
    /** Returns the value of the exposed parameter specified. If the parameter doesn&#x27;t exist the function returns false. Prior to calling SetFloat and after ClearFloat has been called on this parameter the value returned will be that of the current snapshot or snapshot transition. */
    GetFloat(name: string, value: unknown): boolean;
    /** Sets the value of the exposed parameter specified. When a parameter is exposed, it is not controlled by mixer snapshots. You can only change the parameter with this function.

Note: Calling this function in MonoBehaviour.Awake will result in unexpected behavior. Use MonoBehaviour.Start instead. */
    SetFloat(name: string, value: number): boolean;
    /** Transitions to a weighted mixture of the snapshots specified. This can be used for games that specify the game state as a continuum between states or for interpolating snapshots from a triangulated map location. */
    TransitionToSnapshots(snapshots: CSArray<AudioMixerSnapshot>, weights: CSArray<number>, timeToReach: number): void;

}
    
interface AudioMixerSnapshot extends Object, ISubAssetNotDuplicatable {
    audioMixer: AudioMixer;


    /** Performs an interpolated transition towards this snapshot over the time interval specified. */
    TransitionTo(timeToReach: number): void;

}
    
interface AudioSourceConstructor {

    new(): AudioSource;


    GamepadSpeakerSupportsOutputType(outputType: GamepadSpeakerOutputType): boolean;
    PlayClipAtPoint(clip: AudioClip, position: Vector3): void;
    PlayClipAtPoint(clip: AudioClip, position: Vector3, volume: number): void;
}
declare const AudioSource: AudioSourceConstructor;
    
interface ITween {


    Cancel(): void;
    GetTotalDuration(includeDelay: boolean): number;

}
    
interface Tween<DriverValueType> extends MonoBehaviour, ITween {


    Await(): void;
    Cancel(): void;
    GetTotalDuration(includeDelay: boolean): number;
    OnGetFrom(): DriverValueType;
    OnInitialize(): boolean;
    OnUpdate(easedTime: number): void;
    SetDelay(delay: number, goToFirstFrameImmediately: boolean): Tween<DriverValueType>;
    SetEase(ease: EaseType): Tween<DriverValueType>;
    SetEaseBackIn(): Tween<DriverValueType>;
    SetEaseBackInOut(): Tween<DriverValueType>;
    SetEaseBackOut(): Tween<DriverValueType>;
    SetEaseBounceIn(): Tween<DriverValueType>;
    SetEaseBounceInOut(): Tween<DriverValueType>;
    SetEaseBounceOut(): Tween<DriverValueType>;
    SetEaseCircIn(): Tween<DriverValueType>;
    SetEaseCircInOut(): Tween<DriverValueType>;
    SetEaseCircOut(): Tween<DriverValueType>;
    SetEaseCubicIn(): Tween<DriverValueType>;
    SetEaseCubicInOut(): Tween<DriverValueType>;
    SetEaseCubicOut(): Tween<DriverValueType>;
    SetEaseElasticIn(): Tween<DriverValueType>;
    SetEaseElasticInOut(): Tween<DriverValueType>;
    SetEaseElasticOut(): Tween<DriverValueType>;
    SetEaseExpoIn(): Tween<DriverValueType>;
    SetEaseExpoInOut(): Tween<DriverValueType>;
    SetEaseExpoOut(): Tween<DriverValueType>;
    SetEaseLinear(): Tween<DriverValueType>;
    SetEaseQuadIn(): Tween<DriverValueType>;
    SetEaseQuadInOut(): Tween<DriverValueType>;
    SetEaseQuadOut(): Tween<DriverValueType>;
    SetEaseQuartIn(): Tween<DriverValueType>;
    SetEaseQuartInOut(): Tween<DriverValueType>;
    SetEaseQuartOut(): Tween<DriverValueType>;
    SetEaseQuintIn(): Tween<DriverValueType>;
    SetEaseQuintInOut(): Tween<DriverValueType>;
    SetEaseQuintOut(): Tween<DriverValueType>;
    SetEaseSineIn(): Tween<DriverValueType>;
    SetEaseSineInOut(): Tween<DriverValueType>;
    SetEaseSineOut(): Tween<DriverValueType>;
    SetFrom(valueFrom: DriverValueType): Tween<DriverValueType>;
    SetInfinite(): Tween<DriverValueType>;
    SetLoopCount(loopCount: number): Tween<DriverValueType>;
    SetOnCancel(onCancel: unknown): Tween<DriverValueType>;
    SetOnComplete(onComplete: unknown): Tween<DriverValueType>;
    SetOnStart(onStart: unknown): Tween<DriverValueType>;
    SetOvershooting(overshooting: number): Tween<DriverValueType>;
    SetPaused(isPaused: boolean): Tween<DriverValueType>;
    SetPingPong(): Tween<DriverValueType>;
    SetRandomTime(): Tween<DriverValueType>;
    SetTime(time: number): Tween<DriverValueType>;
    SetUseUnscaledTime(useUnscaledTime: boolean): Tween<DriverValueType>;
    Yield(): unknown;

}
    
interface Bridge {



}
    
interface IChatroomNetwork {
    OwnID: number;
    PeerIDs: CSArray<number>;


    BroadcastAudioSegment(data: ChatroomAudioSegment): void;
    CloseChatroom(data: unknown): void;
    HostChatroom(data: unknown): void;
    JoinChatroom(data: unknown): void;
    LeaveChatroom(data: unknown): void;

}
    
interface ChatroomAudioSegment {
    segmentIndex: number;
    frequency: number;
    channelCount: number;
    samples: CSArray<number>;



}
    
interface AirshipUniVoiceNetwork extends NetworkBehaviour, IChatroomNetwork {
    agent: ChatroomAgent;
    OwnID: number;
    PeerIDs: CSArray<number>;


    Awake(): void;
    BroadcastAudioSegment(data: ChatroomAudioSegment): void;
    CloseChatroom(data: unknown): void;
    Dispose(): void;
    FromByteArray<T>(data: CSArray<number>): T;
    HostChatroom(data: unknown): void;
    JoinChatroom(data: unknown): void;
    LeaveChatroom(data: unknown): void;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnDespawnServer(connection: NetworkConnection): void;
    OnSpawnServer(conn: NetworkConnection): void;
    OnStartNetwork(): void;
    OnStartServer(): void;
    OnStopNetwork(): void;
    ToByteArray<T>(obj: T): CSArray<number>;

}
    
interface ChatroomAgent {
    PeerOutputs: CSDictionary<number, IAudioOutput>;
    OnModeChanged: unknown;
    PeerSettings: CSDictionary<number, ChatroomPeerSettings>;
    Network: IChatroomNetwork;
    AudioInput: IAudioInput;
    AudioOutputFactory: IAudioOutputFactory;
    CurrentMode: ChatroomAgentMode;
    MuteOthers: boolean;
    MuteSelf: boolean;


    Dispose(): void;

}
    
interface IAudioOutput {
    ID: string;


    Feed(segmentIndex: number, frequency: number, channelCount: number, audioSamples: CSArray<number>): void;
    Feed(segment: ChatroomAudioSegment): void;

}
    
interface ChatroomPeerSettings {
    muteThem: boolean;
    muteSelf: boolean;



}
    
interface ChatroomPeerSettingsConstructor {

    new(): ChatroomPeerSettings;


}
declare const ChatroomPeerSettings: ChatroomPeerSettingsConstructor;
    
interface IAudioInput {
    Frequency: number;
    ChannelCount: number;
    SegmentRate: number;



}
    
interface IAudioOutputFactory {


    Create(frequency: number, channelCount: number, samplesLen: number, audioSource: AudioSource): IAudioOutput;

}
    
interface ChatroomAgentConstructor {

    new(chatroomNetwork: IChatroomNetwork, audioInput: IAudioInput, audioOutputFactory: IAudioOutputFactory): ChatroomAgent;


}
declare const ChatroomAgent: ChatroomAgentConstructor;
    
interface AirshipUniVoiceNetworkConstructor {

    new(): AirshipUniVoiceNetwork;


}
declare const AirshipUniVoiceNetwork: AirshipUniVoiceNetworkConstructor;
    
interface BridgeConstructor {



    CopyToClipboard(text: string): void;
    DownloadTexture2DYielding(url: string): Texture2D;
    GetActiveScene(): Scene;
    GetAirshipVoiceChatNetwork(): AirshipUniVoiceNetwork;
    GetAllocatedRam(): number;
    GetAverageFPS(): number;
    GetCurrentFPS(): number;
    GetCurrentMicDeviceIndex(): number;
    GetMicDevices(): CSArray<string>;
    GetMonoRam(): number;
    GetReservedRam(): number;
    GetScene(sceneName: string): Scene;
    GetScenes(): CSArray<Scene>;
    GetVolume(): number;
    HasMicrophonePermission(): boolean;
    IsFullScreen(): boolean;
    IsMicRecording(): boolean;
    Lerp(start: Vector3, goal: Vector3, alpha: number): Vector3;
    LoadGlobalSceneByName(sceneName: string): void;
    LoadScene(sceneName: string, restartLuau: boolean, loadSceneMode: LoadSceneMode): void;
    LoadSceneForConnection(conn: NetworkConnection, sceneName: string, makeActiveScene: boolean): void;
    LoadSceneFromAssetBundle(sceneName: string, loadSceneMode: LoadSceneMode): void;
    MakeMaterialPropertyBlock(): MaterialPropertyBlock;
    MakeMesh(): Mesh;
    MakeSprite(texture2D: Texture2D): Sprite;
    MakeVector2(x: number, y: number): Vector2;
    MoveGameObjectToScene(gameObject: GameObject, scene: Scene): void;
    OpenDevConsole(): void;
    RemoveRichText(input: string): string;
    RequestMicrophonePermissionAsync(): void;
    ScreenPointToLocalPointInRectangle(rectTransform: RectTransform, screenPoint: Vector2): Vector2;
    SetFullScreen(value: boolean): void;
    SetMicDeviceIndex(i: number): void;
    SetParentToSceneRoot(transform: Transform): void;
    SetVolume(volume: number): void;
    Slerp(start: Vector3, goal: Vector3, alpha: number): Vector3;
    StartMicRecording(frequency: number, sampleLength: number): void;
    StopMicRecording(): void;
    UnloadGlobalSceneByName(sceneName: string): void;
    UnloadScene(sceneName: string): void;
    UnloadSceneForConnection(conn: NetworkConnection, sceneName: string, preferredActiveScene: string): void;
    UpdateLayout(xform: Transform, recursive: boolean): void;
}
declare const Bridge: BridgeConstructor;
    
interface CanvasGroup extends Behaviour, ICanvasRaycastFilter {
    alpha: number;
    interactable: boolean;
    blocksRaycasts: boolean;
    ignoreParentGroups: boolean;


    /** Returns true if the Group allows raycasts. */
    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;

}
    
interface CanvasGroupConstructor {

    new(): CanvasGroup;


}
declare const CanvasGroup: CanvasGroupConstructor;
    
interface AutoShutdownBridge extends MonoBehaviour {


    SetBundlesLoaded(assetBundlesLoaded: boolean): void;

}
    
interface AutoShutdownBridgeConstructor {

    new(): AutoShutdownBridge;


}
declare const AutoShutdownBridge: AutoShutdownBridgeConstructor;
    
interface ScreenCapture {



}
    
interface ScreenCaptureConstructor {



    CaptureScreenshot(filename: string): void;
    CaptureScreenshot(filename: string, superSize: number): void;
    CaptureScreenshot(filename: string, stereoCaptureMode: StereoScreenCaptureMode): void;
    CaptureScreenshotAsTexture(): Texture2D;
    CaptureScreenshotAsTexture(superSize: number): Texture2D;
    CaptureScreenshotAsTexture(stereoCaptureMode: StereoScreenCaptureMode): Texture2D;
    CaptureScreenshotIntoRenderTexture(renderTexture: RenderTexture): void;
}
declare const ScreenCapture: ScreenCaptureConstructor;
    
interface VoxelBlocks {
    maxResolution: number;
    atlasSize: number;
    pointFiltering: boolean;
    atlas: TexturePacker;
    materials: CSDictionary<string, Material>;
    loadedBlocks: CSDictionary<number, BlockDefinition>;
    rootAssetPath: string;
    m_bundlePaths: CSArray<string>;


    AddSolidMaskToVoxelValue(voxelValue: number): number;
    GetBlock(index: number): BlockDefinition;
    GetBlockDefinitionByStringId(blockTypeId: string): BlockDefinition;
    GetBlockDefinitionFromIndex(index: number): BlockDefinition;
    GetBlockIdFromStringId(stringId: string): number;
    GetStringIdFromBlockId(blockVoxelId: number): string;
    Load(contentsOfBlockDefines: CSArray<string>, loadTexturesDirectlyFromDisk: boolean): void;
    UpdateVoxelBlockId(voxelValue: number, blockId: number): number;

}
    
interface TexturePacker {
    diffuse: RenderTexture;
    normals: RenderTexture;


    Dispose(): void;
    GetColor(texture: string): Color;
    GetUVs(texture: string): Rect;
    PackTextures(textures: CSDictionary<string, TextureSet>, desiredPadding: number, width: number, height: number, numMips: number, normalizedSize: number): void;

}
    
interface TextureSet {
    diffuse: Texture2D;
    normals: Texture2D;
    roughTexture: Texture2D;
    metalTexture: Texture2D;
    emissiveTexture: Texture2D;
    roughness: number;
    metallic: number;
    normalScale: number;
    emissive: number;
    brightness: number;



}
    
interface TextureSetConstructor {

    new(diffuse: Texture2D, normals: Texture2D, roughTex: Texture2D, metalTex: Texture2D, emissiveTex: Texture2D, roughness: number, metallic: number, normalScale: number, emissive: number, brightness: number): TextureSet;


}
declare const TextureSet: TextureSetConstructor;
    
interface TexturePackerConstructor {

    new(): TexturePacker;


    CustomBlit(renderTarget: RenderTexture, sourceTexture: Texture, material: Material, destX: number, destY: number, destWidth: number, destHeight: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number): void;
    DoPadding(target: RenderTexture, source: Texture2D, rect: Rect, pad: number, flipMaterial: Material): void;
}
declare const TexturePacker: TexturePackerConstructor;
    
interface BlockDefinition {
    prefab: boolean;
    metallic: number;
    roughness: number;
    normalScale: number;
    emissive: number;
    brightness: number;
    solid: boolean;
    collisionType: CollisionType;
    randomRotation: boolean;
    mesh: VoxelMeshCopy;
    meshLod: VoxelMeshCopy;
    meshTiles: CSDictionary<number, LodSet>;
    meshTileProcessingOrder: CSArray<number>;
    contextStyle: ContextStyle;
    meshContexts: CSDictionary<number, VoxelMeshCopy>;
    detail: boolean;
    meshTexturePath: string;
    topTexturePath: string;
    sideTexturePath: string;
    bottomTexturePath: string;
    editorTexture: Texture2D;
    topUvs: Rect;
    bottomUvs: Rect;
    sideUvs: Rect;
    doOcclusion: boolean;
    materials: CSArray<string>;
    meshMaterialName: string;
    averageColor: CSArray<Color>;
    minecraftConversions: CSArray<string>;
    blockId: number;
    blockTypeId: string;
    name: string;
    material: string;
    topMaterial: string;
    sideMaterial: string;
    bottomMaterial: string;
    topTexture: string;
    sideTexture: string;
    bottomTexture: string;
    meshTexture: string;
    meshPath: string;
    meshPathLod: string;


    GetUvsForFace(i: number): Rect;

}
    
interface VoxelMeshCopy {
    quaternions: CSArray<unknown>;
    rotation: CSDictionary<number, PrecalculatedRotation>;
    srcUvs: CSArray<Vector2>;
    srcColors: CSArray<Color32>;
    srcVertices: CSArray<Vector3>;
    srcNormals: CSArray<Vector3>;
    surfaces: CSArray<Surface>;


    AdjustUVs(uvs: Rect): void;

}
    
interface PrecalculatedRotation {
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;



}
    
interface PrecalculatedRotationConstructor {

    new(srcVertices: CSArray<Vector3>, srcNormals: CSArray<Vector3>, rot: Rotations, quat: Quaternion): PrecalculatedRotation;
    new(srcVertices: CSArray<Vector3>, srcNormals: CSArray<Vector3>, rot: Rotations, quat: Quaternion): PrecalculatedRotation;


}
declare const PrecalculatedRotation: PrecalculatedRotationConstructor;
    
interface Surface {
    triangles: CSArray<number>;
    meshMaterial: Material;
    meshMaterialName: string;



}
    
interface SurfaceConstructor {

    new(triangles: CSArray<number>, material: Material, materialName: string): Surface;
    new(): Surface;


}
declare const Surface: SurfaceConstructor;
    
interface VoxelMeshCopyConstructor {

    new(mesh: Mesh): VoxelMeshCopy;
    new(src: VoxelMeshCopy): VoxelMeshCopy;
    new(assetPath: string, showError: boolean): VoxelMeshCopy;


}
declare const VoxelMeshCopy: VoxelMeshCopyConstructor;
    
interface LodSet {
    lod0: VoxelMeshCopy;
    lod1: VoxelMeshCopy;
    lod2: VoxelMeshCopy;



}
    
interface LodSetConstructor {

    new(): LodSet;


}
declare const LodSet: LodSetConstructor;
    
interface BlockDefinitionConstructor {

    new(): BlockDefinition;


}
declare const BlockDefinition: BlockDefinitionConstructor;
    
interface VoxelBlocksConstructor {
    meshTileOffsets: CSDictionary<number, Vector3>;
    meshTileSizes: CSDictionary<number, unknown>;
    TileSizeNames: CSArray<string>;
    ContextBlockNames: CSArray<string>;
    QuarterBlockNames: CSArray<string>;
    QuarterBlockSubstitutions: CSArray<number>;

    new(): VoxelBlocks;


}
declare const VoxelBlocks: VoxelBlocksConstructor;
    
interface CharacterController extends Collider {
    velocity: Vector3;
    isGrounded: boolean;
    collisionFlags: CollisionFlags;
    radius: number;
    height: number;
    center: Vector3;
    slopeLimit: number;
    stepOffset: number;
    skinWidth: number;
    minMoveDistance: number;
    detectCollisions: boolean;
    enableOverlapRecovery: boolean;


    /** Supplies the movement of a GameObject with an attached CharacterController component. */
    Move(motion: Vector3): CollisionFlags;
    /** Moves the character with speed. */
    SimpleMove(speed: Vector3): boolean;

}
    
interface CharacterControllerConstructor {

    new(): CharacterController;


}
declare const CharacterController: CharacterControllerConstructor;
    
interface ProjectileTrajectoryRenderer extends MonoBehaviour {
    maxIterations: number;
    maxSegmentCount: number;
    segmentStepModulo: number;


    SetDrawingEnabled(enabled: boolean): void;
    UpdateInfo(startingPoint: Vector3, velocity: Vector3, drag: number, gravity: number): void;

}
    
interface ProjectileTrajectoryRendererConstructor {

    new(): ProjectileTrajectoryRenderer;


}
declare const ProjectileTrajectoryRenderer: ProjectileTrajectoryRendererConstructor;
    
interface ProjectileLauncher extends NetworkBehaviour {


    Awake(): void;
    ClientFire(projectilePath: string, launcherItemTypeId: number, itemTypeId: number, position: Vector3, velocity: Vector3, gravity: number, drag: number): AirshipProjectile;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;

}
    
interface AirshipProjectile extends MonoBehaviour {
    gravity: number;
    drag: number;
    launcherItemTypeId: number;
    itemTypeId: number;


    Initialize(startingVelocity: Vector3, gravity: number, drag: number, passedTime: number, itemTypeId: number, launcherItemTypeId: number): void;

}
    
interface AirshipProjectileConstructor {

    new(): AirshipProjectile;


}
declare const AirshipProjectile: AirshipProjectileConstructor;
    
interface ProjectileLauncherConstructor {

    new(): ProjectileLauncher;


}
declare const ProjectileLauncher: ProjectileLauncherConstructor;
    
interface ProjectileValidateEvent {
    shooter: GameObject;
    validated: boolean;
    projectilePath: string;
    position: Vector3;
    velocity: Vector3;
    gravity: number;
    drag: number;
    itemTypeId: number;



}
    
interface TrailRenderer extends Renderer {
    numPositions: number;
    time: number;
    startWidth: number;
    endWidth: number;
    widthMultiplier: number;
    autodestruct: boolean;
    emitting: boolean;
    numCornerVertices: number;
    numCapVertices: number;
    minVertexDistance: number;
    startColor: Color;
    endColor: Color;
    positionCount: number;
    textureScale: Vector2;
    shadowBias: number;
    generateLightingData: boolean;
    textureMode: LineTextureMode;
    alignment: LineAlignment;
    maskInteraction: SpriteMaskInteraction;
    widthCurve: AnimationCurve;
    colorGradient: Gradient;


    /** Adds a position to the trail. */
    AddPosition(position: Vector3): void;
    /** Add an array of positions to the trail. */
    AddPositions(positions: CSArray<Vector3>): void;
    AddPositions(positions: CSArray<Vector3>): void;
    AddPositions(positions: CSArray<Vector3>): void;
    /** Creates a snapshot of TrailRenderer and stores it in mesh. */
    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    /** Creates a snapshot of TrailRenderer and stores it in mesh. */
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    /** Removes all points from the TrailRenderer.
Useful for restarting a trail from a new position. */
    Clear(): void;
    /** Get the position of a vertex in the trail. */
    GetPosition(index: number): Vector3;
    /** Get the positions of all vertices in the trail. */
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    /** Get the visible positions of all vertices in the trail. */
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    /** Set the position of a vertex in the trail. */
    SetPosition(index: number, position: Vector3): void;
    /** Sets the positions of all vertices in the trail. */
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;

}
    
interface TrailRendererConstructor {

    new(): TrailRenderer;


}
declare const TrailRenderer: TrailRendererConstructor;
    
interface WindowCore {



}
    
interface WindowProxy extends MonoBehaviour {


    HasFocus(): boolean;

}
    
interface WindowProxyConstructor {

    new(): WindowProxy;


}
declare const WindowProxy: WindowProxyConstructor;
    
interface WindowCoreConstructor {
    Window: WindowProxy;



    SetWindowProxy(window: WindowProxy): void;
}
declare const WindowCore: WindowCoreConstructor;
    
interface CharacterMoveModifier {
    speedMultiplier: number;
    jumpMultiplier: number;
    blockSprint: boolean;
    blockJump: boolean;



}
    
interface CharacterMoveModifierConstructor {

    new(): CharacterMoveModifier;


}
declare const CharacterMoveModifier: CharacterMoveModifierConstructor;
    
interface DynamicVariables extends ScriptableObject {
    collectionId: string;
    strings: CSArray<unknown>;
    numbers: CSArray<unknown>;
    vectors: CSArray<unknown>;


    GetAsString(key: string): string;
    GetNumber(key: string): number;
    GetString(key: string): string;
    GetVector3(key: string): Vector3;
    Register(): void;
    ReplicateAll(): void;
    ReplicateNumber(key: string): void;
    ReplicateString(key: string): void;
    ReplicateVector3(key: string): void;
    SetNumber(key: string, val: number): void;
    SetString(key: string, val: string): void;
    SetVector3(key: string, val: Vector3): void;

}
    
interface DynamicVariablesConstructor {

    new(): DynamicVariables;


}
declare const DynamicVariables: DynamicVariablesConstructor;
    
interface ProjectileHitEvent {
    raycastHit: RaycastHit;
    velocity: Vector3;



}
    
interface MaterialColor extends MonoBehaviour {
    colorSettings: CSArray<ColorSetting>;
    addedByEditorScript: boolean;


    DoUpdate(): void;
    EditorFirstTimeSetup(): void;
    GetColorSettings(materialIndex: number): ColorSetting;
    SetAllColors(diffuseColor: Color, multiplyColor: boolean): void;
    SetAllEmissive(emissiveColor: Color, emissiveMix: number): void;
    SetColorSettings(materialIndex: number, settings: ColorSetting): boolean;
    SetMaterialColor(index: number, color: Color): void;

}
    
interface ColorSetting {
    materialColor: Color;
    emissiveColor: Color;
    emissiveMix: number;
    emissiveLevel: number;
    reference: string;


    CopyFrom(otherSettings: ColorSetting): void;

}
    
interface ColorSettingConstructor {

    new(materialColor: Color, emissiveColor: Color, emissiveMix: number, emissiveLevel: number): ColorSetting;


}
declare const ColorSetting: ColorSettingConstructor;
    
interface MaterialColorConstructor {

    new(): MaterialColor;


}
declare const MaterialColor: MaterialColorConstructor;
    
interface DefaultObjectPool extends ObjectPool {
    Cache: CSArray<CSDictionary<number, CSArray<NetworkObject>>>;


    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    ClearPool(): void;
    ClearPool(collectionId: number): void;
    GetOrCreateCache(collectionId: number, prefabId: number): CSArray<NetworkObject>;
    GetPrefab(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    RetrieveObject(prefabId: number, collectionId: number, parent: Transform, nullableLocalPosition: unknown, nullableLocalRotation: unknown, nullableLocalScale: unknown, makeActive: boolean, asServer: boolean): NetworkObject;
    StoreObject(instantiated: NetworkObject, asServer: boolean): void;

}
    
interface DefaultObjectPoolConstructor {

    new(): DefaultObjectPool;


}
declare const DefaultObjectPool: DefaultObjectPoolConstructor;
    
interface AirshipObjectPool extends DefaultObjectPool {
    maxSpawnPerFrame: number;


    SlowlyCacheObjects(prefab: NetworkObject, count: number): void;

}
    
interface AirshipObjectPoolConstructor {

    new(): AirshipObjectPool;


}
declare const AirshipObjectPool: AirshipObjectPoolConstructor;
    
interface MainMenuLoadingScreen extends BundleLoadingScreen {
    canvas: Canvas;
    progressText: TMP_Text;
    continueButton: Button;
    spinner: GameObject;
    errorWrapper: GameObject;
    errorText: TMP_Text;
    sceneManager: MainMenuSceneManager;


    ClickContinueButton(): void;
    Close(): void;
    Retry(): void;
    SetError(msg: string): void;
    SetProgress(text: string, percent: number): void;
    SetTotalDownloadSize(sizeBytes: number): void;

}
    
interface MainMenuSceneManager extends MonoBehaviour {
    editorConfig: AirshipEditorConfig;
    loadingScreen: MainMenuLoadingScreen;


    Retry(): void;

}
    
interface MainMenuSceneManagerConstructor {
    cdnUrl: string;
    deploymentUrl: string;

    new(): MainMenuSceneManager;


    GetLatestPackageVersion(packageId: string): unknown;
}
declare const MainMenuSceneManager: MainMenuSceneManagerConstructor;
    
interface MainMenuLoadingScreenConstructor {

    new(): MainMenuLoadingScreen;


}
declare const MainMenuLoadingScreen: MainMenuLoadingScreenConstructor;
    
interface HttpManager {



}
    
interface HttpResponse {
    success: boolean;
    statusCode: number;
    data: string;
    error: string;



}
    
interface RequestHelper {
    Uri: string;
    Method: string;
    Body: unknown;
    BodyString: string;
    BodyRaw: CSArray<number>;
    Timeout?: number;
    ContentType: string;
    Retries: number;
    RetrySecondsDelay: number;
    RetryCallbackOnlyOnNetworkErrors: boolean;
    RetryCallback: unknown;
    ProgressCallback: unknown;
    EnableDebug: boolean;
    UseHttpContinue?: boolean;
    RedirectLimit?: number;
    IgnoreHttpException: boolean;
    FormData: WWWForm;
    SimpleForm: CSDictionary<string, string>;
    FormSections: CSArray<IMultipartFormSection>;
    CertificateHandler: CertificateHandler;
    UploadHandler: UploadHandler;
    DownloadHandler: DownloadHandler;
    Headers: CSDictionary<string, string>;
    Params: CSDictionary<string, string>;
    ParseResponseBody: boolean;
    Request: UnityWebRequest;
    UploadProgress: number;
    UploadedBytes: number;
    DownloadProgress: number;
    DownloadedBytes: number;
    IsAborted: boolean;
    DefaultContentType: boolean;


    Abort(): void;
    GetHeader(name: string): string;

}
    
interface WWWForm {
    headers: CSDictionary<string, string>;
    data: CSArray<number>;


    /** Add binary data to the form. */
    AddBinaryData(fieldName: string, contents: CSArray<number>): void;
    /** Add binary data to the form. */
    AddBinaryData(fieldName: string, contents: CSArray<number>, fileName: string): void;
    /** Add binary data to the form. */
    AddBinaryData(fieldName: string, contents: CSArray<number>, fileName: string, mimeType: string): void;
    /** Add a simple field to the form. */
    AddField(fieldName: string, value: string): void;
    /** Add a simple field to the form. */
    AddField(fieldName: string, value: string, e: unknown): void;
    /** Adds a simple field to the form. */
    AddField(fieldName: string, i: number): void;

}
    
interface WWWFormConstructor {

    new(): WWWForm;


}
declare const WWWForm: WWWFormConstructor;
    
interface IMultipartFormSection {
    sectionName: string;
    sectionData: CSArray<number>;
    fileName: string;
    contentType: string;



}
    
interface CertificateHandler {


    /** Signals that this [CertificateHandler] is no longer being used, and should clean up any resources it is using. */
    Dispose(): void;

}
    
interface UploadHandler {
    data: CSArray<number>;
    contentType: string;
    progress: number;


    /** Signals that this UploadHandler is no longer being used, and should clean up any resources it is using. */
    Dispose(): void;

}
    
interface DownloadHandler {
    isDone: boolean;
    error: string;
    nativeData: CSArray<number>;
    data: CSArray<number>;
    text: string;


    /** Signals that this DownloadHandler is no longer being used, and should clean up any resources it is using. */
    Dispose(): void;

}
    
interface UnityWebRequest {
    disposeCertificateHandlerOnDispose: boolean;
    disposeDownloadHandlerOnDispose: boolean;
    disposeUploadHandlerOnDispose: boolean;
    method: string;
    error: string;
    useHttpContinue: boolean;
    url: string;
    uri: unknown;
    responseCode: number;
    uploadProgress: number;
    isModifiable: boolean;
    isDone: boolean;
    isNetworkError: boolean;
    isHttpError: boolean;
    result: Result;
    downloadProgress: number;
    uploadedBytes: number;
    downloadedBytes: number;
    redirectLimit: number;
    chunkedTransfer: boolean;
    uploadHandler: UploadHandler;
    downloadHandler: DownloadHandler;
    certificateHandler: CertificateHandler;
    timeout: number;
    isError: boolean;


    /** If in progress, halts the UnityWebRequest as soon as possible. */
    Abort(): void;
    /** Signals that this UnityWebRequest is no longer being used, and should clean up any resources it is using. */
    Dispose(): void;
    /** Retrieves the value of a custom request header. */
    GetRequestHeader(name: string): string;
    /** Retrieves the value of a response header from the latest HTTP response received. */
    GetResponseHeader(name: string): string;
    /** Retrieves a dictionary containing all the response headers received by this UnityWebRequest in the latest HTTP response. */
    GetResponseHeaders(): CSDictionary<string, string>;
    /** Begin communicating with the remote server. */
    Send(): AsyncOperation;
    /** Begin communicating with the remote server. */
    SendWebRequest(): UnityWebRequestAsyncOperation;
    /** Set a HTTP request header to a custom value. */
    SetRequestHeader(name: string, value: string): void;

}
    
interface UnityWebRequestAsyncOperation extends AsyncOperation {
    webRequest: UnityWebRequest;



}
    
interface UnityWebRequestAsyncOperationConstructor {

    new(): UnityWebRequestAsyncOperation;


}
declare const UnityWebRequestAsyncOperation: UnityWebRequestAsyncOperationConstructor;
    
interface CachedAssetBundle {
    name: string;
    hash: Hash128;



}
    
interface CachedAssetBundleConstructor {

    new(name: string, hash: Hash128): CachedAssetBundle;


}
declare const CachedAssetBundle: CachedAssetBundleConstructor;
    
interface UnityWebRequestConstructor {
    kHttpVerbGET: string;
    kHttpVerbHEAD: string;
    kHttpVerbPOST: string;
    kHttpVerbPUT: string;
    kHttpVerbCREATE: string;
    kHttpVerbDELETE: string;

    new(): UnityWebRequest;
    new(url: string): UnityWebRequest;
    new(uri: unknown): UnityWebRequest;
    new(url: string, method: string): UnityWebRequest;
    new(uri: unknown, method: string): UnityWebRequest;
    new(url: string, method: string, downloadHandler: DownloadHandler, uploadHandler: UploadHandler): UnityWebRequest;
    new(uri: unknown, method: string, downloadHandler: DownloadHandler, uploadHandler: UploadHandler): UnityWebRequest;


    ClearCookieCache(): void;
    ClearCookieCache(uri: unknown): void;
    Delete(uri: string): UnityWebRequest;
    Delete(uri: unknown): UnityWebRequest;
    EscapeURL(s: string): string;
    EscapeURL(s: string, e: unknown): string;
    GenerateBoundary(): CSArray<number>;
    Get(uri: string): UnityWebRequest;
    Get(uri: unknown): UnityWebRequest;
    GetAssetBundle(uri: string): UnityWebRequest;
    GetAssetBundle(uri: string, crc: number): UnityWebRequest;
    GetAssetBundle(uri: string, version: number, crc: number): UnityWebRequest;
    GetAssetBundle(uri: string, hash: Hash128, crc: number): UnityWebRequest;
    GetAssetBundle(uri: string, cachedAssetBundle: CachedAssetBundle, crc: number): UnityWebRequest;
    GetAudioClip(uri: string, audioType: AudioType): UnityWebRequest;
    GetTexture(uri: string): UnityWebRequest;
    GetTexture(uri: string, nonReadable: boolean): UnityWebRequest;
    Head(uri: string): UnityWebRequest;
    Head(uri: unknown): UnityWebRequest;
    Post(uri: string, postData: string): UnityWebRequest;
    Post(uri: unknown, postData: string): UnityWebRequest;
    Post(uri: string, postData: string, contentType: string): UnityWebRequest;
    Post(uri: unknown, postData: string, contentType: string): UnityWebRequest;
    Post(uri: string, formData: WWWForm): UnityWebRequest;
    Post(uri: unknown, formData: WWWForm): UnityWebRequest;
    Post(uri: string, multipartFormSections: CSArray<IMultipartFormSection>): UnityWebRequest;
    Post(uri: unknown, multipartFormSections: CSArray<IMultipartFormSection>): UnityWebRequest;
    Post(uri: string, multipartFormSections: CSArray<IMultipartFormSection>, boundary: CSArray<number>): UnityWebRequest;
    Post(uri: unknown, multipartFormSections: CSArray<IMultipartFormSection>, boundary: CSArray<number>): UnityWebRequest;
    Post(uri: string, formFields: CSDictionary<string, string>): UnityWebRequest;
    Post(uri: unknown, formFields: CSDictionary<string, string>): UnityWebRequest;
    PostWwwForm(uri: string, form: string): UnityWebRequest;
    PostWwwForm(uri: unknown, form: string): UnityWebRequest;
    Put(uri: string, bodyData: CSArray<number>): UnityWebRequest;
    Put(uri: unknown, bodyData: CSArray<number>): UnityWebRequest;
    Put(uri: string, bodyData: string): UnityWebRequest;
    Put(uri: unknown, bodyData: string): UnityWebRequest;
    SerializeFormSections(multipartFormSections: CSArray<IMultipartFormSection>, boundary: CSArray<number>): CSArray<number>;
    SerializeSimpleForm(formFields: CSDictionary<string, string>): CSArray<number>;
    UnEscapeURL(s: string): string;
    UnEscapeURL(s: string, e: unknown): string;
}
declare const UnityWebRequest: UnityWebRequestConstructor;
    
interface RequestHelperConstructor {

    new(): RequestHelper;


}
declare const RequestHelper: RequestHelperConstructor;
    
interface HttpManagerConstructor {
    loggingEnabled: boolean;

    new(): HttpManager;


    DeleteAsync(url: string): HttpResponse;
    DeleteAsync(url: string, headers: string): HttpResponse;
    GetAsync(url: string, headers: string): HttpResponse;
    GetAsync(url: string): HttpResponse;
    PatchAsync(url: string, data: string): HttpResponse;
    PatchAsync(url: string, data: string, headers: string): HttpResponse;
    PostAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string, data: string, headers: string): HttpResponse;
    PutAsync(url: string, data: string): HttpResponse;
    PutAsync(url: string, data: string, headers: string): HttpResponse;
    PutAsync(options: RequestHelper, headers: string): HttpResponse;
    SetLoggingEnabled(val: boolean): void;
}
declare const HttpManager: HttpManagerConstructor;
    
interface InternalHttpManager {



}
    
interface InternalHttpManagerConstructor {
    authToken: string;

    new(): InternalHttpManager;


    DeleteAsync(url: string): HttpResponse;
    GetAsync(url: string): HttpResponse;
    GetAsyncWithHeaders(url: string, headers: string): HttpResponse;
    PatchAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string): HttpResponse;
    PutAsync(url: string, data: string): HttpResponse;
    PutImageAsync(url: string, filePath: string): HttpResponse;
    SetAuthToken(authToken: string): void;
}
declare const InternalHttpManager: InternalHttpManagerConstructor;
    
interface FriendsControllerBackend {



}
    
interface FriendsControllerBackendConstructor {

    new(): FriendsControllerBackend;


    GetFriends(): HttpResponse;
    IsFriendsWith(uid: string): HttpResponse;
}
declare const FriendsControllerBackend: FriendsControllerBackendConstructor;
    
interface MatchmakingControllerBackend {



}
    
interface MatchmakingControllerBackendConstructor {

    new(): MatchmakingControllerBackend;


    GetStatus(): HttpResponse;
}
declare const MatchmakingControllerBackend: MatchmakingControllerBackendConstructor;
    
interface PartyControllerBackend {



}
    
interface PartyControllerBackendConstructor {

    new(): PartyControllerBackend;


    GetParty(): HttpResponse;
}
declare const PartyControllerBackend: PartyControllerBackendConstructor;
    
interface AirshipInventoryControllerBackend {



}
    
interface AirshipInventoryControllerBackendConstructor {

    new(): AirshipInventoryControllerBackend;


    GetEquippedOutfitByUserId(uid: string): HttpResponse;
    GetEquippedProfilePictureByUserId(uid: string): HttpResponse;
}
declare const AirshipInventoryControllerBackend: AirshipInventoryControllerBackendConstructor;
    
interface TransferControllerBackend {



}
    
interface TransferControllerBackendConstructor {

    new(): TransferControllerBackend;


    TransferToGame(body: string): HttpResponse;
    TransferToPartyLeader(): HttpResponse;
}
declare const TransferControllerBackend: TransferControllerBackendConstructor;
    
interface UsersControllerBackend {



}
    
interface UsersControllerBackendConstructor {

    new(): UsersControllerBackend;


    GetUserById(userId: string): HttpResponse;
    GetUserByUsername(username: string): HttpResponse;
    GetUsersById(query: string): HttpResponse;
}
declare const UsersControllerBackend: UsersControllerBackendConstructor;
    
interface CacheStoreServiceBackend {



}
    
interface CacheStoreServiceBackendConstructor {

    new(): CacheStoreServiceBackend;


    GetKey(key: string, expireTimeSec: unknown): HttpResponse;
    SetKey(key: string, expireTimeSec: number, body: string): HttpResponse;
    SetKeyTTL(key: string, expireTimeSec: number): HttpResponse;
}
declare const CacheStoreServiceBackend: CacheStoreServiceBackendConstructor;
    
interface DataStoreServiceBackend {



}
    
interface DataStoreServiceBackendConstructor {

    new(): DataStoreServiceBackend;


    DeleteKey(key: string): HttpResponse;
    GetKey(key: string): HttpResponse;
    SetKey(key: string, body: string): HttpResponse;
}
declare const DataStoreServiceBackend: DataStoreServiceBackendConstructor;
    
interface LeaderboardServiceBackend {



}
    
interface LeaderboardServiceBackendConstructor {

    new(): LeaderboardServiceBackend;


    GetRank(leaderboardName: string, id: string): HttpResponse;
    GetRankRange(leaderboardName: string, skip: number, limit: number): HttpResponse;
    Update(leaderboardName: string, body: string): HttpResponse;
}
declare const LeaderboardServiceBackend: LeaderboardServiceBackendConstructor;
    
interface PartyServiceBackend {



}
    
interface PartyServiceBackendConstructor {

    new(): PartyServiceBackend;


    GetPartyById(partyId: string): HttpResponse;
    GetPartyForUserId(userId: string): HttpResponse;
}
declare const PartyServiceBackend: PartyServiceBackendConstructor;
    
interface MatchmakingServiceBackend {



}
    
interface MatchmakingServiceBackendConstructor {

    new(): MatchmakingServiceBackend;


    GetMatchmakingRegions(): HttpResponse;
    JoinPartyToQueue(partyId: string, body: string): HttpResponse;
    RemovePartyFromQueue(partyId: string): HttpResponse;
}
declare const MatchmakingServiceBackend: MatchmakingServiceBackendConstructor;
    
interface TransferServiceBackend {



}
    
interface TransferServiceBackendConstructor {

    new(): TransferServiceBackend;


    CreateServer(body: string): HttpResponse;
    Transfer(body: string): HttpResponse;
}
declare const TransferServiceBackend: TransferServiceBackendConstructor;
    
interface AirshipInventoryServiceBackend {



}
    
interface AirshipInventoryServiceBackendConstructor {

    new(): AirshipInventoryServiceBackend;


    DeleteAccessory(itemId: string): HttpResponse;
    DeleteItem(itemId: string): HttpResponse;
    DeleteProfilePicture(itemId: string): HttpResponse;
    GetAccessories(uid: string, query: string): HttpResponse;
    GetEquippedOutfitByUserId(userId: string): HttpResponse;
    GetEquippedProfilePictureByUserId(uid: string): HttpResponse;
    GetItems(uid: string, query: string): HttpResponse;
    GetProfilePictures(uid: string, query: string): HttpResponse;
    GrantAccessory(uid: string, classId: string): HttpResponse;
    GrantItem(uid: string, classId: string): HttpResponse;
    GrantProfilePicture(uid: string, classId: string): HttpResponse;
    PerformTrade(body: string): HttpResponse;
}
declare const AirshipInventoryServiceBackend: AirshipInventoryServiceBackendConstructor;
    
interface UsersServiceBackend {



}
    
interface UsersServiceBackendConstructor {

    new(): UsersServiceBackend;


    GetUserById(userId: string): HttpResponse;
    GetUserByUsername(username: string): HttpResponse;
    GetUsersById(query: string): HttpResponse;
}
declare const UsersServiceBackend: UsersServiceBackendConstructor;
    
interface CrossSceneState {



}
    
interface ServerTransferData {
    address: string;
    port: number;



}
    
interface ServerTransferDataConstructor {

    new(): ServerTransferData;


}
declare const ServerTransferData: ServerTransferDataConstructor;
    
interface CrossSceneStateConstructor {
    ServerTransferData: ServerTransferData;
    UseLocalBundles: boolean;



    IsLocalServer(): boolean;
}
declare const CrossSceneState: CrossSceneStateConstructor;
    
interface Toggle extends Selectable, ISubmitHandler, IPointerClickHandler, ICanvasElement {
    toggleTransition: ToggleTransition;
    graphic: Graphic;
    onValueChanged: ToggleEvent;
    group: ToggleGroup;
    isOn: boolean;


    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetIsOnWithoutNotify(value: boolean): void;

}
    
interface ToggleEvent {



}
    
interface ToggleEventConstructor {

    new(): ToggleEvent;


}
declare const ToggleEvent: ToggleEventConstructor;
    
interface ToggleGroup extends UIBehaviour {
    allowSwitchOff: boolean;


    ActiveToggles(): CSArray<Toggle>;
    AnyTogglesOn(): boolean;
    EnsureValidState(): void;
    GetFirstActiveToggle(): Toggle;
    NotifyToggleOn(toggle: Toggle, sendCallback: boolean): void;
    RegisterToggle(toggle: Toggle): void;
    SetAllTogglesOff(sendCallback: boolean): void;
    UnregisterToggle(toggle: Toggle): void;

}
    
interface ILayoutController {


    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;

}
    
interface ILayoutGroup extends ILayoutController {



}
    
interface LayoutGroup extends UIBehaviour, ILayoutGroup, ILayoutElement {
    padding: RectOffset;
    childAlignment: TextAnchor;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;

}
    
interface RectOffset {
    left: number;
    right: number;
    top: number;
    bottom: number;
    horizontal: number;
    vertical: number;


    /** Add the border offsets to a rect. */
    Add(rect: Rect): Rect;
    /** Remove the border offsets from a rect. */
    Remove(rect: Rect): Rect;
    /** Returns a formatted string for this RectOffset. */
    ToString(): string;
    /** Returns a formatted string for this RectOffset. */
    ToString(format: string): string;
    /** Returns a formatted string for this RectOffset. */
    ToString(format: string, formatProvider: unknown): string;

}
    
interface RectOffsetConstructor {

    new(): RectOffset;
    new(left: number, right: number, top: number, bottom: number): RectOffset;


}
declare const RectOffset: RectOffsetConstructor;
    
interface HorizontalOrVerticalLayoutGroup extends LayoutGroup {
    spacing: number;
    childForceExpandWidth: boolean;
    childForceExpandHeight: boolean;
    childControlWidth: boolean;
    childControlHeight: boolean;
    childScaleWidth: boolean;
    childScaleHeight: boolean;
    reverseArrangement: boolean;



}
    
interface HorizontalLayoutGroup extends HorizontalOrVerticalLayoutGroup {


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;

}
    
interface VerticalLayoutGroup extends HorizontalOrVerticalLayoutGroup {


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;

}
    
interface ILayoutSelfController extends ILayoutController {



}
    
interface ContentSizeFitter extends UIBehaviour, ILayoutSelfController {
    horizontalFit: FitMode;
    verticalFit: FitMode;


    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;

}
    
interface LayoutRebuilder extends ICanvasElement {
    transform: Transform;


    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GraphicUpdateComplete(): void;
    IsDestroyed(): boolean;
    LayoutComplete(): void;
    Rebuild(executing: CanvasUpdate): void;
    ToString(): string;

}
    
interface LayoutRebuilderConstructor {

    new(): LayoutRebuilder;


    ForceRebuildLayoutImmediate(layoutRoot: RectTransform): void;
    MarkLayoutForRebuild(rect: RectTransform): void;
}
declare const LayoutRebuilder: LayoutRebuilderConstructor;
    
interface RectTransformUtility {



}
    
interface RectTransformUtilityConstructor {



    CalculateRelativeRectTransformBounds(root: Transform, child: Transform): Bounds;
    CalculateRelativeRectTransformBounds(trans: Transform): Bounds;
    FlipLayoutAxes(rect: RectTransform, keepPositioning: boolean, recursive: boolean): void;
    FlipLayoutOnAxis(rect: RectTransform, axis: number, keepPositioning: boolean, recursive: boolean): void;
    PixelAdjustPoint(point: Vector2, elementTransform: Transform, canvas: Canvas): Vector2;
    PixelAdjustRect(rectTransform: RectTransform, canvas: Canvas): Rect;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2): boolean;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2, cam: Camera): boolean;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2, cam: Camera, offset: Vector4): boolean;
    ScreenPointToLocalPointInRectangle(rect: RectTransform, screenPoint: Vector2, cam: Camera, localPoint: unknown): boolean;
    ScreenPointToRay(cam: Camera, screenPos: Vector2): Ray;
    ScreenPointToWorldPointInRectangle(rect: RectTransform, screenPoint: Vector2, cam: Camera, worldPoint: unknown): boolean;
    WorldToScreenPoint(cam: Camera, worldPoint: Vector3): Vector2;
}
declare const RectTransformUtility: RectTransformUtilityConstructor;
    
interface ScrollRect extends UIBehaviour, ILayoutGroup, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, ILayoutElement {
    content: RectTransform;
    horizontal: boolean;
    vertical: boolean;
    movementType: MovementType;
    elasticity: number;
    inertia: boolean;
    decelerationRate: number;
    scrollSensitivity: number;
    viewport: RectTransform;
    horizontalScrollbar: Scrollbar;
    verticalScrollbar: Scrollbar;
    horizontalScrollbarVisibility: ScrollbarVisibility;
    verticalScrollbarVisibility: ScrollbarVisibility;
    horizontalScrollbarSpacing: number;
    verticalScrollbarSpacing: number;
    onValueChanged: ScrollRectEvent;
    velocity: Vector2;
    normalizedPosition: Vector2;
    horizontalNormalizedPosition: number;
    verticalNormalizedPosition: number;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    GraphicUpdateComplete(): void;
    IsActive(): boolean;
    LayoutComplete(): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnScroll(data: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;
    StopMovement(): void;

}
    
interface ScrollRectEvent {



}
    
interface ScrollRectEventConstructor {

    new(): ScrollRectEvent;


}
declare const ScrollRectEvent: ScrollRectEventConstructor;
    
interface NetworkTransform extends NetworkBehaviour {
    _clientAuthoritative: boolean;
    TakenOwnership: boolean;
    ParentBehaviour: NetworkBehaviour;


    Awake(): void;
    ForceSend(ticks: number): void;
    ForceSend(): void;
    GetSendToOwner(): boolean;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnOwnershipClient(prevOwner: NetworkConnection): void;
    OnOwnershipServer(prevOwner: NetworkConnection): void;
    OnSpawnServer(connection: NetworkConnection): void;
    OnStartClient(): void;
    OnStartNetwork(): void;
    OnStartServer(): void;
    OnStopNetwork(): void;
    SetInterval(value: number): void;
    SetPositionSnapping(axes: SnappedAxes): void;
    SetRotationSnapping(axes: SnappedAxes): void;
    SetScaleSnapping(axes: SnappedAxes): void;
    SetSendToOwner(value: boolean): void;
    SetSynchronizedProperties(value: SynchronizedProperty): void;
    SetSynchronizePosition(value: boolean): void;
    SetSynchronizeRotation(value: boolean): void;
    SetSynchronizeScale(value: boolean): void;

}
    
interface SnappedAxes {
    X: boolean;
    Y: boolean;
    Z: boolean;



}
    
interface NetworkTransformConstructor {
    MAX_INTERPOLATION: number;

    new(): NetworkTransform;


}
declare const NetworkTransform: NetworkTransformConstructor;
    
interface CameraScreenshotRecorder extends MonoBehaviour {
    saveFolder: SaveFolder;
    shouldSaveCaptures: boolean;
    resWidth: number;
    resHeight: number;
    FolderName: string;


    SaveRenderTexture(rt: RenderTexture, fileName: string, png: boolean): CameraScreenshotResponse;
    SaveTexture(texture: Texture2D, fileName: string, png: boolean): CameraScreenshotResponse;
    ScreenShotName(width: number, height: number, png: boolean): string;
    ScreenShotName(filename: string, png: boolean): string;
    TakeCameraScreenshot(camera: Camera, fileName: string, superSampleSize: number): void;
    TakeCameraScreenshotCo(camera: Camera, fileName: string, superSampleSize: number): unknown;
    TakeScreenshot(fileName: string, superSampleSize: number, png: boolean): void;

}
    
interface CameraScreenshotResponse {
    path: string;
    filesize: number;
    extension: string;



}
    
interface CameraScreenshotResponseConstructor {

    new(): CameraScreenshotResponse;


}
declare const CameraScreenshotResponse: CameraScreenshotResponseConstructor;
    
interface OnPictureTaken {


    BeginInvoke(screenshot: Texture2D, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(screenshot: Texture2D): void;

}
    
interface OnPictureTakenConstructor {

    new(object: unknown, method: unknown): OnPictureTaken;


}
declare const OnPictureTaken: OnPictureTakenConstructor;
    
interface CameraScreenshotRecorderConstructor {
    onPictureTaken: OnPictureTaken;
    GetScreenshotTexture: Texture2D;

    new(): CameraScreenshotRecorder;


}
declare const CameraScreenshotRecorder: CameraScreenshotRecorderConstructor;
    
interface DevConsole {



}
    
interface DevConsoleMono extends MonoBehaviour {
    activeContext: LogContext;


    ClearActiveConsoleContext(): void;
    CloseConsole(): void;
    OnClientTabClick(): void;
    OnLogMessageCallback(logString: string, stackTrace: string, type: LogType): void;
    OnLogMessageReceived(logString: string, stackTrace: string, type: LogType, context: LogContext, time: string, prepend: boolean): void;
    OnRepositionButtonPointerDown(eventData: BaseEventData): void;
    OnRepositionButtonPointerUp(_: BaseEventData): void;
    OnServerTabClick(): void;
    OpenLogsFolder(): void;
    SetActiveContext(context: LogContext): void;

}
    
interface DevConsoleMonoConstructor {

    new(): DevConsoleMono;


}
declare const DevConsoleMono: DevConsoleMonoConstructor;
    
interface Command {
    Name: string;
    HelpText: string;
    IsCustomCommand: boolean;


    GetAliases(): CSArray<string>;
    GetFormattedName(): string;
    GetFormattedParameter(parameterIndex: number): string;
    GetParameters(): CSArray<Parameter>;
    ToFormattedString(): string;
    ToString(): string;

}
    
interface Parameter {
    Type: unknown;
    FriendlyTypeName: string;
    Name: string;
    HelpText: string;


    ToFormattedString(): string;
    ToString(): string;

}
    
interface ParameterConstructor {



    Create(name: string, helpText: string): Parameter;
}
declare const Parameter: ParameterConstructor;
    
interface CommandConstructor {



    Create(name: string, aliases: string, helpText: string, callback: unknown): Command;
    Create<T1>(name: string, aliases: string, helpText: string, p1: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3, T4>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, p4: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3, T4, T5>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, p4: Parameter, p5: Parameter, callback: unknown, defaultCallback: unknown): Command;
}
declare const Command: CommandConstructor;
    
interface DevConsoleConstructor {
    console: DevConsoleMono;
    IsEnabled: boolean;
    IsOpen: boolean;
    IsOpenAndFocused: boolean;
    IsKeyBindingsEnabled: boolean;
    ToggleKey?: Key;
    AverageFps: number;
    AverageMs: number;



    AddCommand(command: Command, onlyInDevBuild: boolean): boolean;
    AddParameterType<T>(parseFunc: unknown): boolean;
    ClearActiveConsoleContext(): void;
    ClearConsole(): void;
    CloseConsole(): void;
    DisableConsole(): void;
    DisableToggleKey(): void;
    EnableConsole(): void;
    GetCommand(name: string): Command;
    GetCommand(name: string, command: unknown): boolean;
    InvokeCoroutine(enumerator: unknown): Coroutine;
    InvokeDelayed(action: unknown, delay: number): Coroutine;
    Log(message: unknown, context: LogContext, prepend: boolean): void;
    Log(message: unknown, colour: Color, context: LogContext, prepend: boolean): void;
    LogCollection<T>(collection: CSArray<T>, toString: unknown, prefix: string, suffix: string): void;
    LogCommand(): void;
    LogCommand(name: string): void;
    LogError(message: unknown, context: LogContext, prepend: boolean): void;
    LogException(exception: unknown, context: LogContext, prepend: boolean): void;
    LogSeperator(message: unknown): void;
    LogSuccess(message: unknown, context: LogContext): void;
    LogVariable(variableName: string, value: unknown, suffix: string): void;
    LogWarning(message: unknown, context: LogContext, prepend: boolean): void;
    OpenConsole(): void;
    RemoveCommand(name: string): boolean;
    RemoveTrackedStat(name: string): boolean;
    RunCommand(input: string): boolean;
    SetToggleKey(toggleKey: unknown): void;
    SetTrackedStat(name: string, func: unknown, startEnabled: boolean): void;
}
declare const DevConsole: DevConsoleConstructor;
    
interface EasyShake extends MonoBehaviour {
    shakeDuration: number;
    shakeOnEnable: boolean;
    movementLerpMod: number;
    movementsPerSecond: number;
    minimizeShakeOverTime: boolean;
    maxPositionOffset: Vector3;
    maxRotationOffsetAngles: Vector3;
    destroyComponentOnEnd: boolean;


    GetRandomVector3(maxRange: Vector3): Vector3;
    SetStartingPosRot(localPosition: Vector3, localRotation: Quaternion): void;
    Shake(duration: number): void;
    ShakeForever(): void;
    StopShake(): void;

}
    
interface EasyShakeConstructor {

    new(): EasyShake;


}
declare const EasyShake: EasyShakeConstructor;
    
interface EasyMotion extends MonoBehaviour {
    runInEditor: boolean;
    transformSpace: Space;
    translate: boolean;
    translationSpeed: Vector3;
    rotate: boolean;
    angularRotationSpeed: Vector3;
    scale: boolean;
    scaleSpeed: Vector3;
    sineMotion: boolean;
    sineMod: number;
    sineOffset: number;



}
    
interface EasyMotionConstructor {

    new(): EasyMotion;


}
declare const EasyMotion: EasyMotionConstructor;
    
interface GroundItemDrop extends MonoBehaviour {
    boxCollider: BoxCollider;


    GetVelocity(): Vector3;
    IsGrounded(): boolean;
    SetGrounded(grounded: boolean): void;
    SetPosition(position: Vector3): void;
    SetSpinActive(active: boolean): void;
    SetVelocity(velocity: Vector3): void;

}
    
interface BoxCollider extends Collider {
    center: Vector3;
    size: Vector3;
    extents: Vector3;



}
    
interface BoxColliderConstructor {

    new(): BoxCollider;


}
declare const BoxCollider: BoxColliderConstructor;
    
interface GroundItemDropConstructor {

    new(): GroundItemDrop;


}
declare const GroundItemDrop: GroundItemDropConstructor;
    
interface CloudImage extends MonoBehaviour {
    url: string;
    image: Image;
    downloadOnStart: boolean;
    releaseImageOnDisable: boolean;
    hideErrors: boolean;
    loadedUrl: string;


    ReleaseImage(notifyCache: boolean): void;
    StartDownload(): void;

}
    
interface CloudImageConstructor {

    new(): CloudImage;


    CleanseCache(): void;
    ClearCache(): void;
    PrintCache(): void;
}
declare const CloudImage: CloudImageConstructor;
    
interface LineRenderer extends Renderer {
    numPositions: number;
    startWidth: number;
    endWidth: number;
    widthMultiplier: number;
    numCornerVertices: number;
    numCapVertices: number;
    useWorldSpace: boolean;
    loop: boolean;
    startColor: Color;
    endColor: Color;
    positionCount: number;
    textureScale: Vector2;
    shadowBias: number;
    generateLightingData: boolean;
    textureMode: LineTextureMode;
    alignment: LineAlignment;
    maskInteraction: SpriteMaskInteraction;
    widthCurve: AnimationCurve;
    colorGradient: Gradient;


    /** Creates a snapshot of LineRenderer and stores it in mesh. */
    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    /** Creates a snapshot of LineRenderer and stores it in mesh. */
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    /** Get the position of a vertex in the line. */
    GetPosition(index: number): Vector3;
    /** Get the positions of all vertices in the line. */
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    /** Set the line color at the start and at the end. */
    SetColors(start: Color, end: Color): void;
    /** Set the position of a vertex in the line. */
    SetPosition(index: number, position: Vector3): void;
    /** Set the positions of all vertices in the line. */
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    /** Set the number of line segments. */
    SetVertexCount(count: number): void;
    /** Set the line width at the start and at the end. */
    SetWidth(start: number, end: number): void;
    /** Generates a simplified version of the original line by removing points that fall within the specified tolerance. */
    Simplify(tolerance: number): void;

}
    
interface LineRendererConstructor {

    new(): LineRenderer;


}
declare const LineRenderer: LineRendererConstructor;
    
interface AirshipRedirectDrag extends MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IPointerEnterHandler, IPointerExitHandler {
    isDragging: boolean;
    redirectTarget: ScrollRect;


    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;

}
    
interface AirshipRedirectDragConstructor {

    new(): AirshipRedirectDrag;


}
declare const AirshipRedirectDrag: AirshipRedirectDragConstructor;
    
interface IMeshModifier {


    ModifyMesh(mesh: Mesh): void;
    ModifyMesh(verts: VertexHelper): void;

}
    
interface VertexHelper {
    currentVertCount: number;
    currentIndexCount: number;


    AddTriangle(idx0: number, idx1: number, idx2: number): void;
    AddUIVertexQuad(verts: CSArray<UIVertex>): void;
    AddUIVertexStream(verts: CSArray<UIVertex>, indices: CSArray<number>): void;
    AddUIVertexTriangleStream(verts: CSArray<UIVertex>): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4, uv1: Vector4, uv2: Vector4, uv3: Vector4, normal: Vector3, tangent: Vector4): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4, uv1: Vector4, normal: Vector3, tangent: Vector4): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4): void;
    AddVert(v: UIVertex): void;
    Clear(): void;
    Dispose(): void;
    FillMesh(mesh: Mesh): void;
    GetUIVertexStream(stream: CSArray<UIVertex>): void;
    PopulateUIVertex(vertex: unknown, i: number): void;
    SetUIVertex(vertex: UIVertex, i: number): void;

}
    
interface VertexHelperConstructor {

    new(): VertexHelper;
    new(m: Mesh): VertexHelper;


}
declare const VertexHelper: VertexHelperConstructor;
    
interface TrueShadow extends UIBehaviour, IMeshModifier, ICanvasElement {
    Size: number;
    Spread: number;
    UseGlobalAngle: boolean;
    OffsetAngle: number;
    OffsetDistance: number;
    Color: Color;
    UseCasterAlpha: boolean;
    IgnoreCasterColor: boolean;
    Inset: boolean;
    BlendMode: BlendMode;
    ColorBleedMode: ColorBleedMode;
    DisableFitCompensation: boolean;
    ClearColor: Color;
    ShadowAsSibling: boolean;
    CustomHash: number;
    Offset: Vector2;
    Cutout: boolean;
    UsingRendererMaterialProvider: boolean;


    ApplySerializedData(): void;
    CopyTo(other: TrueShadow): void;
    CopyTo(other: GameObject): void;
    CopyToTMPSubMeshes(): void;
    GetShadowCastingMaterial(): Material;
    GetShadowRenderingMaterial(): Material;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    ModifyMesh(mesh: Mesh): void;
    ModifyMesh(verts: VertexHelper): void;
    ModifyShadowCastingMaterialProperties(propertyBlock: MaterialPropertyBlock): void;
    ModifyShadowCastingMesh(mesh: Mesh): void;
    ModifyShadowRendererMaterial(baseMaterial: Material): void;
    ModifyShadowRendererMesh(vertexHelper: VertexHelper): void;
    Rebuild(executing: CanvasUpdate): void;
    RefreshPlugins(): void;
    SetHierachyDirty(): void;
    SetLayoutDirty(): void;
    SetTextureDirty(): void;

}
    
interface TrueShadowConstructor {

    new(): TrueShadow;


}
declare const TrueShadow: TrueShadowConstructor;
    
interface ScalableBufferManager {



}
    
interface ScalableBufferManagerConstructor {
    widthScaleFactor: number;
    heightScaleFactor: number;



    ResizeBuffers(widthScale: number, heightScale: number): void;
}
declare const ScalableBufferManager: ScalableBufferManagerConstructor;
    
interface AirshipPlatformUtil {



}
    
interface AirshipPlatformUtilConstructor {
    livePlatforms: CSArray<number>;

    new(): AirshipPlatformUtil;


    FromBuildTarget(buildTarget: BuildTarget): AirshipPlatform;
    FromRuntimePlatform(runtimePlatform: RuntimePlatform): AirshipPlatform;
    GetLocalPlatform(): AirshipPlatform;
    IsDeviceSimulator(): boolean;
    ToBuildTarget(platform: AirshipPlatform): BuildTarget;
}
declare const AirshipPlatformUtil: AirshipPlatformUtilConstructor;
    
interface ColliderRollback extends NetworkBehaviour {


    Awake(): void;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnStartServer(): void;
    OnStopServer(): void;

}
    
interface ColliderRollbackConstructor {

    new(): ColliderRollback;


}
declare const ColliderRollback: ColliderRollbackConstructor;
    
interface AvatarAccessoryCollection extends ScriptableObject {
    accessories: CSArray<AccessoryComponent>;
    faces: CSArray<AccessoryFace>;
    skinColors: CSArray<Color>;



}
    
interface AvatarAccessoryCollectionConstructor {

    new(): AvatarAccessoryCollection;


}
declare const AvatarAccessoryCollection: AvatarAccessoryCollectionConstructor;
    
interface ContactPoint {
    point: Vector3;
    normal: Vector3;
    impulse: Vector3;
    thisCollider: Collider;
    otherCollider: Collider;
    separation: number;



}
    
interface SystemInfo {



}
    
interface SystemInfoConstructor {
    unsupportedIdentifier: string;
    batteryLevel: number;
    batteryStatus: BatteryStatus;
    operatingSystem: string;
    operatingSystemFamily: OperatingSystemFamily;
    processorType: string;
    processorFrequency: number;
    processorCount: number;
    systemMemorySize: number;
    deviceUniqueIdentifier: string;
    deviceName: string;
    deviceModel: string;
    supportsAccelerometer: boolean;
    supportsGyroscope: boolean;
    supportsLocationService: boolean;
    supportsVibration: boolean;
    supportsAudio: boolean;
    deviceType: DeviceType;
    graphicsMemorySize: number;
    graphicsDeviceName: string;
    graphicsDeviceVendor: string;
    graphicsDeviceID: number;
    graphicsDeviceVendorID: number;
    graphicsDeviceType: GraphicsDeviceType;
    graphicsUVStartsAtTop: boolean;
    graphicsDeviceVersion: string;
    graphicsShaderLevel: number;
    graphicsMultiThreaded: boolean;
    renderingThreadingMode: RenderingThreadingMode;
    foveatedRenderingCaps: FoveatedRenderingCaps;
    hasHiddenSurfaceRemovalOnGPU: boolean;
    hasDynamicUniformArrayIndexingInFragmentShaders: boolean;
    supportsShadows: boolean;
    supportsRawShadowDepthSampling: boolean;
    supportsRenderTextures: boolean;
    supportsMotionVectors: boolean;
    supportsRenderToCubemap: boolean;
    supportsImageEffects: boolean;
    supports3DTextures: boolean;
    supportsCompressed3DTextures: boolean;
    supports2DArrayTextures: boolean;
    supports3DRenderTextures: boolean;
    supportsCubemapArrayTextures: boolean;
    supportsAnisotropicFilter: boolean;
    copyTextureSupport: CopyTextureSupport;
    supportsComputeShaders: boolean;
    supportsGeometryShaders: boolean;
    supportsTessellationShaders: boolean;
    supportsRenderTargetArrayIndexFromVertexShader: boolean;
    supportsInstancing: boolean;
    supportsHardwareQuadTopology: boolean;
    supports32bitsIndexBuffer: boolean;
    supportsSparseTextures: boolean;
    supportedRenderTargetCount: number;
    supportsSeparatedRenderTargetsBlend: boolean;
    supportedRandomWriteTargetCount: number;
    supportsMultisampledTextures: number;
    supportsMultisampled2DArrayTextures: boolean;
    supportsMultisampleAutoResolve: boolean;
    supportsTextureWrapMirrorOnce: number;
    usesReversedZBuffer: boolean;
    supportsStencil: number;
    npotSupport: NPOTSupport;
    maxTextureSize: number;
    maxTexture3DSize: number;
    maxTextureArraySlices: number;
    maxCubemapSize: number;
    maxAnisotropyLevel: number;
    maxComputeBufferInputsVertex: number;
    maxComputeBufferInputsFragment: number;
    maxComputeBufferInputsGeometry: number;
    maxComputeBufferInputsDomain: number;
    maxComputeBufferInputsHull: number;
    maxComputeBufferInputsCompute: number;
    maxComputeWorkGroupSize: number;
    maxComputeWorkGroupSizeX: number;
    maxComputeWorkGroupSizeY: number;
    maxComputeWorkGroupSizeZ: number;
    computeSubGroupSize: number;
    supportsAsyncCompute: boolean;
    supportsGpuRecorder: boolean;
    supportsGraphicsFence: boolean;
    supportsAsyncGPUReadback: boolean;
    supportsRayTracingShaders: boolean;
    supportsRayTracing: boolean;
    supportsInlineRayTracing: boolean;
    supportsSetConstantBuffer: boolean;
    constantBufferOffsetAlignment: number;
    maxConstantBufferSize: number;
    maxGraphicsBufferSize: number;
    minConstantBufferOffsetAlignment: boolean;
    hasMipMaxLevel: boolean;
    supportsMipStreaming: boolean;
    graphicsPixelFillrate: number;
    usesLoadStoreActions: boolean;
    hdrDisplaySupportFlags: HDRDisplaySupportFlags;
    supportsConservativeRaster: boolean;
    supportsMultiview: boolean;
    supportsStoreAndResolveAction: boolean;
    supportsMultisampleResolveDepth: boolean;
    supportsMultisampleResolveStencil: boolean;
    supportsIndirectArgumentsBuffer: boolean;
    supportsVertexPrograms: boolean;
    supportsGPUFence: boolean;

    new(): SystemInfo;


    GetCompatibleFormat(format: GraphicsFormat, usage: FormatUsage): GraphicsFormat;
    GetCompatibleFormat(format: GraphicsFormat, usage: GraphicsFormatUsage): GraphicsFormat;
    GetGraphicsFormat(format: DefaultFormat): GraphicsFormat;
    GetRenderTextureSupportedMSAASampleCount(desc: RenderTextureDescriptor): number;
    IsFormatSupported(format: GraphicsFormat, usage: FormatUsage): boolean;
    IsFormatSupported(format: GraphicsFormat, usage: GraphicsFormatUsage): boolean;
    SupportsBlendingOnRenderTextureFormat(format: RenderTextureFormat): boolean;
    SupportsRandomWriteOnRenderTextureFormat(format: RenderTextureFormat): boolean;
    SupportsRenderTextureFormat(format: RenderTextureFormat): boolean;
    SupportsTextureFormat(format: TextureFormat): boolean;
    SupportsVertexAttributeFormat(format: VertexAttributeFormat, dimension: number): boolean;
}
declare const SystemInfo: SystemInfoConstructor;
    
interface CanvasScaler extends UIBehaviour {
    uiScaleMode: ScaleMode;
    referencePixelsPerUnit: number;
    scaleFactor: number;
    referenceResolution: Vector2;
    screenMatchMode: ScreenMatchMode;
    matchWidthOrHeight: number;
    physicalUnit: Unit;
    fallbackScreenDPI: number;
    defaultSpriteDPI: number;
    dynamicPixelsPerUnit: number;



}
    
interface GridLayoutGroup extends LayoutGroup {
    startCorner: Corner;
    startAxis: Axis;
    cellSize: Vector2;
    spacing: Vector2;
    constraint: Constraint;
    constraintCount: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;

}
    
interface ILayoutIgnorer {
    ignoreLayout: boolean;



}
    
interface LayoutElement extends UIBehaviour, ILayoutIgnorer, ILayoutElement {
    ignoreLayout: boolean;
    minWidth: number;
    minHeight: number;
    preferredWidth: number;
    preferredHeight: number;
    flexibleWidth: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;

}
    
interface Screen {



}
    
interface Resolution {
    width: number;
    height: number;
    refreshRateRatio: RefreshRate;
    refreshRate: number;


    /** Returns a nicely formatted string of the resolution. */
    ToString(): string;

}
    
interface RefreshRate {
    numerator: number;
    denominator: number;
    value: number;


    CompareTo(other: RefreshRate): number;
    Equals(other: RefreshRate): boolean;
    ToString(): string;

}
    
interface DisplayInfo {
    width: number;
    height: number;
    refreshRate: RefreshRate;
    workArea: RectInt;
    name: string;


    Equals(other: DisplayInfo): boolean;

}
    
interface ScreenConstructor {
    width: number;
    height: number;
    dpi: number;
    currentResolution: Resolution;
    resolutions: CSArray<Resolution>;
    msaaSamples: number;
    fullScreen: boolean;
    fullScreenMode: FullScreenMode;
    safeArea: Rect;
    cutouts: CSArray<Rect>;
    autorotateToPortrait: boolean;
    autorotateToPortraitUpsideDown: boolean;
    autorotateToLandscapeLeft: boolean;
    autorotateToLandscapeRight: boolean;
    orientation: ScreenOrientation;
    sleepTimeout: number;
    brightness: number;
    mainWindowPosition: Vector2Int;
    mainWindowDisplayInfo: DisplayInfo;
    GetResolution: CSArray<Resolution>;
    showCursor: boolean;
    lockCursor: boolean;

    new(): Screen;


    GetDisplayLayout(displayLayout: CSArray<DisplayInfo>): void;
    MoveMainWindowTo(display: unknown, position: Vector2Int): AsyncOperation;
    SetMSAASamples(numSamples: number): void;
    SetResolution(width: number, height: number, fullscreenMode: FullScreenMode, preferredRefreshRate: RefreshRate): void;
    SetResolution(width: number, height: number, fullscreenMode: FullScreenMode, preferredRefreshRate: number): void;
    SetResolution(width: number, height: number, fullscreenMode: FullScreenMode): void;
    SetResolution(width: number, height: number, fullscreen: boolean, preferredRefreshRate: number): void;
    SetResolution(width: number, height: number, fullscreen: boolean): void;
}
declare const Screen: ScreenConstructor;
    
interface Gizmos {



}
    
interface GizmosConstructor {
    color: Color;
    matrix: Matrix4x4;
    exposure: Texture;
    probeSize: number;

    new(): Gizmos;


    CalculateLOD(position: Vector3, radius: number): number;
    DrawCube(center: Vector3, size: Vector3): void;
    DrawFrustum(center: Vector3, fov: number, maxRange: number, minRange: number, aspect: number): void;
    DrawGUITexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material): void;
    DrawGUITexture(screenRect: Rect, texture: Texture): void;
    DrawGUITexture(screenRect: Rect, texture: Texture, mat: Material): void;
    DrawGUITexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number): void;
    DrawIcon(center: Vector3, name: string, allowScaling: boolean): void;
    DrawIcon(center: Vector3, name: string, allowScaling: boolean, tint: Color): void;
    DrawIcon(center: Vector3, name: string): void;
    DrawLine(from: Vector3, to: Vector3): void;
    DrawLineList(points: unknown): void;
    DrawLineStrip(points: unknown, looped: boolean): void;
    DrawMesh(mesh: Mesh, submeshIndex: number, position: Vector3, rotation: Quaternion, scale: Vector3): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion): void;
    DrawMesh(mesh: Mesh, position: Vector3): void;
    DrawMesh(mesh: Mesh): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, scale: Vector3): void;
    DrawMesh(mesh: Mesh, submeshIndex: number, position: Vector3, rotation: Quaternion): void;
    DrawMesh(mesh: Mesh, submeshIndex: number, position: Vector3): void;
    DrawMesh(mesh: Mesh, submeshIndex: number): void;
    DrawRay(r: Ray): void;
    DrawRay(from: Vector3, direction: Vector3): void;
    DrawSphere(center: Vector3, radius: number): void;
    DrawWireCube(center: Vector3, size: Vector3): void;
    DrawWireMesh(mesh: Mesh, submeshIndex: number, position: Vector3, rotation: Quaternion, scale: Vector3): void;
    DrawWireMesh(mesh: Mesh, position: Vector3, rotation: Quaternion): void;
    DrawWireMesh(mesh: Mesh, position: Vector3): void;
    DrawWireMesh(mesh: Mesh): void;
    DrawWireMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, scale: Vector3): void;
    DrawWireMesh(mesh: Mesh, submeshIndex: number, position: Vector3, rotation: Quaternion): void;
    DrawWireMesh(mesh: Mesh, submeshIndex: number, position: Vector3): void;
    DrawWireMesh(mesh: Mesh, submeshIndex: number): void;
    DrawWireSphere(center: Vector3, radius: number): void;
}
declare const Gizmos: GizmosConstructor;
    
interface RenderUtils {



}
    
interface RenderUtilsConstructor {



    CreateDefaultRenderTexture(width: number, height: number): RenderTexture;
}
declare const RenderUtils: RenderUtilsConstructor;
    
interface DeviceBridge {



}
    
interface DeviceBridgeConstructor {
    isTablet: boolean;

    new(): DeviceBridge;


    GetDeviceType(): AirshipDeviceType;
    OnLoad(): void;
}
declare const DeviceBridge: DeviceBridgeConstructor;
    
interface Mask extends UIBehaviour, IMaterialModifier, ICanvasRaycastFilter {
    rectTransform: RectTransform;
    showMaskGraphic: boolean;
    graphic: Graphic;


    GetModifiedMaterial(baseMaterial: Material): Material;
    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;
    MaskEnabled(): boolean;
    OnSiblingGraphicEnabledDisabled(): void;

}
    
interface ImageWithRoundedCorners extends MonoBehaviour {
    radius: number;


    Refresh(): void;
    Validate(): void;

}
    
interface ImageWithRoundedCornersConstructor {

    new(): ImageWithRoundedCorners;


}
declare const ImageWithRoundedCorners: ImageWithRoundedCornersConstructor;
    
interface ImageWithIndependentRoundedCorners extends MonoBehaviour {
    r: Vector4;


    Refresh(): void;
    Validate(): void;

}
    
interface ImageWithIndependentRoundedCornersConstructor {

    new(): ImageWithIndependentRoundedCorners;


}
declare const ImageWithIndependentRoundedCorners: ImageWithIndependentRoundedCornersConstructor;
    
interface NavMeshAgent extends Behaviour {
    destination: Vector3;
    stoppingDistance: number;
    velocity: Vector3;
    nextPosition: Vector3;
    steeringTarget: Vector3;
    desiredVelocity: Vector3;
    remainingDistance: number;
    baseOffset: number;
    isOnOffMeshLink: boolean;
    currentOffMeshLinkData: OffMeshLinkData;
    nextOffMeshLinkData: OffMeshLinkData;
    autoTraverseOffMeshLink: boolean;
    autoBraking: boolean;
    autoRepath: boolean;
    hasPath: boolean;
    pathPending: boolean;
    isPathStale: boolean;
    pathStatus: NavMeshPathStatus;
    pathEndPosition: Vector3;
    isStopped: boolean;
    path: NavMeshPath;
    navMeshOwner: Object;
    agentTypeID: number;
    walkableMask: number;
    areaMask: number;
    speed: number;
    angularSpeed: number;
    acceleration: number;
    updatePosition: boolean;
    updateRotation: boolean;
    updateUpAxis: boolean;
    radius: number;
    height: number;
    obstacleAvoidanceType: ObstacleAvoidanceType;
    avoidancePriority: number;
    isOnNavMesh: boolean;


    /** Enables or disables the current off-mesh link. */
    ActivateCurrentOffMeshLink(activated: boolean): void;
    /** Calculate a path to a specified point and store the resulting path. */
    CalculatePath(targetPosition: Vector3, path: NavMeshPath): boolean;
    /** Completes the movement on the current OffMeshLink. */
    CompleteOffMeshLink(): void;
    /** Locate the closest NavMesh edge. */
    FindClosestEdge(hit: unknown): boolean;
    /** Gets the cost for path calculation when crossing area of a particular type. */
    GetAreaCost(areaIndex: number): number;
    /** Gets the cost for crossing ground of a particular type. */
    GetLayerCost(layer: number): number;
    /** Apply relative movement to current position. */
    Move(offset: Vector3): void;
    /** Trace a straight path towards a target postion in the NavMesh without moving the agent. */
    Raycast(targetPosition: Vector3, hit: unknown): boolean;
    /** Clears the current path. */
    ResetPath(): void;
    /** Resumes the movement along the current path after a pause. */
    Resume(): void;
    /** Sample a position along the current path. */
    SamplePathPosition(areaMask: number, maxDistance: number, hit: unknown): boolean;
    /** Sets the cost for traversing over areas of the area type. */
    SetAreaCost(areaIndex: number, areaCost: number): void;
    /** Sets or updates the destination thus triggering the calculation for a new path. */
    SetDestination(target: Vector3): boolean;
    /** Sets the cost for traversing over geometry of the layer type. */
    SetLayerCost(layer: number, cost: number): void;
    /** Assign a new path to this agent. */
    SetPath(path: NavMeshPath): boolean;
    /** Stop movement of this agent along its current path. */
    Stop(): void;
    Stop(stopUpdates: boolean): void;
    /** Warps agent to the provided position. */
    Warp(newPosition: Vector3): boolean;

}
    
interface OffMeshLinkData {
    valid: boolean;
    activated: boolean;
    linkType: OffMeshLinkType;
    startPos: Vector3;
    endPos: Vector3;
    owner: Object;
    offMeshLink: OffMeshLink;



}
    
interface OffMeshLink extends Behaviour {
    activated: boolean;
    occupied: boolean;
    costOverride: number;
    biDirectional: boolean;
    navMeshLayer: number;
    area: number;
    autoUpdatePositions: boolean;
    startTransform: Transform;
    endTransform: Transform;


    /** Explicitly update the link endpoints. */
    UpdatePositions(): void;

}
    
interface OffMeshLinkConstructor {

    new(): OffMeshLink;


}
declare const OffMeshLink: OffMeshLinkConstructor;
    
interface NavMeshPath {
    corners: CSArray<Vector3>;
    status: NavMeshPathStatus;


    /** Erase all corner points from path. */
    ClearCorners(): void;
    /** Calculate the corners for the path. */
    GetCornersNonAlloc(results: CSArray<Vector3>): number;

}
    
interface NavMeshPathConstructor {

    new(): NavMeshPath;


}
declare const NavMeshPath: NavMeshPathConstructor;
    
interface NavMeshAgentConstructor {

    new(): NavMeshAgent;


}
declare const NavMeshAgent: NavMeshAgentConstructor;
    
    
interface OnNavMeshPreUpdate {


    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;

}
    
interface OnNavMeshPreUpdateConstructor {

    new(object: unknown, method: unknown): OnNavMeshPreUpdate;


}
declare const OnNavMeshPreUpdate: OnNavMeshPreUpdateConstructor;
    
interface NavMeshLinkInstance {
    valid: boolean;
    owner: Object;


    /** Removes this instance from the game. */
    Remove(): void;

}
    
interface NavMeshLinkData {
    startPosition: Vector3;
    endPosition: Vector3;
    costModifier: number;
    bidirectional: boolean;
    width: number;
    area: number;
    agentTypeID: number;



}
    
interface NavMeshDataInstance {
    valid: boolean;
    owner: Object;


    /** Removes this instance from the NavMesh system. */
    Remove(): void;

}
    
interface NavMeshData extends Object {
    sourceBounds: Bounds;
    position: Vector3;
    rotation: Quaternion;



}
    
interface NavMeshDataConstructor {

    new(): NavMeshData;
    new(agentTypeID: number): NavMeshData;


}
declare const NavMeshData: NavMeshDataConstructor;
    
interface NavMeshQueryFilter {
    areaMask: number;
    agentTypeID: number;


    /** Returns the area cost multiplier for the given area type for this filter. */
    GetAreaCost(areaIndex: number): number;
    /** Sets the pathfinding cost multiplier for this filter for a given area type. */
    SetAreaCost(areaIndex: number, cost: number): void;

}
    
interface NavMeshTriangulation {
    vertices: CSArray<Vector3>;
    indices: CSArray<number>;
    areas: CSArray<number>;
    layers: CSArray<number>;



}
    
interface NavMeshBuildSettings {
    agentTypeID: number;
    agentRadius: number;
    agentHeight: number;
    agentSlope: number;
    agentClimb: number;
    ledgeDropHeight: number;
    maxJumpAcrossDistance: number;
    minRegionArea: number;
    overrideVoxelSize: boolean;
    voxelSize: number;
    overrideTileSize: boolean;
    tileSize: number;
    maxJobWorkers: number;
    preserveTilesOutsideBounds: boolean;
    buildHeightMesh: boolean;
    debug: NavMeshBuildDebugSettings;


    /** Validates the properties of NavMeshBuildSettings. */
    ValidationReport(buildBounds: Bounds): CSArray<string>;

}
    
interface NavMeshBuildDebugSettings {
    flags: NavMeshBuildDebugFlags;



}
    
    
interface NavMeshObstacle extends Behaviour {
    height: number;
    radius: number;
    velocity: Vector3;
    carving: boolean;
    carveOnlyStationary: boolean;
    carvingMoveThreshold: number;
    carvingTimeToStationary: number;
    shape: NavMeshObstacleShape;
    center: Vector3;
    size: Vector3;



}
    
interface NavMeshObstacleConstructor {

    new(): NavMeshObstacle;


}
declare const NavMeshObstacle: NavMeshObstacleConstructor;
    
interface IStylePropertyAnimations {
    runningAnimationCount: number;
    completedAnimationCount: number;


    CancelAllAnimations(): void;
    CancelAnimation(id: StylePropertyId): void;
    GetAllAnimations(outPropertyIds: CSArray<StylePropertyId>): void;
    HasRunningAnimation(id: StylePropertyId): boolean;
    Start(id: StylePropertyId, from: number, to: number, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: number, to: number, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Length, to: Length, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Color, to: Color, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Background, to: Background, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: FontDefinition, to: FontDefinition, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Font, to: Font, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: TextShadow, to: TextShadow, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Scale, to: Scale, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Translate, to: Translate, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: Rotate, to: Rotate, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: TransformOrigin, to: TransformOrigin, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: BackgroundPosition, to: BackgroundPosition, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: BackgroundRepeat, to: BackgroundRepeat, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    Start(id: StylePropertyId, from: BackgroundSize, to: BackgroundSize, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    StartEnum(id: StylePropertyId, from: number, to: number, durationMs: number, delayMs: number, easingCurve: unknown): boolean;
    UpdateAnimation(id: StylePropertyId): void;

}
    
interface Length {
    value: number;
    unit: LengthUnit;


    Equals(other: Length): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    /** Check if Length is Auto. */
    IsAuto(): boolean;
    /** Check if Length is None. */
    IsNone(): boolean;
    ToString(): string;

}
    
interface LengthConstructor {

    new(value: number): Length;
    new(value: number, unit: LengthUnit): Length;


    Auto(): Length;
    None(): Length;
    Percent(value: number): Length;
}
declare const Length: LengthConstructor;
    
interface Background {
    texture: Texture2D;
    sprite: Sprite;
    renderTexture: RenderTexture;
    vectorImage: VectorImage;


    Equals(other: Background): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    /** Retrieves the selected asset which can be of a type of Texture, Sprite, RenderTexture or VectorImage. */
    GetSelectedImage(): Object;
    /** Help verify whether an asset has been assigned or not. */
    IsEmpty(): boolean;
    ToString(): string;

}
    
interface VectorImage extends ScriptableObject {
    width: number;
    height: number;



}
    
interface VectorImageConstructor {

    new(): VectorImage;


}
declare const VectorImage: VectorImageConstructor;
    
interface BackgroundConstructor {

    new(t: Texture2D): Background;


    FromRenderTexture(rt: RenderTexture): Background;
    FromSprite(s: Sprite): Background;
    FromTexture2D(t: Texture2D): Background;
    FromVectorImage(vi: VectorImage): Background;
}
declare const Background: BackgroundConstructor;
    
interface FontDefinition {
    font: Font;
    fontAsset: FontAsset;


    Equals(other: FontDefinition): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface TextAsset extends ScriptableObject {
    version: string;
    instanceID: number;
    hashCode: number;
    material: Material;
    materialHashCode: number;



}
    
interface FontAsset extends TextAsset {
    fontAssetCreationEditorSettings: FontAssetCreationEditorSettings;
    sourceFontFile: Font;
    atlasPopulationMode: AtlasPopulationMode;
    faceInfo: FaceInfo;
    glyphTable: CSArray<Glyph>;
    glyphLookupTable: CSDictionary<number, Glyph>;
    characterTable: CSArray<Character>;
    characterLookupTable: CSDictionary<number, Character>;
    atlasTexture: Texture2D;
    atlasTextures: CSArray<Texture2D>;
    atlasTextureCount: number;
    isMultiAtlasTexturesEnabled: boolean;
    getFontFeatures: boolean;
    atlasWidth: number;
    atlasHeight: number;
    atlasPadding: number;
    atlasRenderMode: GlyphRenderMode;
    fontFeatureTable: FontFeatureTable;
    fallbackFontAssetTable: CSArray<FontAsset>;
    fontWeightTable: CSArray<FontWeightPair>;
    regularStyleWeight: number;
    regularStyleSpacing: number;
    boldStyleWeight: number;
    boldStyleSpacing: number;
    italicStyleSlant: number;
    tabMultiple: number;


    ClearFontAssetData(setAtlasSizeToZero: boolean): void;
    HasCharacter(character: number): boolean;
    HasCharacter(character: string, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacter(character: number, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<string>): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<number>, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string): boolean;
    ReadFontAssetDefinition(): void;
    TryAddCharacters(unicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(unicodes: CSArray<number>, missingUnicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, missingCharacters: CSArray<string>, includeFontFeatures: boolean): boolean;

}
    
interface FontAssetCreationEditorSettings {
    sourceFontFileGUID: string;
    faceIndex: number;
    pointSizeSamplingMode: number;
    pointSize: number;
    padding: number;
    paddingMode: number;
    packingMode: number;
    atlasWidth: number;
    atlasHeight: number;
    characterSetSelectionMode: number;
    characterSequence: string;
    referencedFontAssetGUID: string;
    referencedTextAssetGUID: string;
    fontStyle: number;
    fontStyleModifier: number;
    renderMode: number;
    includeFontFeatures: boolean;



}
    
interface TextElement {
    elementType: TextElementType;
    unicode: number;
    textAsset: TextAsset;
    glyph: Glyph;
    glyphIndex: number;
    scale: number;



}
    
interface Character extends TextElement {



}
    
interface CharacterConstructor {

    new(): Character;
    new(unicode: number, glyph: Glyph): Character;
    new(unicode: number, fontAsset: FontAsset, glyph: Glyph): Character;


}
declare const Character: CharacterConstructor;
    
interface FontFeatureTable {


    /** Sorts the glyph pair adjustment records by glyph index. */
    SortGlyphPairAdjustmentRecords(): void;
    /** Sorts the Mark-to-Base Adjustment Table records. */
    SortMarkToBaseAdjustmentRecords(): void;
    /** Sorts the Mark-to-Mark Adjustment Table records. */
    SortMarkToMarkAdjustmentRecords(): void;

}
    
interface FontWeightPair {
    regularTypeface: FontAsset;
    italicTypeface: FontAsset;



}
    
interface FontAssetConstructor {

    new(): FontAsset;


    CreateFontAsset(familyName: string, styleName: string, pointSize: number): FontAsset;
    CreateFontAsset(fontFilePath: string, faceIndex: number, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number): FontAsset;
    CreateFontAsset(font: Font): FontAsset;
    CreateFontAsset(font: Font, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number, atlasPopulationMode: AtlasPopulationMode, enableMultiAtlasSupport: boolean): FontAsset;
    GetCharacters(fontAsset: FontAsset): string;
    GetCharactersArray(fontAsset: FontAsset): CSArray<number>;
}
declare const FontAsset: FontAssetConstructor;
    
interface FontDefinitionConstructor {



    FromFont(f: Font): FontDefinition;
    FromSDFFont(f: FontAsset): FontDefinition;
}
declare const FontDefinition: FontDefinitionConstructor;
    
interface TextShadow {
    offset: Vector2;
    blurRadius: number;
    color: Color;


    Equals(obj: unknown): boolean;
    Equals(other: TextShadow): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface Scale {
    value: Vector3;


    Equals(other: Scale): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface ScaleConstructor {

    new(scale: Vector2): Scale;
    new(scale: Vector3): Scale;


    None(): Scale;
}
declare const Scale: ScaleConstructor;
    
interface Translate {
    x: Length;
    y: Length;
    z: number;


    Equals(other: Translate): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface TranslateConstructor {

    new(x: Length, y: Length, z: number): Translate;
    new(x: Length, y: Length): Translate;


    None(): Translate;
}
declare const Translate: TranslateConstructor;
    
interface Rotate {
    angle: Angle;


    Equals(other: Rotate): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface Angle {
    value: number;
    unit: AngleUnit;


    Equals(other: Angle): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    /** Returns the value of the angle, expressed in degrees. */
    ToDegrees(): number;
    /** Returns the value of the angle, expressed in gradians. */
    ToGradians(): number;
    /** Returns the value of the angle, expressed in radians. */
    ToRadians(): number;
    ToString(): string;
    /** Returns the value of the angle, expressed in turns. */
    ToTurns(): number;

}
    
interface AngleConstructor {

    new(value: number): Angle;
    new(value: number, unit: AngleUnit): Angle;


    Degrees(value: number): Angle;
    Gradians(value: number): Angle;
    Radians(value: number): Angle;
    Turns(value: number): Angle;
}
declare const Angle: AngleConstructor;
    
interface RotateConstructor {

    new(angle: Angle): Rotate;


    None(): Rotate;
}
declare const Rotate: RotateConstructor;
    
interface TransformOrigin {
    x: Length;
    y: Length;
    z: number;


    Equals(other: TransformOrigin): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface TransformOriginConstructor {

    new(x: Length, y: Length, z: number): TransformOrigin;
    new(x: Length, y: Length): TransformOrigin;


    Initial(): TransformOrigin;
}
declare const TransformOrigin: TransformOriginConstructor;
    
interface BackgroundPosition {
    keyword: BackgroundPositionKeyword;
    offset: Length;


    Equals(obj: unknown): boolean;
    Equals(other: BackgroundPosition): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface BackgroundPositionConstructor {

    new(keyword: BackgroundPositionKeyword): BackgroundPosition;
    new(keyword: BackgroundPositionKeyword, offset: Length): BackgroundPosition;


}
declare const BackgroundPosition: BackgroundPositionConstructor;
    
interface BackgroundRepeat {
    x: Repeat;
    y: Repeat;


    Equals(obj: unknown): boolean;
    Equals(other: BackgroundRepeat): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface BackgroundRepeatConstructor {

    new(repeatX: Repeat, repeatY: Repeat): BackgroundRepeat;


}
declare const BackgroundRepeat: BackgroundRepeatConstructor;
    
interface BackgroundSize {
    sizeType: BackgroundSizeType;
    x: Length;
    y: Length;


    Equals(obj: unknown): boolean;
    Equals(other: BackgroundSize): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface BackgroundSizeConstructor {

    new(sizeX: Length, sizeY: Length): BackgroundSize;
    new(sizeType: BackgroundSizeType): BackgroundSize;


}
declare const BackgroundSize: BackgroundSizeConstructor;
    
interface IVisualElementScheduler {


    Execute(timerUpdateEvent: unknown): IVisualElementScheduledItem;
    /** Schedule this action to be executed later. */
    Execute(updateEvent: unknown): IVisualElementScheduledItem;

}
    
interface IVisualElementScheduledItem {
    element: VisualElement;
    isActive: boolean;


    /** Repeats this action after a specified time. */
    Every(intervalMs: number): IVisualElementScheduledItem;
    /** Cancels any previously scheduled execution of this item and re-schedules the item. */
    ExecuteLater(delayMs: number): void;
    /** After specified duration, the item will be automatically unscheduled. */
    ForDuration(durationMs: number): IVisualElementScheduledItem;
    /** Removes this item from its VisualElement&#x27;s scheduler. */
    Pause(): void;
    /** If not already active, will schedule this item on its VisualElement&#x27;s scheduler. */
    Resume(): void;
    /** Adds a delay to the first invokation. */
    StartingIn(delayMs: number): IVisualElementScheduledItem;
    Until(stopCondition: unknown): IVisualElementScheduledItem;

}
    
interface ITransitionAnimations {


    /** Triggers an animation changing this element&#x27;s layout style values. */
    Layout(to: Rect, durationMs: number): unknown;
    /** Triggers an animation changing this element&#x27;s transform position. */
    Position(to: Vector3, duration: number): unknown;
    /** Triggers an animation changing this element&#x27;s transform rotation. */
    Rotation(to: Quaternion, duration: number): unknown;
    /** Triggers an animation changing this element&#x27;s transform scale. */
    Scale(to: number, duration: number): unknown;
    /** Triggers an animation changing this element&#x27;s size style values. */
    Size(to: Vector2, durationMs: number): unknown;
    Start(from: number, to: number, durationMs: number, onValueChanged: unknown): unknown;
    Start(from: Rect, to: Rect, durationMs: number, onValueChanged: unknown): unknown;
    Start(from: Color, to: Color, durationMs: number, onValueChanged: unknown): unknown;
    Start(from: Vector3, to: Vector3, durationMs: number, onValueChanged: unknown): unknown;
    Start(from: Vector2, to: Vector2, durationMs: number, onValueChanged: unknown): unknown;
    Start(from: Quaternion, to: Quaternion, durationMs: number, onValueChanged: unknown): unknown;
    /** Starts a transition animation on this VisualElement. */
    Start(from: StyleValues, to: StyleValues, durationMs: number): unknown;
    /** Starts a transition animation on this VisualElement. */
    Start(to: StyleValues, durationMs: number): unknown;
    Start(fromValueGetter: unknown, to: number, durationMs: number, onValueChanged: unknown): unknown;
    Start(fromValueGetter: unknown, to: Rect, durationMs: number, onValueChanged: unknown): unknown;
    Start(fromValueGetter: unknown, to: Color, durationMs: number, onValueChanged: unknown): unknown;
    Start(fromValueGetter: unknown, to: Vector3, durationMs: number, onValueChanged: unknown): unknown;
    Start(fromValueGetter: unknown, to: Vector2, durationMs: number, onValueChanged: unknown): unknown;
    Start(fromValueGetter: unknown, to: Quaternion, durationMs: number, onValueChanged: unknown): unknown;
    /** Triggers an animation changing this element&#x27;s positioning style values. */
    TopLeft(to: Vector2, durationMs: number): unknown;

}
    
interface StyleValues {
    top: number;
    left: number;
    width: number;
    height: number;
    right: number;
    bottom: number;
    color: Color;
    backgroundColor: Color;
    unityBackgroundImageTintColor: Color;
    borderColor: Color;
    marginLeft: number;
    marginTop: number;
    marginRight: number;
    marginBottom: number;
    paddingLeft: number;
    paddingTop: number;
    paddingRight: number;
    paddingBottom: number;
    borderLeftWidth: number;
    borderRightWidth: number;
    borderTopWidth: number;
    borderBottomWidth: number;
    borderTopLeftRadius: number;
    borderTopRightRadius: number;
    borderBottomLeftRadius: number;
    borderBottomRightRadius: number;
    opacity: number;
    flexGrow: number;
    flexShrink: number;



}
    
interface IResolvedStyle {
    alignContent: Align;
    alignItems: Align;
    alignSelf: Align;
    backgroundColor: Color;
    backgroundImage: Background;
    backgroundPositionX: BackgroundPosition;
    backgroundPositionY: BackgroundPosition;
    backgroundRepeat: BackgroundRepeat;
    backgroundSize: BackgroundSize;
    borderBottomColor: Color;
    borderBottomLeftRadius: number;
    borderBottomRightRadius: number;
    borderBottomWidth: number;
    borderLeftColor: Color;
    borderLeftWidth: number;
    borderRightColor: Color;
    borderRightWidth: number;
    borderTopColor: Color;
    borderTopLeftRadius: number;
    borderTopRightRadius: number;
    borderTopWidth: number;
    bottom: number;
    color: Color;
    display: DisplayStyle;
    flexBasis: StyleFloat;
    flexDirection: FlexDirection;
    flexGrow: number;
    flexShrink: number;
    flexWrap: Wrap;
    fontSize: number;
    height: number;
    justifyContent: Justify;
    left: number;
    letterSpacing: number;
    marginBottom: number;
    marginLeft: number;
    marginRight: number;
    marginTop: number;
    maxHeight: StyleFloat;
    maxWidth: StyleFloat;
    minHeight: StyleFloat;
    minWidth: StyleFloat;
    opacity: number;
    paddingBottom: number;
    paddingLeft: number;
    paddingRight: number;
    paddingTop: number;
    position: Position;
    right: number;
    rotate: Rotate;
    scale: Scale;
    textOverflow: TextOverflow;
    top: number;
    transformOrigin: Vector3;
    transitionDelay: CSArray<TimeValue>;
    transitionDuration: CSArray<TimeValue>;
    transitionProperty: CSArray<StylePropertyName>;
    transitionTimingFunction: CSArray<EasingFunction>;
    translate: Vector3;
    unityBackgroundImageTintColor: Color;
    unityFont: Font;
    unityFontDefinition: FontDefinition;
    unityFontStyleAndWeight: FontStyle;
    unityParagraphSpacing: number;
    unitySliceBottom: number;
    unitySliceLeft: number;
    unitySliceRight: number;
    unitySliceScale: number;
    unitySliceTop: number;
    unityTextAlign: TextAnchor;
    unityTextOutlineColor: Color;
    unityTextOutlineWidth: number;
    unityTextOverflowPosition: TextOverflowPosition;
    visibility: Visibility;
    whiteSpace: WhiteSpace;
    width: number;
    wordSpacing: number;
    unityBackgroundScaleMode: unknown;



}
    
interface StyleFloat {
    value: number;
    keyword: StyleKeyword;


    Equals(other: StyleFloat): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleFloatConstructor {

    new(v: number): StyleFloat;
    new(keyword: StyleKeyword): StyleFloat;


}
declare const StyleFloat: StyleFloatConstructor;
    
interface TimeValue {
    value: number;
    unit: TimeUnit;


    Equals(other: TimeValue): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface TimeValueConstructor {

    new(value: number): TimeValue;
    new(value: number, unit: TimeUnit): TimeValue;


}
declare const TimeValue: TimeValueConstructor;
    
interface StylePropertyName {


    Equals(other: unknown): boolean;
    Equals(other: StylePropertyName): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StylePropertyNameConstructor {

    new(name: string): StylePropertyName;


    IsNullOrEmpty(propertyName: StylePropertyName): boolean;
}
declare const StylePropertyName: StylePropertyNameConstructor;
    
interface EasingFunction {
    mode: EasingMode;


    Equals(other: EasingFunction): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface EasingFunctionConstructor {

    new(mode: EasingMode): EasingFunction;


}
declare const EasingFunction: EasingFunctionConstructor;
    
interface IExperimentalFeatures {
    animation: ITransitionAnimations;



}
    
interface ITransform {
    position: Vector3;
    rotation: Quaternion;
    scale: Vector3;
    matrix: Matrix4x4;



}
    
interface IEventHandler {


    /** Handles an event according to its propagation phase and current target, by executing the element&#x27;s
 default action or callbacks associated with the event. */
    HandleEvent(evt: EventBase): void;
    /** Returns true if event handlers for the event propagation BubbleUp phase, have been attached on this object. */
    HasBubbleUpHandlers(): boolean;
    /** Returns true if event handlers, for the event propagation TrickleDown phase, are attached to this object. */
    HasTrickleDownHandlers(): boolean;
    /** Sends an event to the event handler. */
    SendEvent(e: EventBase): void;

}
    
interface EventBase {
    eventTypeId: number;
    timestamp: number;
    bubbles: boolean;
    tricklesDown: boolean;
    target: IEventHandler;
    isPropagationStopped: boolean;
    isImmediatePropagationStopped: boolean;
    isDefaultPrevented: boolean;
    propagationPhase: PropagationPhase;
    currentTarget: IEventHandler;
    dispatch: boolean;
    imguiEvent: Event;
    originalMousePosition: Vector2;


    /** Implementation of IDisposable. */
    Dispose(): void;
    /** Indicates whether the default actions are prevented from being executed for this event. */
    PreventDefault(): void;
    /** Immediately stops the propagation of the event. The event isn&#x27;t sent to other elements along the propagation path. This method prevents other event handlers from executing on the current target. */
    StopImmediatePropagation(): void;
    /** Stops propagating this event. The event is not sent to other elements along the propagation path.
 This method does not prevent other event handlers from executing on the current target.
 If this method is called during the TrickleDown propagation phase, it will prevent default actions
 to be processed, such as an element getting focused as a result of a PointerDownEvent. */
    StopPropagation(): void;

}
    
interface CallbackEventHandler extends IEventHandler {


    /** Return true if event handlers for the event propagation BubbleUp phase have been attached on this object. */
    HasBubbleUpHandlers(): boolean;
    /** Returns true if event handlers, for the event propagation TrickleDown phase, are attached to this object. */
    HasTrickleDownHandlers(): boolean;
    RegisterCallback<TEventType>(callback: unknown, useTrickleDown: TrickleDown): void;
    RegisterCallback<TEventType, TUserArgsType>(callback: unknown, userArgs: TUserArgsType, useTrickleDown: TrickleDown): void;
    RegisterCallbackOnce<TEventType>(callback: unknown, useTrickleDown: TrickleDown): void;
    RegisterCallbackOnce<TEventType, TUserArgsType>(callback: unknown, userArgs: TUserArgsType, useTrickleDown: TrickleDown): void;
    /** Sends an event to the event handler. */
    SendEvent(e: EventBase): void;
    UnregisterCallback<TEventType>(callback: unknown, useTrickleDown: TrickleDown): void;
    UnregisterCallback<TEventType, TUserArgsType>(callback: unknown, useTrickleDown: TrickleDown): void;

}
    
interface Focusable extends CallbackEventHandler {
    focusController: FocusController;
    focusable: boolean;
    tabIndex: number;
    delegatesFocus: boolean;
    canGrabFocus: boolean;


    /** Tell the element to release the focus. */
    Blur(): void;
    /** Attempt to give the focus to this element. */
    Focus(): void;

}
    
interface FocusController {
    focusedElement: Focusable;


    /** Instructs the FocusController to ignore the given event.
 This will prevent the event from changing the current focused VisualElement or triggering focus events. */
    IgnoreEvent(evt: EventBase): void;

}
    
interface FocusControllerConstructor {

    new(focusRing: IFocusRing): FocusController;


}
declare const FocusController: FocusControllerConstructor;
    
    
interface PropertyPath {
    Length: number;
    IsEmpty: boolean;
    Item: PropertyPathPart;


    /** Indicates whether this instance and a specified object are equal. */
    Equals(other: PropertyPath): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface PropertyPathPart {
    IsName: boolean;
    IsIndex: boolean;
    IsKey: boolean;
    Kind: PropertyPathPartKind;
    Name: string;
    Index: number;
    Key: unknown;


    /** Indicates whether this instance and a specified object are equal. */
    Equals(other: PropertyPathPart): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface PropertyPathPartConstructor {

    new(name: string): PropertyPathPart;
    new(index: number): PropertyPathPart;
    new(key: unknown): PropertyPathPart;


}
declare const PropertyPathPart: PropertyPathPartConstructor;
    
interface IProperty {
    Name: string;
    IsReadOnly: boolean;


    /** Returns the declared value type of the property. */
    DeclaredValueType(): unknown;
    /** Returns the first attribute of the given type. */
    GetAttribute<TAttribute>(): TAttribute;
    /** Returns all attribute of the given type. */
    GetAttributes<TAttribute>(): CSArray<TAttribute>;
    /** Returns all attribute of the given type. */
    GetAttributes(): CSArray<unknown>;
    /** Returns true if the property has any attributes of the given type. */
    HasAttribute<TAttribute>(): boolean;

}
    
interface PropertyPathConstructor {

    new(path: string): PropertyPath;


    AppendIndex(path: unknown, index: number): PropertyPath;
    AppendKey(path: unknown, key: unknown): PropertyPath;
    AppendName(path: unknown, name: string): PropertyPath;
    AppendPart(path: unknown, part: unknown): PropertyPath;
    AppendProperty(path: unknown, property: IProperty): PropertyPath;
    Combine(path: unknown, pathToAppend: unknown): PropertyPath;
    Combine(path: unknown, pathToAppend: string): PropertyPath;
    FromIndex(index: number): PropertyPath;
    FromKey(key: unknown): PropertyPath;
    FromName(name: string): PropertyPath;
    FromPart(part: unknown): PropertyPath;
    Pop(path: unknown): PropertyPath;
    SubPath(path: unknown, startIndex: number): PropertyPath;
    SubPath(path: unknown, startIndex: number, length: number): PropertyPath;
}
declare const PropertyPath: PropertyPathConstructor;
    
interface Hierarchy {
    parent: VisualElement;
    childCount: number;
    Item: VisualElement;


    Add(child: VisualElement): void;
    Children(): CSArray<VisualElement>;
    Clear(): void;
    ElementAt(index: number): VisualElement;
    Equals(other: Hierarchy): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    IndexOf(element: VisualElement): number;
    Insert(index: number, child: VisualElement): void;
    Remove(child: VisualElement): void;
    RemoveAt(index: number): void;
    Sort(comp: unknown): void;

}
    
interface IPanel {
    visualTree: VisualElement;
    dispatcher: EventDispatcher;
    contextType: ContextType;
    focusController: FocusController;
    contextualMenuManager: ContextualMenuManager;
    isDirty: boolean;


    /** Returns the top element at this position. Will not return elements with pickingMode set to PickingMode.Ignore. */
    Pick(point: Vector2): VisualElement;
    PickAll(point: Vector2, picked: CSArray<VisualElement>): VisualElement;

}
    
interface EventDispatcher {



}
    
interface ContextualMenuManager {


    /** Displays the contextual menu. */
    DisplayMenu(triggerEvent: EventBase, target: IEventHandler): void;
    /** Checks if the event triggers the display of the contextual menu. This method also displays the menu. */
    DisplayMenuIfEventMatches(evt: EventBase, eventHandler: IEventHandler): void;

}
    
interface VisualTreeAsset extends ScriptableObject {
    importedWithErrors: boolean;
    importedWithWarnings: boolean;
    templateDependencies: CSArray<VisualTreeAsset>;
    stylesheets: CSArray<StyleSheet>;
    contentHash: number;


    /** Build a tree of VisualElements from the asset. */
    CloneTree(): TemplateContainer;
    /** Build a tree of VisualElements from the asset. */
    CloneTree(bindingPath: string): TemplateContainer;
    /** Builds a tree of VisualElements from the asset. */
    CloneTree(target: VisualElement): void;
    CloneTree(target: VisualElement, firstElementIndex: unknown, elementAddedCount: unknown): void;
    /** Build a tree of VisualElements from the asset. */
    Instantiate(): TemplateContainer;
    /** Build a tree of VisualElements from the asset. */
    Instantiate(bindingPath: string): TemplateContainer;

}
    
interface StyleSheet extends ScriptableObject {
    importedWithErrors: boolean;
    importedWithWarnings: boolean;
    contentHash: number;



}
    
interface StyleSheetConstructor {

    new(): StyleSheet;


}
declare const StyleSheet: StyleSheetConstructor;
    
interface IBindable {
    binding: IBinding;
    bindingPath: string;



}
    
interface IBinding {


    /** Called at regular intervals to synchronize bound properties to their IBindable counterparts. Called before the Update() method. */
    PreUpdate(): void;
    /** Disconnects the field from its bound property */
    Release(): void;
    /** Called at regular intervals to synchronize bound properties to their IBindable counterparts. Called before the Update() method. */
    Update(): void;

}
    
interface BindableElement extends VisualElement, IBindable {
    binding: IBinding;
    bindingPath: string;



}
    
interface BindableElementConstructor {

    new(): BindableElement;


}
declare const BindableElement: BindableElementConstructor;
    
interface TemplateContainer extends BindableElement {
    templateId: string;
    templateSource: VisualTreeAsset;
    contentContainer: VisualElement;



}
    
interface TemplateContainerConstructor {

    new(): TemplateContainer;
    new(templateId: string): TemplateContainer;


}
declare const TemplateContainer: TemplateContainerConstructor;
    
interface VisualTreeAssetConstructor {

    new(): VisualTreeAsset;


}
declare const VisualTreeAsset: VisualTreeAssetConstructor;
    
    
interface StyleColor {
    value: Color;
    keyword: StyleKeyword;


    Equals(other: StyleColor): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleColorConstructor {

    new(v: Color): StyleColor;
    new(keyword: StyleKeyword): StyleColor;


}
declare const StyleColor: StyleColorConstructor;
    
interface StyleBackground {
    value: Background;
    keyword: StyleKeyword;


    Equals(other: StyleBackground): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleBackgroundConstructor {

    new(v: Background): StyleBackground;
    new(v: Texture2D): StyleBackground;
    new(v: Sprite): StyleBackground;
    new(v: VectorImage): StyleBackground;
    new(keyword: StyleKeyword): StyleBackground;


}
declare const StyleBackground: StyleBackgroundConstructor;
    
interface StyleBackgroundPosition {
    value: BackgroundPosition;
    keyword: StyleKeyword;


    Equals(other: StyleBackgroundPosition): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleBackgroundPositionConstructor {

    new(v: BackgroundPosition): StyleBackgroundPosition;
    new(keyword: StyleKeyword): StyleBackgroundPosition;


}
declare const StyleBackgroundPosition: StyleBackgroundPositionConstructor;
    
interface StyleBackgroundRepeat {
    value: BackgroundRepeat;
    keyword: StyleKeyword;


    Equals(other: StyleBackgroundRepeat): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleBackgroundRepeatConstructor {

    new(v: BackgroundRepeat): StyleBackgroundRepeat;
    new(keyword: StyleKeyword): StyleBackgroundRepeat;


}
declare const StyleBackgroundRepeat: StyleBackgroundRepeatConstructor;
    
interface StyleBackgroundSize {
    value: BackgroundSize;
    keyword: StyleKeyword;


    Equals(other: StyleBackgroundSize): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleBackgroundSizeConstructor {

    new(v: BackgroundSize): StyleBackgroundSize;
    new(keyword: StyleKeyword): StyleBackgroundSize;


}
declare const StyleBackgroundSize: StyleBackgroundSizeConstructor;
    
interface StyleLength {
    value: Length;
    keyword: StyleKeyword;


    Equals(other: StyleLength): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleLengthConstructor {

    new(v: number): StyleLength;
    new(v: Length): StyleLength;
    new(keyword: StyleKeyword): StyleLength;


}
declare const StyleLength: StyleLengthConstructor;
    
interface StyleCursor {
    value: Cursor;
    keyword: StyleKeyword;


    Equals(other: StyleCursor): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface Cursor {
    texture: Texture2D;
    hotspot: Vector2;


    Equals(obj: unknown): boolean;
    Equals(other: Cursor): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleCursorConstructor {

    new(v: Cursor): StyleCursor;
    new(keyword: StyleKeyword): StyleCursor;


}
declare const StyleCursor: StyleCursorConstructor;
    
interface StyleRotate {
    value: Rotate;
    keyword: StyleKeyword;


    Equals(other: StyleRotate): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleRotateConstructor {

    new(v: Rotate): StyleRotate;
    new(keyword: StyleKeyword): StyleRotate;


}
declare const StyleRotate: StyleRotateConstructor;
    
interface StyleScale {
    value: Scale;
    keyword: StyleKeyword;


    Equals(other: StyleScale): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleScaleConstructor {

    new(v: Scale): StyleScale;
    new(keyword: StyleKeyword): StyleScale;
    new(scale: Vector2): StyleScale;


}
declare const StyleScale: StyleScaleConstructor;
    
interface StyleTextShadow {
    value: TextShadow;
    keyword: StyleKeyword;


    Equals(other: StyleTextShadow): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleTextShadowConstructor {

    new(v: TextShadow): StyleTextShadow;
    new(keyword: StyleKeyword): StyleTextShadow;


}
declare const StyleTextShadow: StyleTextShadowConstructor;
    
interface StyleTransformOrigin {
    value: TransformOrigin;
    keyword: StyleKeyword;


    Equals(other: StyleTransformOrigin): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleTransformOriginConstructor {

    new(v: TransformOrigin): StyleTransformOrigin;
    new(keyword: StyleKeyword): StyleTransformOrigin;


}
declare const StyleTransformOrigin: StyleTransformOriginConstructor;
    
interface StyleTranslate {
    value: Translate;
    keyword: StyleKeyword;


    Equals(other: StyleTranslate): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleTranslateConstructor {

    new(v: Translate): StyleTranslate;
    new(keyword: StyleKeyword): StyleTranslate;


}
declare const StyleTranslate: StyleTranslateConstructor;
    
interface StyleFont {
    value: Font;
    keyword: StyleKeyword;


    Equals(other: StyleFont): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleFontConstructor {

    new(v: Font): StyleFont;
    new(keyword: StyleKeyword): StyleFont;


}
declare const StyleFont: StyleFontConstructor;
    
interface StyleFontDefinition {
    value: FontDefinition;
    keyword: StyleKeyword;


    Equals(other: StyleFontDefinition): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;

}
    
interface StyleFontDefinitionConstructor {

    new(f: FontDefinition): StyleFontDefinition;
    new(f: FontAsset): StyleFontDefinition;
    new(f: Font): StyleFontDefinition;
    new(keyword: StyleKeyword): StyleFontDefinition;


}
declare const StyleFontDefinition: StyleFontDefinitionConstructor;
    
interface StyleInt {
    value: number;
    keyword: StyleKeyword;


    Equals(other: StyleInt): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;

}
    
interface StyleIntConstructor {

    new(v: number): StyleInt;
    new(keyword: StyleKeyword): StyleInt;


}
declare const StyleInt: StyleIntConstructor;
    
interface ICustomStyle {


    TryGetValue(property: unknown, value: unknown): boolean;
    TryGetValue(property: unknown, value: unknown): boolean;
    TryGetValue(property: unknown, value: unknown): boolean;
    TryGetValue(property: unknown, value: unknown): boolean;
    TryGetValue(property: unknown, value: unknown): boolean;
    TryGetValue(property: unknown, value: unknown): boolean;
    TryGetValue(property: unknown, value: unknown): boolean;
    TryGetValue<T>(property: unknown, value: unknown): boolean;
    TryGetValue(property: unknown, value: CSArray<string>): boolean;

}
    
interface VisualElementStyleSheetSet {
    count: number;
    Item: StyleSheet;


    /** Adds a style sheet for the owner element. */
    Add(styleSheet: StyleSheet): void;
    /** Removes all style sheets for the owner element. */
    Clear(): void;
    /** Looks for the specified StyleSheet */
    Contains(styleSheet: StyleSheet): boolean;
    /** Compares instances of the VisualElementStyleSheetSet struct for equality. */
    Equals(other: VisualElementStyleSheetSet): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    /** Removes a style sheet for the owner element. */
    Remove(styleSheet: StyleSheet): boolean;

}
    
interface BindingId {


    /** Indicates whether two binding properties are equal. */
    Equals(other: BindingId): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    /** Returns the binding property as a string. */
    ToString(): string;

}
    
interface BindingIdConstructor {
    Invalid: BindingId;

    new(path: string): BindingId;
    new(path: unknown): BindingId;


}
declare const BindingId: BindingIdConstructor;
    
interface Binding {
    isDirty: boolean;
    updateTrigger: BindingUpdateTrigger;


    /** Notifies the binding system to process this binding. */
    MarkDirty(): void;

}
    
interface BindingConstructor {



    ResetPanelLogLevel(panel: IPanel): void;
    SetGlobalLogLevel(logLevel: BindingLogLevel): void;
    SetPanelLogLevel(panel: IPanel, logLevel: BindingLogLevel): void;
}
declare const Binding: BindingConstructor;
    
interface BindingInfo {
    targetElement: VisualElement;
    bindingId: BindingId;
    binding: Binding;



}
    
interface DataSourceContext {
    dataSource: unknown;
    dataSourcePath: PropertyPath;



}
    
interface DataSourceContextConstructor {

    new(dataSource: unknown, dataSourcePath: unknown): DataSourceContext;


}
declare const DataSourceContext: DataSourceContextConstructor;
    
    
    
    
interface ScrollView extends VisualElement {
    horizontalScrollerVisibility: ScrollerVisibility;
    verticalScrollerVisibility: ScrollerVisibility;
    elasticAnimationIntervalMs: number;
    showHorizontal: boolean;
    showVertical: boolean;
    scrollOffset: Vector2;
    horizontalPageSize: number;
    verticalPageSize: number;
    mouseWheelScrollSize: number;
    scrollDecelerationRate: number;
    elasticity: number;
    touchScrollBehavior: TouchScrollBehavior;
    nestedInteractionKind: NestedInteractionKind;
    contentViewport: VisualElement;
    horizontalScroller: Scroller;
    verticalScroller: Scroller;
    contentContainer: VisualElement;
    mode: ScrollViewMode;


    /** Scroll to a specific child element. */
    ScrollTo(child: VisualElement): void;

}
    
interface Scroller extends VisualElement {
    slider: Slider;
    lowButton: RepeatButton;
    highButton: RepeatButton;
    value: number;
    lowValue: number;
    highValue: number;
    direction: SliderDirection;


    /** Updates the slider element size as a ratio of total range. A value greater than or equal to 1 will disable the Scroller. */
    Adjust(factor: number): void;
    /** Will change the value according to the current slider pageSize. */
    ScrollPageDown(): void;
    /** Will change the value according to the current slider pageSize. */
    ScrollPageDown(factor: number): void;
    /** Will change the value according to the current slider pageSize. */
    ScrollPageUp(): void;
    /** Will change the value according to the current slider pageSize. */
    ScrollPageUp(factor: number): void;

}
    
interface Slider {


    ApplyInputDeviceDelta(delta: Vector3, speed: DeltaSpeed, startValue: number): void;

}
    
interface SliderConstructor {
    ussClassName: string;
    labelUssClassName: string;
    inputUssClassName: string;

    new(): Slider;
    new(start: number, end: number, direction: SliderDirection, pageSize: number): Slider;
    new(label: string, start: number, end: number, direction: SliderDirection, pageSize: number): Slider;


}
declare const Slider: SliderConstructor;
    
interface ITextElement {
    text: string;



}
    
interface ITextEdition {
    isReadOnly: boolean;
    maxLength: number;
    placeholder: string;
    isDelayed: boolean;
    maskChar: string;
    isPassword: boolean;
    hidePlaceholderOnFocus: boolean;
    autoCorrection: boolean;
    hideMobileInput: boolean;
    touchScreenKeyboard: TouchScreenKeyboard;
    keyboardType: TouchScreenKeyboardType;



}
    
interface ITextElementExperimentalFeatures extends IExperimentalFeatures {


    /** Setting this property will override the displayed text while preserving the original text value. */
    SetRenderedText(renderedText: string): void;

}
    
interface ITextSelection {
    isSelectable: boolean;
    cursorColor: Color;
    selectionColor: Color;
    cursorIndex: number;
    doubleClickSelectsWord: boolean;
    selectIndex: number;
    tripleClickSelectsLine: boolean;
    selectAllOnFocus: boolean;
    selectAllOnMouseUp: boolean;
    cursorPosition: Vector2;


    /** Return true is the TextElement has a selection. */
    HasSelection(): boolean;
    /** Selects all the text contained in the field. */
    SelectAll(): void;
    /** Remove selection */
    SelectNone(): void;
    /** Select text between cursorIndex and selectIndex. */
    SelectRange(cursorIndex: number, selectionIndex: number): void;

}
    
interface TextElement extends BindableElement, ITextElement, ITextEdition, ITextElementExperimentalFeatures, ITextSelection {
    text: string;
    enableRichText: boolean;
    emojiFallbackSupport: boolean;
    parseEscapeSequences: boolean;
    displayTooltipWhenElided: boolean;
    isElided: boolean;
    experimental: ITextElementExperimentalFeatures;
    selection: ITextSelection;


    MeasureTextSize(textToMeasure: string, width: number, widthMode: MeasureMode, height: number, heightMode: MeasureMode): Vector2;

}
    
interface TextElementConstructor {
    ussClassName: string;
    selectableUssClassName: string;

    new(): TextElement;


}
declare const TextElement: TextElementConstructor;
    
interface RepeatButton extends TextElement {


    SetAction(clickEvent: unknown, delay: number, interval: number): void;

}
    
interface RepeatButtonConstructor {
    ussClassName: string;

    new(): RepeatButton;
    new(clickEvent: unknown, delay: number, interval: number): RepeatButton;


}
declare const RepeatButton: RepeatButtonConstructor;
    
interface ScrollerConstructor {
    ussClassName: string;
    horizontalVariantUssClassName: string;
    verticalVariantUssClassName: string;
    sliderUssClassName: string;
    lowButtonUssClassName: string;
    highButtonUssClassName: string;

    new(): Scroller;
    new(lowValue: number, highValue: number, valueChanged: unknown, direction: SliderDirection): Scroller;


}
declare const Scroller: ScrollerConstructor;
    
interface ScrollViewConstructor {
    ussClassName: string;
    viewportUssClassName: string;
    horizontalVariantViewportUssClassName: string;
    verticalVariantViewportUssClassName: string;
    verticalHorizontalVariantViewportUssClassName: string;
    contentAndVerticalScrollUssClassName: string;
    contentUssClassName: string;
    horizontalVariantContentUssClassName: string;
    verticalVariantContentUssClassName: string;
    verticalHorizontalVariantContentUssClassName: string;
    hScrollerUssClassName: string;
    vScrollerUssClassName: string;
    horizontalVariantUssClassName: string;
    verticalVariantUssClassName: string;
    verticalHorizontalVariantUssClassName: string;
    scrollVariantUssClassName: string;

    new(): ScrollView;
    new(scrollViewMode: ScrollViewMode): ScrollView;


}
declare const ScrollView: ScrollViewConstructor;
    
interface AirshipLongPress extends MonoBehaviour, IBeginDragHandler, IDragHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler {
    holdTime: number;


    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    Update(): void;

}
    
interface AirshipLongPressConstructor {

    new(): AirshipLongPress;


}
declare const AirshipLongPress: AirshipLongPressConstructor;
    
interface BoxCollider2D extends Collider2D {
    size: Vector2;
    edgeRadius: number;
    autoTiling: boolean;
    center: Vector2;



}
    
interface BoxCollider2DConstructor {

    new(): BoxCollider2D;


}
declare const BoxCollider2D: BoxCollider2DConstructor;
    
interface CircleCollider2D extends Collider2D {
    radius: number;
    center: Vector2;



}
    
interface CircleCollider2DConstructor {

    new(): CircleCollider2D;


}
declare const CircleCollider2D: CircleCollider2DConstructor;
    
interface CapsuleCollider2D extends Collider2D {
    size: Vector2;
    direction: CapsuleDirection2D;



}
    
interface CapsuleCollider2DConstructor {

    new(): CapsuleCollider2D;


}
declare const CapsuleCollider2D: CapsuleCollider2DConstructor;
    
interface PolygonCollider2D extends Collider2D {
    useDelaunayMesh: boolean;
    autoTiling: boolean;
    points: CSArray<Vector2>;
    pathCount: number;


    CreatePrimitive(sides: number): void;
    CreatePrimitive(sides: number, scale: Vector2): void;
    /** Creates as regular primitive polygon with the specified number of sides. */
    CreatePrimitive(sides: number, scale: Vector2, offset: Vector2): void;
    /** Gets a path from the Collider by its index. */
    GetPath(index: number): CSArray<Vector2>;
    GetPath(index: number, points: CSArray<Vector2>): number;
    /** Return the total number of points in the polygon in all paths. */
    GetTotalPointCount(): number;
    /** Define a path by its constituent points. */
    SetPath(index: number, points: CSArray<Vector2>): void;
    SetPath(index: number, points: CSArray<Vector2>): void;

}
    
interface PolygonCollider2DConstructor {

    new(): PolygonCollider2D;


}
declare const PolygonCollider2D: PolygonCollider2DConstructor;
    
interface CustomCollider2D extends Collider2D {
    customShapeCount: number;
    customVertexCount: number;


    /** Deletes a specific number of shapes defined by shapeCount starting at shapeIndex along with all associated vertices those shapes use. */
    ClearCustomShapes(shapeIndex: number, shapeCount: number): void;
    /** Deletes all the shapes and associated vertices for those shapes from the Collider. */
    ClearCustomShapes(): void;
    /** Gets all the physics shapes and vertices in the Collider and places them in the specified PhysicsShapeGroup2D. */
    GetCustomShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    /** Gets a specified number of physics shapes defined byshapeCount starting at shapeIndex along with all associated vertices those shapes use and places them in the specified PhysicsShapeGroup2D. */
    GetCustomShapes(physicsShapeGroup: PhysicsShapeGroup2D, shapeIndex: number, shapeCount: number): number;
    GetCustomShapes(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): number;
    /** Sets a single shape and all associated shape vertices from the specified physicsShapeGroup into the Collider. */
    SetCustomShape(physicsShapeGroup: PhysicsShapeGroup2D, srcShapeIndex: number, dstShapeIndex: number): void;
    SetCustomShape(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>, srcShapeIndex: number, dstShapeIndex: number): void;
    /** Sets all the shapes and vertices in the Collider to those represented by the specified PhysicsShapeGroup2D. */
    SetCustomShapes(physicsShapeGroup: PhysicsShapeGroup2D): void;
    SetCustomShapes(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;

}
    
interface CustomCollider2DConstructor {

    new(): CustomCollider2D;


}
declare const CustomCollider2D: CustomCollider2DConstructor;
    
interface EdgeCollider2D extends Collider2D {
    edgeRadius: number;
    edgeCount: number;
    pointCount: number;
    points: CSArray<Vector2>;
    useAdjacentStartPoint: boolean;
    useAdjacentEndPoint: boolean;
    adjacentStartPoint: Vector2;
    adjacentEndPoint: Vector2;


    GetPoints(points: CSArray<Vector2>): number;
    /** Reset to a single edge consisting of two points. */
    Reset(): void;
    SetPoints(points: CSArray<Vector2>): boolean;

}
    
interface EdgeCollider2DConstructor {

    new(): EdgeCollider2D;


}
declare const EdgeCollider2D: EdgeCollider2DConstructor;
    
interface TilemapCollider2D extends Collider2D {
    useDelaunayMesh: boolean;
    maximumTileChangeCount: number;
    extrusionFactor: number;
    hasTilemapChanges: boolean;


    /** Processes Tilemap changes for Collider updates immediately, if there are any. */
    ProcessTilemapChanges(): void;

}
    
interface TilemapCollider2DConstructor {

    new(): TilemapCollider2D;


}
declare const TilemapCollider2D: TilemapCollider2DConstructor;
    
interface SphereCollider extends Collider {
    center: Vector3;
    radius: number;



}
    
interface SphereColliderConstructor {

    new(): SphereCollider;


}
declare const SphereCollider: SphereColliderConstructor;
    
interface CapsuleCollider extends Collider {
    center: Vector3;
    radius: number;
    height: number;
    direction: number;



}
    
interface CapsuleColliderConstructor {

    new(): CapsuleCollider;


}
declare const CapsuleCollider: CapsuleColliderConstructor;
    
interface MeshCollider extends Collider {
    sharedMesh: Mesh;
    convex: boolean;
    cookingOptions: MeshColliderCookingOptions;
    smoothSphereCollisions: boolean;
    skinWidth: number;
    inflateMesh: boolean;



}
    
interface MeshColliderConstructor {

    new(): MeshCollider;


}
declare const MeshCollider: MeshColliderConstructor;
    
interface WheelCollider extends Collider {
    center: Vector3;
    radius: number;
    suspensionDistance: number;
    suspensionSpring: JointSpring;
    suspensionExpansionLimited: boolean;
    forceAppPointDistance: number;
    mass: number;
    wheelDampingRate: number;
    forwardFriction: WheelFrictionCurve;
    sidewaysFriction: WheelFrictionCurve;
    motorTorque: number;
    brakeTorque: number;
    steerAngle: number;
    isGrounded: boolean;
    rpm: number;
    sprungMass: number;
    rotationSpeed: number;


    /** Configure vehicle sub-stepping parameters. */
    ConfigureVehicleSubsteps(speedThreshold: number, stepsBelowThreshold: number, stepsAboveThreshold: number): void;
    /** Gets ground collision data for the wheel. */
    GetGroundHit(hit: unknown): boolean;
    /** Gets the world space pose of the wheel accounting for ground contact, suspension limits, steer angle, and rotation angle (angles in degrees). */
    GetWorldPose(pos: unknown, quat: unknown): void;
    /** Reset the sprung masses of the vehicle. */
    ResetSprungMasses(): void;

}
    
interface JointSpring {
    spring: number;
    damper: number;
    targetPosition: number;



}
    
interface WheelFrictionCurve {
    extremumSlip: number;
    extremumValue: number;
    asymptoteSlip: number;
    asymptoteValue: number;
    stiffness: number;



}
    
interface WheelColliderConstructor {

    new(): WheelCollider;


}
declare const WheelCollider: WheelColliderConstructor;
    
interface TerrainCollider extends Collider {
    terrainData: TerrainData;



}
    
interface TerrainData extends Object {
    heightmapWidth: number;
    heightmapHeight: number;
    heightmapTexture: RenderTexture;
    heightmapResolution: number;
    heightmapScale: Vector3;
    holesTexture: Texture;
    enableHolesTextureCompression: boolean;
    holesResolution: number;
    size: Vector3;
    bounds: Bounds;
    thickness: number;
    wavingGrassStrength: number;
    wavingGrassAmount: number;
    wavingGrassSpeed: number;
    wavingGrassTint: Color;
    detailWidth: number;
    detailHeight: number;
    maxDetailScatterPerRes: number;
    detailPatchCount: number;
    detailResolution: number;
    detailResolutionPerPatch: number;
    detailScatterMode: DetailScatterMode;
    detailPrototypes: CSArray<DetailPrototype>;
    treeInstances: CSArray<TreeInstance>;
    treeInstanceCount: number;
    treePrototypes: CSArray<TreePrototype>;
    alphamapLayers: number;
    alphamapResolution: number;
    alphamapWidth: number;
    alphamapHeight: number;
    baseMapResolution: number;
    alphamapTextureCount: number;
    alphamapTextures: CSArray<Texture2D>;
    splatPrototypes: CSArray<SplatPrototype>;
    terrainLayers: CSArray<TerrainLayer>;


    /** This function computes and returns the coverage (how many instances fit in a square unit) of a detail prototype, given its index. */
    ComputeDetailCoverage(detailPrototypeIndex: number): number;
    /** This function computes and returns an array of detail object transforms for the specified patch and the specified prototype. You can use this function to retrieve the exact same transform data the Unity engine uses for detail rendering. */
    ComputeDetailInstanceTransforms(patchX: number, patchY: number, layer: number, density: number, bounds: unknown): CSArray<DetailInstanceTransform>;
    /** Copies the specified part of the active RenderTexture to the Terrain heightmap texture. */
    CopyActiveRenderTextureToHeightmap(sourceRect: RectInt, dest: Vector2Int, syncControl: TerrainHeightmapSyncControl): void;
    /** Copies the specified part of the active RenderTexture to the Terrain texture. */
    CopyActiveRenderTextureToTexture(textureName: string, textureIndex: number, sourceRect: RectInt, dest: Vector2Int, allowDelayedCPUSync: boolean): void;
    /** Marks the specified part of the heightmap as dirty. */
    DirtyHeightmapRegion(region: RectInt, syncControl: TerrainHeightmapSyncControl): void;
    /** Marks the specified part of the Terrain texture as dirty. */
    DirtyTextureRegion(textureName: string, region: RectInt, allowDelayedCPUSync: boolean): void;
    /** Returns the alpha map at a position x, y given a width and height. */
    GetAlphamaps(x: number, y: number, width: number, height: number): unknown;
    /** Returns the alphamap texture at the specified index. */
    GetAlphamapTexture(index: number): Texture2D;
    /** Returns an array of detail patches, which are each identified by X-Z coordinates. Detail objects in the patches are clamped to the maximum count. */
    GetClampedDetailPatches(density: number): CSArray<Vector2Int>;
    /** Returns a 2D array of the detail object density (i.e. the number of detail objects for this layer) in the specific location. */
    GetDetailLayer(xBase: number, yBase: number, width: number, height: number, layer: number): unknown;
    GetDetailLayer(positionBase: Vector2Int, size: Vector2Int, layer: number): unknown;
    /** Gets the world space height of the Terrain at a certain point x,y without adding the Terrain&#x27;s world position y. */
    GetHeight(x: number, y: number): number;
    /** Gets an array of heightmap samples. */
    GetHeights(xBase: number, yBase: number, width: number, height: number): unknown;
    /** Gets an array of Terrain holes samples. */
    GetHoles(xBase: number, yBase: number, width: number, height: number): unknown;
    /** Gets an interpolated height at a point x,y. The x and y coordinates are clamped to [0, 1]. */
    GetInterpolatedHeight(x: number, y: number): number;
    /** Gets an array of terrain height values using the normalized x,y coordinates. */
    GetInterpolatedHeights(xBase: number, yBase: number, xCount: number, yCount: number, xInterval: number, yInterval: number): unknown;
    /** Fills the array with Terrain height values using normalized x,y coordinates. */
    GetInterpolatedHeights(results: unknown, resultXOffset: number, resultYOffset: number, xBase: number, yBase: number, xCount: number, yCount: number, xInterval: number, yInterval: number): void;
    /** Get an interpolated normal at a given location. */
    GetInterpolatedNormal(x: number, y: number): Vector3;
    /** Returns an array of tesselation maximum height error values per renderable terrain patch.  The returned array can be modified and passed to OverrideMaximumHeightError. */
    GetMaximumHeightError(): CSArray<number>;
    /** Returns an array of min max height values for all the renderable patches in a terrain.  The returned array can be modified and then passed to OverrideMinMaxPatchHeights. */
    GetPatchMinMaxHeights(): CSArray<PatchExtents>;
    /** Gets the gradient of the terrain at point (x,y). */
    GetSteepness(x: number, y: number): number;
    /** Returns an array of all supported detail layer indices in the area. */
    GetSupportedLayers(xBase: number, yBase: number, totalWidth: number, totalHeight: number): CSArray<number>;
    GetSupportedLayers(positionBase: Vector2Int, size: Vector2Int): CSArray<number>;
    /** Gets the tree instance at the specified index. It is used as a faster version of treeInstances[index] as this function doesn&#x27;t create the entire tree instances array. */
    GetTreeInstance(index: number): TreeInstance;
    /** Gets whether a certain point at x,y is a hole. */
    IsHole(x: number, y: number): boolean;
    /** Override the maximum tessellation height error with user provided values.  Note that the overriden values get reset when the terrain resolution is changed and stays unchanged when the terrain heightmap is painted or changed via script. */
    OverrideMaximumHeightError(maxError: CSArray<number>): void;
    /** Override the minimum and maximum patch heights for every renderable terrain patch.  Note that the overriden values get reset when the terrain resolution is changed and stays unchanged when the terrain heightmap is painted or changed via script. */
    OverrideMinMaxPatchHeights(minMaxHeights: CSArray<PatchExtents>): void;
    /** Reloads all the values of the available prototypes (ie, detail mesh assets) in the TerrainData Object. */
    RefreshPrototypes(): void;
    /** Removes the detail prototype at the specified index. */
    RemoveDetailPrototype(index: number): void;
    /** Assign all splat values in the given map area. */
    SetAlphamaps(x: number, y: number, map: unknown): void;
    /** Marks the terrain data as dirty to trigger an update of the terrain basemap texture. */
    SetBaseMapDirty(): void;
    /** Sets the detail layer density map. */
    SetDetailLayer(xBase: number, yBase: number, layer: number, details: unknown): void;
    SetDetailLayer(basePosition: Vector2Int, layer: number, details: unknown): void;
    /** Sets the resolution of the detail map. */
    SetDetailResolution(detailResolution: number, resolutionPerPatch: number): void;
    /** Sets the DetailScatterMode. */
    SetDetailScatterMode(scatterMode: DetailScatterMode): void;
    /** Sets an array of heightmap samples. */
    SetHeights(xBase: number, yBase: number, heights: unknown): void;
    /** Sets an array of heightmap samples. */
    SetHeightsDelayLOD(xBase: number, yBase: number, heights: unknown): void;
    /** Sets an array of Terrain holes samples. */
    SetHoles(xBase: number, yBase: number, holes: unknown): void;
    /** Sets an array of Terrain holes samples. */
    SetHolesDelayLOD(xBase: number, yBase: number, holes: unknown): void;
    /** This function sets the terrainLayers property, and in addition, registers the action to the Editor&#x27;s undo stack. */
    SetTerrainLayersRegisterUndo(terrainLayers: CSArray<TerrainLayer>, undoName: string): void;
    /** Sets the tree instance with new parameters at the specified index. However, you cannot change TreeInstance.prototypeIndex and TreeInstance.position. If you change them, the method throws an ArgumentException. */
    SetTreeInstance(index: number, instance: TreeInstance): void;
    /** Sets the Tree Instance array, and optionally snaps Trees onto the surface of the Terrain heightmap. */
    SetTreeInstances(instances: CSArray<TreeInstance>, snapToHeightmap: boolean): void;
    /** Performs synchronization queued by previous calls to CopyActiveRenderTextureToHeightmap and DirtyHeightmapRegion, which makes the height data and LOD data used for tessellation up to date. */
    SyncHeightmap(): void;
    /** Performs synchronization queued by previous calls to CopyActiveRenderTextureToTexture and DirtyTextureRegion, which makes CPU data of the Terrain textures up to date. */
    SyncTexture(textureName: string): void;
    /** Triggers an update to integrate modifications done to the heightmap outside of unity. */
    UpdateDirtyRegion(x: number, y: number, width: number, height: number, syncHeightmapTextureImmediately: boolean): void;

}
    
interface DetailPrototype {
    prototype: GameObject;
    prototypeTexture: Texture2D;
    minWidth: number;
    maxWidth: number;
    minHeight: number;
    maxHeight: number;
    noiseSeed: number;
    noiseSpread: number;
    density: number;
    bendFactor: number;
    holeEdgePadding: number;
    healthyColor: Color;
    dryColor: Color;
    renderMode: DetailRenderMode;
    usePrototypeMesh: boolean;
    useInstancing: boolean;
    targetCoverage: number;
    useDensityScaling: boolean;
    alignToGround: number;
    positionJitter: number;


    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    /** Returns true if the detail prototype is valid and the Terrain can accept it. */
    Validate(): boolean;
    /** Returns true if the detail prototype is valid and the Terrain can accept it. */
    Validate(errorMessage: CSArray<string>): boolean;

}
    
interface DetailPrototypeConstructor {

    new(): DetailPrototype;
    new(other: DetailPrototype): DetailPrototype;


}
declare const DetailPrototype: DetailPrototypeConstructor;
    
interface TreeInstance {
    position: Vector3;
    widthScale: number;
    heightScale: number;
    rotation: number;
    color: Color32;
    lightmapColor: Color32;
    prototypeIndex: number;



}
    
interface TreePrototype {
    prefab: GameObject;
    bendFactor: number;
    navMeshLod: number;


    Equals(obj: unknown): boolean;
    GetHashCode(): number;

}
    
interface TreePrototypeConstructor {

    new(): TreePrototype;
    new(other: TreePrototype): TreePrototype;


}
declare const TreePrototype: TreePrototypeConstructor;
    
interface SplatPrototype {
    texture: Texture2D;
    normalMap: Texture2D;
    tileSize: Vector2;
    tileOffset: Vector2;
    specular: Color;
    metallic: number;
    smoothness: number;



}
    
interface SplatPrototypeConstructor {

    new(): SplatPrototype;


}
declare const SplatPrototype: SplatPrototypeConstructor;
    
interface TerrainLayer extends Object {
    diffuseTexture: Texture2D;
    normalMapTexture: Texture2D;
    maskMapTexture: Texture2D;
    tileSize: Vector2;
    tileOffset: Vector2;
    specular: Color;
    metallic: number;
    smoothness: number;
    normalScale: number;
    diffuseRemapMin: Vector4;
    diffuseRemapMax: Vector4;
    maskMapRemapMin: Vector4;
    maskMapRemapMax: Vector4;
    smoothnessSource: TerrainLayerSmoothnessSource;



}
    
interface TerrainLayerConstructor {

    new(): TerrainLayer;


}
declare const TerrainLayer: TerrainLayerConstructor;
    
interface DetailInstanceTransform {
    posX: number;
    posY: number;
    posZ: number;
    scaleXZ: number;
    scaleY: number;
    rotationY: number;



}
    
interface PatchExtents {
    min: number;
    max: number;



}
    
interface TerrainDataConstructor {
    AlphamapTextureName: string;
    HolesTextureName: string;

    new(): TerrainData;


}
declare const TerrainData: TerrainDataConstructor;
    
interface TerrainColliderConstructor {

    new(): TerrainCollider;


}
declare const TerrainCollider: TerrainColliderConstructor;
    
interface NavMeshHit {
    position: Vector3;
    normal: Vector3;
    distance: number;
    mask: number;
    hit: boolean;



}
    
interface Graphics {



}
    
interface LightProbeProxyVolume extends Behaviour {
    boundsGlobal: Bounds;
    sizeCustom: Vector3;
    originCustom: Vector3;
    probeDensity: number;
    gridResolutionX: number;
    gridResolutionY: number;
    gridResolutionZ: number;
    boundingBoxMode: BoundingBoxMode;
    resolutionMode: ResolutionMode;
    probePositionMode: ProbePositionMode;
    refreshMode: RefreshMode;
    qualityMode: QualityMode;
    dataFormat: DataFormat;


    /** Triggers an update of the Light Probe Proxy Volume. */
    Update(): void;

}
    
interface LightProbeProxyVolumeConstructor {
    isFeatureSupported: boolean;

    new(): LightProbeProxyVolume;


}
declare const LightProbeProxyVolume: LightProbeProxyVolumeConstructor;
    
interface RenderParams {
    layer: number;
    renderingLayerMask: number;
    rendererPriority: number;
    instanceID: number;
    worldBounds: Bounds;
    camera: Camera;
    motionVectorMode: MotionVectorGenerationMode;
    reflectionProbeUsage: ReflectionProbeUsage;
    material: Material;
    matProps: MaterialPropertyBlock;
    shadowCastingMode: ShadowCastingMode;
    receiveShadows: boolean;
    lightProbeUsage: LightProbeUsage;
    lightProbeProxyVolume: LightProbeProxyVolume;
    overrideSceneCullingMask: boolean;
    sceneCullingMask: number;



}
    
interface RenderParamsConstructor {

    new(mat: Material): RenderParams;


}
declare const RenderParams: RenderParamsConstructor;
    
interface RenderTargetSetup {
    color: CSArray<RenderBuffer>;
    depth: RenderBuffer;
    mipLevel: number;
    cubemapFace: CubemapFace;
    depthSlice: number;
    colorLoad: CSArray<number>;
    colorStore: CSArray<number>;
    depthLoad: RenderBufferLoadAction;
    depthStore: RenderBufferStoreAction;



}
    
interface RenderTargetSetupConstructor {

    new(color: CSArray<RenderBuffer>, depth: RenderBuffer, mip: number, face: CubemapFace, colorLoad: CSArray<number>, colorStore: CSArray<number>, depthLoad: RenderBufferLoadAction, depthStore: RenderBufferStoreAction): RenderTargetSetup;
    new(color: RenderBuffer, depth: RenderBuffer): RenderTargetSetup;
    new(color: RenderBuffer, depth: RenderBuffer, mipLevel: number): RenderTargetSetup;
    new(color: RenderBuffer, depth: RenderBuffer, mipLevel: number, face: CubemapFace): RenderTargetSetup;
    new(color: RenderBuffer, depth: RenderBuffer, mipLevel: number, face: CubemapFace, depthSlice: number): RenderTargetSetup;
    new(color: CSArray<RenderBuffer>, depth: RenderBuffer): RenderTargetSetup;
    new(color: CSArray<RenderBuffer>, depth: RenderBuffer, mipLevel: number): RenderTargetSetup;
    new(color: CSArray<RenderBuffer>, depth: RenderBuffer, mip: number, face: CubemapFace): RenderTargetSetup;


}
declare const RenderTargetSetup: RenderTargetSetupConstructor;
    
interface GraphicsConstructor {
    activeColorGamut: ColorGamut;
    activeTier: GraphicsTier;
    preserveFramebufferAlpha: boolean;
    minOpenGLESVersion: OpenGLESVersion;
    activeColorBuffer: RenderBuffer;
    activeDepthBuffer: RenderBuffer;
    deviceName: string;
    deviceVendor: string;
    deviceVersion: string;

    new(): Graphics;


    Blit(source: Texture, dest: RenderTexture): void;
    Blit(source: Texture, dest: RenderTexture, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: RenderTexture, scale: Vector2, offset: Vector2): void;
    Blit(source: Texture, dest: RenderTexture, scale: Vector2, offset: Vector2, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: RenderTexture, mat: Material, pass: number): void;
    Blit(source: Texture, dest: RenderTexture, mat: Material, pass: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: RenderTexture, mat: Material): void;
    Blit(source: Texture, mat: Material, pass: number): void;
    Blit(source: Texture, mat: Material, pass: number, destDepthSlice: number): void;
    Blit(source: Texture, mat: Material): void;
    Blit(source: Texture, dest: GraphicsTexture): void;
    Blit(source: Texture, dest: GraphicsTexture, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: GraphicsTexture, scale: Vector2, offset: Vector2): void;
    Blit(source: Texture, dest: GraphicsTexture, scale: Vector2, offset: Vector2, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: GraphicsTexture, mat: Material, pass: number): void;
    Blit(source: Texture, dest: GraphicsTexture, mat: Material, pass: number, destDepthSlice: number): void;
    Blit(source: Texture, dest: GraphicsTexture, mat: Material): void;
    BlitMultiTap(source: Texture, dest: RenderTexture, mat: Material, offsets: CSArray<Vector2>): void;
    BlitMultiTap(source: Texture, dest: RenderTexture, mat: Material, destDepthSlice: number, offsets: CSArray<Vector2>): void;
    BlitMultiTap(source: Texture, dest: GraphicsTexture, mat: Material, offsets: CSArray<Vector2>): void;
    BlitMultiTap(source: Texture, dest: GraphicsTexture, mat: Material, destDepthSlice: number, offsets: CSArray<Vector2>): void;
    ClearRandomWriteTargets(): void;
    ConvertTexture(src: Texture, dst: Texture): boolean;
    ConvertTexture(src: Texture, srcElement: number, dst: Texture, dstElement: number): boolean;
    CopyBuffer(source: GraphicsBuffer, dest: GraphicsBuffer): void;
    CopyTexture(src: Texture, dst: Texture): void;
    CopyTexture(src: Texture, srcElement: number, dst: Texture, dstElement: number): void;
    CopyTexture(src: Texture, srcElement: number, srcMip: number, dst: Texture, dstElement: number, dstMip: number): void;
    CopyTexture(src: Texture, srcElement: number, srcMip: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number, dst: Texture, dstElement: number, dstMip: number, dstX: number, dstY: number): void;
    CreateAsyncGraphicsFence(stage: SynchronisationStage): GraphicsFence;
    CreateAsyncGraphicsFence(): GraphicsFence;
    CreateGPUFence(stage: SynchronisationStage): GPUFence;
    CreateGPUFence(): GPUFence;
    CreateGraphicsFence(fenceType: GraphicsFenceType, stage: SynchronisationStageFlags): GraphicsFence;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean, receiveShadows: boolean, useLightProbes: boolean): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform, useLightProbes: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean, receiveShadows: boolean, useLightProbes: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, materialIndex: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, materialIndex: number): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean, receiveShadows: boolean): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean): void;
    DrawMesh(mesh: Mesh, position: Vector3, rotation: Quaternion, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: boolean, receiveShadows: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform, useLightProbes: boolean): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, layer: number, camera: Camera, submeshIndex: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, probeAnchor: Transform, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, matrices: CSArray<Matrix4x4>, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage): void;
    DrawMeshInstancedProcedural(mesh: Mesh, submeshIndex: number, material: Material, bounds: Bounds, count: number, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number, camera: Camera, lightProbeUsage: LightProbeUsage, lightProbeProxyVolume: LightProbeProxyVolume): void;
    DrawMeshNow(mesh: Mesh, position: Vector3, rotation: Quaternion, materialIndex: number): void;
    DrawMeshNow(mesh: Mesh, matrix: Matrix4x4, materialIndex: number): void;
    DrawMeshNow(mesh: Mesh, position: Vector3, rotation: Quaternion): void;
    DrawMeshNow(mesh: Mesh, matrix: Matrix4x4): void;
    DrawProcedural(material: Material, bounds: Bounds, topology: MeshTopology, vertexCount: number, instanceCount: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProcedural(material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: number, instanceCount: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProcedural(topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    DrawProceduralIndirect(material: Material, bounds: Bounds, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirect(material: Material, bounds: Bounds, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirect(material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: ComputeBuffer, argsOffset: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirect(material: Material, bounds: Bounds, topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: GraphicsBuffer, argsOffset: number, camera: Camera, properties: MaterialPropertyBlock, castShadows: ShadowCastingMode, receiveShadows: boolean, layer: number): void;
    DrawProceduralIndirect(topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirectNow(topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirectNow(topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirectNow(topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralIndirectNow(topology: MeshTopology, indexBuffer: GraphicsBuffer, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralNow(topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    DrawProceduralNow(topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: number, instanceCount: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, color: Color, mat: Material, pass: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material, pass: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material, pass: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, mat: Material, pass: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, color: Color, mat: Material): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, color: Color): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material): void;
    DrawTexture(screenRect: Rect, texture: Texture, sourceRect: Rect, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number, mat: Material): void;
    DrawTexture(screenRect: Rect, texture: Texture, leftBorder: number, rightBorder: number, topBorder: number, bottomBorder: number): void;
    DrawTexture(screenRect: Rect, texture: Texture, mat: Material): void;
    DrawTexture(screenRect: Rect, texture: Texture): void;
    ExecuteCommandBuffer(buffer: CommandBuffer): void;
    ExecuteCommandBufferAsync(buffer: CommandBuffer, queueType: ComputeQueueType): void;
    RenderMesh(rparams: unknown, mesh: Mesh, submeshIndex: number, objectToWorld: Matrix4x4, prevObjectToWorld: unknown): void;
    RenderMeshIndirect(rparams: unknown, mesh: Mesh, commandBuffer: GraphicsBuffer, commandCount: number, startCommand: number): void;
    RenderMeshInstanced<T>(rparams: unknown, mesh: Mesh, submeshIndex: number, instanceData: CSArray<T>, instanceCount: number, startInstance: number): void;
    RenderMeshInstanced<T>(rparams: unknown, mesh: Mesh, submeshIndex: number, instanceData: CSArray<T>, instanceCount: number, startInstance: number): void;
    RenderMeshInstanced<T>(rparams: RenderParams, mesh: Mesh, submeshIndex: number, instanceData: CSArray<T>, instanceCount: number, startInstance: number): void;
    RenderMeshPrimitives(rparams: unknown, mesh: Mesh, submeshIndex: number, instanceCount: number): void;
    RenderPrimitives(rparams: unknown, topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    RenderPrimitivesIndexed(rparams: unknown, topology: MeshTopology, indexBuffer: GraphicsBuffer, indexCount: number, startIndex: number, instanceCount: number): void;
    RenderPrimitivesIndexedIndirect(rparams: unknown, topology: MeshTopology, indexBuffer: GraphicsBuffer, commandBuffer: GraphicsBuffer, commandCount: number, startCommand: number): void;
    RenderPrimitivesIndirect(rparams: unknown, topology: MeshTopology, commandBuffer: GraphicsBuffer, commandCount: number, startCommand: number): void;
    SetRandomWriteTarget(index: number, uav: RenderTexture): void;
    SetRandomWriteTarget(index: number, uav: ComputeBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, uav: GraphicsBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, uav: ComputeBuffer): void;
    SetRandomWriteTarget(index: number, uav: GraphicsBuffer): void;
    SetRenderTarget(rt: RenderTexture, mipLevel: number, face: CubemapFace, depthSlice: number): void;
    SetRenderTarget(rt: GraphicsTexture, mipLevel: number, face: CubemapFace, depthSlice: number): void;
    SetRenderTarget(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: number, face: CubemapFace, depthSlice: number): void;
    SetRenderTarget(colorBuffers: CSArray<RenderBuffer>, depthBuffer: RenderBuffer): void;
    SetRenderTarget(setup: RenderTargetSetup): void;
    SetRenderTarget(rt: RenderTexture): void;
    SetRenderTarget(rt: RenderTexture, mipLevel: number): void;
    SetRenderTarget(rt: RenderTexture, mipLevel: number, face: CubemapFace): void;
    SetRenderTarget(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer): void;
    SetRenderTarget(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: number): void;
    SetRenderTarget(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer, mipLevel: number, face: CubemapFace): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStage): void;
    WaitOnGPUFence(fence: GPUFence, stage: SynchronisationStage): void;
    WaitOnGPUFence(fence: GPUFence): void;
}
declare const Graphics: GraphicsConstructor;
    
interface StandaloneFileBrowser {



}
    
interface ExtensionFilter {
    Name: string;
    Extensions: CSArray<string>;



}
    
interface ExtensionFilterConstructor {

    new(filterName: string, filterExtensions: CSArray<string>): ExtensionFilter;


}
declare const ExtensionFilter: ExtensionFilterConstructor;
    
interface StandaloneFileBrowserConstructor {

    new(): StandaloneFileBrowser;


    OpenFilePanel(title: string, directory: string, extension: string, multiselect: boolean): CSArray<string>;
    OpenFilePanel(title: string, directory: string, extensions: CSArray<ExtensionFilter>, multiselect: boolean): CSArray<string>;
    OpenFilePanelAsync(title: string, directory: string, extension: string, multiselect: boolean, cb: unknown): void;
    OpenFilePanelAsync(title: string, directory: string, extensions: CSArray<ExtensionFilter>, multiselect: boolean, cb: unknown): void;
    OpenFolderPanel(title: string, directory: string, multiselect: boolean): CSArray<string>;
    OpenFolderPanelAsync(title: string, directory: string, multiselect: boolean, cb: unknown): void;
    SaveFilePanel(title: string, directory: string, defaultName: string, extension: string): string;
    SaveFilePanel(title: string, directory: string, defaultName: string, extensions: CSArray<ExtensionFilter>): string;
    SaveFilePanelAsync(title: string, directory: string, defaultName: string, extension: string, cb: unknown): void;
    SaveFilePanelAsync(title: string, directory: string, defaultName: string, extensions: CSArray<ExtensionFilter>, cb: unknown): void;
}
declare const StandaloneFileBrowser: StandaloneFileBrowserConstructor;
    
interface MaterialColorURP extends MonoBehaviour {
    colorSettings: CSArray<ColorSetting>;
    addedByEditorScript: boolean;


    DoUpdate(): void;
    EditorFirstTimeSetup(): void;

}
    
interface ColorSetting {
    baseColor: Color;
    reference: string;


    CopyFrom(otherSettings: ColorSetting): void;

}
    
interface ColorSettingConstructor {

    new(baseColor: Color): ColorSetting;


}
declare const ColorSetting: ColorSettingConstructor;
    
interface MaterialColorURPConstructor {

    new(): MaterialColorURP;


}
declare const MaterialColorURP: MaterialColorURPConstructor;
    
interface Mathf {



}
    
interface MathfConstructor {
    PI: number;
    Infinity: number;
    NegativeInfinity: number;
    Deg2Rad: number;
    Rad2Deg: number;
    Epsilon: number;



    Abs(f: number): number;
    Abs(value: number): number;
    Acos(f: number): number;
    Approximately(a: number, b: number): boolean;
    Asin(f: number): number;
    Atan(f: number): number;
    Atan2(y: number, x: number): number;
    Ceil(f: number): number;
    CeilToInt(f: number): number;
    Clamp(value: number, min: number, max: number): number;
    Clamp(value: number, min: number, max: number): number;
    Clamp01(value: number): number;
    ClosestPowerOfTwo(value: number): number;
    CorrelatedColorTemperatureToRGB(kelvin: number): Color;
    Cos(f: number): number;
    DeltaAngle(current: number, target: number): number;
    Exp(power: number): number;
    FloatToHalf(val: number): number;
    Floor(f: number): number;
    FloorToInt(f: number): number;
    Gamma(value: number, absmax: number, gamma: number): number;
    GammaToLinearSpace(value: number): number;
    HalfToFloat(val: number): number;
    InverseLerp(a: number, b: number, value: number): number;
    IsPowerOfTwo(value: number): boolean;
    Lerp(a: number, b: number, t: number): number;
    LerpAngle(a: number, b: number, t: number): number;
    LerpUnclamped(a: number, b: number, t: number): number;
    LinearToGammaSpace(value: number): number;
    Log(f: number, p: number): number;
    Log(f: number): number;
    Log10(f: number): number;
    Max(a: number, b: number): number;
    Max(values: CSArray<number>): number;
    Max(a: number, b: number): number;
    Max(values: CSArray<number>): number;
    Min(a: number, b: number): number;
    Min(values: CSArray<number>): number;
    Min(a: number, b: number): number;
    Min(values: CSArray<number>): number;
    MoveTowards(current: number, target: number, maxDelta: number): number;
    MoveTowardsAngle(current: number, target: number, maxDelta: number): number;
    NextPowerOfTwo(value: number): number;
    PerlinNoise(x: number, y: number): number;
    PerlinNoise1D(x: number): number;
    PingPong(t: number, length: number): number;
    Pow(f: number, p: number): number;
    Repeat(t: number, length: number): number;
    Round(f: number): number;
    RoundToInt(f: number): number;
    Sign(f: number): number;
    Sin(f: number): number;
    SmoothDamp(current: number, target: number, currentVelocity: unknown, smoothTime: number, maxSpeed: number): number;
    SmoothDamp(current: number, target: number, currentVelocity: unknown, smoothTime: number): number;
    SmoothDamp(current: number, target: number, currentVelocity: unknown, smoothTime: number, maxSpeed: number, deltaTime: number): number;
    SmoothDampAngle(current: number, target: number, currentVelocity: unknown, smoothTime: number, maxSpeed: number): number;
    SmoothDampAngle(current: number, target: number, currentVelocity: unknown, smoothTime: number): number;
    SmoothDampAngle(current: number, target: number, currentVelocity: unknown, smoothTime: number, maxSpeed: number, deltaTime: number): number;
    SmoothStep(from: number, to: number, t: number): number;
    Sqrt(f: number): number;
    Tan(f: number): number;
}
declare const Mathf: MathfConstructor;
    
interface UnityWebRequestTexture {



}
    
interface UnityWebRequestTextureConstructor {



    GetTexture(uri: string): UnityWebRequest;
    GetTexture(uri: unknown): UnityWebRequest;
    GetTexture(uri: string, nonReadable: boolean): UnityWebRequest;
    GetTexture(uri: unknown, nonReadable: boolean): UnityWebRequest;
}
declare const UnityWebRequestTexture: UnityWebRequestTextureConstructor;
    
interface DownloadHandlerTexture extends DownloadHandler {
    texture: Texture2D;


    Dispose(): void;

}
    
interface DownloadHandlerTextureConstructor {

    new(): DownloadHandlerTexture;
    new(readable: boolean): DownloadHandlerTexture;


    GetContent(www: UnityWebRequest): Texture2D;
}
declare const DownloadHandlerTexture: DownloadHandlerTextureConstructor;
    
interface UIOutline extends Graphic {
    mainTexture: Texture;



}
    
interface UIOutlineConstructor {

    new(): UIOutline;


}
declare const UIOutline: UIOutlineConstructor;
    
interface IDropHandler extends IEventSystemHandler {


    OnDrop(eventData: PointerEventData): void;

}
    
interface EventTrigger extends MonoBehaviour, ISubmitHandler, IPointerClickHandler, ICancelHandler, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IUpdateSelectedHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IMoveHandler, IPointerUpHandler {
    delegates: CSArray<Entry>;
    triggers: CSArray<Entry>;


    OnBeginDrag(eventData: PointerEventData): void;
    OnCancel(eventData: BaseEventData): void;
    OnDeselect(eventData: BaseEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnDrop(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    OnScroll(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    OnUpdateSelected(eventData: BaseEventData): void;

}
    
interface Entry {
    eventID: EventTriggerType;
    callback: TriggerEvent;



}
    
interface TriggerEvent {



}
    
interface TriggerEventConstructor {

    new(): TriggerEvent;


}
declare const TriggerEvent: TriggerEventConstructor;
    
interface EntryConstructor {

    new(): Entry;


}
declare const Entry: EntryConstructor;
    
interface CharacterMovementData extends MonoBehaviour {
    characterHeight: number;
    characterRadius: number;
    speed: number;
    sprintSpeed: number;
    airSpeedMultiplier: number;
    onlySprintForward: boolean;
    autoCrouch: boolean;
    crouchSpeedMultiplier: number;
    crouchHeightMultiplier: number;
    slideSpeedMultiplier: number;
    slideHeightMultiplier: number;
    slideCooldown: number;
    numberOfJumps: number;
    jumpSpeed: number;
    jumpCoyoteTime: number;
    jumpUpBlockCooldown: number;
    useGravity: boolean;
    useGravityWhileGrounded: boolean;
    gravityMultiplier: number;
    upwardsGravityMultiplier: number;
    groundCollisionLayerMask: LayerMask;
    terminalVelocity: number;
    slopeForce: number;
    minSlopeDelta: number;
    maxSlopeDelta: number;
    maxStepUpHeight: number;
    drag: number;
    detectSlopes: boolean;
    detectStepUps: boolean;
    alwaysStepUp: boolean;
    assistedLedgeJump: boolean;
    preventWallClipping: boolean;
    preventFallingWhileCrouching: boolean;



}
    
interface CharacterMovementDataConstructor {

    new(): CharacterMovementData;


}
declare const CharacterMovementData: CharacterMovementDataConstructor;

