-- Compiled with unity-ts v3.0.0-113
-- import Signal from "@rbxts/signal";
local Reflect = require("@Easy/Core/Shared/Resources/TSExtra/node_modules/@easy-games/flamework-core/out/reflect").Reflect
local getDeferredConstructor, isConstructor
local Modding = {}
do
	local _container = Modding
	local listeners = {}
	local lifecycleListeners = {}
	local decoratorListeners = {}
	-- const listenerAdded = new Signal<ListenerAddedEvent>();
	-- const listenerRemoved = new Signal<ListenerRemovedEvent>();
	-- const listenerAddedEvents = new Map<string, Signal<ListenerAddedEvent>>();
	-- const listenerRemovedEvents = new Map<string, Signal<ListenerRemovedEvent>>();
	local dependencyResolution = {}
	local resolvedSingletons = {}
	local loadingList = {}
	--[[
		*
		* Registers a listener for lifecycle events.
	]]
	local function addListener(object)
		local listener = {
			eventIds = {},
			involvement = {},
		}
		for _, lifecycleEvents in Reflect.getMetadatas(object, "flamework:implements") do
			for _1, lifecycleEvent in lifecycleEvents do
				if listener.eventIds[lifecycleEvent] ~= nil then
					continue
				end
				local lifecycleListener = lifecycleListeners[lifecycleEvent]
				if not lifecycleListener then
					lifecycleListener = {}
					local _lifecycleListener = lifecycleListener
					lifecycleListeners[lifecycleEvent] = _lifecycleListener
				end
				local _lifecycleListener = lifecycleListener
				local _object = object
				_lifecycleListener[_object] = true
				listener.eventIds[lifecycleEvent] = true
				local _involvement = listener.involvement
				local _lifecycleListener_1 = lifecycleListener
				table.insert(_involvement, _lifecycleListener_1)
				-- listenerAddedEvents.get(lifecycleEvent)?.Fire(object);
			end
		end
		local decorators = Reflect.getMetadata(object, "flamework:decorators")
		if decorators then
			for _, decorator in decorators do
				if listener.eventIds[decorator] ~= nil then
					continue
				end
				local decoratorListener = decoratorListeners[decorator]
				if not decoratorListener then
					decoratorListener = {}
					local _decoratorListener = decoratorListener
					decoratorListeners[decorator] = _decoratorListener
				end
				local _decoratorListener = decoratorListener
				local _object = object
				_decoratorListener[_object] = true
				listener.eventIds[decorator] = true
				local _involvement = listener.involvement
				local _decoratorListener_1 = decoratorListener
				table.insert(_involvement, _decoratorListener_1)
				-- listenerAddedEvents.get(decorator)?.Fire(object);
			end
		end
		local _object = object
		listeners[_object] = listener
		-- listenerAdded.Fire(object);
	end
	_container.addListener = addListener
	--[[
		*
		* Removes a listener for lifecycle events and decorators.
	]]
	local function removeListener(object)
		local _object = object
		local listener = listeners[_object]
		if not listener then
			return nil
		end
		for _, set in listener.involvement do
			local _object_1 = object
			set[_object_1] = nil
		end
		for id in listener.eventIds do
		end
		local _object_1 = object
		listeners[_object_1] = nil
		-- listenerRemoved.Fire(object);
	end
	_container.removeListener = removeListener
	--[[
		*
		* Registers a listener added event.
		* Fires whenever any listener is added.
		*
		* Fires for all existing listeners.
	]]
	-- export function onListenerAdded(func: ListenerAddedEvent): RBXScriptConnection;
	--[[
		*
		* Registers a listener added event.
		* Fires whenever a listener has a decorator with the specified ID.
		*
		* Fires for all existing listeners.
	]]
	-- export function onListenerAdded<T extends AnyDecorator>(func: ListenerAddedEvent, id?: string): RBXScriptConnection;
	--[[
		*
		* Registers a listener added event.
		* Fires whenever a listener has a lifecycle event with the specified ID.
		*
		* Fires for all existing listeners.
	]]
	-- export function onListenerAdded<T>(func: (value: T) => void, id?: string): RBXScriptConnection;
	--[[
		*
		* Registers a listener added event.
	]]
	local function onListenerAdded(func, id)
	end
	_container.onListenerAdded = onListenerAdded
	--[[
		*
		* Registers a listener removed event.
		*
		* Fires whenever any listener is removed.
	]]
	-- export function onListenerRemoved(func: ListenerRemovedEvent): RBXScriptConnection;
	--[[
		*
		* Registers a listener removed event.
		*
		* Fires whenever a listener has a decorator with the specified ID.
	]]
	-- export function onListenerRemoved<T extends AnyDecorator>(func: ListenerRemovedEvent): RBXScriptConnection;
	--[[
		*
		* Registers a listener removed event.
		*
		* Fires whenever a listener has a lifecycle event with the specified ID.
	]]
	-- export function onListenerRemoved<T>(func: (object: T) => void, id?: string): RBXScriptConnection;
	--[[
		*
		* Registers a listener removed event.
	]]
	-- export function onListenerRemoved(func: ListenerRemovedEvent, id?: string) {
	-- if (id !== undefined) {
	-- let listenerRemovedEvent = listenerRemovedEvents.get(id);
	-- if (!listenerRemovedEvent) listenerRemovedEvents.set(id, (listenerRemovedEvent = new Signal()));
	-- return listenerRemovedEvent.Connect(func);
	-- } else {
	-- return listenerRemoved.Connect(func);
	-- }
	-- }
	--[[
		*
		* Registers a class decorator.
	]]
	--[[
		*
		* Registers a method decorator.
	]]
	--[[
		*
		* Registers a property decorator.
	]]
	--[[
		*
		* Registers a decorator.
	]]
	local defineDecoratorMetadata
	local function createDecorator(_kind, func)
		return {
			func = function(descriptor, config)
				defineDecoratorMetadata(descriptor, config)
				func(descriptor, config)
			end,
		}
	end
	_container.createDecorator = createDecorator
	--[[
		*
		* Registers a metadata class decorator.
	]]
	--[[
		*
		* Registers a metadata method decorator.
	]]
	--[[
		*
		* Registers a metadata property decorator.
	]]
	--[[
		*
		* Registers a metadata decorator.
	]]
	local function createMetaDecorator(_kind)
		return {
			func = function(descriptor, config)
				defineDecoratorMetadata(descriptor, config)
			end,
		}
	end
	_container.createMetaDecorator = createMetaDecorator
	--[[
		*
		* Retrieves registered decorators.
	]]
	local function getDecorators(id)
		local _arg0 = id ~= nil
		assert(_arg0)
		local _decorators = Reflect.decorators
		local _id = id
		local decorators = _decorators[_id]
		if not decorators then
			return {}
		end
		local _arg0_1 = function(object)
			local decoratorConfig = Reflect.getOwnMetadata(object, "flamework:decorators." .. id)
			assert(decoratorConfig)
			return {
				object = object,
				arguments = decoratorConfig.arguments,
			}
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#decorators)
		for _k, _v in decorators do
			_newValue[_k] = _arg0_1(_v, _k - 1, decorators)
		end
		-- ▲ ReadonlyArray.map ▲
		return _newValue
	end
	_container.getDecorators = getDecorators
	--[[
		*
		* Creates a map of every property using the specified decorator.
	]]
	local getDecorator
	local function getPropertyDecorators(obj, id)
		local decorators = {}
		local _arg0 = id ~= nil
		assert(_arg0)
		for _, prop in Reflect.getProperties(obj) do
			local decorator = getDecorator(obj, prop, id)
			if decorator then
				decorators[prop] = decorator
			end
		end
		return decorators
	end
	_container.getPropertyDecorators = getPropertyDecorators
	--[[
		*
		* Retrieves a decorator from an object or its properties.
	]]
	function getDecorator(object, property, id)
		local decorator = Reflect.getMetadata(object, "flamework:decorators." .. tostring(id), property)
		if not decorator then
			return nil
		end
		return decorator
	end
	_container.getDecorator = getDecorator
	--[[
		*
		* Retrieves a singleton or instantiates one if it does not exist.
	]]
	local createDependency
	local function resolveSingleton(ctor)
		local _ctor = ctor
		local resolvedDependency = resolvedSingletons[_ctor]
		if resolvedDependency ~= nil then
			return resolvedDependency
		end
		local _ctor_1 = ctor
		if table.find(loadingList, _ctor_1) ~= nil then
			-- ▼ ReadonlyArray.join ▼
			local _result = table.create(#loadingList)
			for _k, _v in loadingList do
				_result[_k] = tostring(_v)
			end
			-- ▲ ReadonlyArray.join ▲
			error("Circular dependency detected " .. (table.concat(_result, " <=> ") .. (" <=> " .. tostring(ctor))))
		end
		local _ctor_2 = ctor
		table.insert(loadingList, _ctor_2)
		-- Flamework can resolve singletons at any arbitrary point,
		-- so we should fetch custom dependency resolution (added via decorator) through the Reflect api.
		local opts = Reflect.getOwnMetadata(ctor, "flamework:dependency_resolution")
		local dependency = createDependency(ctor, opts)
		local _ctor_3 = ctor
		resolvedSingletons[_ctor_3] = dependency
		loadingList[#loadingList] = nil
		addListener(dependency)
		return dependency
	end
	_container.resolveSingleton = resolveSingleton
	-- * @internal Used for bootstrapping
	local function getSingletons()
		return resolvedSingletons
	end
	_container.getSingletons = getSingletons
	--[[
		*
		* Modifies dependency resolution for a specific ID.
		*
		* If a function is passed, it will be called, passing the target constructor, every time that ID needs to be resolved.
		* Otherwise, the passed object is returned directly.
	]]
	local function registerDependency(dependency, id)
		local _arg0 = id ~= nil
		assert(_arg0)
		local _dependency = dependency
		if type(_dependency) == "function" then
			local _id = id
			local _dependency_1 = dependency
			dependencyResolution[_id] = _dependency_1
		else
			local _id = id
			local _arg1 = function()
				return dependency
			end
			dependencyResolution[_id] = _arg1
		end
	end
	_container.registerDependency = registerDependency
	--[[
		*
		* Instantiates this class using dependency injection.
	]]
	local createDeferredDependency
	function createDependency(ctor, options)
		if options == nil then
			options = {}
		end
		local _binding = createDeferredDependency(ctor, options)
		local obj = _binding[1]
		local construct = _binding[2]
		construct()
		return obj
	end
	_container.createDependency = createDependency
	--[[
		*
		* Creates an object for this class and returns a deferred constructor.
	]]
	local resolveDependency
	function createDeferredDependency(ctor, options)
		if options == nil then
			options = {}
		end
		local _binding = getDeferredConstructor(ctor)
		local obj = _binding[1]
		local construct = _binding[2]
		return { obj, function()
			local dependencies = Reflect.getMetadata(ctor, "flamework:parameters")
			local constructorDependencies = {}
			if dependencies then
				for index, dependencyId in pairs(dependencies) do
					constructorDependencies[index - 1 + 1] = resolveDependency(ctor, dependencyId, index - 1, options)
				end
			end
			construct(unpack(constructorDependencies))
		end }
	end
	_container.createDeferredDependency = createDeferredDependency
	--[[
		*
		* Dependency resolution logic.
		* @internal
	]]
	function resolveDependency(ctor, dependencyId, index, options)
		if options.handle ~= nil then
			local dependency = options.handle(dependencyId, index)
			if dependency ~= nil then
				return dependency
			end
		end
		local _dependencyId = dependencyId
		local resolution = dependencyResolution[_dependencyId]
		if resolution ~= nil then
			return resolution(ctor)
		end
		local _idToObj = Reflect.idToObj
		local _dependencyId_1 = dependencyId
		local dependencyCtor = _idToObj[_dependencyId_1]
		if dependencyCtor and isConstructor(dependencyCtor) then
			return resolveSingleton(dependencyCtor)
		end
		if string.sub(dependencyId, 1, 2) == "$p" then
			if string.sub(dependencyId, 1, 3) == "$ps" then
				return string.sub(dependencyId, 5)
			end
			if string.sub(dependencyId, 1, 3) == "$pn" then
				local _condition = tonumber(string.sub(dependencyId, 5))
				if _condition == nil then
					_condition = 0
				end
				return _condition
			end
			if options.handlePrimitive ~= nil then
				return options.handlePrimitive(dependencyId, index)
			end
			error("Unexpected primitive dependency '" .. (dependencyId .. ("' while constructing " .. tostring(ctor))))
		end
		error("Could not find constructor for " .. (dependencyId .. (" while constructing " .. (tostring(ctor) .. ". This is usually caused by yielding inside a controller/service constructor. Make sure you do not yield or error inside a controller/service constructor."))))
	end
	_container.resolveDependency = resolveDependency
	--[[
		*
		* @hidden
		* @deprecated
	]]
	-- export function macro<T>(values: string | [string, unknown][], directValue?: unknown): T {
	-- if (typeIs(values, "string")) {
	-- return {
	-- [values]: directValue,
	-- } as never;
	-- }
	-- const result = {} as Record<string, unknown>;
	-- for (const [name, value] of values) {
	-- result[name] = value;
	-- }
	-- return result as T;
	-- }
	function defineDecoratorMetadata(descriptor, config)
		local propertyKey = if descriptor.isStatic then "static:" .. descriptor.property else descriptor.property
		Reflect.defineMetadata(descriptor.object, "flamework:decorators." .. descriptor.id, {
			arguments = config,
		}, propertyKey)
		local decoratorList = Reflect.getMetadata(descriptor.object, "flamework:decorators", propertyKey)
		if not decoratorList then
			local _fn = Reflect
			local _exp = descriptor.object
			decoratorList = {}
			_fn.defineMetadata(_exp, "flamework:decorators", decoratorList, propertyKey)
		end
		local _decoratorList = decoratorList
		local _id = descriptor.id
		table.insert(_decoratorList, _id)
	end
end
function isConstructor(obj)
	return obj.new ~= nil and obj.constructor ~= nil
end
function getDeferredConstructor(ctor)
	local obj = setmetatable({}, ctor)
	return { obj, function(...)
		local args = { ... }
		local result = obj:constructor(unpack(args))
		local _arg0 = result == nil or result == obj
		assert(_arg0, "Deferred constructors are not allowed to return values.")
	end }
end
return {
	Modding = Modding,
}
-- ----------------------------------
-- ----------------------------------
