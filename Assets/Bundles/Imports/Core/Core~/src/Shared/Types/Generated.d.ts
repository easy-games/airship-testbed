/* eslint-disable */

/**
* Types generated by Unity.
* To generate, use the menu action: Typescript > Generate Types
*
* DO NOT EDIT!
*/

declare const enum HideFlags {
    None = 0,
    HideInHierarchy = 1,
    HideInInspector = 2,
    DontSaveInEditor = 4,
    NotEditable = 8,
    DontSaveInBuild = 16,
    DontUnloadUnusedAsset = 32,
    DontSave = 52,
    HideAndDontSave = 61,
}
declare const enum Space {
    World = 0,
    Self = 1,
}
declare const enum SendMessageOptions {
    RequireReceiver = 0,
    DontRequireReceiver = 1,
}
declare const enum PrimitiveType {
    Sphere = 0,
    Capsule = 1,
    Cylinder = 2,
    Cube = 3,
    Plane = 4,
    Quad = 5,
}
declare const enum RigidbodyConstraints {
    None = 0,
    FreezePositionX = 2,
    FreezePositionY = 4,
    FreezePositionZ = 8,
    FreezePosition = 14,
    FreezeRotationX = 16,
    FreezeRotationY = 32,
    FreezeRotationZ = 64,
    FreezeRotation = 112,
    FreezeAll = 126,
}
declare const enum CollisionDetectionMode {
    Discrete = 0,
    Continuous = 1,
    ContinuousDynamic = 2,
    ContinuousSpeculative = 3,
}
declare const enum RigidbodyInterpolation {
    None = 0,
    Interpolate = 1,
    Extrapolate = 2,
}
declare const enum ForceMode {
    Force = 0,
    Impulse = 1,
    VelocityChange = 2,
    Acceleration = 5,
}
declare const enum QueryTriggerInteraction {
    UseGlobal = 0,
    Ignore = 1,
    Collide = 2,
}
declare const enum ArticulationJointType {
    FixedJoint = 0,
    PrismaticJoint = 1,
    RevoluteJoint = 2,
    SphericalJoint = 3,
}
declare const enum ArticulationDofLock {
    LockedMotion = 0,
    LimitedMotion = 1,
    FreeMotion = 2,
}
declare const enum PhysicMaterialCombine {
    Average = 0,
    Multiply = 1,
    Minimum = 2,
    Maximum = 3,
}
declare const enum LogType {
    Error = 0,
    Assert = 1,
    Warning = 2,
    Log = 3,
    Exception = 4,
}
declare const enum LogOption {
    None = 0,
    NoStacktrace = 1,
}
declare const enum GraphicsFormat {
    None = 0,
    R8_SRGB = 1,
    R8G8_SRGB = 2,
    R8G8B8_SRGB = 3,
    R8G8B8A8_SRGB = 4,
    R8_UNorm = 5,
    R8G8_UNorm = 6,
    R8G8B8_UNorm = 7,
    R8G8B8A8_UNorm = 8,
    R8_SNorm = 9,
    R8G8_SNorm = 10,
    R8G8B8_SNorm = 11,
    R8G8B8A8_SNorm = 12,
    R8_UInt = 13,
    R8G8_UInt = 14,
    R8G8B8_UInt = 15,
    R8G8B8A8_UInt = 16,
    R8_SInt = 17,
    R8G8_SInt = 18,
    R8G8B8_SInt = 19,
    R8G8B8A8_SInt = 20,
    R16_UNorm = 21,
    R16G16_UNorm = 22,
    R16G16B16_UNorm = 23,
    R16G16B16A16_UNorm = 24,
    R16_SNorm = 25,
    R16G16_SNorm = 26,
    R16G16B16_SNorm = 27,
    R16G16B16A16_SNorm = 28,
    R16_UInt = 29,
    R16G16_UInt = 30,
    R16G16B16_UInt = 31,
    R16G16B16A16_UInt = 32,
    R16_SInt = 33,
    R16G16_SInt = 34,
    R16G16B16_SInt = 35,
    R16G16B16A16_SInt = 36,
    R32_UInt = 37,
    R32G32_UInt = 38,
    R32G32B32_UInt = 39,
    R32G32B32A32_UInt = 40,
    R32_SInt = 41,
    R32G32_SInt = 42,
    R32G32B32_SInt = 43,
    R32G32B32A32_SInt = 44,
    R16_SFloat = 45,
    R16G16_SFloat = 46,
    R16G16B16_SFloat = 47,
    R16G16B16A16_SFloat = 48,
    R32_SFloat = 49,
    R32G32_SFloat = 50,
    R32G32B32_SFloat = 51,
    R32G32B32A32_SFloat = 52,
    B8G8R8_SRGB = 56,
    B8G8R8A8_SRGB = 57,
    B8G8R8_UNorm = 58,
    B8G8R8A8_UNorm = 59,
    B8G8R8_SNorm = 60,
    B8G8R8A8_SNorm = 61,
    B8G8R8_UInt = 62,
    B8G8R8A8_UInt = 63,
    B8G8R8_SInt = 64,
    B8G8R8A8_SInt = 65,
    R4G4B4A4_UNormPack16 = 66,
    B4G4R4A4_UNormPack16 = 67,
    R5G6B5_UNormPack16 = 68,
    B5G6R5_UNormPack16 = 69,
    R5G5B5A1_UNormPack16 = 70,
    B5G5R5A1_UNormPack16 = 71,
    A1R5G5B5_UNormPack16 = 72,
    E5B9G9R9_UFloatPack32 = 73,
    B10G11R11_UFloatPack32 = 74,
    A2B10G10R10_UNormPack32 = 75,
    A2B10G10R10_UIntPack32 = 76,
    A2B10G10R10_SIntPack32 = 77,
    A2R10G10B10_UNormPack32 = 78,
    A2R10G10B10_UIntPack32 = 79,
    A2R10G10B10_SIntPack32 = 80,
    A2R10G10B10_XRSRGBPack32 = 81,
    A2R10G10B10_XRUNormPack32 = 82,
    R10G10B10_XRSRGBPack32 = 83,
    R10G10B10_XRUNormPack32 = 84,
    A10R10G10B10_XRSRGBPack32 = 85,
    A10R10G10B10_XRUNormPack32 = 86,
    D16_UNorm = 90,
    D24_UNorm = 91,
    D24_UNorm_S8_UInt = 92,
    D32_SFloat = 93,
    D32_SFloat_S8_UInt = 94,
    S8_UInt = 95,
    RGB_DXT1_SRGB = 96,
    RGBA_DXT1_SRGB = 96,
    RGB_DXT1_UNorm = 97,
    RGBA_DXT1_UNorm = 97,
    RGBA_DXT3_SRGB = 98,
    RGBA_DXT3_UNorm = 99,
    RGBA_DXT5_SRGB = 100,
    RGBA_DXT5_UNorm = 101,
    R_BC4_UNorm = 102,
    R_BC4_SNorm = 103,
    RG_BC5_UNorm = 104,
    RG_BC5_SNorm = 105,
    RGB_BC6H_UFloat = 106,
    RGB_BC6H_SFloat = 107,
    RGBA_BC7_SRGB = 108,
    RGBA_BC7_UNorm = 109,
    RGB_PVRTC_2Bpp_SRGB = 110,
    RGB_PVRTC_2Bpp_UNorm = 111,
    RGB_PVRTC_4Bpp_SRGB = 112,
    RGB_PVRTC_4Bpp_UNorm = 113,
    RGBA_PVRTC_2Bpp_SRGB = 114,
    RGBA_PVRTC_2Bpp_UNorm = 115,
    RGBA_PVRTC_4Bpp_SRGB = 116,
    RGBA_PVRTC_4Bpp_UNorm = 117,
    RGB_ETC_UNorm = 118,
    RGB_ETC2_SRGB = 119,
    RGB_ETC2_UNorm = 120,
    RGB_A1_ETC2_SRGB = 121,
    RGB_A1_ETC2_UNorm = 122,
    RGBA_ETC2_SRGB = 123,
    RGBA_ETC2_UNorm = 124,
    R_EAC_UNorm = 125,
    R_EAC_SNorm = 126,
    RG_EAC_UNorm = 127,
    RG_EAC_SNorm = 128,
    RGBA_ASTC4X4_SRGB = 129,
    RGBA_ASTC4X4_UNorm = 130,
    RGBA_ASTC5X5_SRGB = 131,
    RGBA_ASTC5X5_UNorm = 132,
    RGBA_ASTC6X6_SRGB = 133,
    RGBA_ASTC6X6_UNorm = 134,
    RGBA_ASTC8X8_SRGB = 135,
    RGBA_ASTC8X8_UNorm = 136,
    RGBA_ASTC10X10_SRGB = 137,
    RGBA_ASTC10X10_UNorm = 138,
    RGBA_ASTC12X12_SRGB = 139,
    RGBA_ASTC12X12_UNorm = 140,
    YUV2 = 141,
    DepthAuto = 142,
    ShadowAuto = 143,
    VideoAuto = 144,
    RGBA_ASTC4X4_UFloat = 145,
    RGBA_ASTC5X5_UFloat = 146,
    RGBA_ASTC6X6_UFloat = 147,
    RGBA_ASTC8X8_UFloat = 148,
    RGBA_ASTC10X10_UFloat = 149,
    RGBA_ASTC12X12_UFloat = 150,
}
declare const enum TextureDimension {
    None = 0,
    Any = 1,
    Tex2D = 2,
    Tex3D = 3,
    Cube = 4,
    Tex2DArray = 5,
    CubeArray = 6,
    Unknown = -1,
}
declare const enum TextureWrapMode {
    Repeat = 0,
    Clamp = 1,
    Mirror = 2,
    MirrorOnce = 3,
}
declare const enum FilterMode {
    Point = 0,
    Bilinear = 1,
    Trilinear = 2,
}
declare const enum AnisotropicFiltering {
    Disable = 0,
    Enable = 1,
    ForceEnable = 2,
}
declare const enum TextureFormat {
    Alpha8 = 1,
    ARGB4444 = 2,
    RGB24 = 3,
    RGBA32 = 4,
    ARGB32 = 5,
    RGB565 = 7,
    R16 = 9,
    DXT1 = 10,
    DXT5 = 12,
    RGBA4444 = 13,
    BGRA32 = 14,
    RHalf = 15,
    RGHalf = 16,
    RGBAHalf = 17,
    RFloat = 18,
    RGFloat = 19,
    RGBAFloat = 20,
    YUY2 = 21,
    RGB9e5Float = 22,
    BC6H = 24,
    BC7 = 25,
    BC4 = 26,
    BC5 = 27,
    DXT1Crunched = 28,
    DXT5Crunched = 29,
    PVRTC_RGB2 = 30,
    PVRTC_RGBA2 = 31,
    PVRTC_RGB4 = 32,
    PVRTC_RGBA4 = 33,
    ETC_RGB4 = 34,
    EAC_R = 41,
    EAC_R_SIGNED = 42,
    EAC_RG = 43,
    EAC_RG_SIGNED = 44,
    ETC2_RGB = 45,
    ETC2_RGBA1 = 46,
    ETC2_RGBA8 = 47,
    ASTC_4x4 = 48,
    ASTC_RGB_4x4 = 48,
    ASTC_RGB_5x5 = 49,
    ASTC_5x5 = 49,
    ASTC_RGB_6x6 = 50,
    ASTC_6x6 = 50,
    ASTC_8x8 = 51,
    ASTC_RGB_8x8 = 51,
    ASTC_10x10 = 52,
    ASTC_RGB_10x10 = 52,
    ASTC_RGB_12x12 = 53,
    ASTC_12x12 = 53,
    ASTC_RGBA_4x4 = 54,
    ASTC_RGBA_5x5 = 55,
    ASTC_RGBA_6x6 = 56,
    ASTC_RGBA_8x8 = 57,
    ASTC_RGBA_10x10 = 58,
    ASTC_RGBA_12x12 = 59,
    ETC_RGB4_3DS = 60,
    ETC_RGBA8_3DS = 61,
    RG16 = 62,
    R8 = 63,
    ETC_RGB4Crunched = 64,
    ETC2_RGBA8Crunched = 65,
    ASTC_HDR_4x4 = 66,
    ASTC_HDR_5x5 = 67,
    ASTC_HDR_6x6 = 68,
    ASTC_HDR_8x8 = 69,
    ASTC_HDR_10x10 = 70,
    ASTC_HDR_12x12 = 71,
    RG32 = 72,
    RGB48 = 73,
    RGBA64 = 74,
    PVRTC_2BPP_RGB = -127,
    PVRTC_2BPP_RGBA = -127,
    ATC_RGB4 = -127,
    PVRTC_4BPP_RGB = -127,
    ATC_RGBA8 = -127,
    PVRTC_4BPP_RGBA = -127,
}
declare const enum SpritePackingMode {
    Tight = 0,
    Rectangle = 1,
}
declare const enum SpritePackingRotation {
    None = 0,
    FlipHorizontal = 1,
    FlipVertical = 2,
    Rotate180 = 3,
    Any = 15,
}
declare const enum SpriteMeshType {
    FullRect = 0,
    Tight = 1,
}
declare const enum DefaultFormat {
    LDR = 0,
    HDR = 1,
    DepthStencil = 2,
    Shadow = 3,
    Video = 4,
}
declare const enum TextureCreationFlags {
    None = 0,
    MipChain = 1,
    Crunch = 64,
}
declare const enum ConditionOverrideType {
    AddMissing = 1,
    UseManager = 2,
    IgnoreManager = 3,
}
declare const enum ObserverConditionType {
    Normal = 1,
    Timed = 2,
}
declare const enum Channel {
    Reliable = 0,
    Unreliable = 1,
}
declare const enum AutoPackType {
    Unpacked = 0,
    Packed = 1,
    PackedLess = 2,
}
declare const enum HostVisibilityUpdateTypes {
    Manager = 1,
    Spawned = 2,
}
declare const enum LocalConnectionState {
    Stopped = 0,
    Starting = 1,
    Started = 2,
    Stopping = 3,
}
declare const enum RemoteConnectionState {
    Stopped = 0,
    Started = 2,
}
declare const enum IPAddressType {
    IPv4 = 0,
    IPv6 = 1,
}
declare const enum PhysicsMode {
    Unity = 0,
    TimeManager = 1,
    Disabled = 2,
}
declare const enum TickType {
    Tick = 0,
    LocalTick = 1,
    LastPacketTick = 2,
}
declare const enum TickRounding {
    RoundUp = 0,
    RoundDown = 1,
    RoundNearest = 2,
}
declare const enum LoadSceneMode {
    Single = 0,
    Additive = 1,
}
declare const enum LocalPhysicsMode {
    None = 0,
    Physics2D = 1,
    Physics3D = 2,
}
declare const enum SceneScopeType {
    Global = 0,
    Connections = 1,
}
declare const enum ReplaceOption {
    All = 0,
    OnlineOnly = 1,
    None = 2,
}
declare const enum ServerUnloadMode {
    UnloadUnused = 0,
    KeepUnused = 1,
}
declare const enum PhysicsType {
    TwoDimensional = 1,
    ThreeDimensional = 2,
    Both = 4,
}
declare const enum LoggingType {
    Off = 0,
    Error = 1,
    Warning = 2,
    Common = 3,
}
declare const enum DataSource {
    Unset = 0,
    Server = 1,
    Client = 2,
}
declare const enum DespawnType {
    Destroy = 0,
    Pool = 1,
}
declare const enum OldTickOption {
    Discard = 0,
    SetLastRemoteTick = 1,
    SetRemoteTick = 2,
}
declare const enum KickReason {
    Unset = 0,
    ExploitAttempt = 1,
    MalformedData = 2,
    ExploitExcessiveData = 3,
    ExcessiveData = 4,
    UnexpectedProblem = 5,
    UnusualActivity = 6,
}
declare const enum RenderingPath {
    VertexLit = 0,
    Forward = 1,
    DeferredLighting = 2,
    DeferredShading = 3,
    UsePlayerSettings = -1,
}
declare const enum OpaqueSortMode {
    Default = 0,
    FrontToBack = 1,
    NoDistanceSort = 2,
}
declare const enum TransparencySortMode {
    Default = 0,
    Perspective = 1,
    Orthographic = 2,
    CustomAxis = 3,
}
declare const enum CameraType {
    Game = 1,
    SceneView = 2,
    Preview = 4,
    VR = 8,
    Reflection = 16,
}
declare const enum CameraClearFlags {
    Skybox = 1,
    Color = 2,
    SolidColor = 2,
    Depth = 3,
    Nothing = 4,
}
declare const enum DepthTextureMode {
    None = 0,
    Depth = 1,
    DepthNormals = 2,
    MotionVectors = 4,
}
declare const enum GateFitMode {
    None = 0,
    Vertical = 1,
    Horizontal = 2,
    Fill = 3,
    Overscan = 4,
}
declare const enum RenderTextureFormat {
    ARGB32 = 0,
    Depth = 1,
    ARGBHalf = 2,
    Shadowmap = 3,
    RGB565 = 4,
    ARGB4444 = 5,
    ARGB1555 = 6,
    Default = 7,
    ARGB2101010 = 8,
    DefaultHDR = 9,
    ARGB64 = 10,
    ARGBFloat = 11,
    RGFloat = 12,
    RGHalf = 13,
    RFloat = 14,
    RHalf = 15,
    R8 = 16,
    ARGBInt = 17,
    RGInt = 18,
    RInt = 19,
    BGRA32 = 20,
    RGB111110Float = 22,
    RG32 = 23,
    RGBAUShort = 24,
    RG16 = 25,
    BGRA10101010_XR = 26,
    BGR101010_XR = 27,
    R16 = 28,
}
declare const enum ShadowSamplingMode {
    CompareDepths = 0,
    RawDepth = 1,
    None = 2,
}
declare const enum VRTextureUsage {
    None = 0,
    OneEye = 1,
    TwoEyes = 2,
    DeviceSpecific = 3,
}
declare const enum RenderTextureCreationFlags {
    MipMap = 1,
    AutoGenerateMips = 2,
    SRGB = 4,
    EyeTexture = 8,
    EnableRandomWrite = 16,
    CreatedFromScript = 32,
    AllowVerticalFlip = 128,
    NoResolvedColorSurface = 256,
    DynamicallyScalable = 1024,
    BindMS = 2048,
}
declare const enum RenderTextureMemoryless {
    None = 0,
    Color = 1,
    Depth = 2,
    MSAA = 4,
}
declare const enum MonoOrStereoscopicEye {
    Left = 0,
    Right = 1,
    Mono = 2,
}
declare const enum RenderTextureReadWrite {
    Default = 0,
    Linear = 1,
    sRGB = 2,
}
declare const enum StereoTargetEyeMask {
    None = 0,
    Left = 1,
    Right = 2,
    Both = 3,
}
declare const enum SceneViewFilterMode {
    Off = 0,
    ShowFiltered = 1,
}
declare const enum CameraEvent {
    BeforeDepthTexture = 0,
    AfterDepthTexture = 1,
    BeforeDepthNormalsTexture = 2,
    AfterDepthNormalsTexture = 3,
    BeforeGBuffer = 4,
    AfterGBuffer = 5,
    BeforeLighting = 6,
    AfterLighting = 7,
    BeforeFinalPass = 8,
    AfterFinalPass = 9,
    BeforeForwardOpaque = 10,
    AfterForwardOpaque = 11,
    BeforeImageEffectsOpaque = 12,
    AfterImageEffectsOpaque = 13,
    BeforeSkybox = 14,
    AfterSkybox = 15,
    BeforeForwardAlpha = 16,
    AfterForwardAlpha = 17,
    BeforeImageEffects = 18,
    AfterImageEffects = 19,
    AfterEverything = 20,
    BeforeReflections = 21,
    AfterReflections = 22,
    BeforeHaloAndLensFlares = 23,
    AfterHaloAndLensFlares = 24,
}
declare const enum ShaderKeywordType {
    None = 0,
    BuiltinDefault = 2,
    BuiltinExtra = 6,
    BuiltinAutoStripped = 10,
    UserDefined = 16,
    Plugin = 32,
}
declare const enum ShaderPropertyFlags {
    None = 0,
    HideInInspector = 1,
    PerRendererData = 2,
    NoScaleOffset = 4,
    Normal = 8,
    HDR = 16,
    Gamma = 32,
    NonModifiableTextureData = 64,
    MainTexture = 128,
    MainColor = 256,
}
declare const enum ShaderPropertyType {
    Color = 0,
    Vector = 1,
    Float = 2,
    Range = 3,
    Texture = 4,
    Int = 5,
}
declare const enum ShaderHardwareTier {
    Tier1 = 0,
    Tier2 = 1,
    Tier3 = 2,
}
declare const enum Target {
    Vertex = 1,
    Index = 2,
    CopySource = 4,
    CopyDestination = 8,
    Structured = 16,
    Raw = 32,
    Append = 64,
    Counter = 128,
    IndirectArguments = 256,
    Constant = 512,
}
declare const enum TexGenMode {
    None = 0,
    SphereMap = 1,
    Object = 2,
    EyeLinear = 3,
    CubeReflect = 4,
    CubeNormal = 5,
}
declare const enum RenderTextureSubElement {
    Color = 0,
    Depth = 1,
    Stencil = 2,
    Default = 3,
}
declare const enum MaterialGlobalIlluminationFlags {
    None = 0,
    RealtimeEmissive = 1,
    BakedEmissive = 2,
    AnyEmissive = 3,
    EmissiveIsBlack = 4,
}
declare const enum ShadowCastingMode {
    Off = 0,
    On = 1,
    TwoSided = 2,
    ShadowsOnly = 3,
}
declare const enum MotionVectorGenerationMode {
    Camera = 0,
    Object = 1,
    ForceNoMotion = 2,
}
declare const enum LightProbeUsage {
    Off = 0,
    BlendProbes = 1,
    UseProxyVolume = 2,
    CustomProvided = 4,
}
declare const enum ReflectionProbeUsage {
    Off = 0,
    BlendProbes = 1,
    BlendProbesAndSkybox = 2,
    Simple = 3,
}
declare const enum RayTracingMode {
    Off = 0,
    Static = 1,
    DynamicTransform = 2,
    DynamicGeometry = 3,
}
declare const enum ReflectionProbeType {
    Cube = 0,
    Card = 1,
}
declare const enum ReflectionProbeClearFlags {
    Skybox = 1,
    SolidColor = 2,
}
declare const enum ReflectionProbeMode {
    Baked = 0,
    Realtime = 1,
    Custom = 2,
}
declare const enum ReflectionProbeRefreshMode {
    OnAwake = 0,
    EveryFrame = 1,
    ViaScripting = 2,
}
declare const enum ReflectionProbeTimeSlicingMode {
    AllFacesAtOnce = 0,
    IndividualFaces = 1,
    NoTimeSlicing = 2,
}
declare const enum RTClearFlags {
    None = 0,
    Color = 1,
    Depth = 2,
    ColorDepth = 3,
    Stencil = 4,
    ColorStencil = 5,
    DepthStencil = 6,
    All = 7,
}
declare const enum SynchronisationStage {
    VertexProcessing = 0,
    PixelProcessing = 1,
}
declare const enum GraphicsFenceType {
    AsyncQueueSynchronisation = 0,
    CPUSynchronisation = 1,
}
declare const enum SynchronisationStageFlags {
    VertexProcessing = 1,
    PixelProcessing = 2,
    ComputeProcessing = 4,
    AllGPUOperations = 7,
}
declare const enum IndexFormat {
    UInt16 = 0,
    UInt32 = 1,
}
declare const enum MeshTopology {
    Triangles = 0,
    Quads = 2,
    Lines = 3,
    LineStrip = 4,
    Points = 5,
}
declare const enum VertexAttribute {
    Position = 0,
    Normal = 1,
    Tangent = 2,
    Color = 3,
    TexCoord0 = 4,
    TexCoord1 = 5,
    TexCoord2 = 6,
    TexCoord3 = 7,
    TexCoord4 = 8,
    TexCoord5 = 9,
    TexCoord6 = 10,
    TexCoord7 = 11,
    BlendWeight = 12,
    BlendIndices = 13,
}
declare const enum VertexAttributeFormat {
    Float32 = 0,
    Float16 = 1,
    UNorm8 = 2,
    SNorm8 = 3,
    UNorm16 = 4,
    SNorm16 = 5,
    UInt8 = 6,
    SInt8 = 7,
    UInt16 = 8,
    SInt16 = 9,
    UInt32 = 10,
    SInt32 = 11,
}
declare const enum MeshUpdateFlags {
    Default = 0,
    DontValidateIndices = 1,
    DontResetBoneBounds = 2,
    DontNotifyMeshUsers = 4,
    DontRecalculateBounds = 8,
}
declare const enum CameraLateLatchMatrixType {
    View = 0,
    InverseView = 1,
    ViewProjection = 2,
    InverseViewProjection = 3,
}
declare const enum CommandBufferExecutionFlags {
    None = 0,
    AsyncCompute = 2,
}
declare const enum RenderBufferLoadAction {
    Load = 0,
    Clear = 1,
    DontCare = 2,
}
declare const enum RenderBufferStoreAction {
    Store = 0,
    Resolve = 1,
    StoreAndResolve = 2,
    DontCare = 3,
}
declare const enum CubemapFace {
    PositiveX = 0,
    NegativeX = 1,
    PositiveY = 2,
    NegativeY = 3,
    PositiveZ = 4,
    NegativeZ = 5,
    Unknown = -1,
}
declare const enum RenderTargetFlags {
    None = 0,
    ReadOnlyDepth = 1,
    ReadOnlyStencil = 2,
    ReadOnlyDepthStencil = 3,
}
declare const enum SinglePassStereoMode {
    None = 0,
    SideBySide = 1,
    Instancing = 2,
    Multiview = 3,
}
declare const enum ComputeQueueType {
    Default = 0,
    Background = 1,
    Urgent = 2,
}
declare const enum StereoscopicEye {
    Left = 0,
    Right = 1,
}
declare const enum RenderRequestMode {
    None = 0,
    ObjectId = 1,
    Depth = 2,
    VertexNormal = 3,
    WorldPosition = 4,
    EntityId = 5,
    BaseColor = 6,
    SpecularColor = 7,
    Metallic = 8,
    Emission = 9,
    Normal = 10,
    Smoothness = 11,
    Occlusion = 12,
    DiffuseColor = 13,
}
declare const enum RenderRequestOutputSpace {
    UV0 = 0,
    UV1 = 1,
    UV2 = 2,
    UV3 = 3,
    UV4 = 4,
    UV5 = 5,
    UV6 = 6,
    UV7 = 7,
    UV8 = 8,
    ScreenSpace = -1,
}
declare const enum IMECompositionMode {
    Auto = 0,
    On = 1,
    Off = 2,
}
declare const enum DeviceOrientation {
    Unknown = 0,
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeLeft = 3,
    LandscapeRight = 4,
    FaceUp = 5,
    FaceDown = 6,
}
declare const enum LocationServiceStatus {
    Stopped = 0,
    Initializing = 1,
    Running = 2,
    Failed = 3,
}
declare const enum TouchPhase {
    Began = 0,
    Moved = 1,
    Stationary = 2,
    Ended = 3,
    Canceled = 4,
}
declare const enum TouchType {
    Direct = 0,
    Indirect = 1,
    Stylus = 2,
}
declare const enum KeyCode {
    None = 0,
    Backspace = 8,
    Tab = 9,
    Clear = 12,
    Return = 13,
    Pause = 19,
    Escape = 27,
    Space = 32,
    Exclaim = 33,
    DoubleQuote = 34,
    Hash = 35,
    Dollar = 36,
    Percent = 37,
    Ampersand = 38,
    Quote = 39,
    LeftParen = 40,
    RightParen = 41,
    Asterisk = 42,
    Plus = 43,
    Comma = 44,
    Minus = 45,
    Period = 46,
    Slash = 47,
    Alpha0 = 48,
    Alpha1 = 49,
    Alpha2 = 50,
    Alpha3 = 51,
    Alpha4 = 52,
    Alpha5 = 53,
    Alpha6 = 54,
    Alpha7 = 55,
    Alpha8 = 56,
    Alpha9 = 57,
    Colon = 58,
    Semicolon = 59,
    Less = 60,
    Equals = 61,
    Greater = 62,
    Question = 63,
    At = 64,
    LeftBracket = 91,
    Backslash = 92,
    RightBracket = 93,
    Caret = 94,
    Underscore = 95,
    BackQuote = 96,
    A = 97,
    B = 98,
    C = 99,
    D = 100,
    E = 101,
    F = 102,
    G = 103,
    H = 104,
    I = 105,
    J = 106,
    K = 107,
    L = 108,
    M = 109,
    N = 110,
    O = 111,
    P = 112,
    Q = 113,
    R = 114,
    S = 115,
    T = 116,
    U = 117,
    V = 118,
    W = 119,
    X = 120,
    Y = 121,
    Z = 122,
    LeftCurlyBracket = 123,
    Pipe = 124,
    RightCurlyBracket = 125,
    Tilde = 126,
    Delete = 127,
    Keypad0 = 256,
    Keypad1 = 257,
    Keypad2 = 258,
    Keypad3 = 259,
    Keypad4 = 260,
    Keypad5 = 261,
    Keypad6 = 262,
    Keypad7 = 263,
    Keypad8 = 264,
    Keypad9 = 265,
    KeypadPeriod = 266,
    KeypadDivide = 267,
    KeypadMultiply = 268,
    KeypadMinus = 269,
    KeypadPlus = 270,
    KeypadEnter = 271,
    KeypadEquals = 272,
    UpArrow = 273,
    DownArrow = 274,
    RightArrow = 275,
    LeftArrow = 276,
    Insert = 277,
    Home = 278,
    End = 279,
    PageUp = 280,
    PageDown = 281,
    F1 = 282,
    F2 = 283,
    F3 = 284,
    F4 = 285,
    F5 = 286,
    F6 = 287,
    F7 = 288,
    F8 = 289,
    F9 = 290,
    F10 = 291,
    F11 = 292,
    F12 = 293,
    F13 = 294,
    F14 = 295,
    F15 = 296,
    Numlock = 300,
    CapsLock = 301,
    ScrollLock = 302,
    RightShift = 303,
    LeftShift = 304,
    RightControl = 305,
    LeftControl = 306,
    RightAlt = 307,
    LeftAlt = 308,
    RightMeta = 309,
    RightCommand = 309,
    RightApple = 309,
    LeftMeta = 310,
    LeftCommand = 310,
    LeftApple = 310,
    LeftWindows = 311,
    RightWindows = 312,
    AltGr = 313,
    Help = 315,
    Print = 316,
    SysReq = 317,
    Break = 318,
    Menu = 319,
    Mouse0 = 323,
    Mouse1 = 324,
    Mouse2 = 325,
    Mouse3 = 326,
    Mouse4 = 327,
    Mouse5 = 328,
    Mouse6 = 329,
    JoystickButton0 = 330,
    JoystickButton1 = 331,
    JoystickButton2 = 332,
    JoystickButton3 = 333,
    JoystickButton4 = 334,
    JoystickButton5 = 335,
    JoystickButton6 = 336,
    JoystickButton7 = 337,
    JoystickButton8 = 338,
    JoystickButton9 = 339,
    JoystickButton10 = 340,
    JoystickButton11 = 341,
    JoystickButton12 = 342,
    JoystickButton13 = 343,
    JoystickButton14 = 344,
    JoystickButton15 = 345,
    JoystickButton16 = 346,
    JoystickButton17 = 347,
    JoystickButton18 = 348,
    JoystickButton19 = 349,
    Joystick1Button0 = 350,
    Joystick1Button1 = 351,
    Joystick1Button2 = 352,
    Joystick1Button3 = 353,
    Joystick1Button4 = 354,
    Joystick1Button5 = 355,
    Joystick1Button6 = 356,
    Joystick1Button7 = 357,
    Joystick1Button8 = 358,
    Joystick1Button9 = 359,
    Joystick1Button10 = 360,
    Joystick1Button11 = 361,
    Joystick1Button12 = 362,
    Joystick1Button13 = 363,
    Joystick1Button14 = 364,
    Joystick1Button15 = 365,
    Joystick1Button16 = 366,
    Joystick1Button17 = 367,
    Joystick1Button18 = 368,
    Joystick1Button19 = 369,
    Joystick2Button0 = 370,
    Joystick2Button1 = 371,
    Joystick2Button2 = 372,
    Joystick2Button3 = 373,
    Joystick2Button4 = 374,
    Joystick2Button5 = 375,
    Joystick2Button6 = 376,
    Joystick2Button7 = 377,
    Joystick2Button8 = 378,
    Joystick2Button9 = 379,
    Joystick2Button10 = 380,
    Joystick2Button11 = 381,
    Joystick2Button12 = 382,
    Joystick2Button13 = 383,
    Joystick2Button14 = 384,
    Joystick2Button15 = 385,
    Joystick2Button16 = 386,
    Joystick2Button17 = 387,
    Joystick2Button18 = 388,
    Joystick2Button19 = 389,
    Joystick3Button0 = 390,
    Joystick3Button1 = 391,
    Joystick3Button2 = 392,
    Joystick3Button3 = 393,
    Joystick3Button4 = 394,
    Joystick3Button5 = 395,
    Joystick3Button6 = 396,
    Joystick3Button7 = 397,
    Joystick3Button8 = 398,
    Joystick3Button9 = 399,
    Joystick3Button10 = 400,
    Joystick3Button11 = 401,
    Joystick3Button12 = 402,
    Joystick3Button13 = 403,
    Joystick3Button14 = 404,
    Joystick3Button15 = 405,
    Joystick3Button16 = 406,
    Joystick3Button17 = 407,
    Joystick3Button18 = 408,
    Joystick3Button19 = 409,
    Joystick4Button0 = 410,
    Joystick4Button1 = 411,
    Joystick4Button2 = 412,
    Joystick4Button3 = 413,
    Joystick4Button4 = 414,
    Joystick4Button5 = 415,
    Joystick4Button6 = 416,
    Joystick4Button7 = 417,
    Joystick4Button8 = 418,
    Joystick4Button9 = 419,
    Joystick4Button10 = 420,
    Joystick4Button11 = 421,
    Joystick4Button12 = 422,
    Joystick4Button13 = 423,
    Joystick4Button14 = 424,
    Joystick4Button15 = 425,
    Joystick4Button16 = 426,
    Joystick4Button17 = 427,
    Joystick4Button18 = 428,
    Joystick4Button19 = 429,
    Joystick5Button0 = 430,
    Joystick5Button1 = 431,
    Joystick5Button2 = 432,
    Joystick5Button3 = 433,
    Joystick5Button4 = 434,
    Joystick5Button5 = 435,
    Joystick5Button6 = 436,
    Joystick5Button7 = 437,
    Joystick5Button8 = 438,
    Joystick5Button9 = 439,
    Joystick5Button10 = 440,
    Joystick5Button11 = 441,
    Joystick5Button12 = 442,
    Joystick5Button13 = 443,
    Joystick5Button14 = 444,
    Joystick5Button15 = 445,
    Joystick5Button16 = 446,
    Joystick5Button17 = 447,
    Joystick5Button18 = 448,
    Joystick5Button19 = 449,
    Joystick6Button0 = 450,
    Joystick6Button1 = 451,
    Joystick6Button2 = 452,
    Joystick6Button3 = 453,
    Joystick6Button4 = 454,
    Joystick6Button5 = 455,
    Joystick6Button6 = 456,
    Joystick6Button7 = 457,
    Joystick6Button8 = 458,
    Joystick6Button9 = 459,
    Joystick6Button10 = 460,
    Joystick6Button11 = 461,
    Joystick6Button12 = 462,
    Joystick6Button13 = 463,
    Joystick6Button14 = 464,
    Joystick6Button15 = 465,
    Joystick6Button16 = 466,
    Joystick6Button17 = 467,
    Joystick6Button18 = 468,
    Joystick6Button19 = 469,
    Joystick7Button0 = 470,
    Joystick7Button1 = 471,
    Joystick7Button2 = 472,
    Joystick7Button3 = 473,
    Joystick7Button4 = 474,
    Joystick7Button5 = 475,
    Joystick7Button6 = 476,
    Joystick7Button7 = 477,
    Joystick7Button8 = 478,
    Joystick7Button9 = 479,
    Joystick7Button10 = 480,
    Joystick7Button11 = 481,
    Joystick7Button12 = 482,
    Joystick7Button13 = 483,
    Joystick7Button14 = 484,
    Joystick7Button15 = 485,
    Joystick7Button16 = 486,
    Joystick7Button17 = 487,
    Joystick7Button18 = 488,
    Joystick7Button19 = 489,
    Joystick8Button0 = 490,
    Joystick8Button1 = 491,
    Joystick8Button2 = 492,
    Joystick8Button3 = 493,
    Joystick8Button4 = 494,
    Joystick8Button5 = 495,
    Joystick8Button6 = 496,
    Joystick8Button7 = 497,
    Joystick8Button8 = 498,
    Joystick8Button9 = 499,
    Joystick8Button10 = 500,
    Joystick8Button11 = 501,
    Joystick8Button12 = 502,
    Joystick8Button13 = 503,
    Joystick8Button14 = 504,
    Joystick8Button15 = 505,
    Joystick8Button16 = 506,
    Joystick8Button17 = 507,
    Joystick8Button18 = 508,
    Joystick8Button19 = 509,
}
declare const enum InputButton {
    Left = 0,
    Right = 1,
    Middle = 2,
}
declare const enum MoveDirection {
    Left = 0,
    Up = 1,
    Right = 2,
    Down = 3,
    None = 4,
}
declare const enum Mode {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
    Automatic = 3,
    Explicit = 4,
}
declare const enum Transition {
    None = 0,
    ColorTint = 1,
    SpriteSwap = 2,
    Animation = 3,
}
declare const enum CanvasUpdate {
    Prelayout = 0,
    Layout = 1,
    PostLayout = 2,
    PreRender = 3,
    LatePreRender = 4,
    MaxUpdateValue = 5,
}
declare const enum Edge {
    Left = 0,
    Right = 1,
    Top = 2,
    Bottom = 3,
}
declare const enum Axis {
    Horizontal = 0,
    Vertical = 1,
}
declare const enum RenderMode {
    ScreenSpaceOverlay = 0,
    ScreenSpaceCamera = 1,
    WorldSpace = 2,
}
declare const enum AdditionalCanvasShaderChannels {
    None = 0,
    TexCoord1 = 1,
    TexCoord2 = 2,
    TexCoord3 = 4,
    Normal = 8,
    Tangent = 16,
}
declare const enum Type {
    Simple = 0,
    Sliced = 1,
    Tiled = 2,
    Filled = 3,
}
declare const enum FillMethod {
    Horizontal = 0,
    Vertical = 1,
    Radial90 = 2,
    Radial180 = 3,
    Radial360 = 4,
}
declare const enum AnimatorUpdateMode {
    Normal = 0,
    AnimatePhysics = 1,
    UnscaledTime = 2,
}
declare const enum AnimatorControllerParameterType {
    Float = 1,
    Int = 3,
    Bool = 4,
    Trigger = 9,
}
declare const enum AnimatorCullingMode {
    AlwaysAnimate = 0,
    CullUpdateTransforms = 1,
    BasedOnRenderers = 1,
    CullCompletely = 2,
}
declare const enum AnimatorRecorderMode {
    Offline = 0,
    Playback = 1,
    Record = 2,
}
declare const enum WrapMode {
    Default = 0,
    Once = 1,
    Clamp = 1,
    Loop = 2,
    PingPong = 4,
    ClampForever = 8,
}
declare const enum AnimationBlendMode {
    Blend = 0,
    Additive = 1,
}
declare const enum WeightedMode {
    None = 0,
    In = 1,
    Out = 2,
    Both = 3,
}
declare const enum DirectorUpdateMode {
    DSPClock = 0,
    GameTime = 1,
    UnscaledGameTime = 2,
    Manual = 3,
}
declare const enum DurationUnit {
    Fixed = 0,
    Normalized = 1,
}
declare const enum HumanBodyBones {
    Hips = 0,
    LeftUpperLeg = 1,
    RightUpperLeg = 2,
    LeftLowerLeg = 3,
    RightLowerLeg = 4,
    LeftFoot = 5,
    RightFoot = 6,
    Spine = 7,
    Chest = 8,
    Neck = 9,
    Head = 10,
    LeftShoulder = 11,
    RightShoulder = 12,
    LeftUpperArm = 13,
    RightUpperArm = 14,
    LeftLowerArm = 15,
    RightLowerArm = 16,
    LeftHand = 17,
    RightHand = 18,
    LeftToes = 19,
    RightToes = 20,
    LeftEye = 21,
    RightEye = 22,
    Jaw = 23,
    LeftThumbProximal = 24,
    LeftThumbIntermediate = 25,
    LeftThumbDistal = 26,
    LeftIndexProximal = 27,
    LeftIndexIntermediate = 28,
    LeftIndexDistal = 29,
    LeftMiddleProximal = 30,
    LeftMiddleIntermediate = 31,
    LeftMiddleDistal = 32,
    LeftRingProximal = 33,
    LeftRingIntermediate = 34,
    LeftRingDistal = 35,
    LeftLittleProximal = 36,
    LeftLittleIntermediate = 37,
    LeftLittleDistal = 38,
    RightThumbProximal = 39,
    RightThumbIntermediate = 40,
    RightThumbDistal = 41,
    RightIndexProximal = 42,
    RightIndexIntermediate = 43,
    RightIndexDistal = 44,
    RightMiddleProximal = 45,
    RightMiddleIntermediate = 46,
    RightMiddleDistal = 47,
    RightRingProximal = 48,
    RightRingIntermediate = 49,
    RightRingDistal = 50,
    RightLittleProximal = 51,
    RightLittleIntermediate = 52,
    RightLittleDistal = 53,
    UpperChest = 54,
    LastBone = 55,
}
declare const enum AvatarIKHint {
    LeftKnee = 0,
    RightKnee = 1,
    LeftElbow = 2,
    RightElbow = 3,
}
declare const enum AvatarIKGoal {
    LeftFoot = 0,
    RightFoot = 1,
    LeftHand = 2,
    RightHand = 3,
}
declare const enum AvatarTarget {
    Root = 0,
    Body = 1,
    LeftFoot = 2,
    RightFoot = 3,
    LeftHand = 4,
    RightHand = 5,
}
declare const enum UnityEventCallState {
    Off = 0,
    EditorAndRuntime = 1,
    RuntimeOnly = 2,
}
declare const enum ReceiveGI {
    Lightmaps = 1,
    LightProbes = 2,
}
declare const enum FontStyle {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    BoldAndItalic = 3,
}
declare const enum AtlasPopulationMode {
    Static = 0,
    Dynamic = 1,
}
declare const enum TextElementType {
    Character = 1,
    Sprite = 2,
}
declare const enum GlyphRenderMode {
    SMOOTH = 4117,
    RASTER = 4118,
    SMOOTH_HINTED = 4121,
    RASTER_HINTED = 4122,
    SDF = 4134,
    SDFAA = 4165,
    SDFAA_HINTED = 4169,
    SDF8 = 8230,
    SDF16 = 16422,
    SDF32 = 32806,
}
declare const enum FontFeatureLookupFlags {
    None = 0,
    IgnoreLigatures = 4,
    IgnoreSpacingAdjustments = 256,
}
declare const enum ColorMode {
    Single = 0,
    HorizontalGradient = 1,
    VerticalGradient = 2,
    FourCornersGradient = 3,
}
declare const enum FontWeight {
    Thin = 100,
    ExtraLight = 200,
    Light = 300,
    Regular = 400,
    Medium = 500,
    SemiBold = 600,
    Bold = 700,
    Heavy = 800,
    Black = 900,
}
declare const enum FontStyles {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    LowerCase = 8,
    UpperCase = 16,
    SmallCaps = 32,
    Strikethrough = 64,
    Superscript = 128,
    Subscript = 256,
    Highlight = 512,
}
declare const enum HorizontalAlignmentOptions {
    Left = 1,
    Center = 2,
    Right = 4,
    Justified = 8,
    Flush = 16,
    Geometry = 32,
}
declare const enum VerticalAlignmentOptions {
    Top = 256,
    Middle = 512,
    Bottom = 1024,
    Baseline = 2048,
    Geometry = 4096,
    Capline = 8192,
}
declare const enum TextAlignmentOptions {
    TopLeft = 257,
    Top = 258,
    TopRight = 260,
    TopJustified = 264,
    TopFlush = 272,
    TopGeoAligned = 288,
    Left = 513,
    Center = 514,
    Right = 516,
    Justified = 520,
    Flush = 528,
    CenterGeoAligned = 544,
    BottomLeft = 1025,
    Bottom = 1026,
    BottomRight = 1028,
    BottomJustified = 1032,
    BottomFlush = 1040,
    BottomGeoAligned = 1056,
    BaselineLeft = 2049,
    Baseline = 2050,
    BaselineRight = 2052,
    BaselineJustified = 2056,
    BaselineFlush = 2064,
    BaselineGeoAligned = 2080,
    MidlineLeft = 4097,
    Midline = 4098,
    MidlineRight = 4100,
    MidlineJustified = 4104,
    MidlineFlush = 4112,
    MidlineGeoAligned = 4128,
    CaplineLeft = 8193,
    Capline = 8194,
    CaplineRight = 8196,
    CaplineJustified = 8200,
    CaplineFlush = 8208,
    CaplineGeoAligned = 8224,
    Converted = 65535,
}
declare const enum TextOverflowModes {
    Overflow = 0,
    Ellipsis = 1,
    Masking = 2,
    Truncate = 3,
    ScrollRect = 4,
    Page = 5,
    Linked = 6,
}
declare const enum TextureMappingOptions {
    Character = 0,
    Line = 1,
    Paragraph = 2,
    MatchAspect = 3,
}
declare const enum TextRenderFlags {
    DontRender = 0,
    Render = 255,
}
declare const enum VertexSortingOrder {
    Normal = 0,
    Reverse = 1,
}
declare const enum TMP_TextElementType {
    Character = 0,
    Sprite = 1,
}
declare const enum TMP_VertexDataUpdateFlags {
    None = 0,
    Vertices = 1,
    Uv0 = 2,
    Uv2 = 4,
    Uv4 = 8,
    Colors32 = 16,
    All = 255,
}
declare const enum AnimationCullingType {
    AlwaysAnimate = 0,
    BasedOnRenderers = 1,
    BasedOnClipBounds = 2,
    BasedOnUserBounds = 3,
}
declare const enum PlayMode {
    StopSameLayer = 0,
    StopAll = 4,
}
declare const enum QueueMode {
    CompleteOthers = 0,
    PlayNow = 2,
}
declare const enum AnimationPlayMode {
    Stop = 0,
    Queue = 1,
    Mix = 2,
}
declare const enum FogMode {
    Linear = 1,
    Exponential = 2,
    ExponentialSquared = 3,
}
declare const enum AmbientMode {
    Skybox = 0,
    Trilight = 1,
    Flat = 3,
    Custom = 4,
}
declare const enum LightType {
    Spot = 0,
    Directional = 1,
    Point = 2,
    Area = 3,
    Rectangle = 3,
    Disc = 4,
}
declare const enum LightShape {
    Cone = 0,
    Pyramid = 1,
    Box = 2,
}
declare const enum LightmapBakeType {
    Mixed = 1,
    Baked = 2,
    Realtime = 4,
}
declare const enum MixedLightingMode {
    IndirectOnly = 0,
    Subtractive = 1,
    Shadowmask = 2,
}
declare const enum LightShadowCasterMode {
    Default = 0,
    NonLightmappedOnly = 1,
    Everything = 2,
}
declare const enum LightShadows {
    None = 0,
    Hard = 1,
    Soft = 2,
}
declare const enum LightShadowResolution {
    Low = 0,
    Medium = 1,
    High = 2,
    VeryHigh = 3,
    FromQualitySettings = -1,
}
declare const enum LightRenderMode {
    Auto = 0,
    ForcePixel = 1,
    ForceVertex = 2,
}
declare const enum LightmappingMode {
    Mixed = 1,
    Baked = 2,
    Realtime = 4,
}
declare const enum LightEvent {
    BeforeShadowMap = 0,
    AfterShadowMap = 1,
    BeforeScreenspaceMask = 2,
    AfterScreenspaceMask = 3,
    BeforeShadowMapPass = 4,
    AfterShadowMapPass = 5,
}
declare const enum ShadowMapPass {
    PointlightPositiveX = 1,
    PointlightNegativeX = 2,
    PointlightPositiveY = 4,
    PointlightNegativeY = 8,
    PointlightPositiveZ = 16,
    PointlightNegativeZ = 32,
    Pointlight = 63,
    DirectionalCascade0 = 64,
    DirectionalCascade1 = 128,
    DirectionalCascade2 = 256,
    DirectionalCascade3 = 512,
    Directional = 960,
    Spotlight = 1024,
    All = 2047,
}
declare const enum DefaultReflectionMode {
    Skybox = 0,
    Custom = 1,
}
declare const enum UnloadSceneOptions {
    None = 0,
    UnloadAllEmbeddedSceneObjects = 1,
}
declare const enum AccessorySlot {
    Hat = 0,
    Hair = 1,
    RightHand = 2,
    LeftHand = 3,
    Shirt = 4,
    Root = 5,
}
declare const enum AccessoryAddMode {
    ReplaceAll = 0,
    Replace = 1,
    Additive = 2,
    AddIfNone = 3,
}
declare const enum ParticleSystemSimulationSpace {
    Local = 0,
    World = 1,
    Custom = 2,
}
declare const enum ParticleSystemScalingMode {
    Hierarchy = 0,
    Local = 1,
    Shape = 2,
}
declare const enum ParticleSystemCurveMode {
    Constant = 0,
    Curve = 1,
    TwoCurves = 2,
    TwoConstants = 3,
}
declare const enum ParticleSystemGradientMode {
    Color = 0,
    Gradient = 1,
    TwoColors = 2,
    TwoGradients = 3,
    RandomColor = 4,
}
declare const enum GradientMode {
    Blend = 0,
    Fixed = 1,
}
declare const enum ParticleSystemEmitterVelocityMode {
    Transform = 0,
    Rigidbody = 1,
    Custom = 2,
}
declare const enum ParticleSystemStopAction {
    None = 0,
    Disable = 1,
    Destroy = 2,
    Callback = 3,
}
declare const enum ParticleSystemRingBufferMode {
    Disabled = 0,
    PauseUntilReplaced = 1,
    LoopUntilReplaced = 2,
}
declare const enum ParticleSystemCullingMode {
    Automatic = 0,
    PauseAndCatchup = 1,
    Pause = 2,
    AlwaysSimulate = 3,
}
declare const enum ParticleSystemEmissionType {
    Time = 0,
    Distance = 1,
}
declare const enum ParticleSystemShapeType {
    Sphere = 0,
    SphereShell = 1,
    Hemisphere = 2,
    HemisphereShell = 3,
    Cone = 4,
    Box = 5,
    Mesh = 6,
    ConeShell = 7,
    ConeVolume = 8,
    ConeVolumeShell = 9,
    Circle = 10,
    CircleEdge = 11,
    SingleSidedEdge = 12,
    MeshRenderer = 13,
    SkinnedMeshRenderer = 14,
    BoxShell = 15,
    BoxEdge = 16,
    Donut = 17,
    Rectangle = 18,
    Sprite = 19,
    SpriteRenderer = 20,
}
declare const enum ParticleSystemShapeMultiModeValue {
    Random = 0,
    Loop = 1,
    PingPong = 2,
    BurstSpread = 3,
}
declare const enum ParticleSystemMeshShapeType {
    Vertex = 0,
    Edge = 1,
    Triangle = 2,
}
declare const enum SkinQuality {
    Auto = 0,
    Bone1 = 1,
    Bone2 = 2,
    Bone4 = 4,
}
declare const enum SpriteDrawMode {
    Simple = 0,
    Sliced = 1,
    Tiled = 2,
}
declare const enum SpriteTileMode {
    Continuous = 0,
    Adaptive = 1,
}
declare const enum SpriteMaskInteraction {
    None = 0,
    VisibleInsideMask = 1,
    VisibleOutsideMask = 2,
}
declare const enum SpriteSortPoint {
    Center = 0,
    Pivot = 1,
}
declare const enum ParticleSystemShapeTextureChannel {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
}
declare const enum ParticleSystemInheritVelocityMode {
    Initial = 0,
    Current = 1,
}
declare const enum ParticleSystemGameObjectFilter {
    LayerMask = 0,
    List = 1,
    LayerMaskAndList = 2,
}
declare const enum ParticleSystemForceFieldShape {
    Sphere = 0,
    Hemisphere = 1,
    Cylinder = 2,
    Box = 3,
}
declare const enum ParticleSystemNoiseQuality {
    Low = 0,
    Medium = 1,
    High = 2,
}
declare const enum ParticleSystemCollisionType {
    Planes = 0,
    World = 1,
}
declare const enum ParticleSystemCollisionMode {
    Collision3D = 0,
    Collision2D = 1,
}
declare const enum ParticleSystemCollisionQuality {
    High = 0,
    Medium = 1,
    Low = 2,
}
declare const enum ParticleSystemOverlapAction {
    Ignore = 0,
    Kill = 1,
    Callback = 2,
}
declare const enum ParticleSystemColliderQueryMode {
    Disabled = 0,
    One = 1,
    All = 2,
}
declare const enum ParticleSystemSubEmitterType {
    Birth = 0,
    Collision = 1,
    Death = 2,
    Trigger = 3,
    Manual = 4,
}
declare const enum ParticleSystemSubEmitterProperties {
    InheritNothing = 0,
    InheritColor = 1,
    InheritSize = 2,
    InheritRotation = 4,
    InheritLifetime = 8,
    InheritDuration = 16,
    InheritEverything = 31,
}
declare const enum ParticleSystemAnimationMode {
    Grid = 0,
    Sprites = 1,
}
declare const enum ParticleSystemAnimationTimeMode {
    Lifetime = 0,
    Speed = 1,
    FPS = 2,
}
declare const enum ParticleSystemAnimationType {
    WholeSheet = 0,
    SingleRow = 1,
}
declare const enum ParticleSystemAnimationRowMode {
    Custom = 0,
    Random = 1,
    MeshIndex = 2,
}
declare const enum UVChannelFlags {
    UV0 = 1,
    UV1 = 2,
    UV2 = 4,
    UV3 = 8,
}
declare const enum ParticleSystemTrailMode {
    PerParticle = 0,
    Ribbon = 1,
}
declare const enum ParticleSystemTrailTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3,
}
declare const enum ParticleSystemCustomData {
    Custom1 = 0,
    Custom2 = 1,
}
declare const enum ParticleSystemCustomDataMode {
    Disabled = 0,
    Vector = 1,
    Color = 2,
}
declare const enum ParticleSystemStopBehavior {
    StopEmittingAndClear = 0,
    StopEmitting = 1,
}
declare const enum FadeMode {
    FixedSpeed = 0,
    FixedDuration = 1,
    FromStart = 2,
    NormalizedSpeed = 3,
    NormalizedDuration = 4,
    NormalizedFromStart = 5,
}
declare const enum AvatarMaskBodyPart {
    Root = 0,
    Body = 1,
    Head = 2,
    LeftLeg = 3,
    RightLeg = 4,
    LeftArm = 5,
    RightArm = 6,
    LeftFingers = 7,
    RightFingers = 8,
    LeftFootIK = 9,
    RightFootIK = 10,
    LeftHandIK = 11,
    RightHandIK = 12,
    LastBodyPart = 13,
}
declare const enum KnownVectorType {
    LocalForward = 0,
    LocalBack = 1,
    LocalRight = 2,
    LocalLeft = 3,
    LocalUp = 4,
    LocalDown = 5,
    WorldForward = 6,
    WorldBack = 7,
    WorldRight = 8,
    WorldLeft = 9,
    WorldUp = 10,
    WorldDown = 11,
    CameraForward = 12,
    CameraBack = 13,
    CameraRight = 14,
    CameraLeft = 15,
    CameraUp = 16,
    CameraDown = 17,
}
declare const enum ApplicationInstallMode {
    Unknown = 0,
    Store = 1,
    DeveloperBuild = 2,
    Adhoc = 3,
    Enterprise = 4,
    Editor = 5,
}
declare const enum ApplicationSandboxType {
    Unknown = 0,
    NotSandboxed = 1,
    Sandboxed = 2,
    SandboxBroken = 3,
}
declare const enum StackTraceLogType {
    None = 0,
    ScriptOnly = 1,
    Full = 2,
}
declare const enum ThreadPriority {
    Low = 0,
    BelowNormal = 1,
    Normal = 2,
    High = 4,
}
declare const enum RuntimePlatform {
    OSXEditor = 0,
    OSXPlayer = 1,
    WindowsPlayer = 2,
    OSXWebPlayer = 3,
    OSXDashboardPlayer = 4,
    WindowsWebPlayer = 5,
    WindowsEditor = 7,
    IPhonePlayer = 8,
    PS3 = 9,
    XBOX360 = 10,
    Android = 11,
    NaCl = 12,
    LinuxPlayer = 13,
    FlashPlayer = 15,
    LinuxEditor = 16,
    WebGLPlayer = 17,
    MetroPlayerX86 = 18,
    WSAPlayerX86 = 18,
    MetroPlayerX64 = 19,
    WSAPlayerX64 = 19,
    MetroPlayerARM = 20,
    WSAPlayerARM = 20,
    WP8Player = 21,
    BlackBerryPlayer = 22,
    BB10Player = 22,
    TizenPlayer = 23,
    PSP2 = 24,
    PS4 = 25,
    PSM = 26,
    XboxOne = 27,
    SamsungTVPlayer = 28,
    WiiU = 30,
    tvOS = 31,
    Switch = 32,
    Lumin = 33,
    Stadia = 34,
    CloudRendering = 35,
    GameCoreXboxSeries = 36,
    GameCoreXboxOne = 37,
    PS5 = 38,
    EmbeddedLinuxArm64 = 39,
    EmbeddedLinuxArm32 = 40,
    EmbeddedLinuxX64 = 41,
    EmbeddedLinuxX86 = 42,
    LinuxServer = 43,
    WindowsServer = 44,
    OSXServer = 45,
    GameCoreScarlett = -1,
}
declare const enum SystemLanguage {
    Afrikaans = 0,
    Arabic = 1,
    Basque = 2,
    Belarusian = 3,
    Bulgarian = 4,
    Catalan = 5,
    Chinese = 6,
    Czech = 7,
    Danish = 8,
    Dutch = 9,
    English = 10,
    Estonian = 11,
    Faroese = 12,
    Finnish = 13,
    French = 14,
    German = 15,
    Greek = 16,
    Hebrew = 17,
    Hungarian = 18,
    Hugarian = 18,
    Icelandic = 19,
    Indonesian = 20,
    Italian = 21,
    Japanese = 22,
    Korean = 23,
    Latvian = 24,
    Lithuanian = 25,
    Norwegian = 26,
    Polish = 27,
    Portuguese = 28,
    Romanian = 29,
    Russian = 30,
    SerboCroatian = 31,
    Slovak = 32,
    Slovenian = 33,
    Spanish = 34,
    Swedish = 35,
    Thai = 36,
    Turkish = 37,
    Ukrainian = 38,
    Vietnamese = 39,
    ChineseSimplified = 40,
    ChineseTraditional = 41,
    Unknown = 42,
}
declare const enum NetworkReachability {
    NotReachable = 0,
    ReachableViaCarrierDataNetwork = 1,
    ReachableViaLocalAreaNetwork = 2,
}
declare const enum UserAuthorization {
    WebCam = 1,
    Microphone = 2,
}
declare const enum ParticleSystemRenderSpace {
    View = 0,
    World = 1,
    Local = 2,
    Facing = 3,
    Velocity = 4,
}
declare const enum ParticleSystemRenderMode {
    Billboard = 0,
    Stretch = 1,
    HorizontalBillboard = 2,
    VerticalBillboard = 3,
    Mesh = 4,
    None = 5,
}
declare const enum ParticleSystemMeshDistribution {
    UniformRandom = 0,
    NonUniformRandom = 1,
}
declare const enum ParticleSystemSortMode {
    None = 0,
    Distance = 1,
    OldestInFront = 2,
    YoungestInFront = 3,
    Depth = 4,
}
declare const enum ParticleSystemVertexStreams {
    None = 0,
    Position = 1,
    Normal = 2,
    Tangent = 4,
    Color = 8,
    UV = 16,
    UV2BlendAndFrame = 32,
    CenterAndVertexID = 64,
    Size = 128,
    Rotation = 256,
    Velocity = 512,
    Lifetime = 1024,
    Custom1 = 2048,
    Custom2 = 4096,
    Random = 8192,
    All = 2147483647,
}
declare const enum ParticleSystemVertexStream {
    Position = 0,
    Normal = 1,
    Tangent = 2,
    Color = 3,
    UV = 4,
    UV2 = 5,
    UV3 = 6,
    UV4 = 7,
    AnimBlend = 8,
    AnimFrame = 9,
    Center = 10,
    VertexID = 11,
    SizeX = 12,
    SizeXY = 13,
    SizeXYZ = 14,
    Rotation = 15,
    Rotation3D = 16,
    RotationSpeed = 17,
    RotationSpeed3D = 18,
    Velocity = 19,
    Speed = 20,
    AgePercent = 21,
    InvStartLifetime = 22,
    StableRandomX = 23,
    StableRandomXY = 24,
    StableRandomXYZ = 25,
    StableRandomXYZW = 26,
    VaryingRandomX = 27,
    VaryingRandomXY = 28,
    VaryingRandomXYZ = 29,
    VaryingRandomXYZW = 30,
    Custom1X = 31,
    Custom1XY = 32,
    Custom1XYZ = 33,
    Custom1XYZW = 34,
    Custom2X = 35,
    Custom2XY = 36,
    Custom2XYZ = 37,
    Custom2XYZW = 38,
    NoiseSumX = 39,
    NoiseSumXY = 40,
    NoiseSumXYZ = 41,
    NoiseImpulseX = 42,
    NoiseImpulseXY = 43,
    NoiseImpulseXYZ = 44,
    MeshIndex = 45,
}
declare const enum ProfilerArea {
    CPU = 0,
    GPU = 1,
    Rendering = 2,
    Memory = 3,
    Audio = 4,
    Video = 5,
    Physics = 6,
    Physics2D = 7,
    NetworkMessages = 8,
    NetworkOperations = 9,
    UI = 10,
    UIDetails = 11,
    GlobalIllumination = 12,
    VirtualTexturing = 13,
}
declare const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    TopToBottom = 3,
}
declare const enum ContentType {
    Standard = 0,
    Autocorrected = 1,
    IntegerNumber = 2,
    DecimalNumber = 3,
    Alphanumeric = 4,
    Name = 5,
    EmailAddress = 6,
    Password = 7,
    Pin = 8,
    Custom = 9,
}
declare const enum LineType {
    SingleLine = 0,
    MultiLineSubmit = 1,
    MultiLineNewline = 2,
}
declare const enum InputType {
    Standard = 0,
    AutoCorrect = 1,
    Password = 2,
}
declare const enum TouchScreenKeyboardType {
    Default = 0,
    ASCIICapable = 1,
    NumbersAndPunctuation = 2,
    URL = 3,
    NumberPad = 4,
    PhonePad = 5,
    NamePhonePad = 6,
    EmailAddress = 7,
    NintendoNetworkAccount = 8,
    Social = 9,
    Search = 10,
    DecimalPad = 11,
    OneTimeCode = 12,
}
declare const enum CharacterValidation {
    None = 0,
    Digit = 1,
    Integer = 2,
    Decimal = 3,
    Alphanumeric = 4,
    Name = 5,
    Regex = 6,
    EmailAddress = 7,
    CustomValidator = 8,
}
declare const enum EventType {
    MouseDown = 0,
    mouseDown = 0,
    MouseUp = 1,
    mouseUp = 1,
    MouseMove = 2,
    mouseMove = 2,
    mouseDrag = 3,
    MouseDrag = 3,
    KeyDown = 4,
    keyDown = 4,
    keyUp = 5,
    KeyUp = 5,
    ScrollWheel = 6,
    scrollWheel = 6,
    Repaint = 7,
    repaint = 7,
    Layout = 8,
    layout = 8,
    DragUpdated = 9,
    dragUpdated = 9,
    dragPerform = 10,
    DragPerform = 10,
    ignore = 11,
    Ignore = 11,
    used = 12,
    Used = 12,
    ValidateCommand = 13,
    ExecuteCommand = 14,
    DragExited = 15,
    ContextClick = 16,
    MouseEnterWindow = 20,
    MouseLeaveWindow = 21,
    TouchDown = 30,
    TouchUp = 31,
    TouchMove = 32,
    TouchEnter = 33,
    TouchLeave = 34,
    TouchStationary = 35,
}
declare const enum PointerType {
    Mouse = 0,
    Touch = 1,
    Pen = 2,
}
declare const enum EventModifiers {
    None = 0,
    Shift = 1,
    Control = 2,
    Alt = 4,
    Command = 8,
    Numeric = 16,
    CapsLock = 32,
    FunctionKey = 64,
}
declare const enum RigidbodyType2D {
    Dynamic = 0,
    Kinematic = 1,
    Static = 2,
}
declare const enum RigidbodyConstraints2D {
    None = 0,
    FreezePositionX = 1,
    FreezePositionY = 2,
    FreezePosition = 3,
    FreezeRotation = 4,
    FreezeAll = 7,
}
declare const enum RigidbodyInterpolation2D {
    None = 0,
    Interpolate = 1,
    Extrapolate = 2,
}
declare const enum RigidbodySleepMode2D {
    NeverSleep = 0,
    StartAwake = 1,
    StartAsleep = 2,
}
declare const enum CollisionDetectionMode2D {
    None = 0,
    Discrete = 0,
    Continuous = 1,
}
declare const enum ForceMode2D {
    Force = 0,
    Impulse = 1,
}
declare const enum GeometryType {
    Outlines = 0,
    Polygons = 1,
}
declare const enum GenerationType {
    Synchronous = 0,
    Manual = 1,
}
declare const enum ColliderErrorState2D {
    None = 0,
    NoShapes = 1,
    RemovedShapes = 2,
}
declare const enum PhysicsShapeType2D {
    Circle = 0,
    Capsule = 1,
    Polygon = 2,
    Edges = 3,
}
declare const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    TopToBottom = 3,
}
declare const enum AudioClipLoadType {
    DecompressOnLoad = 0,
    CompressedInMemory = 1,
    Streaming = 2,
}
declare const enum AudioDataLoadState {
    Unloaded = 0,
    Loading = 1,
    Loaded = 2,
    Failed = 3,
}
declare const enum AudioMixerUpdateMode {
    Normal = 0,
    UnscaledTime = 1,
}
declare const enum GamepadSpeakerOutputType {
    Speaker = 0,
    Vibration = 1,
    SecondaryVibration = 2,
}
declare const enum AudioVelocityUpdateMode {
    Auto = 0,
    Fixed = 1,
    Dynamic = 2,
}
declare const enum AudioRolloffMode {
    Logarithmic = 0,
    Linear = 1,
    Custom = 2,
}
declare const enum AudioSourceCurveType {
    CustomRolloff = 0,
    SpatialBlend = 1,
    ReverbZoneMix = 2,
    Spread = 3,
}
declare const enum FFTWindow {
    Rectangular = 0,
    Triangle = 1,
    Hamming = 2,
    Hanning = 3,
    Blackman = 4,
    BlackmanHarris = 5,
}
declare const enum EaseType {
    Linear = 0,
    SineIn = 10,
    SineOut = 11,
    SineInOut = 12,
    QuadIn = 20,
    QuadOut = 21,
    QuadInOut = 22,
    CubicIn = 30,
    CubicOut = 31,
    CubicInOut = 32,
    QuartIn = 40,
    QuartOut = 41,
    QuartInOut = 42,
    QuintIn = 50,
    QuintOut = 51,
    QuintInOut = 52,
    ExpoIn = 60,
    ExpoOut = 61,
    ExpoInOut = 62,
    CircIn = 70,
    CircOut = 71,
    CircInOut = 72,
    BackIn = 80,
    BackOut = 81,
    BackInOut = 82,
    ElasticIn = 90,
    ElasticOut = 91,
    ElasticInOut = 92,
    BounceIn = 100,
    BounceOut = 101,
    BounceInOut = 102,
}
declare const enum StereoScreenCaptureMode {
    LeftEye = 1,
    RightEye = 2,
    BothEyes = 3,
}
declare const enum CollisionFlags {
    None = 0,
    Sides = 1,
    CollidedSides = 1,
    Above = 2,
    CollidedAbove = 2,
    Below = 4,
    CollidedBelow = 4,
}
declare const enum LineTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3,
}
declare const enum LineAlignment {
    View = 0,
    Local = 1,
    TransformZ = 1,
}
declare const enum EntityAnimationEventKey {
    FOOTSTEP = 0,
    JUMP = 1,
    LAND = 2,
    SLIDE_START = 3,
    SLIDE_END = 4,
    DEFAULT = -1,
}

    
interface RaycastHit {
    textureCoord1: Vector2;
    collider: Collider;
    colliderInstanceID: number;
    point: Vector3;
    normal: Vector3;
    barycentricCoordinate: Vector3;
    distance: number;
    triangleIndex: number;
    textureCoord: Vector2;
    textureCoord2: Vector2;
    transform: Transform;
    rigidbody: Rigidbody;
    articulationBody: ArticulationBody;
    lightmapCoord: Vector2;


}
    
interface Vector2 {
    x: number;
    y: number;
    Item: number;
    normalized: Vector2;
    magnitude: number;
    sqrMagnitude: number;

    constructor(x: number, y: number): Vector2;

    Equals(other: unknown): boolean;
    Equals(other: Vector2): boolean;
    GetHashCode(): number;
    Normalize(): void;
    Scale(scale: Vector2): void;
    Set(newX: number, newY: number): void;
    SqrMagnitude(): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Vector2Constructor {
    kEpsilon: number;
    kEpsilonNormalSqrt: number;
    zero: Vector2;
    one: Vector2;
    up: Vector2;
    down: Vector2;
    left: Vector2;
    right: Vector2;
    positiveInfinity: Vector2;
    negativeInfinity: Vector2;


    Angle(from: Vector2, to: Vector2): number;
    ClampMagnitude(vector: Vector2, maxLength: number): Vector2;
    Distance(a: Vector2, b: Vector2): number;
    Dot(lhs: Vector2, rhs: Vector2): number;
    Lerp(a: Vector2, b: Vector2, t: number): Vector2;
    LerpUnclamped(a: Vector2, b: Vector2, t: number): Vector2;
    Max(lhs: Vector2, rhs: Vector2): Vector2;
    Min(lhs: Vector2, rhs: Vector2): Vector2;
    MoveTowards(current: Vector2, target: Vector2, maxDistanceDelta: number): Vector2;
    Perpendicular(inDirection: Vector2): Vector2;
    Reflect(inDirection: Vector2, inNormal: Vector2): Vector2;
    Scale(a: Vector2, b: Vector2): Vector2;
    SignedAngle(from: Vector2, to: Vector2): number;
    SmoothDamp(current: Vector2, target: Vector2, currentVelocity: unknown, smoothTime: number, maxSpeed: number): Vector2;
    SmoothDamp(current: Vector2, target: Vector2, currentVelocity: unknown, smoothTime: number): Vector2;
    SmoothDamp(current: Vector2, target: Vector2, currentVelocity: unknown, smoothTime: number, maxSpeed: number, deltaTime: number): Vector2;
    SqrMagnitude(a: Vector2): number;
}
declare const Vector2: Vector2Constructor;
    
    
    
    
    
    
    
    
interface Matrix4x4 {
    m00: number;
    m10: number;
    m20: number;
    m30: number;
    m01: number;
    m11: number;
    m21: number;
    m31: number;
    m02: number;
    m12: number;
    m22: number;
    m32: number;
    m03: number;
    m13: number;
    m23: number;
    m33: number;
    rotation: Quaternion;
    lossyScale: Vector3;
    isIdentity: boolean;
    determinant: number;
    decomposeProjection: FrustumPlanes;
    inverse: Matrix4x4;
    transpose: Matrix4x4;
    Item: number;

    constructor(column0: Vector4, column1: Vector4, column2: Vector4, column3: Vector4): Matrix4x4;

    Equals(other: unknown): boolean;
    Equals(other: Matrix4x4): boolean;
    GetColumn(index: number): Vector4;
    GetHashCode(): number;
    GetPosition(): Vector3;
    GetRow(index: number): Vector4;
    MultiplyPoint(point: Vector3): Vector3;
    MultiplyPoint3x4(point: Vector3): Vector3;
    MultiplyVector(vector: Vector3): Vector3;
    SetColumn(index: number, column: Vector4): void;
    SetRow(index: number, row: Vector4): void;
    SetTRS(pos: Vector3, q: Quaternion, s: Vector3): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
    TransformPlane(plane: Plane): Plane;
    ValidTRS(): boolean;
}
    
interface FrustumPlanes {
    left: number;
    right: number;
    bottom: number;
    top: number;
    zNear: number;
    zFar: number;


}
    
interface Vector4 {
    x: number;
    y: number;
    z: number;
    w: number;
    Item: number;
    normalized: Vector4;
    magnitude: number;
    sqrMagnitude: number;

    constructor(x: number, y: number, z: number, w: number): Vector4;
    constructor(x: number, y: number, z: number): Vector4;
    constructor(x: number, y: number): Vector4;

    Equals(other: unknown): boolean;
    Equals(other: Vector4): boolean;
    GetHashCode(): number;
    Normalize(): void;
    Scale(scale: Vector4): void;
    Set(newX: number, newY: number, newZ: number, newW: number): void;
    SqrMagnitude(): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Vector4Constructor {
    kEpsilon: number;
    zero: Vector4;
    one: Vector4;
    positiveInfinity: Vector4;
    negativeInfinity: Vector4;


    Distance(a: Vector4, b: Vector4): number;
    Dot(a: Vector4, b: Vector4): number;
    Lerp(a: Vector4, b: Vector4, t: number): Vector4;
    LerpUnclamped(a: Vector4, b: Vector4, t: number): Vector4;
    Magnitude(a: Vector4): number;
    Max(lhs: Vector4, rhs: Vector4): Vector4;
    Min(lhs: Vector4, rhs: Vector4): Vector4;
    MoveTowards(current: Vector4, target: Vector4, maxDistanceDelta: number): Vector4;
    Normalize(a: Vector4): Vector4;
    Project(a: Vector4, b: Vector4): Vector4;
    Scale(a: Vector4, b: Vector4): Vector4;
    SqrMagnitude(a: Vector4): number;
}
declare const Vector4: Vector4Constructor;
    
interface Plane {
    normal: Vector3;
    distance: number;
    flipped: Plane;

    constructor(inNormal: Vector3, inPoint: Vector3): Plane;
    constructor(inNormal: Vector3, d: number): Plane;
    constructor(a: Vector3, b: Vector3, c: Vector3): Plane;

    ClosestPointOnPlane(point: Vector3): Vector3;
    Flip(): void;
    GetDistanceToPoint(point: Vector3): number;
    GetSide(point: Vector3): boolean;
    Raycast(ray: Ray, enter: unknown): boolean;
    SameSide(inPt0: Vector3, inPt1: Vector3): boolean;
    Set3Points(a: Vector3, b: Vector3, c: Vector3): void;
    SetNormalAndPosition(inNormal: Vector3, inPoint: Vector3): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
    Translate(translation: Vector3): void;
}
    
    
interface PlaneConstructor {


    Translate(plane: Plane, translation: Vector3): Plane;
}
declare const Plane: PlaneConstructor;
    
interface Matrix4x4Constructor {
    zero: Matrix4x4;
    identity: Matrix4x4;


    Determinant(m: Matrix4x4): number;
    Frustum(left: number, right: number, bottom: number, top: number, zNear: number, zFar: number): Matrix4x4;
    Frustum(fp: FrustumPlanes): Matrix4x4;
    Inverse(m: Matrix4x4): Matrix4x4;
    Inverse3DAffine(input: Matrix4x4, result: unknown): boolean;
    LookAt(from: Vector3, to: Vector3, up: Vector3): Matrix4x4;
    Ortho(left: number, right: number, bottom: number, top: number, zNear: number, zFar: number): Matrix4x4;
    Perspective(fov: number, aspect: number, zNear: number, zFar: number): Matrix4x4;
    Rotate(q: Quaternion): Matrix4x4;
    Scale(vector: Vector3): Matrix4x4;
    Translate(vector: Vector3): Matrix4x4;
    Transpose(m: Matrix4x4): Matrix4x4;
    TRS(pos: Vector3, q: Quaternion, s: Vector3): Matrix4x4;
}
declare const Matrix4x4: Matrix4x4Constructor;
    
    
interface Scene {
    handle: number;
    path: string;
    name: string;
    isLoaded: boolean;
    buildIndex: number;
    isDirty: boolean;
    rootCount: number;
    isSubScene: boolean;


    Equals(other: unknown): boolean;
    GetHashCode(): number;
    GetRootGameObjects(): CSArray<GameObject>;
    GetRootGameObjects(rootGameObjects: CSArray<GameObject>): void;
    IsValid(): boolean;
}
    
    
    
    
    
interface Collider extends Component {
    enabled: boolean;
    attachedRigidbody: Rigidbody;
    attachedArticulationBody: ArticulationBody;
    isTrigger: boolean;
    contactOffset: number;
    bounds: Bounds;
    hasModifiableContacts: boolean;
    sharedMaterial: PhysicMaterial;
    material: PhysicMaterial;

    constructor(): Collider;

    ClosestPoint(position: Vector3): Vector3;
    ClosestPointOnBounds(position: Vector3): Vector3;
    Raycast(ray: Ray, hitInfo: unknown, maxDistance: number): boolean;
}
    
interface Rigidbody extends Component {
    sleepVelocity: number;
    sleepAngularVelocity: number;
    useConeFriction: boolean;
    solverIterationCount: number;
    solverVelocityIterationCount: number;
    velocity: Vector3;
    angularVelocity: Vector3;
    drag: number;
    angularDrag: number;
    mass: number;
    useGravity: boolean;
    maxDepenetrationVelocity: number;
    isKinematic: boolean;
    freezeRotation: boolean;
    constraints: RigidbodyConstraints;
    collisionDetectionMode: CollisionDetectionMode;
    centerOfMass: Vector3;
    worldCenterOfMass: Vector3;
    inertiaTensorRotation: Quaternion;
    inertiaTensor: Vector3;
    detectCollisions: boolean;
    position: Vector3;
    rotation: Quaternion;
    interpolation: RigidbodyInterpolation;
    solverIterations: number;
    sleepThreshold: number;
    maxAngularVelocity: number;
    solverVelocityIterations: number;

    constructor(): Rigidbody;

    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number, mode: ForceMode): void;
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number): void;
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number): void;
    AddForce(force: Vector3, mode: ForceMode): void;
    AddForce(force: Vector3): void;
    AddForce(x: number, y: number, z: number, mode: ForceMode): void;
    AddForce(x: number, y: number, z: number): void;
    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
    AddForceAtPosition(force: Vector3, position: Vector3): void;
    AddRelativeForce(force: Vector3, mode: ForceMode): void;
    AddRelativeForce(force: Vector3): void;
    AddRelativeForce(x: number, y: number, z: number, mode: ForceMode): void;
    AddRelativeForce(x: number, y: number, z: number): void;
    AddRelativeTorque(torque: Vector3, mode: ForceMode): void;
    AddRelativeTorque(torque: Vector3): void;
    AddRelativeTorque(x: number, y: number, z: number, mode: ForceMode): void;
    AddRelativeTorque(x: number, y: number, z: number): void;
    AddTorque(torque: Vector3, mode: ForceMode): void;
    AddTorque(torque: Vector3): void;
    AddTorque(x: number, y: number, z: number, mode: ForceMode): void;
    AddTorque(x: number, y: number, z: number): void;
    ClosestPointOnBounds(position: Vector3): Vector3;
    GetPointVelocity(worldPoint: Vector3): Vector3;
    GetRelativePointVelocity(relativePoint: Vector3): Vector3;
    IsSleeping(): boolean;
    MovePosition(position: Vector3): void;
    MoveRotation(rot: Quaternion): void;
    ResetCenterOfMass(): void;
    ResetInertiaTensor(): void;
    SetDensity(density: number): void;
    SetMaxAngularVelocity(a: number): void;
    Sleep(): void;
    SweepTest(direction: Vector3, hitInfo: unknown, maxDistance: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SweepTest(direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    SweepTest(direction: Vector3, hitInfo: unknown): boolean;
    SweepTestAll(direction: Vector3, maxDistance: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    SweepTestAll(direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    SweepTestAll(direction: Vector3): CSArray<RaycastHit>;
    WakeUp(): void;
}
    
interface Behaviour extends Component {
    enabled: boolean;
    isActiveAndEnabled: boolean;

    constructor(): Behaviour;

}
    
interface ArticulationBody extends Behaviour {
    jointType: ArticulationJointType;
    anchorPosition: Vector3;
    parentAnchorPosition: Vector3;
    anchorRotation: Quaternion;
    parentAnchorRotation: Quaternion;
    isRoot: boolean;
    computeParentAnchor: boolean;
    matchAnchors: boolean;
    linearLockX: ArticulationDofLock;
    linearLockY: ArticulationDofLock;
    linearLockZ: ArticulationDofLock;
    swingYLock: ArticulationDofLock;
    swingZLock: ArticulationDofLock;
    twistLock: ArticulationDofLock;
    xDrive: ArticulationDrive;
    yDrive: ArticulationDrive;
    zDrive: ArticulationDrive;
    immovable: boolean;
    useGravity: boolean;
    linearDamping: number;
    angularDamping: number;
    jointFriction: number;
    velocity: Vector3;
    angularVelocity: Vector3;
    mass: number;
    centerOfMass: Vector3;
    worldCenterOfMass: Vector3;
    inertiaTensor: Vector3;
    inertiaTensorRotation: Quaternion;
    sleepThreshold: number;
    solverIterations: number;
    solverVelocityIterations: number;
    maxAngularVelocity: number;
    maxLinearVelocity: number;
    maxJointVelocity: number;
    maxDepenetrationVelocity: number;
    jointPosition: ArticulationReducedSpace;
    jointVelocity: ArticulationReducedSpace;
    jointAcceleration: ArticulationReducedSpace;
    jointForce: ArticulationReducedSpace;
    dofCount: number;
    index: number;
    collisionDetectionMode: CollisionDetectionMode;

    constructor(): ArticulationBody;

    AddForce(force: Vector3, mode: ForceMode): void;
    AddForce(force: Vector3): void;
    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
    AddForceAtPosition(force: Vector3, position: Vector3): void;
    AddRelativeForce(force: Vector3, mode: ForceMode): void;
    AddRelativeForce(force: Vector3): void;
    AddRelativeTorque(torque: Vector3, mode: ForceMode): void;
    AddRelativeTorque(torque: Vector3): void;
    AddTorque(torque: Vector3, mode: ForceMode): void;
    AddTorque(torque: Vector3): void;
    GetClosestPoint(point: Vector3): Vector3;
    GetDenseJacobian(jacobian: unknown): number;
    GetDofStartIndices(dofStartIndices: CSArray<number>): number;
    GetDriveTargets(targets: CSArray<number>): number;
    GetDriveTargetVelocities(targetVelocities: CSArray<number>): number;
    GetJointAccelerations(accelerations: CSArray<number>): number;
    GetJointForces(forces: CSArray<number>): number;
    GetJointPositions(positions: CSArray<number>): number;
    GetJointVelocities(velocities: CSArray<number>): number;
    GetPointVelocity(worldPoint: Vector3): Vector3;
    GetRelativePointVelocity(relativePoint: Vector3): Vector3;
    IsSleeping(): boolean;
    ResetCenterOfMass(): void;
    ResetInertiaTensor(): void;
    SetDriveTargets(targets: CSArray<number>): void;
    SetDriveTargetVelocities(targetVelocities: CSArray<number>): void;
    SetJointAccelerations(accelerations: CSArray<number>): void;
    SetJointForces(forces: CSArray<number>): void;
    SetJointPositions(positions: CSArray<number>): void;
    SetJointVelocities(velocities: CSArray<number>): void;
    Sleep(): void;
    SnapAnchorToClosestContact(): void;
    TeleportRoot(position: Vector3, rotation: Quaternion): void;
    WakeUp(): void;
}
    
interface ArticulationDrive {
    lowerLimit: number;
    upperLimit: number;
    stiffness: number;
    damping: number;
    forceLimit: number;
    target: number;
    targetVelocity: number;


}
    
interface ArticulationReducedSpace {
    dofCount: number;
    Item: number;

    constructor(a: number): ArticulationReducedSpace;
    constructor(a: number, b: number): ArticulationReducedSpace;
    constructor(a: number, b: number, c: number): ArticulationReducedSpace;

}
    
interface Bounds {
    center: Vector3;
    size: Vector3;
    extents: Vector3;
    min: Vector3;
    max: Vector3;

    constructor(center: Vector3, size: Vector3): Bounds;

    ClosestPoint(point: Vector3): Vector3;
    Contains(point: Vector3): boolean;
    Encapsulate(point: Vector3): void;
    Encapsulate(bounds: Bounds): void;
    Equals(other: unknown): boolean;
    Equals(other: Bounds): boolean;
    Expand(amount: number): void;
    Expand(amount: Vector3): void;
    GetHashCode(): number;
    IntersectRay(ray: Ray): boolean;
    IntersectRay(ray: Ray, distance: unknown): boolean;
    Intersects(bounds: Bounds): boolean;
    SetMinMax(min: Vector3, max: Vector3): void;
    SqrDistance(point: Vector3): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface PhysicMaterial extends Object {
    bouncyness: number;
    frictionDirection2: Vector3;
    dynamicFriction2: number;
    staticFriction2: number;
    frictionDirection: Vector3;
    bounciness: number;
    dynamicFriction: number;
    staticFriction: number;
    frictionCombine: PhysicMaterialCombine;
    bounceCombine: PhysicMaterialCombine;

    constructor(): PhysicMaterial;
    constructor(name: string): PhysicMaterial;

}
    
interface Physics {

    constructor(): Physics;

}
    
interface PhysicsScene {


    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>): number;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    Equals(other: unknown): boolean;
    Equals(other: PhysicsScene): boolean;
    GetHashCode(): number;
    IsEmpty(): boolean;
    IsValid(): boolean;
    OverlapBox(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapBox(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>): number;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapSphere(position: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, raycastHits: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    Simulate(step: number): void;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    ToString(): string;
}
    
interface PhysicsConstructor {
    kIgnoreRaycastLayer: number;
    kDefaultRaycastLayers: number;
    kAllLayers: number;
    IgnoreRaycastLayer: number;
    DefaultRaycastLayers: number;
    AllLayers: number;
    minPenetrationForPenalty: number;
    bounceTreshold: number;
    sleepVelocity: number;
    sleepAngularVelocity: number;
    maxAngularVelocity: number;
    solverIterationCount: number;
    solverVelocityIterationCount: number;
    penetrationPenaltyForce: number;
    gravity: Vector3;
    defaultContactOffset: number;
    sleepThreshold: number;
    queriesHitTriggers: boolean;
    queriesHitBackfaces: boolean;
    bounceThreshold: number;
    defaultMaxDepenetrationVelocity: number;
    defaultSolverIterations: number;
    defaultSolverVelocityIterations: number;
    defaultMaxAngularSpeed: number;
    improvedPatchFriction: boolean;
    defaultPhysicsScene: PhysicsScene;
    autoSimulation: boolean;
    autoSyncTransforms: boolean;
    reuseCollisionCallbacks: boolean;
    interCollisionDistance: number;
    interCollisionStiffness: number;
    interCollisionSettingsToggle: boolean;
    clothGravity: Vector3;


    BakeMesh(meshID: number, convex: boolean): void;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number, layerMask: number): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown): boolean;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number): CSArray<RaycastHit>;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion): CSArray<RaycastHit>;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3): CSArray<RaycastHit>;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion): number;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number): number;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number): number;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>): number;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown): boolean;
    CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3): CSArray<RaycastHit>;
    CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number): number;
    CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>): number;
    CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layermask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number): boolean;
    CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion): boolean;
    CheckBox(center: Vector3, halfExtents: Vector3): boolean;
    CheckCapsule(start: Vector3, end: Vector3, radius: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CheckCapsule(start: Vector3, end: Vector3, radius: number, layerMask: number): boolean;
    CheckCapsule(start: Vector3, end: Vector3, radius: number): boolean;
    CheckSphere(position: Vector3, radius: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CheckSphere(position: Vector3, radius: number, layerMask: number): boolean;
    CheckSphere(position: Vector3, radius: number): boolean;
    ClosestPoint(point: Vector3, collider: Collider, position: Vector3, rotation: Quaternion): Vector3;
    ComputePenetration(colliderA: Collider, positionA: Vector3, rotationA: Quaternion, colliderB: Collider, positionB: Vector3, rotationB: Quaternion, direction: unknown, distance: unknown): boolean;
    GetIgnoreCollision(collider1: Collider, collider2: Collider): boolean;
    GetIgnoreLayerCollision(layer1: number, layer2: number): boolean;
    IgnoreCollision(collider1: Collider, collider2: Collider, ignore: boolean): void;
    IgnoreCollision(collider1: Collider, collider2: Collider): void;
    IgnoreLayerCollision(layer1: number, layer2: number, ignore: boolean): void;
    IgnoreLayerCollision(layer1: number, layer2: number): void;
    Linecast(start: Vector3, end: Vector3, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Linecast(start: Vector3, end: Vector3, layerMask: number): boolean;
    Linecast(start: Vector3, end: Vector3): boolean;
    Linecast(start: Vector3, end: Vector3, hitInfo: unknown, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Linecast(start: Vector3, end: Vector3, hitInfo: unknown, layerMask: number): boolean;
    Linecast(start: Vector3, end: Vector3, hitInfo: unknown): boolean;
    OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<Collider>;
    OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number): CSArray<Collider>;
    OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion): CSArray<Collider>;
    OverlapBox(center: Vector3, halfExtents: Vector3): CSArray<Collider>;
    OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion, mask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion, mask: number): number;
    OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion): number;
    OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>): number;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<Collider>;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, layerMask: number): CSArray<Collider>;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number): CSArray<Collider>;
    OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>, layerMask: number): number;
    OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>): number;
    OverlapSphere(position: Vector3, radius: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<Collider>;
    OverlapSphere(position: Vector3, radius: number, layerMask: number): CSArray<Collider>;
    OverlapSphere(position: Vector3, radius: number): CSArray<Collider>;
    OverlapSphereNonAlloc(position: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapSphereNonAlloc(position: Vector3, radius: number, results: CSArray<Collider>, layerMask: number): number;
    OverlapSphereNonAlloc(position: Vector3, radius: number, results: CSArray<Collider>): number;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number): boolean;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number): boolean;
    Raycast(origin: Vector3, direction: Vector3): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown): boolean;
    Raycast(ray: Ray, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(ray: Ray, maxDistance: number, layerMask: number): boolean;
    Raycast(ray: Ray, maxDistance: number): boolean;
    Raycast(ray: Ray): boolean;
    Raycast(ray: Ray, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(ray: Ray, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    Raycast(ray: Ray, hitInfo: unknown, maxDistance: number): boolean;
    Raycast(ray: Ray, hitInfo: unknown): boolean;
    RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    RaycastAll(origin: Vector3, direction: Vector3): CSArray<RaycastHit>;
    RaycastAll(ray: Ray, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    RaycastAll(ray: Ray, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    RaycastAll(ray: Ray, maxDistance: number): CSArray<RaycastHit>;
    RaycastAll(ray: Ray): CSArray<RaycastHit>;
    RaycastNonAlloc(ray: Ray, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    RaycastNonAlloc(ray: Ray, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    RaycastNonAlloc(ray: Ray, results: CSArray<RaycastHit>, maxDistance: number): number;
    RaycastNonAlloc(ray: Ray, results: CSArray<RaycastHit>): number;
    RaycastNonAlloc(origin: Vector3, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    RaycastNonAlloc(origin: Vector3, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    RaycastNonAlloc(origin: Vector3, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number): number;
    RaycastNonAlloc(origin: Vector3, direction: Vector3, results: CSArray<RaycastHit>): number;
    RebuildBroadphaseRegions(worldBounds: Bounds, subdivisions: number): void;
    Simulate(step: number): void;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown): boolean;
    SphereCast(ray: Ray, radius: number, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(ray: Ray, radius: number, maxDistance: number, layerMask: number): boolean;
    SphereCast(ray: Ray, radius: number, maxDistance: number): boolean;
    SphereCast(ray: Ray, radius: number): boolean;
    SphereCast(ray: Ray, radius: number, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(ray: Ray, radius: number, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    SphereCast(ray: Ray, radius: number, hitInfo: unknown, maxDistance: number): boolean;
    SphereCast(ray: Ray, radius: number, hitInfo: unknown): boolean;
    SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    SphereCastAll(origin: Vector3, radius: number, direction: Vector3): CSArray<RaycastHit>;
    SphereCastAll(ray: Ray, radius: number, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    SphereCastAll(ray: Ray, radius: number, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    SphereCastAll(ray: Ray, radius: number, maxDistance: number): CSArray<RaycastHit>;
    SphereCastAll(ray: Ray, radius: number): CSArray<RaycastHit>;
    SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number): number;
    SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>): number;
    SphereCastNonAlloc(ray: Ray, radius: number, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    SphereCastNonAlloc(ray: Ray, radius: number, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    SphereCastNonAlloc(ray: Ray, radius: number, results: CSArray<RaycastHit>, maxDistance: number): number;
    SphereCastNonAlloc(ray: Ray, radius: number, results: CSArray<RaycastHit>): number;
    SyncTransforms(): void;
}
declare const Physics: PhysicsConstructor;
    
interface MonoBehaviour extends Behaviour {
    useGUILayout: boolean;
    runInEditMode: boolean;

    constructor(): MonoBehaviour;

    CancelInvoke(): void;
    CancelInvoke(methodName: string): void;
    Invoke(methodName: string, time: number): void;
    InvokeRepeating(methodName: string, time: number, repeatRate: number): void;
    IsInvoking(): boolean;
    IsInvoking(methodName: string): boolean;
    StartCoroutine(methodName: string): Coroutine;
    StartCoroutine(methodName: string, value: unknown): Coroutine;
    StartCoroutine(routine: unknown): Coroutine;
    StartCoroutine_Auto(routine: unknown): Coroutine;
    StopAllCoroutines(): void;
    StopCoroutine(routine: unknown): void;
    StopCoroutine(routine: Coroutine): void;
    StopCoroutine(methodName: string): void;
}
    
interface YieldInstruction {

    constructor(): YieldInstruction;

}
    
interface Coroutine extends YieldInstruction {


}
    
interface MonoBehaviourConstructor {


    print(message: unknown): void;
}
declare const MonoBehaviour: MonoBehaviourConstructor;
    
interface Debug {

    constructor(): Debug;

}
    
    
    
interface DebugConstructor {
    logger: unknown;
    unityLogger: unknown;
    developerConsoleVisible: boolean;
    isDebugBuild: boolean;


    Assert(condition: boolean, format: string, args: CSArray<unknown>): void;
    Assert(condition: boolean): void;
    Assert(condition: boolean, context: Object): void;
    Assert(condition: boolean, message: unknown): void;
    Assert(condition: boolean, message: string): void;
    Assert(condition: boolean, message: unknown, context: Object): void;
    Assert(condition: boolean, message: string, context: Object): void;
    AssertFormat(condition: boolean, format: string, args: CSArray<unknown>): void;
    AssertFormat(condition: boolean, context: Object, format: string, args: CSArray<unknown>): void;
    Break(): void;
    ClearDeveloperConsole(): void;
    DebugBreak(): void;
    DrawLine(start: Vector3, end: Vector3, color: Color, duration: number): void;
    DrawLine(start: Vector3, end: Vector3, color: Color): void;
    DrawLine(start: Vector3, end: Vector3): void;
    DrawLine(start: Vector3, end: Vector3, color: Color, duration: number, depthTest: boolean): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color): void;
    DrawRay(start: Vector3, dir: Vector3): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number, depthTest: boolean): void;
    ExtractStackTraceNoAlloc(buffer: unknown, bufferMax: number, projectFolder: string): number;
    Log(message: unknown): void;
    Log(message: unknown, context: Object): void;
    LogAssertion(message: unknown): void;
    LogAssertion(message: unknown, context: Object): void;
    LogAssertionFormat(format: string, args: CSArray<unknown>): void;
    LogAssertionFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogError(message: unknown): void;
    LogError(message: unknown, context: Object): void;
    LogErrorFormat(format: string, args: CSArray<unknown>): void;
    LogErrorFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogException(exception: unknown): void;
    LogException(exception: unknown, context: Object): void;
    LogFormat(format: string, args: CSArray<unknown>): void;
    LogFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogFormat(logType: LogType, logOptions: LogOption, context: Object, format: string, args: CSArray<unknown>): void;
    LogWarning(message: unknown): void;
    LogWarning(message: unknown, context: Object): void;
    LogWarningFormat(format: string, args: CSArray<unknown>): void;
    LogWarningFormat(context: Object, format: string, args: CSArray<unknown>): void;
}
declare const Debug: DebugConstructor;
    
interface Sprite extends Object {
    bounds: Bounds;
    rect: Rect;
    border: Vector4;
    texture: Texture2D;
    pixelsPerUnit: number;
    spriteAtlasTextureScale: number;
    associatedAlphaSplitTexture: Texture2D;
    pivot: Vector2;
    packed: boolean;
    packingMode: SpritePackingMode;
    packingRotation: SpritePackingRotation;
    textureRect: Rect;
    textureRectOffset: Vector2;
    vertices: CSArray<Vector2>;
    triangles: CSArray<number>;
    uv: CSArray<Vector2>;


    GetPhysicsShape(shapeIdx: number, physicsShape: CSArray<Vector2>): number;
    GetPhysicsShapeCount(): number;
    GetPhysicsShapePointCount(shapeIdx: number): number;
    OverrideGeometry(vertices: CSArray<Vector2>, triangles: CSArray<number>): void;
    OverridePhysicsShape(physicsShapes: CSArray<CSArray<Vector2>>): void;
}
    
interface Rect {
    x: number;
    y: number;
    position: Vector2;
    center: Vector2;
    min: Vector2;
    max: Vector2;
    width: number;
    height: number;
    size: Vector2;
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
    left: number;
    right: number;
    top: number;
    bottom: number;

    constructor(x: number, y: number, width: number, height: number): Rect;
    constructor(position: Vector2, size: Vector2): Rect;
    constructor(source: Rect): Rect;

    Contains(point: Vector2): boolean;
    Contains(point: Vector3): boolean;
    Contains(point: Vector3, allowInverse: boolean): boolean;
    Equals(other: unknown): boolean;
    Equals(other: Rect): boolean;
    GetHashCode(): number;
    Overlaps(other: Rect): boolean;
    Overlaps(other: Rect, allowInverse: boolean): boolean;
    Set(x: number, y: number, width: number, height: number): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface RectConstructor {
    zero: Rect;


    MinMaxRect(xmin: number, ymin: number, xmax: number, ymax: number): Rect;
    NormalizedToPoint(rectangle: Rect, normalizedRectCoordinates: Vector2): Vector2;
    PointToNormalized(rectangle: Rect, point: Vector2): Vector2;
}
declare const Rect: RectConstructor;
    
interface Texture extends Object {
    mipmapCount: number;
    graphicsFormat: GraphicsFormat;
    width: number;
    height: number;
    dimension: TextureDimension;
    isReadable: boolean;
    wrapMode: TextureWrapMode;
    wrapModeU: TextureWrapMode;
    wrapModeV: TextureWrapMode;
    wrapModeW: TextureWrapMode;
    filterMode: FilterMode;
    anisoLevel: number;
    mipMapBias: number;
    texelSize: Vector2;
    updateCount: number;
    imageContentsHash: Hash128;


    GetNativeTextureID(): number;
    GetNativeTexturePtr(): unknown;
    IncrementUpdateCount(): void;
}
    
interface Hash128 {
    isValid: boolean;

    constructor(u32_0: number, u32_1: number, u32_2: number, u32_3: number): Hash128;
    constructor(u64_0: number, u64_1: number): Hash128;

    Append(data: string): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(val: unknown): void;
    Append(val: number): void;
    Append(val: number): void;
    Append(data: unknown, size: number): void;
    CompareTo(rhs: Hash128): number;
    CompareTo(obj: unknown): number;
    Equals(obj: unknown): boolean;
    Equals(obj: Hash128): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface Hash128Constructor {


    Compute(data: string): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(val: unknown): Hash128;
    Compute(val: number): Hash128;
    Compute(val: number): Hash128;
    Compute(data: unknown, size: number): Hash128;
    Parse(hashString: string): Hash128;
}
declare const Hash128: Hash128Constructor;
    
interface TextureConstructor {
    GenerateAllMips: number;
    masterTextureLimit: number;
    anisotropicFiltering: AnisotropicFiltering;
    totalTextureMemory: number;
    desiredTextureMemory: number;
    targetTextureMemory: number;
    currentTextureMemory: number;
    nonStreamingTextureMemory: number;
    streamingMipmapUploadCount: number;
    streamingRendererCount: number;
    streamingTextureCount: number;
    nonStreamingTextureCount: number;
    streamingTexturePendingLoadCount: number;
    streamingTextureLoadingCount: number;
    streamingTextureForceLoadAll: boolean;
    streamingTextureDiscardUnusedMips: boolean;
    allowThreadedTextureCreation: boolean;


    SetGlobalAnisotropicFilteringLimits(forcedMin: number, globalMax: number): void;
    SetStreamingTextureMaterialDebugProperties(): void;
}
declare const Texture: TextureConstructor;
    
interface Texture2D extends Texture {
    format: TextureFormat;
    ignoreMipmapLimit: boolean;
    isReadable: boolean;
    vtOnly: boolean;
    streamingMipmaps: boolean;
    streamingMipmapsPriority: number;
    requestedMipmapLevel: number;
    minimumMipmapLevel: number;
    calculatedMipmapLevel: number;
    desiredMipmapLevel: number;
    loadingMipmapLevel: number;
    loadedMipmapLevel: number;
    alphaIsTransparency: boolean;

    constructor(width: number, height: number, format: DefaultFormat, flags: TextureCreationFlags): Texture2D;
    constructor(width: number, height: number, format: GraphicsFormat, flags: TextureCreationFlags): Texture2D;
    constructor(width: number, height: number, format: GraphicsFormat, mipCount: number, flags: TextureCreationFlags): Texture2D;
    constructor(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean): Texture2D;
    constructor(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean, linear: boolean): Texture2D;
    constructor(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean): Texture2D;
    constructor(width: number, height: number): Texture2D;

    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    ClearMinimumMipmapLevel(): void;
    ClearRequestedMipmapLevel(): void;
    Compress(highQuality: boolean): void;
    GetPixel(x: number, y: number): Color;
    GetPixel(x: number, y: number, mipLevel: number): Color;
    GetPixelBilinear(u: number, v: number): Color;
    GetPixelBilinear(u: number, v: number, mipLevel: number): Color;
    GetPixelData<T>(mipLevel: number): CSArray<T>;
    GetPixels(miplevel: number): CSArray<Color>;
    GetPixels(): CSArray<Color>;
    GetPixels(x: number, y: number, blockWidth: number, blockHeight: number, miplevel: number): CSArray<Color>;
    GetPixels(x: number, y: number, blockWidth: number, blockHeight: number): CSArray<Color>;
    GetPixels32(miplevel: number): CSArray<Color32>;
    GetPixels32(): CSArray<Color32>;
    GetRawTextureData<T>(): CSArray<T>;
    GetRawTextureData(): CSArray<number>;
    IsRequestedMipmapLevelLoaded(): boolean;
    LoadRawTextureData(data: unknown, size: number): void;
    LoadRawTextureData(data: CSArray<number>): void;
    LoadRawTextureData<T>(data: CSArray<T>): void;
    PackTextures(textures: CSArray<Texture2D>, padding: number, maximumAtlasSize: number, makeNoLongerReadable: boolean): CSArray<Rect>;
    PackTextures(textures: CSArray<Texture2D>, padding: number, maximumAtlasSize: number): CSArray<Rect>;
    PackTextures(textures: CSArray<Texture2D>, padding: number): CSArray<Rect>;
    ReadPixels(source: Rect, destX: number, destY: number, recalculateMipMaps: boolean): void;
    ReadPixels(source: Rect, destX: number, destY: number): void;
    Reinitialize(width: number, height: number): boolean;
    Reinitialize(width: number, height: number, format: TextureFormat, hasMipMap: boolean): boolean;
    Reinitialize(width: number, height: number, format: GraphicsFormat, hasMipMap: boolean): boolean;
    Resize(width: number, height: number): boolean;
    Resize(width: number, height: number, format: TextureFormat, hasMipMap: boolean): boolean;
    Resize(width: number, height: number, format: GraphicsFormat, hasMipMap: boolean): boolean;
    SetPixel(x: number, y: number, color: Color): void;
    SetPixel(x: number, y: number, color: Color, mipLevel: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color>, miplevel: number): void;
    SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color>): void;
    SetPixels(colors: CSArray<Color>, miplevel: number): void;
    SetPixels(colors: CSArray<Color>): void;
    SetPixels32(colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(colors: CSArray<Color32>): void;
    SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color32>): void;
    UpdateExternalTexture(nativeTex: unknown): void;
}
    
interface Color32 {
    r: number;
    g: number;
    b: number;
    a: number;
    Item: number;

    constructor(r: number, g: number, b: number, a: number): Color32;

    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Color32Constructor {


    Lerp(a: Color32, b: Color32, t: number): Color32;
    LerpUnclamped(a: Color32, b: Color32, t: number): Color32;
}
declare const Color32: Color32Constructor;
    
interface Texture2DConstructor {
    whiteTexture: Texture2D;
    blackTexture: Texture2D;
    redTexture: Texture2D;
    grayTexture: Texture2D;
    linearGrayTexture: Texture2D;
    normalTexture: Texture2D;


    CreateExternalTexture(width: number, height: number, format: TextureFormat, mipChain: boolean, linear: boolean, nativeTex: unknown): Texture2D;
    GenerateAtlas(sizes: CSArray<Vector2>, padding: number, atlasSize: number, results: CSArray<Rect>): boolean;
}
declare const Texture2D: Texture2DConstructor;
    
interface SpriteConstructor {


    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: boolean): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2): Sprite;
}
declare const Sprite: SpriteConstructor;
    
interface TextAsset extends Object {
    bytes: CSArray<number>;
    text: string;
    dataSize: number;

    constructor(): TextAsset;
    constructor(text: string): TextAsset;

    GetData<T>(): CSArray<T>;
    ToString(): string;
}
    
interface Resources {

    constructor(): Resources;

}
    
interface AsyncOperation extends YieldInstruction {
    isDone: boolean;
    progress: number;
    priority: number;
    allowSceneActivation: boolean;

    constructor(): AsyncOperation;

}
    
interface ResourceRequest extends AsyncOperation {
    asset: Object;

    constructor(): ResourceRequest;

}
    
interface ResourcesConstructor {


    FindObjectsOfTypeAll(type: unknown): CSArray<Object>;
    FindObjectsOfTypeAll<T>(): CSArray<T>;
    GetBuiltinResource(type: unknown, path: string): Object;
    GetBuiltinResource<T>(path: string): T;
    InstanceIDToObject(instanceID: number): Object;
    InstanceIDToObjectList(instanceIDs: CSArray<number>, objects: CSArray<Object>): void;
    Load(path: string): Object;
    Load<T>(path: string): T;
    Load(path: string, systemTypeInstance: unknown): Object;
    LoadAll(path: string, systemTypeInstance: unknown): CSArray<Object>;
    LoadAll(path: string): CSArray<Object>;
    LoadAll<T>(path: string): CSArray<T>;
    LoadAssetAtPath(assetPath: string, type: unknown): Object;
    LoadAssetAtPath<T>(assetPath: string): T;
    LoadAsync(path: string): ResourceRequest;
    LoadAsync<T>(path: string): ResourceRequest;
    LoadAsync(path: string, type: unknown): ResourceRequest;
    UnloadAsset(assetToUnload: Object): void;
    UnloadUnusedAssets(): AsyncOperation;
}
declare const Resources: ResourcesConstructor;
    
interface AgonesCore {

    constructor(): AgonesCore;

}
    
interface AgonesProxy extends MonoBehaviour {

    constructor(): AgonesProxy;

    Connect(): void;
    DoNothingTest(): Vector3;
    Ready(): void;
    Shutdown(): void;
    SleepTest(seconds: number): number;
}
    
interface AgonesCoreConstructor {
    Agones: AgonesProxy;


    SetAgonesProxy(agones: AgonesProxy): void;
}
declare const AgonesCore: AgonesCoreConstructor;
    
interface RunCore {

    constructor(): RunCore;

}
    
interface RunCoreConstructor {


    IsClient(): boolean;
    IsEditor(): boolean;
    IsServer(): boolean;
}
declare const RunCore: RunCoreConstructor;
    
interface NetworkCore {

    constructor(): NetworkCore;

}
    
interface Net extends MonoBehaviour {

    constructor(): Net;

    BroadcastToAllClients(blob: BinaryBlob, reliable: number): void;
    BroadcastToAllExceptClient(ignoredClientId: number, blob: BinaryBlob, reliable: number): void;
    BroadcastToClient(clientId: number, blob: BinaryBlob, reliable: number): void;
    BroadcastToClients(clientIds: CSArray<number>, blob: BinaryBlob, reliable: number): void;
    BroadcastToServer(blob: BinaryBlob, reliable: number): void;
}
    
interface BinaryBlob {
    m_dataSize: number;
    m_data: CSArray<number>;

    constructor(): BinaryBlob;
    constructor(bytes: CSArray<number>): BinaryBlob;

    GetDictionary(): CSDictionary<unknown, unknown>;
}
    
interface NetworkManager extends MonoBehaviour {
    Initialized: boolean;
    IsServer: boolean;
    IsServerOnly: boolean;
    IsClient: boolean;
    IsClientOnly: boolean;
    IsHost: boolean;
    IsOffline: boolean;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    ObserverManager: ObserverManager;
    Authenticator: Authenticator;
    DebugManager: DebugManager;
    StatisticsManager: StatisticsManager;
    ObjectPool: ObjectPool;
    RollbackManager: RollbackManager;
    SpawnablePrefabs: PrefabObjects;
    RuntimeSpawnablePrefabs: CSDictionary<number, PrefabObjects>;

    constructor(): NetworkManager;

    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    CanLog(loggingType: LoggingType): boolean;
    GetInstance<T>(warn: boolean): T;
    GetPooledInstantiated(prefab: NetworkObject, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: NetworkObject, collectionId: number, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: GameObject, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: GameObject, collectionId: number, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefabId: number, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    GetPrefab(prefabId: number, asServer: boolean): NetworkObject;
    GetPrefabIndex(prefab: GameObject, asServer: boolean): number;
    GetPrefabObjects<T>(spawnableCollectionId: number, createIfMissing: boolean): PrefabObjects;
    HasInstance<T>(): boolean;
    Log(value: string): void;
    Log(loggingType: LoggingType, value: string): void;
    LogError(value: string): void;
    LogWarning(value: string): void;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    RemoveSpawnableCollection(spawnableCollectionId: number): boolean;
    StorePooledInstantiated(instantiated: NetworkObject, prefabId: number, asServer: boolean): void;
    StorePooledInstantiated(instantiated: NetworkObject, asServer: boolean): void;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
}
    
interface ServerManager extends MonoBehaviour {
    Clients: CSDictionary<number, NetworkConnection>;
    Started: boolean;
    Objects: ServerObjects;
    NetworkManager: NetworkManager;
    Authenticator: Authenticator;

    constructor(): ServerManager;

    AnyServerStarted(excludedIndex: unknown): boolean;
    Broadcast<T>(connection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(connections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(networkObject: NetworkObject, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(connections: CSArray<NetworkConnection>, excludedConnection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(connections: CSArray<NetworkConnection>, excludedConnections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(excludedConnection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(excludedConnections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Despawn(go: GameObject, despawnType: unknown): void;
    Despawn(networkObject: NetworkObject, despawnType: unknown): void;
    GetAuthenticator(): Authenticator;
    GetStartOnHeadless(): boolean;
    Kick(conn: NetworkConnection, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(clientId: number, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(conn: NetworkConnection, reader: Reader, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    OneServerStarted(): boolean;
    RegisterBroadcast<T>(handler: unknown, requireAuthentication: boolean): void;
    SetAuthenticator(value: Authenticator): void;
    SetStartOnHeadless(value: boolean): void;
    Spawn(go: GameObject, ownerConnection: NetworkConnection): void;
    Spawn(nob: NetworkObject, ownerConnection: NetworkConnection): void;
    StartConnection(): boolean;
    StartConnection(port: number): boolean;
    StopConnection(sendDisconnectMessage: boolean): boolean;
    UnregisterBroadcast<T>(handler: unknown): void;
}
    
interface NetworkConnection {
    ClientId: number;
    Objects: CSArray<NetworkObject>;
    CustomData: unknown;
    PacketTick: EstimatedTick;
    LocalTick: EstimatedTick;
    LevelOfDetails: CSDictionary<NetworkObject, number>;
    NetworkManager: NetworkManager;
    TransportIndex: number;
    Authenticated: boolean;
    IsActive: boolean;
    IsValid: boolean;
    FirstObject: NetworkObject;
    Scenes: CSArray<Scene>;
    Disconnecting: boolean;
    Tick: number;
    LocalReplicateTick: number;
    IsHost: boolean;
    IsLocalClient: boolean;

    constructor(): NetworkConnection;
    constructor(manager: NetworkManager, clientId: number, transportIndex: number, asServer: boolean): NetworkConnection;

    Broadcast<T>(message: T, requireAuthenticated: boolean, channel: Channel): void;
    Disconnect(immediately: boolean): void;
    Equals(obj: unknown): boolean;
    Equals(nc: NetworkConnection): boolean;
    GetAddress(): string;
    GetHashCode(): number;
    Kick(kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(reader: Reader, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    LoadedStartScenes(): boolean;
    LoadedStartScenes(asServer: boolean): boolean;
    SetFirstObject(nob: NetworkObject): void;
    ToString(): string;
}
    
interface NetworkObject extends MonoBehaviour {
    NetworkObserver: NetworkObserver;
    Observers: CSArray<NetworkConnection>;
    IsNested: boolean;
    PredictedSpawner: NetworkConnection;
    IsSceneObject: boolean;
    ComponentIndex: number;
    ObjectId: number;
    PredictedSpawn: PredictedSpawn;
    NetworkBehaviours: CSArray<NetworkBehaviour>;
    ParentNetworkObject: NetworkObject;
    ChildNetworkObjects: CSArray<NetworkObject>;
    RuntimeParentNetworkObject: NetworkObject;
    RuntimeParentTransform: Transform;
    RuntimeChildNetworkObjects: CSArray<NetworkObject>;
    IsNetworked: boolean;
    IsGlobal: boolean;
    ClientInitialized: boolean;
    IsClient: boolean;
    IsClientOnly: boolean;
    IsServer: boolean;
    IsServerOnly: boolean;
    IsHost: boolean;
    IsOffline: boolean;
    IsOwner: boolean;
    Owner: NetworkConnection;
    OwnerId: number;
    IsSpawned: boolean;
    LocalConnection: NetworkConnection;
    NetworkManager: NetworkManager;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    ObserverManager: ObserverManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    PredictionManager: PredictionManager;
    RollbackManager: RollbackManager;
    PrefabId: number;
    SpawnableCollectionId: number;
    AssetPathHash: number;

    constructor(): NetworkObject;

    Broadcast<T>(message: T, requireAuthenticated: boolean, channel: Channel): void;
    Despawn(go: GameObject, despawnType: unknown): void;
    Despawn(nob: NetworkObject, despawnType: unknown): void;
    Despawn(despawnType: unknown): void;
    GetDefaultDespawnType(): DespawnType;
    GetInitializeOrder(): number;
    GetInstance<T>(): T;
    GetNetworkBehaviour(componentIndex: number, error: boolean): NetworkBehaviour;
    GiveOwnership(newOwner: NetworkConnection): void;
    HasInstance<T>(): boolean;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    RemoveOwnership(): void;
    ResetForObjectPool(): void;
    SetAssetPathHash(value: number): void;
    SetDefaultDespawnType(despawnType: DespawnType): void;
    SetIsGlobal(value: boolean): void;
    SetIsNetworked(value: boolean): void;
    SetLocalOwnership(caller: NetworkConnection): void;
    SetParent(nb: NetworkBehaviour): void;
    SetParent(nob: NetworkObject): void;
    SetRenderersVisible(visible: boolean, force: boolean): void;
    Spawn(go: GameObject, ownerConnection: NetworkConnection): void;
    Spawn(nob: NetworkObject, ownerConnection: NetworkConnection): void;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
    UnsetParent(): void;
    UpdateRenderers(updateVisibility: boolean): void;
}
    
interface NetworkObserver extends MonoBehaviour {
    OverrideType: ConditionOverrideType;
    UpdateHostVisibility: boolean;
    ObserverConditions: CSArray<ObserverCondition>;

    constructor(): NetworkObserver;

    GetObserverCondition<T>(): ObserverCondition;
    SetUpdateHostVisibility(value: boolean): void;
}
    
interface ScriptableObject extends Object {

    constructor(): ScriptableObject;

    SetDirty(): void;
}
    
interface ScriptableObjectConstructor {


    CreateInstance(className: string): ScriptableObject;
    CreateInstance(type: unknown): ScriptableObject;
    CreateInstance<T>(): T;
}
declare const ScriptableObject: ScriptableObjectConstructor;
    
interface ObserverCondition extends ScriptableObject {
    NetworkObject: NetworkObject;


    Clone(): ObserverCondition;
    ConditionMet(connection: NetworkConnection, currentlyAdded: boolean, notProcessed: unknown): boolean;
    Deinitialize(destroyed: boolean): void;
    GetConditionType(): ObserverConditionType;
    GetIsEnabled(): boolean;
    Initialize(networkObject: NetworkObject): void;
    SetIsEnabled(value: boolean): void;
    Timed(): boolean;
}
    
interface NetworkBehaviour extends MonoBehaviour {
    verboseLogging: boolean;
    OnStartServerCalled: boolean;
    OnStartClientCalled: boolean;
    IsSpawned: boolean;
    ComponentIndex: number;
    NetworkObject: NetworkObject;
    IsReconciling: boolean;
    IsDeinitializing: boolean;
    NetworkManager: NetworkManager;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    ObserverManager: ObserverManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    PredictionManager: PredictionManager;
    RollbackManager: RollbackManager;
    NetworkObserver: NetworkObserver;
    IsClient: boolean;
    IsClientOnly: boolean;
    IsServer: boolean;
    IsServerOnly: boolean;
    IsHost: boolean;
    IsOffline: boolean;
    Observers: CSArray<NetworkConnection>;
    IsOwner: boolean;
    Owner: NetworkConnection;
    OwnerId: number;
    ObjectId: number;
    LocalConnection: NetworkConnection;


    CanLog(loggingType: LoggingType): boolean;
    ClearBuffedRpcs(): void;
    ClearReplicateCache(asServer: boolean): void;
    ClearReplicateCache(): void;
    ClearReplicateCache_Internal(asServer: boolean): void;
    Despawn(go: GameObject, despawnType: unknown): void;
    Despawn(nob: NetworkObject, despawnType: unknown): void;
    Despawn(despawnType: unknown): void;
    GetInstance<T>(): T;
    GetLastReconcileTick(): number;
    GetLastReplicateTick(): number;
    GiveOwnership(newOwner: NetworkConnection): void;
    NetworkInitializeIfDisabled(): void;
    OnDespawnServer(connection: NetworkConnection): void;
    OnOwnershipClient(prevOwner: NetworkConnection): void;
    OnOwnershipServer(prevOwner: NetworkConnection): void;
    OnSpawnServer(connection: NetworkConnection): void;
    OnStartClient(): void;
    OnStartNetwork(): void;
    OnStartServer(): void;
    OnStopClient(): void;
    OnStopNetwork(): void;
    OnStopServer(): void;
    OwnerMatches(connection: NetworkConnection): boolean;
    Reconcile_Client_Internal<T, T2>(reconcileDel: unknown, replicateULDel: unknown, replicates: CSArray<T2>, data: T, channel: Channel): void;
    Reconcile_ExitEarly_A_Internal(asServer: boolean, channel: unknown): boolean;
    Reconcile_Reader_Internal<T>(reader: PooledReader, data: unknown, channel: Channel): void;
    Reconcile_Server_Internal<T>(methodHash: number, data: T, channel: Channel): void;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    RegisterObserversRpc_Internal(hash: number, del: ClientRpcDelegate): void;
    RegisterReconcileRpc_Internal(hash: number, del: ReconcileRpcDelegate): void;
    RegisterReplicateRpc_Internal(hash: number, del: ReplicateRpcDelegate): void;
    RegisterServerRpc_Internal(hash: number, del: ServerRpcDelegate): void;
    RegisterTargetRpc_Internal(hash: number, del: ClientRpcDelegate): void;
    RemoveOwnership(): void;
    Replicate_ExitEarly_A_Internal(asServer: boolean, replaying: boolean, allowServerControl: boolean): boolean;
    Replicate_NonOwner_Internal<T>(del: unknown, q: unknown, serverControlData: T, allowServerControl: boolean, channel: Channel): void;
    Replicate_Owner_Internal<T>(del: unknown, methodHash: number, replicates: CSArray<T>, data: T, channel: Channel): void;
    Replicate_Reader_Internal<T>(reader: PooledReader, sender: NetworkConnection, arrBuffer: CSArray<T>, replicates: unknown, channel: Channel): void;
    SendObserversRpc_Internal(hash: number, methodWriter: PooledWriter, channel: Channel, buffered: boolean, excludeServer: boolean, excludeOwner: boolean): void;
    SendServerRpc_Internal(hash: number, methodWriter: PooledWriter, channel: Channel): void;
    SendTargetRpc_Internal(hash: number, methodWriter: PooledWriter, channel: Channel, target: NetworkConnection, excludeServer: boolean, validateTarget: boolean): void;
    Server_SendReconcileRpc<T>(hash: number, reconcileData: T, channel: Channel): void;
    Spawn(go: GameObject, ownerConnection: NetworkConnection): void;
    Spawn(nob: NetworkObject, ownerConnection: NetworkConnection): void;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
}
    
interface ClientManager extends MonoBehaviour {
    Connection: NetworkConnection;
    Clients: CSDictionary<number, NetworkConnection>;
    Started: boolean;
    Objects: ClientObjects;
    NetworkManager: NetworkManager;
    LevelOfDetailInterval: number;

    constructor(): ClientManager;

    Broadcast<T>(message: T, channel: Channel): void;
    GetTransportIndex(): number;
    RegisterBroadcast<T>(handler: unknown): void;
    StartConnection(): boolean;
    StartConnection(address: string): boolean;
    StartConnection(address: string, port: number): boolean;
    StopConnection(): boolean;
    UnregisterBroadcast<T>(handler: unknown): void;
}
    
interface ManagedObjects {
    Spawned: CSDictionary<number, NetworkObject>;


}
    
interface ManagedObjectsConstructor {


    InitializePrefab(prefab: NetworkObject, index: number, collectionId: unknown): void;
}
declare const ManagedObjects: ManagedObjectsConstructor;
    
interface ClientObjects extends ManagedObjects {


    WriteDepawn(nob: NetworkObject, writer: Writer): void;
    WriteSpawn(nob: NetworkObject, writer: Writer): void;
}
    
interface Writer {
    Position: number;
    Length: number;
    NetworkManager: NetworkManager;
    Capacity: number;

    constructor(): Writer;

    EnsureBufferCapacity(count: number): void;
    EnsureBufferLength(count: number): void;
    FastInsertByte(value: number, index: number): void;
    GetArraySegment(): CSArray<number>;
    GetBuffer(): CSArray<number>;
    Reserve(count: number): void;
    Reset(manager: NetworkManager): void;
    ToString(): string;
    Write<T>(value: T): void;
    WriteArray<T>(value: CSArray<T>, offset: number, count: number): void;
    WriteArray<T>(value: CSArray<T>, offset: number): void;
    WriteArray<T>(value: CSArray<T>): void;
    WriteArraySegment(value: CSArray<number>): void;
    WriteArraySegmentAndSize(value: CSArray<number>): void;
    WriteBoolean(value: boolean): void;
    WriteByte(value: number): void;
    WriteBytes(value: CSArray<number>, offset: number, count: number): void;
    WriteBytesAndSize(value: CSArray<number>, offset: number, count: number): void;
    WriteBytesAndSize(value: CSArray<number>): void;
    WriteChannel(channel: Channel): void;
    WriteChar(value: string): void;
    WriteColor(value: Color, packType: AutoPackType): void;
    WriteColor32(value: Color32): void;
    WriteDateTime(dt: string): void;
    WriteDecimal(value: number): void;
    WriteDictionary<TKey, TValue>(dict: CSDictionary<TKey, TValue>): void;
    WriteDouble(value: number): void;
    WriteGameObject(go: GameObject): void;
    WriteGuidAllocated(value: unknown): void;
    WriteInt16(value: number): void;
    WriteInt32(value: number, packType: AutoPackType): void;
    WriteInt64(value: number, packType: AutoPackType): void;
    WriteList<T>(value: CSArray<T>): void;
    WriteList<T>(value: CSArray<T>, offset: number, count: number): void;
    WriteList<T>(value: CSArray<T>, offset: number): void;
    WriteListCache<T>(lc: unknown): void;
    WriteMatrix4x4(value: Matrix4x4): void;
    WriteNetworkBehaviour(nb: NetworkBehaviour): void;
    WriteNetworkBehaviourId(nb: NetworkBehaviour): void;
    WriteNetworkConnection(connection: NetworkConnection): void;
    WriteNetworkConnectionId(id: number): void;
    WriteNetworkObject(nob: NetworkObject): void;
    WriteNetworkObjectId(nob: NetworkObject): void;
    WriteNetworkObjectId(objectId: number): void;
    WritePackedWhole(value: number): void;
    WritePlane(value: Plane): void;
    WriteQuaternion(value: Quaternion, packType: AutoPackType): void;
    WriteRay(value: Ray): void;
    WriteRay2D(value: Ray2D): void;
    WriteRect(value: Rect): void;
    WriteSByte(value: number): void;
    WriteSingle(value: number, packType: AutoPackType): void;
    WriteString(value: string): void;
    WriteTickUnpacked(value: number): void;
    WriteTransform(t: Transform): void;
    WriteUInt16(value: number): void;
    WriteUInt32(value: number, packType: AutoPackType): void;
    WriteUInt64(value: number, packType: AutoPackType): void;
    WriteVector2(value: Vector2): void;
    WriteVector2Int(value: Vector2Int, packType: AutoPackType): void;
    WriteVector3(value: Vector3): void;
    WriteVector3Int(value: unknown, packType: AutoPackType): void;
    WriteVector4(value: Vector4): void;
    ZigZagEncode(value: number): number;
}
    
interface Ray2D {
    origin: Vector2;
    direction: Vector2;

    constructor(origin: Vector2, direction: Vector2): Ray2D;

    GetPoint(distance: number): Vector2;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Vector2Int {
    x: number;
    y: number;
    Item: number;
    magnitude: number;
    sqrMagnitude: number;

    constructor(x: number, y: number): Vector2Int;

    Clamp(min: Vector2Int, max: Vector2Int): void;
    Equals(other: unknown): boolean;
    Equals(other: Vector2Int): boolean;
    GetHashCode(): number;
    Scale(scale: Vector2Int): void;
    Set(x: number, y: number): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Vector2IntConstructor {
    zero: Vector2Int;
    one: Vector2Int;
    up: Vector2Int;
    down: Vector2Int;
    left: Vector2Int;
    right: Vector2Int;


    CeilToInt(v: Vector2): Vector2Int;
    Distance(a: Vector2Int, b: Vector2Int): number;
    FloorToInt(v: Vector2): Vector2Int;
    Max(lhs: Vector2Int, rhs: Vector2Int): Vector2Int;
    Min(lhs: Vector2Int, rhs: Vector2Int): Vector2Int;
    RoundToInt(v: Vector2): Vector2Int;
    Scale(a: Vector2Int, b: Vector2Int): Vector2Int;
}
declare const Vector2Int: Vector2IntConstructor;
    
interface WriterConstructor {
    UNSET_COLLECTION_SIZE_VALUE: number;


}
declare const Writer: WriterConstructor;
    
interface ObserverManager extends MonoBehaviour {
    UpdateHostVisibility: boolean;

    constructor(): ObserverManager;

    GetLevelOfDetailInterval(lodLevel: number): number;
    SetUpdateHostVisibility(value: boolean, updateType: HostVisibilityUpdateTypes): void;
}
    
interface TransportManager extends MonoBehaviour {
    Transport: Transport;
    HasIntermediateLayer: boolean;
    LatencySimulator: LatencySimulator;

    constructor(): TransportManager;

    GetLowestMTU(channel: number): number;
    GetMTU(channel: number): number;
    GetMTU(transportIndex: number, channel: number): number;
    GetMTU<T>(channel: number): number;
    GetTransport(index: number): Transport;
    GetTransport<T>(): T;
    IsLocalTransport(connectionId: number): boolean;
}
    
interface Transport extends MonoBehaviour {
    NetworkManager: NetworkManager;
    Index: number;


    GetClientAddress(): string;
    GetConnectionAddress(connectionId: number): string;
    GetConnectionState(server: boolean): LocalConnectionState;
    GetConnectionState(connectionId: number): RemoteConnectionState;
    GetMaximumClients(): number;
    GetMTU(channel: number): number;
    GetPort(): number;
    GetServerBindAddress(addressType: IPAddressType): string;
    GetTimeout(asServer: boolean): number;
    HandleClientConnectionState(connectionStateArgs: ClientConnectionStateArgs): void;
    HandleClientReceivedDataArgs(receivedDataArgs: ClientReceivedDataArgs): void;
    HandleRemoteConnectionState(connectionStateArgs: RemoteConnectionStateArgs): void;
    HandleServerConnectionState(connectionStateArgs: ServerConnectionStateArgs): void;
    HandleServerReceivedDataArgs(receivedDataArgs: ServerReceivedDataArgs): void;
    Initialize(networkManager: NetworkManager, transportIndex: number): void;
    IsLocalTransport(connectionid: number): boolean;
    IterateIncoming(server: boolean): void;
    IterateOutgoing(server: boolean): void;
    SendToClient(channelId: number, segment: CSArray<number>, connectionId: number): void;
    SendToServer(channelId: number, segment: CSArray<number>): void;
    SetClientAddress(address: string): void;
    SetMaximumClients(value: number): void;
    SetPort(port: number): void;
    SetServerBindAddress(address: string, addressType: IPAddressType): void;
    SetTimeout(value: number, asServer: boolean): void;
    Shutdown(): void;
    StartConnection(server: boolean): boolean;
    StopConnection(server: boolean): boolean;
    StopConnection(connectionId: number, immediately: boolean): boolean;
}
    
interface ClientConnectionStateArgs {
    ConnectionState: LocalConnectionState;
    TransportIndex: number;

    constructor(connectionState: LocalConnectionState, transportIndex: number): ClientConnectionStateArgs;

}
    
interface ClientReceivedDataArgs {
    Data: CSArray<number>;
    Channel: Channel;
    TransportIndex: number;

    constructor(data: CSArray<number>, channel: Channel, transportIndex: number): ClientReceivedDataArgs;

}
    
interface RemoteConnectionStateArgs {
    TransportIndex: number;
    ConnectionState: RemoteConnectionState;
    ConnectionId: number;

    constructor(connectionState: RemoteConnectionState, connectionId: number, transportIndex: number): RemoteConnectionStateArgs;

}
    
interface ServerConnectionStateArgs {
    TransportIndex: number;
    ConnectionState: LocalConnectionState;

    constructor(connectionState: LocalConnectionState, transportIndex: number): ServerConnectionStateArgs;

}
    
interface ServerReceivedDataArgs {
    Data: CSArray<number>;
    Channel: Channel;
    ConnectionId: number;
    TransportIndex: number;
    FinalizeMethod: unknown;

    constructor(data: CSArray<number>, channel: Channel, connectionId: number, transportIndex: number): ServerReceivedDataArgs;
    constructor(data: CSArray<number>, channel: Channel, connectionId: number, transportIndex: number, finalizeMethod: unknown): ServerReceivedDataArgs;

}
    
interface LatencySimulator {

    constructor(): LatencySimulator;

    AddOutgoing(channelId: number, segment: CSArray<number>, toServer: boolean, connectionId: number): void;
    GetEnabled(): boolean;
    GetLatency(): number;
    GetOutOfOrder(): number;
    GetPacketLost(): number;
    Initialize(manager: NetworkManager, transport: Transport): void;
    IterateOutgoing(toServer: boolean): void;
    RemovePendingForConnection(connectionId: number): void;
    Reset(): void;
    SetEnabled(value: boolean): void;
    SetLatency(value: number): void;
    SetOutOfOrder(value: number): void;
    SetPacketLoss(value: number): void;
}
    
interface TransportManagerConstructor {
    PACKET_ID_BYTES: number;
    OBJECT_ID_BYTES: number;
    COMPONENT_INDEX_BYTES: number;
    TICK_BYTES: number;
    SPLIT_INDICATOR_SIZE: number;
    CHANNEL_COUNT: number;


}
declare const TransportManager: TransportManagerConstructor;
    
interface TimeManager extends MonoBehaviour {
    RoundTripTime: number;
    LastPacketTick: number;
    Tick: number;
    TickDelta: number;
    FrameTicked: boolean;
    ServerUptime: number;
    ClientUptime: number;
    TickRate: number;
    PhysicsMode: PhysicsMode;
    LocalTick: number;

    constructor(): TimeManager;

    GetPreciseTick(tick: number): PreciseTick;
    GetPreciseTick(tickType: TickType): PreciseTick;
    GetTickPercent(): number;
    LocalTickToTick(localTick: number): number;
    SetPhysicsMode(mode: PhysicsMode): void;
    SetTickRate(value: number): void;
    TicksToTime(tickType: TickType): number;
    TicksToTime(pt: PreciseTick): number;
    TicksToTime(ticks: number): number;
    TickToLocalTick(tick: number): number;
    TimePassed(currentTick: number, previousTick: number): number;
    TimePassed(preciseTick: PreciseTick, allowNegative: boolean): number;
    TimePassed(previousTick: number, allowNegative: boolean): number;
    TimeToTicks(time: number, rounding: TickRounding): number;
}
    
interface PreciseTick {
    Tick: number;
    Percent: number;

    constructor(tick: number, percent: number): PreciseTick;

}
    
interface TimeManagerConstructor {
    UNSET_TICK: number;


}
declare const TimeManager: TimeManagerConstructor;
    
interface SceneManager extends MonoBehaviour {
    SceneConnections: CSDictionary<Scene, CSArray<NetworkConnection>>;
    NetworkManager: NetworkManager;

    constructor(): SceneManager;

    AddConnectionToScene(conn: NetworkConnection, scene: Scene): void;
    AddOwnerToDefaultScene(nob: NetworkObject): void;
    GetSceneProcessor(): SceneProcessorBase;
    LoadConnectionScenes(conn: NetworkConnection, sceneLoadData: SceneLoadData): void;
    LoadConnectionScenes(conns: CSArray<NetworkConnection>, sceneLoadData: SceneLoadData): void;
    LoadConnectionScenes(sceneLoadData: SceneLoadData): void;
    LoadGlobalScenes(sceneLoadData: SceneLoadData): void;
    RemoveAllConnectionsFromScene(scene: Scene): void;
    RemoveConnectionsFromNonGlobalScenes(conns: CSArray<NetworkConnection>): void;
    RemoveConnectionsFromScene(conns: CSArray<NetworkConnection>, scene: Scene): void;
    SetSceneProcessor(value: SceneProcessorBase): void;
    UnloadConnectionScenes(connection: NetworkConnection, sceneUnloadData: SceneUnloadData): void;
    UnloadConnectionScenes(connections: CSArray<NetworkConnection>, sceneUnloadData: SceneUnloadData): void;
    UnloadConnectionScenes(sceneUnloadData: SceneUnloadData): void;
    UnloadGlobalScenes(sceneUnloadData: SceneUnloadData): void;
}
    
interface SceneProcessorBase extends MonoBehaviour {


    ActivateLoadedScenes(): void;
    AddLoadedScene(scene: Scene): void;
    AsyncsIsDone(): unknown;
    BeginLoadAsync(sceneName: string, parameters: LoadSceneParameters): void;
    BeginUnloadAsync(scene: Scene): void;
    GetLoadedScenes(): CSArray<Scene>;
    GetPercentComplete(): number;
    Initialize(manager: SceneManager): void;
    IsPercentComplete(): boolean;
    LoadEnd(queueData: LoadQueueData): void;
    LoadStart(queueData: LoadQueueData): void;
    UnloadEnd(queueData: LoadQueueData): void;
    UnloadEnd(queueData: UnloadQueueData): void;
    UnloadStart(queueData: LoadQueueData): void;
    UnloadStart(queueData: UnloadQueueData): void;
}
    
interface LoadSceneParameters {
    loadSceneMode: LoadSceneMode;
    localPhysicsMode: LocalPhysicsMode;

    constructor(mode: LoadSceneMode): LoadSceneParameters;
    constructor(mode: LoadSceneMode, physicsMode: LocalPhysicsMode): LoadSceneParameters;

}
    
interface LoadQueueData {
    ScopeType: SceneScopeType;
    Connections: CSArray<NetworkConnection>;
    SceneLoadData: SceneLoadData;
    GlobalScenes: CSArray<string>;
    AsServer: boolean;

    constructor(): LoadQueueData;

}
    
interface SceneLoadData {
    PreferredActiveScene: SceneLookupData;
    SceneLookupDatas: CSArray<SceneLookupData>;
    MovedNetworkObjects: CSArray<NetworkObject>;
    ReplaceScenes: ReplaceOption;
    Params: LoadParams;
    Options: LoadOptions;

    constructor(): SceneLoadData;
    constructor(scene: Scene): SceneLoadData;
    constructor(sceneName: string): SceneLoadData;
    constructor(sceneHandle: number): SceneLoadData;
    constructor(sceneHandle: number, sceneName: string): SceneLoadData;
    constructor(sceneLookupData: SceneLookupData): SceneLoadData;
    constructor(scenes: CSArray<Scene>): SceneLoadData;
    constructor(sceneNames: CSArray<string>): SceneLoadData;
    constructor(sceneHandles: CSArray<number>): SceneLoadData;
    constructor(scenes: CSArray<Scene>): SceneLoadData;
    constructor(sceneNames: CSArray<string>): SceneLoadData;
    constructor(sceneHandles: CSArray<number>): SceneLoadData;
    constructor(sceneLookupDatas: CSArray<SceneLookupData>): SceneLoadData;
    constructor(scene: Scene, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    constructor(scenes: CSArray<Scene>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    constructor(sceneNames: CSArray<string>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    constructor(sceneHandles: CSArray<number>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    constructor(sceneLookupDatas: CSArray<SceneLookupData>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;

    GetFirstLookupScene(): Scene;
}
    
interface SceneLookupData {
    Handle: number;
    Name: string;
    NameOnly: string;
    IsValid: boolean;

    constructor(): SceneLookupData;
    constructor(scene: Scene): SceneLookupData;
    constructor(name: string): SceneLookupData;
    constructor(handle: number): SceneLookupData;
    constructor(handle: number, name: string): SceneLookupData;

    Equals(sld: SceneLookupData): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GetScene(foundByHandle: unknown): Scene;
    ToString(): string;
}
    
interface SceneLookupDataConstructor {


    CreateData(scene: Scene): SceneLookupData;
    CreateData(name: string): SceneLookupData;
    CreateData(handle: number): SceneLookupData;
    CreateData(scenes: CSArray<Scene>): CSArray<SceneLookupData>;
    CreateData(names: CSArray<string>): CSArray<SceneLookupData>;
    CreateData(handles: CSArray<number>): CSArray<SceneLookupData>;
    CreateData(scenes: CSArray<Scene>): CSArray<SceneLookupData>;
    CreateData(names: CSArray<string>): CSArray<SceneLookupData>;
    CreateData(handles: CSArray<number>): CSArray<SceneLookupData>;
}
declare const SceneLookupData: SceneLookupDataConstructor;
    
interface LoadParams {
    ServerParams: CSArray<unknown>;
    ClientParams: CSArray<number>;

    constructor(): LoadParams;

}
    
interface LoadOptions {
    AutomaticallyUnload: boolean;
    AllowStacking: boolean;
    LocalPhysics: LocalPhysicsMode;
    ReloadScenes: boolean;
    Addressables: boolean;

    constructor(): LoadOptions;

}
    
interface UnloadQueueData {
    ScopeType: SceneScopeType;
    Connections: CSArray<NetworkConnection>;
    SceneUnloadData: SceneUnloadData;
    GlobalScenes: CSArray<string>;
    AsServer: boolean;

    constructor(): UnloadQueueData;

}
    
interface SceneUnloadData {
    PreferredActiveScene: SceneLookupData;
    SceneLookupDatas: CSArray<SceneLookupData>;
    Params: UnloadParams;
    Options: UnloadOptions;

    constructor(): SceneUnloadData;
    constructor(scene: Scene): SceneUnloadData;
    constructor(sceneName: string): SceneUnloadData;
    constructor(sceneHandle: number): SceneUnloadData;
    constructor(scenes: CSArray<Scene>): SceneUnloadData;
    constructor(sceneNames: CSArray<string>): SceneUnloadData;
    constructor(sceneHandles: CSArray<number>): SceneUnloadData;
    constructor(scenes: CSArray<Scene>): SceneUnloadData;
    constructor(sceneNames: CSArray<string>): SceneUnloadData;
    constructor(sceneHandles: CSArray<number>): SceneUnloadData;
    constructor(sceneLookupDatas: CSArray<SceneLookupData>): SceneUnloadData;

}
    
interface UnloadParams {
    ServerParams: CSArray<unknown>;
    ClientParams: CSArray<number>;

    constructor(): UnloadParams;

}
    
interface UnloadOptions {
    Mode: ServerUnloadMode;
    Addressables: boolean;

    constructor(): UnloadOptions;

}
    
interface SceneManagerConstructor {


    GetScene(sceneName: string): Scene;
    GetScene(sceneHandle: number): Scene;
}
declare const SceneManager: SceneManagerConstructor;
    
interface PredictionManager extends MonoBehaviour {
    LastReconcileTick: number;
    LastReplicateTick: number;
    QueuedInputs: number;

    constructor(): PredictionManager;

    AddRigidbodyCount(c: Component): void;
    GetMaximumServerReplicates(): number;
    InvokeOnReconcile_Internal(nb: NetworkBehaviour, before: boolean): void;
    IsReplaying(): boolean;
    IsReplaying(scene: Scene): boolean;
    RemoveRigidbodyCount(c: Component): void;
    SetMaximumServerReplicates(value: number): void;
}
    
interface RollbackManager extends MonoBehaviour {

    constructor(): RollbackManager;

    Return(): void;
    Rollback(pt: PreciseTick, physicsType: PhysicsType, asOwner: boolean): void;
}
    
interface RollbackManagerConstructor {
    MAX_ROLLBACK_TIME: number;


}
declare const RollbackManager: RollbackManagerConstructor;
    
interface Reader {
    Source: DataSource;
    NetworkManager: NetworkManager;
    Position: number;
    Capacity: number;
    Offset: number;
    Length: number;
    Remaining: number;
    NetworkConnection: NetworkConnection;

    constructor(bytes: CSArray<number>, networkManager: NetworkManager, networkConnection: NetworkConnection, source: DataSource): Reader;
    constructor(segment: CSArray<number>, networkManager: NetworkManager, networkConnection: NetworkConnection, source: DataSource): Reader;

    BlockCopy(target: CSArray<number>, targetOffset: number, count: number): void;
    Clear(): void;
    GetArraySegmentBuffer(): CSArray<number>;
    GetByteBuffer(): CSArray<number>;
    GetByteBufferAllocated(): CSArray<number>;
    GetRemainingData(): CSArray<number>;
    Read<T>(): T;
    ReadArray<T>(collection: CSArray<T>): number;
    ReadArrayAllocated<T>(): CSArray<T>;
    ReadArraySegment(count: number): CSArray<number>;
    ReadArraySegmentAndSize(): CSArray<number>;
    ReadBoolean(): boolean;
    ReadByte(): number;
    ReadBytes(buffer: CSArray<number>, count: number): void;
    ReadBytesAllocated(count: number): CSArray<number>;
    ReadBytesAndSize(target: CSArray<number>): number;
    ReadBytesAndSizeAllocated(): CSArray<number>;
    ReadChannel(): Channel;
    ReadChar(): string;
    ReadColor(packType: AutoPackType): Color;
    ReadColor32(): Color32;
    ReadDateTime(): string;
    ReadDecimal(): number;
    ReadDictionary<TKey, TValue>(): CSDictionary<TKey, TValue>;
    ReadDictionaryAllocated<TKey, TValue>(): CSDictionary<TKey, TValue>;
    ReadDouble(): number;
    ReadGameObject(): GameObject;
    ReadGuid(): unknown;
    ReadInt16(): number;
    ReadInt32(packType: AutoPackType): number;
    ReadInt64(packType: AutoPackType): number;
    ReadList<T>(collection: CSArray<T>, allowNullification: boolean): number;
    ReadListAllocated<T>(): CSArray<T>;
    ReadListCache<T>(listCache: unknown): number;
    ReadListCacheAllocated<T>(): unknown;
    ReadMatrix4x4(): Matrix4x4;
    ReadNetworkBehaviour(objectId: unknown, componentIndex: unknown): NetworkBehaviour;
    ReadNetworkBehaviour(): NetworkBehaviour;
    ReadNetworkConnection(): NetworkConnection;
    ReadNetworkConnectionId(): number;
    ReadNetworkObject(): NetworkObject;
    ReadNetworkObject(objectOrPrefabId: unknown): NetworkObject;
    ReadNetworkObjectId(): number;
    ReadPackedWhole(): number;
    ReadPlane(): Plane;
    ReadQuaternion(packType: AutoPackType): Quaternion;
    ReadRay(): Ray;
    ReadRay2D(): Ray2D;
    ReadRect(): Rect;
    ReadSByte(): number;
    ReadSingle(packType: AutoPackType): number;
    ReadString(): string;
    ReadTickUnpacked(): number;
    ReadTransform(): Transform;
    ReadUInt16(): number;
    ReadUInt32(packType: AutoPackType): number;
    ReadUInt64(packType: AutoPackType): number;
    ReadVector2(): Vector2;
    ReadVector2Int(packType: AutoPackType): Vector2Int;
    ReadVector3(): Vector3;
    ReadVector3Int(packType: AutoPackType): unknown;
    ReadVector4(): Vector4;
    RemainingToString(): string;
    Skip(value: number): void;
    ToString(): string;
    ZigZagDecode(value: number): number;
}
    
interface ReaderConstructor {
    LastNetworkObject: NetworkObject;
    LastNetworkBehaviour: NetworkBehaviour;


}
declare const Reader: ReaderConstructor;
    
interface PooledReader extends Reader {


    Dispose(): void;
    Store(): void;
}
    
interface IReconcileData {


    Dispose(): void;
    GetTick(): number;
    SetTick(value: number): void;
}
    
interface ClientRpcDelegate {

    constructor(object: unknown, method: unknown): ClientRpcDelegate;

    BeginInvoke(reader: PooledReader, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel): void;
}
    
interface ReconcileRpcDelegate {

    constructor(object: unknown, method: unknown): ReconcileRpcDelegate;

    BeginInvoke(reader: PooledReader, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel): void;
}
    
interface ReplicateRpcDelegate {

    constructor(object: unknown, method: unknown): ReplicateRpcDelegate;

    BeginInvoke(reader: PooledReader, sender: NetworkConnection, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, sender: NetworkConnection, channel: Channel): void;
}
    
interface ServerRpcDelegate {

    constructor(object: unknown, method: unknown): ServerRpcDelegate;

    BeginInvoke(reader: PooledReader, channel: Channel, sender: NetworkConnection, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel, sender: NetworkConnection): void;
}
    
interface PooledWriter extends Writer {

    constructor(): PooledWriter;

    Dispose(): void;
    DisposeLength(): void;
    Store(): void;
    StoreLength(): void;
}
    
interface PredictedSpawn extends NetworkBehaviour {

    constructor(): PredictedSpawn;

    Awake(): void;
    Awake___UserLogic(): void;
    GetAllowDespawning(): boolean;
    GetAllowSpawning(): boolean;
    GetAllowSyncTypes(): boolean;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnTryDepawnServer(despawner: NetworkConnection): boolean;
    OnTryDespawnClient(): boolean;
    OnTrySpawnClient(owner: NetworkConnection): boolean;
    OnTrySpawnServer(spawner: NetworkConnection, owner: NetworkConnection): boolean;
    SetAllowDespawning(value: boolean): void;
    SetAllowSpawning(value: boolean): void;
    SetAllowSyncTypes(value: boolean): void;
}
    
interface NetworkObjectConstructor {
    UNSET_OBJECTID_VALUE: number;
    UNSET_PREFABID_VALUE: number;


}
declare const NetworkObject: NetworkObjectConstructor;
    
interface EstimatedTick {
    LocalTick: number;
    RemoteTick: number;
    LastRemoteTick: number;
    IsUnset: boolean;


    IsCurrent(tm: TimeManager): boolean;
    LocalTickDifference(tm: TimeManager): number;
    Reset(): void;
    Update(tm: TimeManager, remoteTick: number, oldTickOption: OldTickOption): boolean;
    Value(tm: TimeManager): number;
    Value(tm: TimeManager, isCurrent: unknown): number;
}
    
interface NetworkConnectionConstructor {
    UNSET_CLIENTID_VALUE: number;


}
declare const NetworkConnection: NetworkConnectionConstructor;
    
interface ServerObjects extends ManagedObjects {


    AddTimedNetworkObserver(networkObject: NetworkObject): void;
    RebuildObservers(timedOnly: boolean): void;
    RebuildObservers(nob: NetworkObject, timedOnly: boolean): void;
    RebuildObservers(connection: NetworkConnection, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, timedOnly: boolean): void;
    RebuildObservers(connections: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, conn: NetworkConnection, timedOnly: boolean): void;
    RebuildObservers(networkObject: NetworkObject, connections: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, conns: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RecentlyDespawned(objectId: number, ticks: number): boolean;
    RemoveTimedNetworkObserver(networkObject: NetworkObject): void;
}
    
interface Authenticator extends MonoBehaviour {
    Initialized: boolean;


    InitializeOnce(networkManager: NetworkManager): void;
    OnRemoteConnection(connection: NetworkConnection): void;
}
    
interface DebugManager extends MonoBehaviour {
    ObserverRpcLinks: boolean;
    TargetRpcLinks: boolean;
    ReplicateRpcLinks: boolean;
    ReconcileRpcLinks: boolean;
    ServerRpcLinks: boolean;

    constructor(): DebugManager;

}
    
interface StatisticsManager extends MonoBehaviour {
    NetworkTraffic: NetworkTraficStatistics;

    constructor(): StatisticsManager;

}
    
interface NetworkTraficStatistics {
    UpdateClient: boolean;
    UpdateServer: boolean;

    constructor(): NetworkTraficStatistics;

    LocalClientReceivedData(dataLength: number): void;
    LocalServerReceivedData(dataLength: number): void;
    SetUpdateClient(update: boolean): void;
    SetUpdateServer(update: boolean): void;
}
    
interface NetworkTraficStatisticsConstructor {


    FormatBytesToLargest(bytes: number): string;
}
declare const NetworkTraficStatistics: NetworkTraficStatisticsConstructor;
    
interface ObjectPool extends MonoBehaviour {


    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    InitializeOnce(nm: NetworkManager): void;
    RetrieveObject(prefabId: number, asServer: boolean): NetworkObject;
    RetrieveObject(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    StoreObject(instantiated: NetworkObject, asServer: boolean): void;
}
    
interface PrefabObjects extends ScriptableObject {
    CollectionId: number;


    AddObject(networkObject: NetworkObject, checkForDuplicates: boolean): void;
    AddObject(dualPrefab: DualPrefab, checkForDuplicates: boolean): void;
    AddObjects(networkObjects: CSArray<NetworkObject>, checkForDuplicates: boolean): void;
    AddObjects(networkObjects: CSArray<NetworkObject>, checkForDuplicates: boolean): void;
    AddObjects(dualPrefab: CSArray<DualPrefab>, checkForDuplicates: boolean): void;
    AddObjects(dualPrefab: CSArray<DualPrefab>, checkForDuplicates: boolean): void;
    Clear(): void;
    GetObject(asServer: boolean, id: number): NetworkObject;
    GetObjectCount(): number;
    InitializePrefabRange(startIndex: number): void;
    RemoveNull(): void;
}
    
interface DualPrefab {
    Server: NetworkObject;
    Client: NetworkObject;


}
    
interface NetworkManagerConstructor {
    Instances: CSArray<NetworkManager>;
    EmptyConnection: NetworkConnection;


    StaticCanLog(loggingType: LoggingType): boolean;
    StaticLog(value: string): void;
    StaticLogError(value: string): void;
    StaticLogWarning(value: string): void;
}
declare const NetworkManager: NetworkManagerConstructor;
    
interface NetworkCoreConstructor {
    Net: Net;
    NetworkManager: NetworkManager;


    Despawn(obj: GameObject): void;
    SetNet(net: Net): void;
    Spawn(obj: GameObject, clientId: number): void;
    Spawn(obj: GameObject): void;
}
declare const NetworkCore: NetworkCoreConstructor;
    
interface Camera extends Behaviour {
    nearClipPlane: number;
    farClipPlane: number;
    fieldOfView: number;
    renderingPath: RenderingPath;
    actualRenderingPath: RenderingPath;
    allowHDR: boolean;
    allowMSAA: boolean;
    allowDynamicResolution: boolean;
    forceIntoRenderTexture: boolean;
    orthographicSize: number;
    orthographic: boolean;
    opaqueSortMode: OpaqueSortMode;
    transparencySortMode: TransparencySortMode;
    transparencySortAxis: Vector3;
    depth: number;
    aspect: number;
    velocity: Vector3;
    cullingMask: number;
    eventMask: number;
    layerCullSpherical: boolean;
    cameraType: CameraType;
    overrideSceneCullingMask: number;
    layerCullDistances: CSArray<number>;
    useOcclusionCulling: boolean;
    cullingMatrix: Matrix4x4;
    backgroundColor: Color;
    clearFlags: CameraClearFlags;
    depthTextureMode: DepthTextureMode;
    clearStencilAfterLightingPass: boolean;
    usePhysicalProperties: boolean;
    sensorSize: Vector2;
    lensShift: Vector2;
    focalLength: number;
    gateFit: GateFitMode;
    rect: Rect;
    pixelRect: Rect;
    pixelWidth: number;
    pixelHeight: number;
    scaledPixelWidth: number;
    scaledPixelHeight: number;
    targetTexture: RenderTexture;
    activeTexture: RenderTexture;
    targetDisplay: number;
    cameraToWorldMatrix: Matrix4x4;
    worldToCameraMatrix: Matrix4x4;
    projectionMatrix: Matrix4x4;
    nonJitteredProjectionMatrix: Matrix4x4;
    useJitteredProjectionMatrixForTransparentRendering: boolean;
    previousViewProjectionMatrix: Matrix4x4;
    scene: Scene;
    stereoEnabled: boolean;
    stereoSeparation: number;
    stereoConvergence: number;
    areVRStereoViewMatricesWithinSingleCullTolerance: boolean;
    stereoTargetEye: StereoTargetEyeMask;
    stereoActiveEye: MonoOrStereoscopicEye;
    sceneViewFilterMode: SceneViewFilterMode;
    commandBufferCount: number;
    isOrthoGraphic: boolean;
    near: number;
    far: number;
    fov: number;
    hdr: boolean;
    stereoMirrorMode: boolean;

    constructor(): Camera;

    AddCommandBuffer(evt: CameraEvent, buffer: CommandBuffer): void;
    AddCommandBufferAsync(evt: CameraEvent, buffer: CommandBuffer, queueType: ComputeQueueType): void;
    CalculateFrustumCorners(viewport: Rect, z: number, eye: MonoOrStereoscopicEye, outCorners: CSArray<Vector3>): void;
    CalculateObliqueMatrix(clipPlane: Vector4): Matrix4x4;
    CopyFrom(other: Camera): void;
    CopyStereoDeviceProjectionMatrixToNonJittered(eye: StereoscopicEye): void;
    DoClear(): void;
    GetCommandBuffers(evt: CameraEvent): CSArray<CommandBuffer>;
    GetGateFittedFieldOfView(): number;
    GetGateFittedLensShift(): Vector2;
    GetScreenHeight(): number;
    GetScreenWidth(): number;
    GetStereoNonJitteredProjectionMatrix(eye: StereoscopicEye): Matrix4x4;
    GetStereoProjectionMatrices(): CSArray<Matrix4x4>;
    GetStereoProjectionMatrix(eye: StereoscopicEye): Matrix4x4;
    GetStereoViewMatrices(): CSArray<Matrix4x4>;
    GetStereoViewMatrix(eye: StereoscopicEye): Matrix4x4;
    RemoveAllCommandBuffers(): void;
    RemoveCommandBuffer(evt: CameraEvent, buffer: CommandBuffer): void;
    RemoveCommandBuffers(evt: CameraEvent): void;
    Render(): void;
    RenderDontRestore(): void;
    RenderToCubemap(cubemap: Cubemap, faceMask: number): boolean;
    RenderToCubemap(cubemap: Cubemap): boolean;
    RenderToCubemap(cubemap: RenderTexture, faceMask: number): boolean;
    RenderToCubemap(cubemap: RenderTexture): boolean;
    RenderToCubemap(cubemap: RenderTexture, faceMask: number, stereoEye: MonoOrStereoscopicEye): boolean;
    RenderWithShader(shader: Shader, replacementTag: string): void;
    Reset(): void;
    ResetAspect(): void;
    ResetCullingMatrix(): void;
    ResetFieldOfView(): void;
    ResetProjectionMatrix(): void;
    ResetReplacementShader(): void;
    ResetStereoProjectionMatrices(): void;
    ResetStereoViewMatrices(): void;
    ResetTransparencySortSettings(): void;
    ResetWorldToCameraMatrix(): void;
    ScreenPointToRay(pos: Vector3, eye: MonoOrStereoscopicEye): Ray;
    ScreenPointToRay(pos: Vector3): Ray;
    ScreenToViewportPoint(position: Vector3): Vector3;
    ScreenToWorldPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    ScreenToWorldPoint(position: Vector3): Vector3;
    SetReplacementShader(shader: Shader, replacementTag: string): void;
    SetStereoProjectionMatrices(leftMatrix: Matrix4x4, rightMatrix: Matrix4x4): void;
    SetStereoProjectionMatrix(eye: StereoscopicEye, matrix: Matrix4x4): void;
    SetStereoViewMatrices(leftMatrix: Matrix4x4, rightMatrix: Matrix4x4): void;
    SetStereoViewMatrix(eye: StereoscopicEye, matrix: Matrix4x4): void;
    SetTargetBuffers(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer): void;
    SetTargetBuffers(colorBuffer: CSArray<RenderBuffer>, depthBuffer: RenderBuffer): void;
    SubmitRenderRequests(renderRequests: CSArray<RenderRequest>): void;
    TryGetCullingParameters(cullingParameters: unknown): boolean;
    TryGetCullingParameters(stereoAware: boolean, cullingParameters: unknown): boolean;
    ViewportPointToRay(pos: Vector3, eye: MonoOrStereoscopicEye): Ray;
    ViewportPointToRay(pos: Vector3): Ray;
    ViewportToScreenPoint(position: Vector3): Vector3;
    ViewportToWorldPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    ViewportToWorldPoint(position: Vector3): Vector3;
    WorldToScreenPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    WorldToScreenPoint(position: Vector3): Vector3;
    WorldToViewportPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    WorldToViewportPoint(position: Vector3): Vector3;
}
    
interface RenderTexture extends Texture {
    generateMips: boolean;
    isCubemap: boolean;
    isVolume: boolean;
    descriptor: RenderTextureDescriptor;
    width: number;
    height: number;
    dimension: TextureDimension;
    graphicsFormat: GraphicsFormat;
    useMipMap: boolean;
    sRGB: boolean;
    vrUsage: VRTextureUsage;
    memorylessMode: RenderTextureMemoryless;
    format: RenderTextureFormat;
    stencilFormat: GraphicsFormat;
    depthStencilFormat: GraphicsFormat;
    autoGenerateMips: boolean;
    volumeDepth: number;
    antiAliasing: number;
    bindTextureMS: boolean;
    enableRandomWrite: boolean;
    useDynamicScale: boolean;
    isPowerOfTwo: boolean;
    colorBuffer: RenderBuffer;
    depthBuffer: RenderBuffer;
    depth: number;

    constructor(desc: RenderTextureDescriptor): RenderTexture;
    constructor(textureToCopy: RenderTexture): RenderTexture;
    constructor(width: number, height: number, depth: number, format: DefaultFormat): RenderTexture;
    constructor(width: number, height: number, depth: number, format: GraphicsFormat): RenderTexture;
    constructor(width: number, height: number, depth: number, format: GraphicsFormat, mipCount: number): RenderTexture;
    constructor(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: number): RenderTexture;
    constructor(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat): RenderTexture;
    constructor(width: number, height: number, depth: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): RenderTexture;
    constructor(width: number, height: number, depth: number, format: RenderTextureFormat): RenderTexture;
    constructor(width: number, height: number, depth: number): RenderTexture;
    constructor(width: number, height: number, depth: number, format: RenderTextureFormat, mipCount: number): RenderTexture;

    ConvertToEquirect(equirect: RenderTexture, eye: MonoOrStereoscopicEye): void;
    Create(): boolean;
    DiscardContents(discardColor: boolean, discardDepth: boolean): void;
    DiscardContents(): void;
    GenerateMips(): void;
    GetNativeDepthBufferPtr(): unknown;
    GetTexelOffset(): Vector2;
    IsCreated(): boolean;
    MarkRestoreExpected(): void;
    Release(): void;
    ResolveAntiAliasedSurface(): void;
    ResolveAntiAliasedSurface(target: RenderTexture): void;
    SetBorderColor(color: Color): void;
    SetGlobalShaderProperty(propertyName: string): void;
}
    
interface RenderTextureDescriptor {
    width: number;
    height: number;
    msaaSamples: number;
    volumeDepth: number;
    mipCount: number;
    graphicsFormat: GraphicsFormat;
    stencilFormat: GraphicsFormat;
    depthStencilFormat: GraphicsFormat;
    colorFormat: RenderTextureFormat;
    sRGB: boolean;
    depthBufferBits: number;
    dimension: TextureDimension;
    shadowSamplingMode: ShadowSamplingMode;
    vrUsage: VRTextureUsage;
    flags: RenderTextureCreationFlags;
    memoryless: RenderTextureMemoryless;
    useMipMap: boolean;
    autoGenerateMips: boolean;
    enableRandomWrite: boolean;
    bindMS: boolean;
    useDynamicScale: boolean;

    constructor(width: number, height: number): RenderTextureDescriptor;
    constructor(width: number, height: number, colorFormat: RenderTextureFormat): RenderTextureDescriptor;
    constructor(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number): RenderTextureDescriptor;
    constructor(width: number, height: number, colorFormat: GraphicsFormat, depthBufferBits: number): RenderTextureDescriptor;
    constructor(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number, mipCount: number): RenderTextureDescriptor;
    constructor(width: number, height: number, colorFormat: GraphicsFormat, depthBufferBits: number, mipCount: number): RenderTextureDescriptor;
    constructor(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat): RenderTextureDescriptor;
    constructor(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: number): RenderTextureDescriptor;

}
    
interface RenderBuffer {


    GetNativeRenderBufferPtr(): unknown;
}
    
interface RenderTextureConstructor {
    enabled: boolean;
    active: RenderTexture;


    GetTemporary(desc: RenderTextureDescriptor): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: boolean): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: boolean): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number): RenderTexture;
    GetTemporary(width: number, height: number): RenderTexture;
    ReleaseTemporary(temp: RenderTexture): void;
    SupportsStencil(rt: RenderTexture): boolean;
}
declare const RenderTexture: RenderTextureConstructor;
    
interface CommandBuffer {
    name: string;
    sizeInBytes: number;

    constructor(): CommandBuffer;

    BeginSample(name: string): void;
    BeginSample(sampler: CustomSampler): void;
    Blit(source: Texture, dest: RenderTargetIdentifier): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, mat: Material): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, mat: Material, pass: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: number, destDepthSlice: number): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure, relativeOrigin: Vector3): void;
    Clear(): void;
    ClearRandomWriteTargets(): void;
    ClearRenderTarget(clearFlags: RTClearFlags, backgroundColor: Color, depth: number, stencil: number): void;
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color): void;
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color, depth: number): void;
    ConvertTexture(src: RenderTargetIdentifier, dst: RenderTargetIdentifier): void;
    ConvertTexture(src: RenderTargetIdentifier, srcElement: number, dst: RenderTargetIdentifier, dstElement: number): void;
    CopyBuffer(source: GraphicsBuffer, dest: GraphicsBuffer): void;
    CopyCounterValue(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyTexture(src: RenderTargetIdentifier, dst: RenderTargetIdentifier): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, dst: RenderTargetIdentifier, dstElement: number): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, srcMip: number, dst: RenderTargetIdentifier, dstElement: number, dstMip: number): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, srcMip: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number, dst: RenderTargetIdentifier, dstElement: number, dstMip: number, dstX: number, dstY: number): void;
    CreateAsyncGraphicsFence(): GraphicsFence;
    CreateAsyncGraphicsFence(stage: SynchronisationStage): GraphicsFence;
    CreateGPUFence(stage: SynchronisationStage): GPUFence;
    CreateGPUFence(): GPUFence;
    CreateGraphicsFence(fenceType: GraphicsFenceType, stage: SynchronisationStageFlags): GraphicsFence;
    DisableKeyword(keyword: unknown): void;
    DisableKeyword(material: Material, keyword: unknown): void;
    DisableKeyword(computeShader: ComputeShader, keyword: unknown): void;
    DisableScissorRect(): void;
    DisableShaderKeyword(keyword: string): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, threadGroupsX: number, threadGroupsY: number, threadGroupsZ: number): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, indirectBuffer: ComputeBuffer, argsOffset: number): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, indirectBuffer: GraphicsBuffer, argsOffset: number): void;
    DispatchRays(rayTracingShader: RayTracingShader, rayGenName: string, width: number, height: number, depth: number, camera: Camera): void;
    Dispose(): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, shaderPass: number, properties: MaterialPropertyBlock): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, shaderPass: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>, count: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer): void;
    DrawMeshInstancedProcedural(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, count: number, properties: MaterialPropertyBlock): void;
    DrawOcclusionMesh(normalizedCamViewport: RectInt): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number, instanceCount: number, properties: MaterialPropertyBlock): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number, instanceCount: number, properties: MaterialPropertyBlock): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number, instanceCount: number): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer): void;
    DrawRenderer(renderer: Renderer, material: Material, submeshIndex: number, shaderPass: number): void;
    DrawRenderer(renderer: Renderer, material: Material, submeshIndex: number): void;
    DrawRenderer(renderer: Renderer, material: Material): void;
    DrawRendererList(rendererList: RendererList): void;
    EnableKeyword(keyword: unknown): void;
    EnableKeyword(material: Material, keyword: unknown): void;
    EnableKeyword(computeShader: ComputeShader, keyword: unknown): void;
    EnableScissorRect(scissor: Rect): void;
    EnableShaderKeyword(keyword: string): void;
    EndSample(name: string): void;
    EndSample(sampler: CustomSampler): void;
    GenerateMips(rt: RenderTargetIdentifier): void;
    GenerateMips(rt: RenderTexture): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless, useDynamicScale: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless, useDynamicScale: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number): void;
    GetTemporaryRT(nameID: number, desc: RenderTextureDescriptor, filter: FilterMode): void;
    GetTemporaryRT(nameID: number, desc: RenderTextureDescriptor): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, useDynamicScale: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number): void;
    IncrementUpdateCount(dest: RenderTargetIdentifier): void;
    IssuePluginCustomBlit(callback: unknown, command: number, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, commandParam: number, commandFlags: number): void;
    IssuePluginCustomTextureUpdate(callback: unknown, targetTexture: Texture, userData: number): void;
    IssuePluginCustomTextureUpdateV1(callback: unknown, targetTexture: Texture, userData: number): void;
    IssuePluginCustomTextureUpdateV2(callback: unknown, targetTexture: Texture, userData: number): void;
    IssuePluginEvent(callback: unknown, eventID: number): void;
    IssuePluginEventAndData(callback: unknown, eventID: number, data: unknown): void;
    MarkLateLatchMatrixShaderPropertyID(matrixPropertyType: CameraLateLatchMatrixType, shaderPropertyID: number): void;
    ProcessVTFeedback(rt: RenderTargetIdentifier, resolver: unknown, slice: number, x: number, width: number, y: number, height: number, mip: number): void;
    Release(): void;
    ReleaseTemporaryRT(nameID: number): void;
    RequestAsyncReadback(src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadback(src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadback(src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadback(src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    ResolveAntiAliasedSurface(rt: RenderTexture, target: RenderTexture): void;
    SetBufferCounterValue(buffer: ComputeBuffer, counterValue: number): void;
    SetBufferCounterValue(buffer: GraphicsBuffer, counterValue: number): void;
    SetBufferData(buffer: ComputeBuffer, data: unknown): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetBufferData(buffer: ComputeBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData(buffer: GraphicsBuffer, data: unknown): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>): void;
    SetBufferData(buffer: GraphicsBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferCounterValue(buffer: ComputeBuffer, counterValue: number): void;
    SetComputeBufferData(buffer: ComputeBuffer, data: unknown): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetComputeBufferData(buffer: ComputeBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, buffer: ComputeBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, buffer: ComputeBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, buffer: GraphicsBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, buffer: GraphicsBuffer): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetComputeFloatParam(computeShader: ComputeShader, nameID: number, val: number): void;
    SetComputeFloatParam(computeShader: ComputeShader, name: string, val: number): void;
    SetComputeFloatParams(computeShader: ComputeShader, name: string, values: CSArray<number>): void;
    SetComputeFloatParams(computeShader: ComputeShader, nameID: number, values: CSArray<number>): void;
    SetComputeIntParam(computeShader: ComputeShader, nameID: number, val: number): void;
    SetComputeIntParam(computeShader: ComputeShader, name: string, val: number): void;
    SetComputeIntParams(computeShader: ComputeShader, name: string, values: CSArray<number>): void;
    SetComputeIntParams(computeShader: ComputeShader, nameID: number, values: CSArray<number>): void;
    SetComputeMatrixArrayParam(computeShader: ComputeShader, nameID: number, values: CSArray<Matrix4x4>): void;
    SetComputeMatrixArrayParam(computeShader: ComputeShader, name: string, values: CSArray<Matrix4x4>): void;
    SetComputeMatrixParam(computeShader: ComputeShader, nameID: number, val: Matrix4x4): void;
    SetComputeMatrixParam(computeShader: ComputeShader, name: string, val: Matrix4x4): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier, mipLevel: number): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier, mipLevel: number): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier, mipLevel: number, element: RenderTextureSubElement): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier, mipLevel: number, element: RenderTextureSubElement): void;
    SetComputeVectorArrayParam(computeShader: ComputeShader, nameID: number, values: CSArray<Vector4>): void;
    SetComputeVectorArrayParam(computeShader: ComputeShader, name: string, values: CSArray<Vector4>): void;
    SetComputeVectorParam(computeShader: ComputeShader, nameID: number, val: Vector4): void;
    SetComputeVectorParam(computeShader: ComputeShader, name: string, val: Vector4): void;
    SetExecutionFlags(flags: CommandBufferExecutionFlags): void;
    SetGlobalBuffer(name: string, value: ComputeBuffer): void;
    SetGlobalBuffer(nameID: number, value: ComputeBuffer): void;
    SetGlobalBuffer(name: string, value: GraphicsBuffer): void;
    SetGlobalBuffer(nameID: number, value: GraphicsBuffer): void;
    SetGlobalColor(nameID: number, value: Color): void;
    SetGlobalColor(name: string, value: Color): void;
    SetGlobalConstantBuffer(buffer: ComputeBuffer, nameID: number, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: ComputeBuffer, name: string, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: GraphicsBuffer, nameID: number, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: GraphicsBuffer, name: string, offset: number, size: number): void;
    SetGlobalDepthBias(bias: number, slopeBias: number): void;
    SetGlobalFloat(nameID: number, value: number): void;
    SetGlobalFloat(name: string, value: number): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(propertyName: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(propertyName: string, values: CSArray<number>): void;
    SetGlobalInt(nameID: number, value: number): void;
    SetGlobalInt(name: string, value: number): void;
    SetGlobalInteger(nameID: number, value: number): void;
    SetGlobalInteger(name: string, value: number): void;
    SetGlobalMatrix(nameID: number, value: Matrix4x4): void;
    SetGlobalMatrix(name: string, value: Matrix4x4): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(propertyName: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(propertyName: string, values: CSArray<Matrix4x4>): void;
    SetGlobalTexture(name: string, value: RenderTargetIdentifier): void;
    SetGlobalTexture(nameID: number, value: RenderTargetIdentifier): void;
    SetGlobalTexture(name: string, value: RenderTargetIdentifier, element: RenderTextureSubElement): void;
    SetGlobalTexture(nameID: number, value: RenderTargetIdentifier, element: RenderTextureSubElement): void;
    SetGlobalVector(nameID: number, value: Vector4): void;
    SetGlobalVector(name: string, value: Vector4): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(propertyName: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(propertyName: string, values: CSArray<Vector4>): void;
    SetInstanceMultiplier(multiplier: number): void;
    SetInvertCulling(invertCulling: boolean): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetKeyword(material: Material, keyword: unknown, value: boolean): void;
    SetKeyword(computeShader: ComputeShader, keyword: unknown, value: boolean): void;
    SetLateLatchProjectionMatrices(projectionMat: CSArray<Matrix4x4>): void;
    SetProjectionMatrix(proj: Matrix4x4): void;
    SetRandomWriteTarget(index: number, rt: RenderTargetIdentifier): void;
    SetRandomWriteTarget(index: number, buffer: ComputeBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, buffer: ComputeBuffer): void;
    SetRandomWriteTarget(index: number, buffer: GraphicsBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, buffer: GraphicsBuffer): void;
    SetRayTracingAccelerationStructure(rayTracingShader: RayTracingShader, name: string, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(rayTracingShader: RayTracingShader, nameID: number, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: ComputeBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: ComputeBuffer): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetRayTracingFloatParam(rayTracingShader: RayTracingShader, name: string, val: number): void;
    SetRayTracingFloatParam(rayTracingShader: RayTracingShader, nameID: number, val: number): void;
    SetRayTracingFloatParams(rayTracingShader: RayTracingShader, name: string, values: CSArray<number>): void;
    SetRayTracingFloatParams(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<number>): void;
    SetRayTracingIntParam(rayTracingShader: RayTracingShader, name: string, val: number): void;
    SetRayTracingIntParam(rayTracingShader: RayTracingShader, nameID: number, val: number): void;
    SetRayTracingIntParams(rayTracingShader: RayTracingShader, name: string, values: CSArray<number>): void;
    SetRayTracingIntParams(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<number>): void;
    SetRayTracingMatrixArrayParam(rayTracingShader: RayTracingShader, name: string, values: CSArray<Matrix4x4>): void;
    SetRayTracingMatrixArrayParam(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<Matrix4x4>): void;
    SetRayTracingMatrixParam(rayTracingShader: RayTracingShader, name: string, val: Matrix4x4): void;
    SetRayTracingMatrixParam(rayTracingShader: RayTracingShader, nameID: number, val: Matrix4x4): void;
    SetRayTracingShaderPass(rayTracingShader: RayTracingShader, passName: string): void;
    SetRayTracingTextureParam(rayTracingShader: RayTracingShader, name: string, rt: RenderTargetIdentifier): void;
    SetRayTracingTextureParam(rayTracingShader: RayTracingShader, nameID: number, rt: RenderTargetIdentifier): void;
    SetRayTracingVectorArrayParam(rayTracingShader: RayTracingShader, name: string, values: CSArray<Vector4>): void;
    SetRayTracingVectorArrayParam(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<Vector4>): void;
    SetRayTracingVectorParam(rayTracingShader: RayTracingShader, name: string, val: Vector4): void;
    SetRayTracingVectorParam(rayTracingShader: RayTracingShader, nameID: number, val: Vector4): void;
    SetRenderTarget(rt: RenderTargetIdentifier): void;
    SetRenderTarget(rt: RenderTargetIdentifier, loadAction: RenderBufferLoadAction, storeAction: RenderBufferStoreAction): void;
    SetRenderTarget(rt: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depth: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): void;
    SetRenderTarget(colors: CSArray<RenderTargetIdentifier>, depth: RenderTargetIdentifier): void;
    SetRenderTarget(colors: CSArray<RenderTargetIdentifier>, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(binding: RenderTargetBinding, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(binding: RenderTargetBinding): void;
    SetShadowSamplingMode(shadowmap: RenderTargetIdentifier, mode: ShadowSamplingMode): void;
    SetSinglePassStereo(mode: SinglePassStereoMode): void;
    SetViewMatrix(view: Matrix4x4): void;
    SetViewport(pixelRect: Rect): void;
    SetViewProjectionMatrices(view: Matrix4x4, proj: Matrix4x4): void;
    UnmarkLateLatchMatrix(matrixPropertyType: CameraLateLatchMatrixType): void;
    WaitAllAsyncReadbackRequests(): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStage): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStageFlags): void;
    WaitOnGPUFence(fence: GPUFence, stage: SynchronisationStage): void;
    WaitOnGPUFence(fence: GPUFence): void;
}
    
interface Sampler {
    isValid: boolean;
    name: string;


    GetRecorder(): Recorder;
}
    
interface Recorder {
    isValid: boolean;
    enabled: boolean;
    elapsedNanoseconds: number;
    gpuElapsedNanoseconds: number;
    sampleBlockCount: number;
    gpuSampleBlockCount: number;


    CollectFromAllThreads(): void;
    FilterToCurrentThread(): void;
}
    
interface RecorderConstructor {


    Get(samplerName: string): Recorder;
}
declare const Recorder: RecorderConstructor;
    
interface SamplerConstructor {


    Get(name: string): Sampler;
    GetNames(names: CSArray<string>): number;
}
declare const Sampler: SamplerConstructor;
    
interface CustomSampler extends Sampler {


    Begin(): void;
    Begin(targetObject: Object): void;
    End(): void;
}
    
interface CustomSamplerConstructor {


    Create(name: string, collectGpuData: boolean): CustomSampler;
}
declare const CustomSampler: CustomSamplerConstructor;
    
interface RenderTargetIdentifier {

    constructor(type: BuiltinRenderTextureType): RenderTargetIdentifier;
    constructor(type: BuiltinRenderTextureType, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    constructor(name: string): RenderTargetIdentifier;
    constructor(name: string, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    constructor(nameID: number): RenderTargetIdentifier;
    constructor(nameID: number, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    constructor(renderTargetIdentifier: RenderTargetIdentifier, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    constructor(tex: Texture): RenderTargetIdentifier;
    constructor(tex: Texture, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    constructor(buf: RenderBuffer, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;

    Equals(rhs: RenderTargetIdentifier): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface RenderTargetIdentifierConstructor {
    AllDepthSlices: number;


}
declare const RenderTargetIdentifier: RenderTargetIdentifierConstructor;
    
interface Material extends Object {
    shader: Shader;
    color: Color;
    mainTexture: Texture;
    mainTextureOffset: Vector2;
    mainTextureScale: Vector2;
    renderQueue: number;
    enabledKeywords: CSArray<LocalKeyword>;
    globalIlluminationFlags: MaterialGlobalIlluminationFlags;
    doubleSidedGI: boolean;
    enableInstancing: boolean;
    passCount: number;
    shaderKeywords: CSArray<string>;

    constructor(shader: Shader): Material;
    constructor(source: Material): Material;
    constructor(contents: string): Material;

    ComputeCRC(): number;
    CopyPropertiesFromMaterial(mat: Material): void;
    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    FindPass(passName: string): number;
    GetColor(name: string): Color;
    GetColor(nameID: number): Color;
    GetColorArray(name: string): CSArray<Color>;
    GetColorArray(nameID: number): CSArray<Color>;
    GetColorArray(name: string, values: CSArray<Color>): void;
    GetColorArray(nameID: number, values: CSArray<Color>): void;
    GetFloat(name: string): number;
    GetFloat(nameID: number): number;
    GetFloatArray(name: string): CSArray<number>;
    GetFloatArray(nameID: number): CSArray<number>;
    GetFloatArray(name: string, values: CSArray<number>): void;
    GetFloatArray(nameID: number, values: CSArray<number>): void;
    GetInt(name: string): number;
    GetInt(nameID: number): number;
    GetInteger(name: string): number;
    GetInteger(nameID: number): number;
    GetMatrix(name: string): Matrix4x4;
    GetMatrix(nameID: number): Matrix4x4;
    GetMatrixArray(name: string): CSArray<Matrix4x4>;
    GetMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetPassName(pass: number): string;
    GetShaderPassEnabled(passName: string): boolean;
    GetTag(tag: string, searchFallbacks: boolean, defaultValue: string): string;
    GetTag(tag: string, searchFallbacks: boolean): string;
    GetTexture(name: string): Texture;
    GetTexture(nameID: number): Texture;
    GetTextureOffset(name: string): Vector2;
    GetTextureOffset(nameID: number): Vector2;
    GetTexturePropertyNameIDs(): CSArray<number>;
    GetTexturePropertyNameIDs(outNames: CSArray<number>): void;
    GetTexturePropertyNames(): CSArray<string>;
    GetTexturePropertyNames(outNames: CSArray<string>): void;
    GetTextureScale(name: string): Vector2;
    GetTextureScale(nameID: number): Vector2;
    GetVector(name: string): Vector4;
    GetVector(nameID: number): Vector4;
    GetVectorArray(name: string): CSArray<Vector4>;
    GetVectorArray(nameID: number): CSArray<Vector4>;
    GetVectorArray(name: string, values: CSArray<Vector4>): void;
    GetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    HasBuffer(name: string): boolean;
    HasBuffer(nameID: number): boolean;
    HasColor(name: string): boolean;
    HasColor(nameID: number): boolean;
    HasConstantBuffer(name: string): boolean;
    HasConstantBuffer(nameID: number): boolean;
    HasFloat(name: string): boolean;
    HasFloat(nameID: number): boolean;
    HasInt(name: string): boolean;
    HasInt(nameID: number): boolean;
    HasInteger(name: string): boolean;
    HasInteger(nameID: number): boolean;
    HasMatrix(name: string): boolean;
    HasMatrix(nameID: number): boolean;
    HasProperty(nameID: number): boolean;
    HasProperty(name: string): boolean;
    HasTexture(name: string): boolean;
    HasTexture(nameID: number): boolean;
    HasVector(name: string): boolean;
    HasVector(nameID: number): boolean;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    Lerp(start: Material, end: Material, t: number): void;
    SetBuffer(name: string, value: ComputeBuffer): void;
    SetBuffer(nameID: number, value: ComputeBuffer): void;
    SetBuffer(name: string, value: GraphicsBuffer): void;
    SetBuffer(nameID: number, value: GraphicsBuffer): void;
    SetColor(name: string, value: Color): void;
    SetColor(nameID: number, value: Color): void;
    SetColorArray(name: string, values: CSArray<Color>): void;
    SetColorArray(nameID: number, values: CSArray<Color>): void;
    SetColorArray(name: string, values: CSArray<Color>): void;
    SetColorArray(nameID: number, values: CSArray<Color>): void;
    SetConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(name: string, value: number): void;
    SetFloat(nameID: number, value: number): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetInt(name: string, value: number): void;
    SetInt(nameID: number, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(nameID: number, value: number): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetMatrix(name: string, value: Matrix4x4): void;
    SetMatrix(nameID: number, value: Matrix4x4): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetOverrideTag(tag: string, val: string): void;
    SetPass(pass: number): boolean;
    SetShaderPassEnabled(passName: string, enabled: boolean): void;
    SetTexture(name: string, value: Texture): void;
    SetTexture(nameID: number, value: Texture): void;
    SetTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTextureOffset(name: string, value: Vector2): void;
    SetTextureOffset(nameID: number, value: Vector2): void;
    SetTextureScale(name: string, value: Vector2): void;
    SetTextureScale(nameID: number, value: Vector2): void;
    SetVector(name: string, value: Vector4): void;
    SetVector(nameID: number, value: Vector4): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
}
    
interface Shader extends Object {
    maximumLOD: number;
    isSupported: boolean;
    keywordSpace: LocalKeywordSpace;
    renderQueue: number;
    passCount: number;
    subshaderCount: number;


    FindPassTagValue(passIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindPassTagValue(subshaderIndex: number, passIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindPropertyIndex(propertyName: string): number;
    FindSubshaderTagValue(subshaderIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindTextureStack(propertyIndex: number, stackName: CSArray<string>, layerIndex: unknown): boolean;
    GetDependency(name: string): Shader;
    GetPassCountInSubshader(subshaderIndex: number): number;
    GetPropertyAttributes(propertyIndex: number): CSArray<string>;
    GetPropertyCount(): number;
    GetPropertyDefaultFloatValue(propertyIndex: number): number;
    GetPropertyDefaultVectorValue(propertyIndex: number): Vector4;
    GetPropertyDescription(propertyIndex: number): string;
    GetPropertyFlags(propertyIndex: number): ShaderPropertyFlags;
    GetPropertyName(propertyIndex: number): string;
    GetPropertyNameId(propertyIndex: number): number;
    GetPropertyRangeLimits(propertyIndex: number): Vector2;
    GetPropertyTextureDefaultName(propertyIndex: number): string;
    GetPropertyTextureDimension(propertyIndex: number): TextureDimension;
    GetPropertyType(propertyIndex: number): ShaderPropertyType;
}
    
interface LocalKeywordSpace {
    keywords: CSArray<LocalKeyword>;
    keywordNames: CSArray<string>;
    keywordCount: number;


    Equals(o: unknown): boolean;
    Equals(rhs: LocalKeywordSpace): boolean;
    FindKeyword(name: string): LocalKeyword;
    GetHashCode(): number;
}
    
interface LocalKeyword {
    name: string;
    isOverridable: boolean;
    isValid: boolean;
    type: ShaderKeywordType;

    constructor(shader: Shader, name: string): LocalKeyword;
    constructor(shader: ComputeShader, name: string): LocalKeyword;

    Equals(o: unknown): boolean;
    Equals(rhs: LocalKeyword): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface ShaderTagId {
    name: string;

    constructor(name: string): ShaderTagId;

    Equals(obj: unknown): boolean;
    Equals(other: ShaderTagId): boolean;
    GetHashCode(): number;
}
    
interface ShaderTagIdConstructor {
    none: ShaderTagId;


}
declare const ShaderTagId: ShaderTagIdConstructor;
    
interface GlobalKeyword {
    name: string;

    constructor(name: string): GlobalKeyword;

    ToString(): string;
}
    
interface GlobalKeywordConstructor {


    Create(name: string): GlobalKeyword;
}
declare const GlobalKeyword: GlobalKeywordConstructor;
    
interface ComputeBuffer {
    count: number;
    stride: number;
    name: string;

    constructor(count: number, stride: number): ComputeBuffer;
    constructor(count: number, stride: number, type: ComputeBufferType): ComputeBuffer;
    constructor(count: number, stride: number, type: ComputeBufferType, usage: ComputeBufferMode): ComputeBuffer;

    BeginWrite<T>(computeBufferStartIndex: number, count: number): CSArray<T>;
    Dispose(): void;
    EndWrite<T>(countWritten: number): void;
    GetData(data: unknown): void;
    GetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    GetNativeBufferPtr(): unknown;
    IsValid(): boolean;
    Release(): void;
    SetCounterValue(counterValue: number): void;
    SetData(data: unknown): void;
    SetData<T>(data: CSArray<T>): void;
    SetData<T>(data: CSArray<T>): void;
    SetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, nativeBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
}
    
interface ComputeBufferConstructor {


    CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
}
declare const ComputeBuffer: ComputeBufferConstructor;
    
interface GraphicsBuffer {
    count: number;
    stride: number;
    target: Target;
    name: string;

    constructor(target: Target, count: number, stride: number): GraphicsBuffer;

    Dispose(): void;
    GetData(data: unknown): void;
    GetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    GetNativeBufferPtr(): unknown;
    IsValid(): boolean;
    Release(): void;
    SetCounterValue(counterValue: number): void;
    SetData(data: unknown): void;
    SetData<T>(data: CSArray<T>): void;
    SetData<T>(data: CSArray<T>): void;
    SetData(data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
}
    
interface GraphicsBufferConstructor {


    CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCount(src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCount(src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyCount(src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
}
declare const GraphicsBuffer: GraphicsBufferConstructor;
    
interface ShaderConstructor {
    maximumChunksOverride: number;
    globalMaximumLOD: number;
    globalRenderPipeline: string;
    enabledGlobalKeywords: CSArray<GlobalKeyword>;
    globalKeywords: CSArray<GlobalKeyword>;
    globalShaderHardwareTier: ShaderHardwareTier;


    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    Find(name: string): Shader;
    GetGlobalColor(name: string): Color;
    GetGlobalColor(nameID: number): Color;
    GetGlobalFloat(name: string): number;
    GetGlobalFloat(nameID: number): number;
    GetGlobalFloatArray(name: string): CSArray<number>;
    GetGlobalFloatArray(nameID: number): CSArray<number>;
    GetGlobalFloatArray(name: string, values: CSArray<number>): void;
    GetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    GetGlobalInt(name: string): number;
    GetGlobalInt(nameID: number): number;
    GetGlobalInteger(name: string): number;
    GetGlobalInteger(nameID: number): number;
    GetGlobalMatrix(name: string): Matrix4x4;
    GetGlobalMatrix(nameID: number): Matrix4x4;
    GetGlobalMatrixArray(name: string): CSArray<Matrix4x4>;
    GetGlobalMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetGlobalTexture(name: string): Texture;
    GetGlobalTexture(nameID: number): Texture;
    GetGlobalVector(name: string): Vector4;
    GetGlobalVector(nameID: number): Vector4;
    GetGlobalVectorArray(name: string): CSArray<Vector4>;
    GetGlobalVectorArray(nameID: number): CSArray<Vector4>;
    GetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    GetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    PropertyToID(name: string): number;
    SetGlobalBuffer(name: string, value: ComputeBuffer): void;
    SetGlobalBuffer(nameID: number, value: ComputeBuffer): void;
    SetGlobalBuffer(name: string, value: GraphicsBuffer): void;
    SetGlobalBuffer(nameID: number, value: GraphicsBuffer): void;
    SetGlobalColor(name: string, value: Color): void;
    SetGlobalColor(nameID: number, value: Color): void;
    SetGlobalConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetGlobalFloat(name: string, value: number): void;
    SetGlobalFloat(nameID: number, value: number): void;
    SetGlobalFloatArray(name: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(name: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalInt(name: string, value: number): void;
    SetGlobalInt(nameID: number, value: number): void;
    SetGlobalInteger(name: string, value: number): void;
    SetGlobalInteger(nameID: number, value: number): void;
    SetGlobalMatrix(name: string, value: Matrix4x4): void;
    SetGlobalMatrix(nameID: number, value: Matrix4x4): void;
    SetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalTexGenMode(propertyName: string, mode: TexGenMode): void;
    SetGlobalTexture(name: string, value: Texture): void;
    SetGlobalTexture(nameID: number, value: Texture): void;
    SetGlobalTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetGlobalTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetGlobalTextureMatrixName(propertyName: string, matrixName: string): void;
    SetGlobalVector(name: string, value: Vector4): void;
    SetGlobalVector(nameID: number, value: Vector4): void;
    SetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    WarmupAllShaders(): void;
}
declare const Shader: ShaderConstructor;
    
interface MaterialConstructor {


    Create(scriptContents: string): Material;
}
declare const Material: MaterialConstructor;
    
interface RayTracingAccelerationStructure {

    constructor(settings: RASSettings): RayTracingAccelerationStructure;
    constructor(): RayTracingAccelerationStructure;

    AddInstance(targetRenderer: Renderer, subMeshMask: CSArray<boolean>, subMeshTransparencyFlags: CSArray<boolean>, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, id: number): void;
    AddInstance(targetRenderer: Renderer, subMeshFlags: CSArray<number>, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, id: number): void;
    AddInstance(aabbBuffer: GraphicsBuffer, numElements: number, material: Material, isCutOff: boolean, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, reuseBounds: boolean, id: number): void;
    AddInstance(aabbBuffer: GraphicsBuffer, numElements: number, material: Material, instanceTransform: Matrix4x4, isCutOff: boolean, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, reuseBounds: boolean, id: number): void;
    Build(): void;
    Build(relativeOrigin: Vector3): void;
    Dispose(): void;
    GetInstanceCount(): number;
    GetSize(): number;
    Release(): void;
    RemoveInstance(targetRenderer: Renderer): void;
    Update(): void;
    Update(relativeOrigin: Vector3): void;
    UpdateInstanceID(renderer: Renderer, instanceID: number): void;
    UpdateInstanceMask(renderer: Renderer, mask: number): void;
    UpdateInstanceTransform(renderer: Renderer): void;
}
    
interface Renderer extends Component {
    bounds: Bounds;
    localBounds: Bounds;
    enabled: boolean;
    isVisible: boolean;
    shadowCastingMode: ShadowCastingMode;
    receiveShadows: boolean;
    forceRenderingOff: boolean;
    staticShadowCaster: boolean;
    motionVectorGenerationMode: MotionVectorGenerationMode;
    lightProbeUsage: LightProbeUsage;
    reflectionProbeUsage: ReflectionProbeUsage;
    renderingLayerMask: number;
    rendererPriority: number;
    rayTracingMode: RayTracingMode;
    sortingLayerName: string;
    sortingLayerID: number;
    sortingOrder: number;
    allowOcclusionWhenDynamic: boolean;
    isPartOfStaticBatch: boolean;
    worldToLocalMatrix: Matrix4x4;
    localToWorldMatrix: Matrix4x4;
    lightProbeProxyVolumeOverride: GameObject;
    probeAnchor: Transform;
    lightmapIndex: number;
    realtimeLightmapIndex: number;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;
    materials: CSArray<Material>;
    material: Material;
    sharedMaterial: Material;
    sharedMaterials: CSArray<Material>;
    lightmapTilingOffset: Vector4;
    lightProbeAnchor: Transform;
    castShadows: boolean;
    motionVectors: boolean;
    useLightProbes: boolean;

    constructor(): Renderer;

    GetClosestReflectionProbes(result: CSArray<ReflectionProbeBlendInfo>): void;
    GetMaterials(m: CSArray<Material>): void;
    GetPropertyBlock(properties: MaterialPropertyBlock): void;
    GetPropertyBlock(properties: MaterialPropertyBlock, materialIndex: number): void;
    GetSharedMaterials(m: CSArray<Material>): void;
    HasPropertyBlock(): boolean;
    ResetBounds(): void;
    ResetLocalBounds(): void;
    SetPropertyBlock(properties: MaterialPropertyBlock): void;
    SetPropertyBlock(properties: MaterialPropertyBlock, materialIndex: number): void;
}
    
interface ReflectionProbeBlendInfo {
    probe: ReflectionProbe;
    weight: number;


}
    
interface ReflectionProbe extends Behaviour {
    type: ReflectionProbeType;
    size: Vector3;
    center: Vector3;
    nearClipPlane: number;
    farClipPlane: number;
    intensity: number;
    bounds: Bounds;
    hdr: boolean;
    renderDynamicObjects: boolean;
    shadowDistance: number;
    resolution: number;
    cullingMask: number;
    clearFlags: ReflectionProbeClearFlags;
    backgroundColor: Color;
    blendDistance: number;
    boxProjection: boolean;
    mode: ReflectionProbeMode;
    importance: number;
    refreshMode: ReflectionProbeRefreshMode;
    timeSlicingMode: ReflectionProbeTimeSlicingMode;
    bakedTexture: Texture;
    customBakedTexture: Texture;
    realtimeTexture: RenderTexture;
    texture: Texture;
    textureHDRDecodeValues: Vector4;

    constructor(): ReflectionProbe;

    IsFinishedRendering(renderId: number): boolean;
    RenderProbe(): number;
    RenderProbe(targetTexture: RenderTexture): number;
    Reset(): void;
}
    
interface ReflectionProbeConstructor {
    minBakedCubemapResolution: number;
    maxBakedCubemapResolution: number;
    defaultTextureHDRDecodeValues: Vector4;
    defaultTexture: Texture;


    BlendCubemap(src: Texture, dst: Texture, blend: number, target: RenderTexture): boolean;
    UpdateCachedState(): void;
}
declare const ReflectionProbe: ReflectionProbeConstructor;
    
interface MaterialPropertyBlock {
    isEmpty: boolean;

    constructor(): MaterialPropertyBlock;

    AddColor(name: string, value: Color): void;
    AddColor(nameID: number, value: Color): void;
    AddFloat(name: string, value: number): void;
    AddFloat(nameID: number, value: number): void;
    AddMatrix(name: string, value: Matrix4x4): void;
    AddMatrix(nameID: number, value: Matrix4x4): void;
    AddTexture(name: string, value: Texture): void;
    AddTexture(nameID: number, value: Texture): void;
    AddVector(name: string, value: Vector4): void;
    AddVector(nameID: number, value: Vector4): void;
    Clear(): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>, sourceStart: number, destStart: number, count: number): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>, sourceStart: number, destStart: number, count: number): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>, sourceStart: number, destStart: number, count: number): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>, sourceStart: number, destStart: number, count: number): void;
    GetColor(name: string): Color;
    GetColor(nameID: number): Color;
    GetFloat(name: string): number;
    GetFloat(nameID: number): number;
    GetFloatArray(name: string): CSArray<number>;
    GetFloatArray(nameID: number): CSArray<number>;
    GetFloatArray(name: string, values: CSArray<number>): void;
    GetFloatArray(nameID: number, values: CSArray<number>): void;
    GetInt(name: string): number;
    GetInt(nameID: number): number;
    GetInteger(name: string): number;
    GetInteger(nameID: number): number;
    GetMatrix(name: string): Matrix4x4;
    GetMatrix(nameID: number): Matrix4x4;
    GetMatrixArray(name: string): CSArray<Matrix4x4>;
    GetMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetTexture(name: string): Texture;
    GetTexture(nameID: number): Texture;
    GetVector(name: string): Vector4;
    GetVector(nameID: number): Vector4;
    GetVectorArray(name: string): CSArray<Vector4>;
    GetVectorArray(nameID: number): CSArray<Vector4>;
    GetVectorArray(name: string, values: CSArray<Vector4>): void;
    GetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    HasBuffer(name: string): boolean;
    HasBuffer(nameID: number): boolean;
    HasColor(name: string): boolean;
    HasColor(nameID: number): boolean;
    HasConstantBuffer(name: string): boolean;
    HasConstantBuffer(nameID: number): boolean;
    HasFloat(name: string): boolean;
    HasFloat(nameID: number): boolean;
    HasInt(name: string): boolean;
    HasInt(nameID: number): boolean;
    HasInteger(name: string): boolean;
    HasInteger(nameID: number): boolean;
    HasMatrix(name: string): boolean;
    HasMatrix(nameID: number): boolean;
    HasProperty(name: string): boolean;
    HasProperty(nameID: number): boolean;
    HasTexture(name: string): boolean;
    HasTexture(nameID: number): boolean;
    HasVector(name: string): boolean;
    HasVector(nameID: number): boolean;
    SetBuffer(name: string, value: ComputeBuffer): void;
    SetBuffer(nameID: number, value: ComputeBuffer): void;
    SetBuffer(name: string, value: GraphicsBuffer): void;
    SetBuffer(nameID: number, value: GraphicsBuffer): void;
    SetColor(name: string, value: Color): void;
    SetColor(nameID: number, value: Color): void;
    SetConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(name: string, value: number): void;
    SetFloat(nameID: number, value: number): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetInt(name: string, value: number): void;
    SetInt(nameID: number, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(nameID: number, value: number): void;
    SetMatrix(name: string, value: Matrix4x4): void;
    SetMatrix(nameID: number, value: Matrix4x4): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetTexture(name: string, value: Texture): void;
    SetTexture(nameID: number, value: Texture): void;
    SetTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetVector(name: string, value: Vector4): void;
    SetVector(nameID: number, value: Vector4): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
}
    
interface SphericalHarmonicsL2 {
    Item: number;


    AddAmbientLight(color: Color): void;
    AddDirectionalLight(direction: Vector3, color: Color, intensity: number): void;
    Clear(): void;
    Equals(other: unknown): boolean;
    Equals(other: SphericalHarmonicsL2): boolean;
    Evaluate(directions: CSArray<Vector3>, results: CSArray<Color>): void;
    GetHashCode(): number;
}
    
interface GraphicsFence {
    passed: boolean;


}
    
interface GPUFence {
    passed: boolean;


}
    
interface ComputeShader extends Object {
    keywordSpace: LocalKeywordSpace;
    shaderKeywords: CSArray<string>;
    enabledKeywords: CSArray<LocalKeyword>;


    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    Dispatch(kernelIndex: number, threadGroupsX: number, threadGroupsY: number, threadGroupsZ: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: ComputeBuffer, argsOffset: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: ComputeBuffer): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: GraphicsBuffer, argsOffset: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: GraphicsBuffer): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    FindKernel(name: string): number;
    GetKernelThreadGroupSizes(kernelIndex: number, x: unknown, y: unknown, z: unknown): void;
    HasKernel(name: string): boolean;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    IsSupported(kernelIndex: number): boolean;
    SetBool(name: string, val: boolean): void;
    SetBool(nameID: number, val: boolean): void;
    SetBuffer(kernelIndex: number, nameID: number, buffer: ComputeBuffer): void;
    SetBuffer(kernelIndex: number, nameID: number, buffer: GraphicsBuffer): void;
    SetBuffer(kernelIndex: number, name: string, buffer: ComputeBuffer): void;
    SetBuffer(kernelIndex: number, name: string, buffer: GraphicsBuffer): void;
    SetConstantBuffer(nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(nameID: number, val: number): void;
    SetFloat(name: string, val: number): void;
    SetFloats(name: string, values: CSArray<number>): void;
    SetFloats(nameID: number, values: CSArray<number>): void;
    SetInt(nameID: number, val: number): void;
    SetInt(name: string, val: number): void;
    SetInts(name: string, values: CSArray<number>): void;
    SetInts(nameID: number, values: CSArray<number>): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetMatrix(nameID: number, val: Matrix4x4): void;
    SetMatrix(name: string, val: Matrix4x4): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetTexture(kernelIndex: number, nameID: number, texture: Texture, mipLevel: number): void;
    SetTexture(kernelIndex: number, nameID: number, texture: Texture): void;
    SetTexture(kernelIndex: number, name: string, texture: Texture): void;
    SetTexture(kernelIndex: number, name: string, texture: Texture, mipLevel: number): void;
    SetTexture(kernelIndex: number, nameID: number, texture: RenderTexture, mipLevel: number, element: RenderTextureSubElement): void;
    SetTexture(kernelIndex: number, name: string, texture: RenderTexture, mipLevel: number, element: RenderTextureSubElement): void;
    SetTextureFromGlobal(kernelIndex: number, nameID: number, globalTextureNameID: number): void;
    SetTextureFromGlobal(kernelIndex: number, name: string, globalTextureName: string): void;
    SetVector(nameID: number, val: Vector4): void;
    SetVector(name: string, val: Vector4): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
}
    
interface RayTracingShader extends Object {
    maxRecursionDepth: number;


    Dispatch(rayGenFunctionName: string, width: number, height: number, depth: number, camera: Camera): void;
    SetAccelerationStructure(nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    SetAccelerationStructure(name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    SetBool(name: string, val: boolean): void;
    SetBool(nameID: number, val: boolean): void;
    SetBuffer(nameID: number, buffer: ComputeBuffer): void;
    SetBuffer(nameID: number, buffer: GraphicsBuffer): void;
    SetBuffer(name: string, buffer: ComputeBuffer): void;
    SetBuffer(name: string, buffer: GraphicsBuffer): void;
    SetConstantBuffer(nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(nameID: number, val: number): void;
    SetFloat(name: string, val: number): void;
    SetFloats(name: string, values: CSArray<number>): void;
    SetFloats(nameID: number, values: CSArray<number>): void;
    SetInt(nameID: number, val: number): void;
    SetInt(name: string, val: number): void;
    SetInts(name: string, values: CSArray<number>): void;
    SetInts(nameID: number, values: CSArray<number>): void;
    SetMatrix(nameID: number, val: Matrix4x4): void;
    SetMatrix(name: string, val: Matrix4x4): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetShaderPass(passName: string): void;
    SetTexture(nameID: number, texture: Texture): void;
    SetTexture(name: string, texture: Texture): void;
    SetTextureFromGlobal(nameID: number, globalTextureNameID: number): void;
    SetTextureFromGlobal(name: string, globalTextureName: string): void;
    SetVector(nameID: number, val: Vector4): void;
    SetVector(name: string, val: Vector4): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
}
    
interface Mesh extends Object {
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    tangents: CSArray<Vector4>;
    uv: CSArray<Vector2>;
    uv2: CSArray<Vector2>;
    uv3: CSArray<Vector2>;
    uv4: CSArray<Vector2>;
    uv5: CSArray<Vector2>;
    uv6: CSArray<Vector2>;
    uv7: CSArray<Vector2>;
    uv8: CSArray<Vector2>;
    colors: CSArray<Color>;
    colors32: CSArray<Color32>;
    vertexAttributeCount: number;
    triangles: CSArray<number>;
    boneWeights: CSArray<BoneWeight>;
    indexFormat: IndexFormat;
    vertexBufferCount: number;
    vertexBufferTarget: Target;
    indexBufferTarget: Target;
    blendShapeCount: number;
    bindposes: CSArray<Matrix4x4>;
    isReadable: boolean;
    vertexCount: number;
    subMeshCount: number;
    bounds: Bounds;
    uv1: CSArray<Vector2>;

    constructor(): Mesh;

    AddBlendShapeFrame(shapeName: string, frameWeight: number, deltaVertices: CSArray<Vector3>, deltaNormals: CSArray<Vector3>, deltaTangents: CSArray<Vector3>): void;
    Clear(keepVertexLayout: boolean): void;
    Clear(): void;
    ClearBlendShapes(): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean, useMatrices: boolean, hasLightmapData: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean, useMatrices: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>): void;
    GetAllBoneWeights(): CSArray<BoneWeight1>;
    GetBaseVertex(submesh: number): number;
    GetBindposes(bindposes: CSArray<Matrix4x4>): void;
    GetBlendShapeFrameCount(shapeIndex: number): number;
    GetBlendShapeFrameVertices(shapeIndex: number, frameIndex: number, deltaVertices: CSArray<Vector3>, deltaNormals: CSArray<Vector3>, deltaTangents: CSArray<Vector3>): void;
    GetBlendShapeFrameWeight(shapeIndex: number, frameIndex: number): number;
    GetBlendShapeIndex(blendShapeName: string): number;
    GetBlendShapeName(shapeIndex: number): string;
    GetBonesPerVertex(): CSArray<number>;
    GetBoneWeights(boneWeights: CSArray<BoneWeight>): void;
    GetColors(colors: CSArray<Color>): void;
    GetColors(colors: CSArray<Color32>): void;
    GetIndexBuffer(): GraphicsBuffer;
    GetIndexCount(submesh: number): number;
    GetIndexStart(submesh: number): number;
    GetIndices(submesh: number): CSArray<number>;
    GetIndices(submesh: number, applyBaseVertex: boolean): CSArray<number>;
    GetIndices(indices: CSArray<number>, submesh: number): void;
    GetIndices(indices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetIndices(indices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetNativeIndexBufferPtr(): unknown;
    GetNativeVertexBufferPtr(index: number): unknown;
    GetNormals(normals: CSArray<Vector3>): void;
    GetSubMesh(index: number): SubMeshDescriptor;
    GetTangents(tangents: CSArray<Vector4>): void;
    GetTopology(submesh: number): MeshTopology;
    GetTriangles(submesh: number): CSArray<number>;
    GetTriangles(submesh: number, applyBaseVertex: boolean): CSArray<number>;
    GetTriangles(triangles: CSArray<number>, submesh: number): void;
    GetTriangles(triangles: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetTriangles(triangles: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetUVDistributionMetric(uvSetIndex: number): number;
    GetUVs(channel: number, uvs: CSArray<Vector2>): void;
    GetUVs(channel: number, uvs: CSArray<Vector3>): void;
    GetUVs(channel: number, uvs: CSArray<Vector4>): void;
    GetVertexAttribute(index: number): VertexAttributeDescriptor;
    GetVertexAttributeDimension(attr: VertexAttribute): number;
    GetVertexAttributeFormat(attr: VertexAttribute): VertexAttributeFormat;
    GetVertexAttributeOffset(attr: VertexAttribute): number;
    GetVertexAttributes(): CSArray<VertexAttributeDescriptor>;
    GetVertexAttributes(attributes: CSArray<VertexAttributeDescriptor>): number;
    GetVertexAttributes(attributes: CSArray<VertexAttributeDescriptor>): number;
    GetVertexAttributeStream(attr: VertexAttribute): number;
    GetVertexBuffer(index: number): GraphicsBuffer;
    GetVertexBufferStride(stream: number): number;
    GetVertices(vertices: CSArray<Vector3>): void;
    HasVertexAttribute(attr: VertexAttribute): boolean;
    MarkDynamic(): void;
    MarkModified(): void;
    Optimize(): void;
    OptimizeIndexBuffers(): void;
    OptimizeReorderVertexBuffer(): void;
    RecalculateBounds(): void;
    RecalculateBounds(flags: MeshUpdateFlags): void;
    RecalculateNormals(): void;
    RecalculateNormals(flags: MeshUpdateFlags): void;
    RecalculateTangents(): void;
    RecalculateTangents(flags: MeshUpdateFlags): void;
    RecalculateUVDistributionMetric(uvSetIndex: number, uvAreaThreshold: number): void;
    RecalculateUVDistributionMetrics(uvAreaThreshold: number): void;
    SetBoneWeights(bonesPerVertex: CSArray<number>, weights: CSArray<BoneWeight1>): void;
    SetColors(inColors: CSArray<Color>): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color>): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color32>): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color32>): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors<T>(inColors: CSArray<T>): void;
    SetColors<T>(inColors: CSArray<T>, start: number, length: number): void;
    SetColors<T>(inColors: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferParams(indexCount: number, format: IndexFormat): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices<T>(indices: CSArray<T>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices<T>(indices: CSArray<T>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetNormals(inNormals: CSArray<Vector3>): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetNormals(inNormals: CSArray<Vector3>): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetNormals<T>(inNormals: CSArray<T>): void;
    SetNormals<T>(inNormals: CSArray<T>, start: number, length: number): void;
    SetNormals<T>(inNormals: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetSubMesh(index: number, desc: SubMeshDescriptor, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, flags: MeshUpdateFlags): void;
    SetSubMeshes<T>(desc: CSArray<T>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes<T>(desc: CSArray<T>, flags: MeshUpdateFlags): void;
    SetTangents(inTangents: CSArray<Vector4>): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTangents(inTangents: CSArray<Vector4>): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTangents<T>(inTangents: CSArray<T>): void;
    SetTangents<T>(inTangents: CSArray<T>, start: number, length: number): void;
    SetTangents<T>(inTangents: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTriangles(triangles: CSArray<number>, submesh: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>, start: number, length: number): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertices(inVertices: CSArray<Vector3>): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertices(inVertices: CSArray<Vector3>): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertices<T>(inVertices: CSArray<T>): void;
    SetVertices<T>(inVertices: CSArray<T>, start: number, length: number): void;
    SetVertices<T>(inVertices: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    UploadMeshData(markNoLongerReadable: boolean): void;
}
    
interface BoneWeight {
    weight0: number;
    weight1: number;
    weight2: number;
    weight3: number;
    boneIndex0: number;
    boneIndex1: number;
    boneIndex2: number;
    boneIndex3: number;


    Equals(other: unknown): boolean;
    Equals(other: BoneWeight): boolean;
    GetHashCode(): number;
}
    
interface CombineInstance {
    mesh: Mesh;
    subMeshIndex: number;
    transform: Matrix4x4;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;


}
    
interface BoneWeight1 {
    weight: number;
    boneIndex: number;


    Equals(other: unknown): boolean;
    Equals(other: BoneWeight1): boolean;
    GetHashCode(): number;
}
    
interface SubMeshDescriptor {
    bounds: Bounds;
    topology: MeshTopology;
    indexStart: number;
    indexCount: number;
    baseVertex: number;
    firstVertex: number;
    vertexCount: number;

    constructor(indexStart: number, indexCount: number, topology: MeshTopology): SubMeshDescriptor;

    ToString(): string;
}
    
interface VertexAttributeDescriptor {
    attribute: VertexAttribute;
    format: VertexAttributeFormat;
    dimension: number;
    stream: number;

    constructor(attribute: VertexAttribute, format: VertexAttributeFormat, dimension: number, stream: number): VertexAttributeDescriptor;

    Equals(other: unknown): boolean;
    Equals(other: VertexAttributeDescriptor): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface MeshDataArray {
    Length: number;
    Item: MeshData;


    Dispose(): void;
}
    
interface MeshData {
    vertexCount: number;
    vertexBufferCount: number;
    indexFormat: IndexFormat;
    subMeshCount: number;


    GetColors(outColors: CSArray<Color>): void;
    GetColors(outColors: CSArray<Color32>): void;
    GetIndexData<T>(): CSArray<T>;
    GetIndices(outIndices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetIndices(outIndices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetNormals(outNormals: CSArray<Vector3>): void;
    GetSubMesh(index: number): SubMeshDescriptor;
    GetTangents(outTangents: CSArray<Vector4>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector2>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector3>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector4>): void;
    GetVertexAttributeDimension(attr: VertexAttribute): number;
    GetVertexAttributeFormat(attr: VertexAttribute): VertexAttributeFormat;
    GetVertexAttributeOffset(attr: VertexAttribute): number;
    GetVertexAttributeStream(attr: VertexAttribute): number;
    GetVertexBufferStride(stream: number): number;
    GetVertexData<T>(stream: number): CSArray<T>;
    GetVertices(outVertices: CSArray<Vector3>): void;
    HasVertexAttribute(attr: VertexAttribute): boolean;
    SetIndexBufferParams(indexCount: number, format: IndexFormat): void;
    SetSubMesh(index: number, desc: SubMeshDescriptor, flags: MeshUpdateFlags): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
}
    
interface MeshConstructor {


    AcquireReadOnlyMeshData(mesh: Mesh): MeshDataArray;
    AcquireReadOnlyMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AcquireReadOnlyMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AllocateWritableMeshData(meshCount: number): MeshDataArray;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, mesh: Mesh, flags: MeshUpdateFlags): void;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, meshes: CSArray<Mesh>, flags: MeshUpdateFlags): void;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, meshes: CSArray<Mesh>, flags: MeshUpdateFlags): void;
}
declare const Mesh: MeshConstructor;
    
interface RectInt {
    x: number;
    y: number;
    center: Vector2;
    min: Vector2Int;
    max: Vector2Int;
    width: number;
    height: number;
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
    position: Vector2Int;
    size: Vector2Int;
    allPositionsWithin: PositionEnumerator;

    constructor(xMin: number, yMin: number, width: number, height: number): RectInt;
    constructor(position: Vector2Int, size: Vector2Int): RectInt;

    ClampToBounds(bounds: RectInt): void;
    Contains(position: Vector2Int): boolean;
    Equals(other: RectInt): boolean;
    Overlaps(other: RectInt): boolean;
    SetMinMax(minPosition: Vector2Int, maxPosition: Vector2Int): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface PositionEnumerator {
    Current: Vector2Int;

    constructor(min: Vector2Int, max: Vector2Int): PositionEnumerator;

    GetEnumerator(): PositionEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}
    
interface RendererList {
    isValid: boolean;


}
    
interface RendererListConstructor {
    nullRendererList: RendererList;


}
declare const RendererList: RendererListConstructor;
    
interface RenderTargetBinding {
    colorRenderTargets: CSArray<RenderTargetIdentifier>;
    depthRenderTarget: RenderTargetIdentifier;
    colorLoadActions: CSArray<number>;
    colorStoreActions: CSArray<number>;
    depthLoadAction: RenderBufferLoadAction;
    depthStoreAction: RenderBufferStoreAction;
    flags: RenderTargetFlags;

    constructor(colorRenderTargets: CSArray<RenderTargetIdentifier>, colorLoadActions: CSArray<number>, colorStoreActions: CSArray<number>, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): RenderTargetBinding;
    constructor(colorRenderTarget: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): RenderTargetBinding;
    constructor(setup: RenderTargetSetup): RenderTargetBinding;

}
    
interface Cubemap extends Texture {
    format: TextureFormat;
    isReadable: boolean;
    streamingMipmaps: boolean;
    streamingMipmapsPriority: number;
    requestedMipmapLevel: number;
    desiredMipmapLevel: number;
    loadingMipmapLevel: number;
    loadedMipmapLevel: number;

    constructor(width: number, format: DefaultFormat, flags: TextureCreationFlags): Cubemap;
    constructor(width: number, format: GraphicsFormat, flags: TextureCreationFlags): Cubemap;
    constructor(width: number, format: TextureFormat, mipCount: number): Cubemap;
    constructor(width: number, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: number): Cubemap;
    constructor(width: number, textureFormat: TextureFormat, mipChain: boolean): Cubemap;

    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    ClearRequestedMipmapLevel(): void;
    GetPixel(face: CubemapFace, x: number, y: number): Color;
    GetPixel(face: CubemapFace, x: number, y: number, mip: number): Color;
    GetPixelData<T>(mipLevel: number, face: CubemapFace): CSArray<T>;
    GetPixels(face: CubemapFace, miplevel: number): CSArray<Color>;
    GetPixels(face: CubemapFace): CSArray<Color>;
    IsRequestedMipmapLevelLoaded(): boolean;
    SetPixel(face: CubemapFace, x: number, y: number, color: Color): void;
    SetPixel(face: CubemapFace, x: number, y: number, color: Color, mip: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, face: CubemapFace, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, face: CubemapFace, sourceDataStartIndex: number): void;
    SetPixels(colors: CSArray<Color>, face: CubemapFace, miplevel: number): void;
    SetPixels(colors: CSArray<Color>, face: CubemapFace): void;
    SmoothEdges(smoothRegionWidthInPixels: number): void;
    SmoothEdges(): void;
    UpdateExternalTexture(nativeTexture: unknown): void;
}
    
interface CubemapConstructor {


    CreateExternalTexture(width: number, format: TextureFormat, mipmap: boolean, nativeTex: unknown): Cubemap;
}
declare const Cubemap: CubemapConstructor;
    
interface RenderRequest {
    isValid: boolean;
    mode: RenderRequestMode;
    result: RenderTexture;
    outputSpace: RenderRequestOutputSpace;

    constructor(mode: RenderRequestMode, rt: RenderTexture): RenderRequest;
    constructor(mode: RenderRequestMode, space: RenderRequestOutputSpace, rt: RenderTexture): RenderRequest;

}
    
interface CameraCallback {

    constructor(object: unknown, method: unknown): CameraCallback;

    BeginInvoke(cam: Camera, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(cam: Camera): void;
}
    
interface GateFitParameters {
    mode: GateFitMode;
    aspect: number;

    constructor(mode: GateFitMode, aspect: number): GateFitParameters;

}
    
interface CameraConstructor {
    onPreCull: CameraCallback;
    onPreRender: CameraCallback;
    onPostRender: CameraCallback;
    main: Camera;
    current: Camera;
    allCamerasCount: number;
    allCameras: CSArray<Camera>;
    mainCamera: Camera;


    CalculateProjectionMatrixFromPhysicalProperties(output: unknown, focalLength: number, sensorSize: Vector2, lensShift: Vector2, nearClip: number, farClip: number, gateFitParameters: GateFitParameters): void;
    FieldOfViewToFocalLength(fieldOfView: number, sensorSize: number): number;
    FocalLengthToFieldOfView(focalLength: number, sensorSize: number): number;
    GetAllCameras(cameras: CSArray<Camera>): number;
    HorizontalToVerticalFieldOfView(horizontalFieldOfView: number, aspectRatio: number): number;
    SetupCurrent(cur: Camera): void;
    VerticalToHorizontalFieldOfView(verticalFieldOfView: number, aspectRatio: number): number;
}
declare const Camera: CameraConstructor;
    
interface Input {

    constructor(): Input;

}
    
interface LocationService {
    isEnabledByUser: boolean;
    status: LocationServiceStatus;
    lastData: LocationInfo;

    constructor(): LocationService;

    Start(desiredAccuracyInMeters: number, updateDistanceInMeters: number): void;
    Start(desiredAccuracyInMeters: number): void;
    Start(): void;
    Stop(): void;
}
    
interface LocationInfo {
    latitude: number;
    longitude: number;
    altitude: number;
    horizontalAccuracy: number;
    verticalAccuracy: number;
    timestamp: number;


}
    
interface Compass {
    magneticHeading: number;
    trueHeading: number;
    headingAccuracy: number;
    rawVector: Vector3;
    timestamp: number;
    enabled: boolean;

    constructor(): Compass;

}
    
interface Gyroscope {
    rotationRate: Vector3;
    rotationRateUnbiased: Vector3;
    gravity: Vector3;
    userAcceleration: Vector3;
    attitude: Quaternion;
    enabled: boolean;
    updateInterval: number;


}
    
interface Touch {
    fingerId: number;
    position: Vector2;
    rawPosition: Vector2;
    deltaPosition: Vector2;
    deltaTime: number;
    tapCount: number;
    phase: TouchPhase;
    pressure: number;
    maximumPossiblePressure: number;
    type: TouchType;
    altitudeAngle: number;
    azimuthAngle: number;
    radius: number;
    radiusVariance: number;


}
    
interface AccelerationEvent {
    acceleration: Vector3;
    deltaTime: number;


}
    
interface InputConstructor {
    simulateMouseWithTouches: boolean;
    anyKey: boolean;
    anyKeyDown: boolean;
    inputString: string;
    mousePosition: Vector3;
    mouseScrollDelta: Vector2;
    imeCompositionMode: IMECompositionMode;
    compositionString: string;
    imeIsSelected: boolean;
    compositionCursorPos: Vector2;
    eatKeyPressOnTextFieldFocus: boolean;
    mousePresent: boolean;
    touchCount: number;
    touchPressureSupported: boolean;
    stylusTouchSupported: boolean;
    touchSupported: boolean;
    multiTouchEnabled: boolean;
    isGyroAvailable: boolean;
    deviceOrientation: DeviceOrientation;
    acceleration: Vector3;
    compensateSensors: boolean;
    accelerationEventCount: number;
    backButtonLeavesApp: boolean;
    location: LocationService;
    compass: Compass;
    gyro: Gyroscope;
    touches: CSArray<Touch>;
    accelerationEvents: CSArray<AccelerationEvent>;


    GetAccelerationEvent(index: number): AccelerationEvent;
    GetAxis(axisName: string): number;
    GetAxisRaw(axisName: string): number;
    GetButton(buttonName: string): boolean;
    GetButtonDown(buttonName: string): boolean;
    GetButtonUp(buttonName: string): boolean;
    GetJoystickNames(): CSArray<string>;
    GetKey(key: KeyCode): boolean;
    GetKey(name: string): boolean;
    GetKeyDown(key: KeyCode): boolean;
    GetKeyDown(name: string): boolean;
    GetKeyUp(key: KeyCode): boolean;
    GetKeyUp(name: string): boolean;
    GetMouseButton(button: number): boolean;
    GetMouseButtonDown(button: number): boolean;
    GetMouseButtonUp(button: number): boolean;
    GetTouch(index: number): Touch;
    IsJoystickPreconfigured(joystickName: string): boolean;
    ResetInputAxes(): void;
}
declare const Input: InputConstructor;
    
interface InstanceFinder {


}
    
interface InstanceFinderConstructor {
    NetworkManager: NetworkManager;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    RollbackManager: RollbackManager;
    PredictionManager: PredictionManager;
    StatisticsManager: StatisticsManager;
    IsServer: boolean;
    IsServerOnly: boolean;
    IsClient: boolean;
    IsClientOnly: boolean;
    IsHost: boolean;
    IsOffline: boolean;


    GetInstance<T>(): T;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
}
declare const InstanceFinder: InstanceFinderConstructor;
    
interface IListItem {
    Key: Key;


}
    
interface Key extends IListItem {

    constructor(): Key;

}
    
interface KeyConstructor {
    NotInList: number;


    IndexOf(key: Key): number;
    IsInList(key: Key): boolean;
}
declare const Key: KeyConstructor;
    
interface Key extends IListItem {

    constructor(): Key;

}
    
interface KeyConstructor {
    NotInList: number;


    IndexOf(key: Key): number;
    IsInList(key: Key): boolean;
}
declare const Key: KeyConstructor;
    
interface IEventSystemHandler {


}
    
interface ISubmitHandler extends IEventSystemHandler {


    OnSubmit(eventData: BaseEventData): void;
}
    
interface AbstractEventData {
    used: boolean;


    Reset(): void;
    Use(): void;
}
    
interface BaseEventData extends AbstractEventData {
    currentInputModule: BaseInputModule;
    selectedObject: GameObject;

    constructor(eventSystem: EventSystem): BaseEventData;

}
    
interface UIBehaviour extends MonoBehaviour {


    IsActive(): boolean;
    IsDestroyed(): boolean;
}
    
interface BaseInputModule extends UIBehaviour {
    input: BaseInput;
    inputOverride: BaseInput;


    ActivateModule(): void;
    ConvertUIToolkitPointerId(sourcePointerData: PointerEventData): number;
    DeactivateModule(): void;
    IsModuleSupported(): boolean;
    IsPointerOverGameObject(pointerId: number): boolean;
    Process(): void;
    ShouldActivateModule(): boolean;
    UpdateModule(): void;
}
    
interface BaseInput extends UIBehaviour {
    compositionString: string;
    imeCompositionMode: IMECompositionMode;
    compositionCursorPos: Vector2;
    mousePresent: boolean;
    mousePosition: Vector2;
    mouseScrollDelta: Vector2;
    touchSupported: boolean;
    touchCount: number;

    constructor(): BaseInput;

    GetAxisRaw(axisName: string): number;
    GetButtonDown(buttonName: string): boolean;
    GetMouseButton(button: number): boolean;
    GetMouseButtonDown(button: number): boolean;
    GetMouseButtonUp(button: number): boolean;
    GetTouch(index: number): Touch;
}
    
interface PointerEventData extends BaseEventData {
    hovered: CSArray<GameObject>;
    pointerEnter: GameObject;
    lastPress: GameObject;
    rawPointerPress: GameObject;
    pointerDrag: GameObject;
    pointerClick: GameObject;
    pointerCurrentRaycast: RaycastResult;
    pointerPressRaycast: RaycastResult;
    eligibleForClick: boolean;
    pointerId: number;
    position: Vector2;
    delta: Vector2;
    pressPosition: Vector2;
    worldPosition: Vector3;
    worldNormal: Vector3;
    clickTime: number;
    clickCount: number;
    scrollDelta: Vector2;
    useDragThreshold: boolean;
    dragging: boolean;
    button: InputButton;
    pressure: number;
    tangentialPressure: number;
    altitudeAngle: number;
    azimuthAngle: number;
    twist: number;
    radius: Vector2;
    radiusVariance: Vector2;
    fullyExited: boolean;
    reentered: boolean;
    enterEventCamera: Camera;
    pressEventCamera: Camera;
    pointerPress: GameObject;

    constructor(eventSystem: EventSystem): PointerEventData;

    IsPointerMoving(): boolean;
    IsScrolling(): boolean;
    ToString(): string;
}
    
interface RaycastResult {
    module: BaseRaycaster;
    distance: number;
    index: number;
    depth: number;
    sortingLayer: number;
    sortingOrder: number;
    worldPosition: Vector3;
    worldNormal: Vector3;
    screenPosition: Vector2;
    displayIndex: number;
    gameObject: GameObject;
    isValid: boolean;


    Clear(): void;
    ToString(): string;
}
    
interface BaseRaycaster extends UIBehaviour {
    eventCamera: Camera;
    priority: number;
    sortOrderPriority: number;
    renderOrderPriority: number;
    rootRaycaster: BaseRaycaster;


    Raycast(eventData: PointerEventData, resultAppendList: CSArray<RaycastResult>): void;
    ToString(): string;
}
    
interface IPointerClickHandler extends IEventSystemHandler {


    OnPointerClick(eventData: PointerEventData): void;
}
    
interface IPointerEnterHandler extends IEventSystemHandler {


    OnPointerEnter(eventData: PointerEventData): void;
}
    
interface ISelectHandler extends IEventSystemHandler {


    OnSelect(eventData: BaseEventData): void;
}
    
interface IPointerExitHandler extends IEventSystemHandler {


    OnPointerExit(eventData: PointerEventData): void;
}
    
interface IDeselectHandler extends IEventSystemHandler {


    OnDeselect(eventData: BaseEventData): void;
}
    
interface IPointerDownHandler extends IEventSystemHandler {


    OnPointerDown(eventData: PointerEventData): void;
}
    
interface IPointerUpHandler extends IEventSystemHandler {


    OnPointerUp(eventData: PointerEventData): void;
}
    
interface IMoveHandler extends IEventSystemHandler {


    OnMove(eventData: AxisEventData): void;
}
    
interface AxisEventData extends BaseEventData {
    moveVector: Vector2;
    moveDir: MoveDirection;

    constructor(eventSystem: EventSystem): AxisEventData;

}
    
interface Selectable extends UIBehaviour, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
    navigation: Navigation;
    transition: Transition;
    colors: ColorBlock;
    spriteState: SpriteState;
    animationTriggers: AnimationTriggers;
    targetGraphic: Graphic;
    interactable: boolean;
    image: Image;
    animator: Animator;


    FindSelectable(dir: Vector3): Selectable;
    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    IsInteractable(): boolean;
    OnDeselect(eventData: BaseEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    Select(): void;
}
    
interface Navigation {
    mode: Mode;
    wrapAround: boolean;
    selectOnUp: Selectable;
    selectOnDown: Selectable;
    selectOnLeft: Selectable;
    selectOnRight: Selectable;


    Equals(other: Navigation): boolean;
}
    
interface NavigationConstructor {
    defaultNavigation: Navigation;


}
declare const Navigation: NavigationConstructor;
    
interface ColorBlock {
    normalColor: Color;
    highlightedColor: Color;
    pressedColor: Color;
    selectedColor: Color;
    disabledColor: Color;
    colorMultiplier: number;
    fadeDuration: number;


    Equals(obj: unknown): boolean;
    Equals(other: ColorBlock): boolean;
    GetHashCode(): number;
}
    
interface ColorBlockConstructor {
    defaultColorBlock: ColorBlock;


}
declare const ColorBlock: ColorBlockConstructor;
    
interface SpriteState {
    highlightedSprite: Sprite;
    pressedSprite: Sprite;
    selectedSprite: Sprite;
    disabledSprite: Sprite;


    Equals(other: SpriteState): boolean;
}
    
interface AnimationTriggers {
    normalTrigger: string;
    highlightedTrigger: string;
    pressedTrigger: string;
    selectedTrigger: string;
    disabledTrigger: string;

    constructor(): AnimationTriggers;

}
    
interface ICanvasElement {
    transform: Transform;


    GraphicUpdateComplete(): void;
    IsDestroyed(): boolean;
    LayoutComplete(): void;
    Rebuild(executing: CanvasUpdate): void;
}
    
interface Graphic extends UIBehaviour, ICanvasElement {
    color: Color;
    raycastTarget: boolean;
    raycastPadding: Vector4;
    depth: number;
    rectTransform: RectTransform;
    canvas: Canvas;
    canvasRenderer: CanvasRenderer;
    defaultMaterial: Material;
    material: Material;
    materialForRendering: Material;
    mainTexture: Texture;


    CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean, useRGB: boolean): void;
    GetPixelAdjustedRect(): Rect;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnCullingChanged(): void;
    OnRebuildRequested(): void;
    PixelAdjustPoint(point: Vector2): Vector2;
    Raycast(sp: Vector2, eventCamera: Camera): boolean;
    Rebuild(update: CanvasUpdate): void;
    RegisterDirtyLayoutCallback(action: UnityAction): void;
    RegisterDirtyMaterialCallback(action: UnityAction): void;
    RegisterDirtyVerticesCallback(action: UnityAction): void;
    SetAllDirty(): void;
    SetLayoutDirty(): void;
    SetMaterialDirty(): void;
    SetNativeSize(): void;
    SetVerticesDirty(): void;
    UnregisterDirtyLayoutCallback(action: UnityAction): void;
    UnregisterDirtyMaterialCallback(action: UnityAction): void;
    UnregisterDirtyVerticesCallback(action: UnityAction): void;
}
    
interface RectTransform extends Transform {
    rect: Rect;
    anchorMin: Vector2;
    anchorMax: Vector2;
    anchoredPosition: Vector2;
    sizeDelta: Vector2;
    pivot: Vector2;
    anchoredPosition3D: Vector3;
    offsetMin: Vector2;
    offsetMax: Vector2;
    drivenByObject: Object;

    constructor(): RectTransform;

    ForceUpdateRectTransforms(): void;
    GetLocalCorners(fourCornersArray: CSArray<Vector3>): void;
    GetWorldCorners(fourCornersArray: CSArray<Vector3>): void;
    SetInsetAndSizeFromParentEdge(edge: Edge, inset: number, size: number): void;
    SetSizeWithCurrentAnchors(axis: Axis, size: number): void;
}
    
interface Canvas extends Behaviour {
    renderMode: RenderMode;
    isRootCanvas: boolean;
    pixelRect: Rect;
    scaleFactor: number;
    referencePixelsPerUnit: number;
    overridePixelPerfect: boolean;
    pixelPerfect: boolean;
    planeDistance: number;
    renderOrder: number;
    overrideSorting: boolean;
    sortingOrder: number;
    targetDisplay: number;
    sortingLayerID: number;
    cachedSortingLayerValue: number;
    additionalShaderChannels: AdditionalCanvasShaderChannels;
    sortingLayerName: string;
    rootCanvas: Canvas;
    renderingDisplaySize: Vector2;
    worldCamera: Camera;
    normalizedSortingGridSize: number;
    sortingGridNormalizedSize: number;

    constructor(): Canvas;

}
    
interface CanvasConstructor {


    ForceUpdateCanvases(): void;
    GetDefaultCanvasMaterial(): Material;
    GetDefaultCanvasTextMaterial(): Material;
    GetETC1SupportedCanvasMaterial(): Material;
}
declare const Canvas: CanvasConstructor;
    
interface CanvasRenderer extends Component {
    hasPopInstruction: boolean;
    materialCount: number;
    popMaterialCount: number;
    absoluteDepth: number;
    hasMoved: boolean;
    cullTransparentMesh: boolean;
    hasRectClipping: boolean;
    relativeDepth: number;
    cull: boolean;
    isMask: boolean;
    clippingSoftness: Vector2;

    constructor(): CanvasRenderer;

    Clear(): void;
    DisableRectClipping(): void;
    EnableRectClipping(rect: Rect): void;
    GetAlpha(): number;
    GetColor(): Color;
    GetInheritedAlpha(): number;
    GetMaterial(index: number): Material;
    GetMaterial(): Material;
    GetPopMaterial(index: number): Material;
    SetAlpha(alpha: number): void;
    SetAlphaTexture(texture: Texture): void;
    SetColor(color: Color): void;
    SetMaterial(material: Material, index: number): void;
    SetMaterial(material: Material, texture: Texture): void;
    SetMesh(mesh: Mesh): void;
    SetPopMaterial(material: Material, index: number): void;
    SetTexture(texture: Texture): void;
    SetVertices(vertices: CSArray<UIVertex>): void;
    SetVertices(vertices: CSArray<UIVertex>, size: number): void;
}
    
interface UIVertex {
    position: Vector3;
    normal: Vector3;
    tangent: Vector4;
    color: Color32;
    uv0: Vector4;
    uv1: Vector4;
    uv2: Vector4;
    uv3: Vector4;


}
    
interface UIVertexConstructor {
    simpleVert: UIVertex;


}
declare const UIVertex: UIVertexConstructor;
    
interface CanvasRendererConstructor {


    AddUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>): void;
    AddUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>): void;
    CreateUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    CreateUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    SplitUIVertexStreams(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    SplitUIVertexStreams(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
}
declare const CanvasRenderer: CanvasRendererConstructor;
    
interface UnityAction {

    constructor(object: unknown, method: unknown): UnityAction;

    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;
}
    
interface GraphicConstructor {
    defaultGraphicMaterial: Material;


}
declare const Graphic: GraphicConstructor;
    
interface ISerializationCallbackReceiver {


    OnAfterDeserialize(): void;
    OnBeforeSerialize(): void;
}
    
interface ILayoutElement {
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
}
    
interface ICanvasRaycastFilter {


    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;
}
    
interface IMaterialModifier {


    GetModifiedMaterial(baseMaterial: Material): Material;
}
    
interface IMaskable {


    RecalculateMasking(): void;
}
    
interface IClippable {
    gameObject: GameObject;
    rectTransform: RectTransform;


    Cull(clipRect: Rect, validRect: boolean): void;
    RecalculateClipping(): void;
    SetClipRect(value: Rect, validRect: boolean): void;
    SetClipSoftness(clipSoftness: Vector2): void;
}
    
interface MaskableGraphic extends Graphic, IMaterialModifier, IMaskable, IClippable {
    onCullStateChanged: CullStateChangedEvent;
    maskable: boolean;
    isMaskingGraphic: boolean;


    Cull(clipRect: Rect, validRect: boolean): void;
    GetModifiedMaterial(baseMaterial: Material): Material;
    ParentMaskStateChanged(): void;
    RecalculateClipping(): void;
    RecalculateMasking(): void;
    SetClipRect(clipRect: Rect, validRect: boolean): void;
    SetClipSoftness(clipSoftness: Vector2): void;
}
    
interface CullStateChangedEvent {

    constructor(): CullStateChangedEvent;

}
    
interface Image extends MaskableGraphic, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter {
    sprite: Sprite;
    overrideSprite: Sprite;
    type: Type;
    preserveAspect: boolean;
    fillCenter: boolean;
    fillMethod: FillMethod;
    fillAmount: number;
    fillClockwise: boolean;
    fillOrigin: number;
    eventAlphaThreshold: number;
    alphaHitTestMinimumThreshold: number;
    useSpriteMesh: boolean;
    mainTexture: Texture;
    hasBorder: boolean;
    pixelsPerUnitMultiplier: number;
    pixelsPerUnit: number;
    material: Material;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    DisableSpriteOptimizations(): void;
    IsRaycastLocationValid(screenPoint: Vector2, eventCamera: Camera): boolean;
    OnAfterDeserialize(): void;
    OnBeforeSerialize(): void;
    SetNativeSize(): void;
}
    
interface ImageConstructor {
    defaultETC1GraphicMaterial: Material;


}
declare const Image: ImageConstructor;
    
interface Animator extends Behaviour {
    isOptimizable: boolean;
    isHuman: boolean;
    hasRootMotion: boolean;
    humanScale: number;
    isInitialized: boolean;
    deltaPosition: Vector3;
    deltaRotation: Quaternion;
    velocity: Vector3;
    angularVelocity: Vector3;
    rootPosition: Vector3;
    rootRotation: Quaternion;
    applyRootMotion: boolean;
    linearVelocityBlending: boolean;
    animatePhysics: boolean;
    updateMode: AnimatorUpdateMode;
    hasTransformHierarchy: boolean;
    gravityWeight: number;
    bodyPosition: Vector3;
    bodyRotation: Quaternion;
    stabilizeFeet: boolean;
    layerCount: number;
    parameters: CSArray<AnimatorControllerParameter>;
    parameterCount: number;
    feetPivotActive: number;
    pivotWeight: number;
    pivotPosition: Vector3;
    isMatchingTarget: boolean;
    speed: number;
    targetPosition: Vector3;
    targetRotation: Quaternion;
    cullingMode: AnimatorCullingMode;
    playbackTime: number;
    recorderStartTime: number;
    recorderStopTime: number;
    recorderMode: AnimatorRecorderMode;
    runtimeAnimatorController: RuntimeAnimatorController;
    hasBoundPlayables: boolean;
    avatar: Avatar;
    playableGraph: PlayableGraph;
    layersAffectMassCenter: boolean;
    leftFeetBottomHeight: number;
    rightFeetBottomHeight: number;
    logWarnings: boolean;
    fireEvents: boolean;
    keepAnimatorControllerStateOnDisable: boolean;

    constructor(): Animator;

    ApplyBuiltinRootMotion(): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void;
    ForceStateNormalizedTime(normalizedTime: number): void;
    GetAnimatorTransitionInfo(layerIndex: number): AnimatorTransitionInfo;
    GetBehaviour<T>(): T;
    GetBehaviours<T>(): CSArray<T>;
    GetBehaviours(fullPathHash: number, layerIndex: number): CSArray<StateMachineBehaviour>;
    GetBoneTransform(humanBoneId: HumanBodyBones): Transform;
    GetBool(name: string): boolean;
    GetBool(id: number): boolean;
    GetCurrentAnimationClipState(layerIndex: number): CSArray<AnimationInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetCurrentAnimatorClipInfoCount(layerIndex: number): number;
    GetCurrentAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetFloat(name: string): number;
    GetFloat(id: number): number;
    GetIKHintPosition(hint: AvatarIKHint): Vector3;
    GetIKHintPositionWeight(hint: AvatarIKHint): number;
    GetIKPosition(goal: AvatarIKGoal): Vector3;
    GetIKPositionWeight(goal: AvatarIKGoal): number;
    GetIKRotation(goal: AvatarIKGoal): Quaternion;
    GetIKRotationWeight(goal: AvatarIKGoal): number;
    GetInteger(name: string): number;
    GetInteger(id: number): number;
    GetLayerIndex(layerName: string): number;
    GetLayerName(layerIndex: number): string;
    GetLayerWeight(layerIndex: number): number;
    GetNextAnimationClipState(layerIndex: number): CSArray<AnimationInfo>;
    GetNextAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetNextAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetNextAnimatorClipInfoCount(layerIndex: number): number;
    GetNextAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetParameter(index: number): AnimatorControllerParameter;
    GetQuaternion(name: string): Quaternion;
    GetQuaternion(id: number): Quaternion;
    GetVector(name: string): Vector3;
    GetVector(id: number): Vector3;
    HasState(layerIndex: number, stateID: number): boolean;
    InterruptMatchTarget(): void;
    InterruptMatchTarget(completeMatch: boolean): void;
    IsControlled(transform: Transform): boolean;
    IsInTransition(layerIndex: number): boolean;
    IsParameterControlledByCurve(name: string): boolean;
    IsParameterControlledByCurve(id: number): boolean;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number): void;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number, targetNormalizedTime: number): void;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number, targetNormalizedTime: number, completeMatch: boolean): void;
    Play(stateName: string, layer: number): void;
    Play(stateName: string): void;
    Play(stateName: string, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number, layer: number): void;
    Play(stateNameHash: number): void;
    PlayInFixedTime(stateName: string, layer: number): void;
    PlayInFixedTime(stateName: string): void;
    PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number): void;
    PlayInFixedTime(stateNameHash: number): void;
    Rebind(): void;
    ResetTrigger(name: string): void;
    ResetTrigger(id: number): void;
    SetBoneLocalRotation(humanBoneId: HumanBodyBones, rotation: Quaternion): void;
    SetBool(name: string, value: boolean): void;
    SetBool(id: number, value: boolean): void;
    SetFloat(name: string, value: number): void;
    SetFloat(name: string, value: number, dampTime: number, deltaTime: number): void;
    SetFloat(id: number, value: number): void;
    SetFloat(id: number, value: number, dampTime: number, deltaTime: number): void;
    SetIKHintPosition(hint: AvatarIKHint, hintPosition: Vector3): void;
    SetIKHintPositionWeight(hint: AvatarIKHint, value: number): void;
    SetIKPosition(goal: AvatarIKGoal, goalPosition: Vector3): void;
    SetIKPositionWeight(goal: AvatarIKGoal, value: number): void;
    SetIKRotation(goal: AvatarIKGoal, goalRotation: Quaternion): void;
    SetIKRotationWeight(goal: AvatarIKGoal, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(id: number, value: number): void;
    SetLayerWeight(layerIndex: number, weight: number): void;
    SetLookAtPosition(lookAtPosition: Vector3): void;
    SetLookAtWeight(weight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number, clampWeight: number): void;
    SetQuaternion(name: string, value: Quaternion): void;
    SetQuaternion(id: number, value: Quaternion): void;
    SetTarget(targetIndex: AvatarTarget, targetNormalizedTime: number): void;
    SetTrigger(name: string): void;
    SetTrigger(id: number): void;
    SetVector(name: string, value: Vector3): void;
    SetVector(id: number, value: Vector3): void;
    StartPlayback(): void;
    StartRecording(frameCount: number): void;
    Stop(): void;
    StopPlayback(): void;
    StopRecording(): void;
    Update(deltaTime: number): void;
    WriteDefaultValues(): void;
}
    
interface AnimatorControllerParameter {
    name: string;
    nameHash: number;
    type: AnimatorControllerParameterType;
    defaultFloat: number;
    defaultInt: number;
    defaultBool: boolean;

    constructor(): AnimatorControllerParameter;

    Equals(o: unknown): boolean;
    GetHashCode(): number;
}
    
interface RuntimeAnimatorController extends Object {
    animationClips: CSArray<AnimationClip>;


}
    
interface Motion extends Object {
    averageDuration: number;
    averageAngularSpeed: number;
    averageSpeed: Vector3;
    apparentSpeed: number;
    isLooping: boolean;
    legacy: boolean;
    isHumanMotion: boolean;
    isAnimatorMotion: boolean;


    ValidateIfRetargetable(val: boolean): boolean;
}
    
interface AnimationClip extends Motion {
    length: number;
    frameRate: number;
    wrapMode: WrapMode;
    localBounds: Bounds;
    legacy: boolean;
    humanMotion: boolean;
    empty: boolean;
    hasGenericRootTransform: boolean;
    hasMotionFloatCurves: boolean;
    hasMotionCurves: boolean;
    hasRootCurves: boolean;
    events: CSArray<AnimationEvent>;

    constructor(): AnimationClip;

    AddEvent(evt: AnimationEvent): void;
    ClearCurves(): void;
    EnsureQuaternionContinuity(): void;
    SampleAnimation(go: GameObject, time: number): void;
    SetCurve(relativePath: string, type: unknown, propertyName: string, curve: AnimationCurve): void;
}
    
interface AnimationEvent {
    data: string;
    stringParameter: string;
    floatParameter: number;
    intParameter: number;
    objectReferenceParameter: Object;
    functionName: string;
    time: number;
    messageOptions: SendMessageOptions;
    isFiredByLegacy: boolean;
    isFiredByAnimator: boolean;
    animationState: AnimationState;
    animatorStateInfo: AnimatorStateInfo;
    animatorClipInfo: AnimatorClipInfo;

    constructor(): AnimationEvent;

}
    
interface TrackedReference {


    Equals(o: unknown): boolean;
    GetHashCode(): number;
}
    
interface AnimationState extends TrackedReference {
    enabled: boolean;
    weight: number;
    wrapMode: WrapMode;
    time: number;
    normalizedTime: number;
    speed: number;
    normalizedSpeed: number;
    length: number;
    layer: number;
    clip: AnimationClip;
    name: string;
    blendMode: AnimationBlendMode;

    constructor(): AnimationState;

    AddMixingTransform(mix: Transform): void;
    AddMixingTransform(mix: Transform, recursive: boolean): void;
    RemoveMixingTransform(mix: Transform): void;
}
    
interface AnimatorStateInfo {
    fullPathHash: number;
    nameHash: number;
    shortNameHash: number;
    normalizedTime: number;
    length: number;
    speed: number;
    speedMultiplier: number;
    tagHash: number;
    loop: boolean;


    IsName(name: string): boolean;
    IsTag(tag: string): boolean;
}
    
interface AnimatorClipInfo {
    clip: AnimationClip;
    weight: number;


}
    
interface AnimationCurve {
    keys: CSArray<Keyframe>;
    Item: Keyframe;
    length: number;
    preWrapMode: WrapMode;
    postWrapMode: WrapMode;

    constructor(keys: CSArray<Keyframe>): AnimationCurve;
    constructor(): AnimationCurve;

    AddKey(time: number, value: number): number;
    AddKey(key: Keyframe): number;
    Equals(o: unknown): boolean;
    Equals(other: AnimationCurve): boolean;
    Evaluate(time: number): number;
    GetHashCode(): number;
    MoveKey(index: number, key: Keyframe): number;
    RemoveKey(index: number): void;
    SmoothTangents(index: number, weight: number): void;
}
    
interface Keyframe {
    time: number;
    value: number;
    inTangent: number;
    outTangent: number;
    inWeight: number;
    outWeight: number;
    weightedMode: WeightedMode;
    tangentMode: number;

    constructor(time: number, value: number): Keyframe;
    constructor(time: number, value: number, inTangent: number, outTangent: number): Keyframe;
    constructor(time: number, value: number, inTangent: number, outTangent: number, inWeight: number, outWeight: number): Keyframe;

}
    
interface AnimationCurveConstructor {


    Constant(timeStart: number, timeEnd: number, value: number): AnimationCurve;
    EaseInOut(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve;
    Linear(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve;
}
declare const AnimationCurve: AnimationCurveConstructor;
    
interface Avatar extends Object {
    isValid: boolean;
    isHuman: boolean;
    humanDescription: HumanDescription;


}
    
interface HumanDescription {
    human: CSArray<HumanBone>;
    skeleton: CSArray<SkeletonBone>;
    upperArmTwist: number;
    lowerArmTwist: number;
    upperLegTwist: number;
    lowerLegTwist: number;
    armStretch: number;
    legStretch: number;
    feetSpacing: number;
    hasTranslationDoF: boolean;


}
    
interface HumanBone {
    limit: HumanLimit;
    boneName: string;
    humanName: string;


}
    
interface HumanLimit {
    useDefaultValues: boolean;
    min: Vector3;
    max: Vector3;
    center: Vector3;
    axisLength: number;


}
    
interface SkeletonBone {
    name: string;
    position: Vector3;
    rotation: Quaternion;
    scale: Vector3;
    transformModified: number;


}
    
interface PlayableGraph {


    Connect<U, V>(source: U, sourceOutputPort: number, destination: V, destinationInputPort: number): boolean;
    Destroy(): void;
    DestroyOutput<U>(output: U): void;
    DestroyPlayable<U>(playable: U): void;
    DestroySubgraph<U>(playable: U): void;
    Disconnect<U>(input: U, inputPort: number): void;
    Evaluate(): void;
    Evaluate(deltaTime: number): void;
    GetEditorName(): string;
    GetOutput(index: number): PlayableOutput;
    GetOutputByType<T>(index: number): PlayableOutput;
    GetOutputCount(): number;
    GetOutputCountByType<T>(): number;
    GetPlayableCount(): number;
    GetResolver(): IExposedPropertyTable;
    GetRootPlayable(index: number): Playable;
    GetRootPlayableCount(): number;
    GetTimeUpdateMode(): DirectorUpdateMode;
    IsDone(): boolean;
    IsPlaying(): boolean;
    IsValid(): boolean;
    Play(): void;
    SetResolver(value: IExposedPropertyTable): void;
    SetTimeUpdateMode(value: DirectorUpdateMode): void;
    Stop(): void;
}
    
interface IPlayableOutput {


    GetHandle(): PlayableOutputHandle;
}
    
interface PlayableOutputHandle {


    Equals(p: unknown): boolean;
    Equals(other: PlayableOutputHandle): boolean;
    GetHashCode(): number;
}
    
interface PlayableOutputHandleConstructor {
    Null: PlayableOutputHandle;


}
declare const PlayableOutputHandle: PlayableOutputHandleConstructor;
    
interface PlayableOutput extends IPlayableOutput {


    Equals(other: PlayableOutput): boolean;
    GetHandle(): PlayableOutputHandle;
    GetPlayableOutputType(): unknown;
    IsPlayableOutputOfType<T>(): boolean;
}
    
interface PlayableOutputConstructor {
    Null: PlayableOutput;


}
declare const PlayableOutput: PlayableOutputConstructor;
    
interface IExposedPropertyTable {


    ClearReferenceValue(id: PropertyName): void;
    GetReferenceValue(id: PropertyName, idValid: unknown): Object;
    SetReferenceValue(id: PropertyName, value: Object): void;
}
    
interface PropertyName {

    constructor(name: string): PropertyName;
    constructor(other: PropertyName): PropertyName;
    constructor(id: number): PropertyName;

    Equals(other: unknown): boolean;
    Equals(other: PropertyName): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface PropertyNameConstructor {


    IsNullOrEmpty(prop: PropertyName): boolean;
}
declare const PropertyName: PropertyNameConstructor;
    
interface IPlayable {


    GetHandle(): PlayableHandle;
}
    
interface PlayableHandle {


    Equals(p: unknown): boolean;
    Equals(other: PlayableHandle): boolean;
    GetHashCode(): number;
}
    
interface PlayableHandleConstructor {
    Null: PlayableHandle;


}
declare const PlayableHandle: PlayableHandleConstructor;
    
interface Playable extends IPlayable {


    Equals(other: Playable): boolean;
    GetHandle(): PlayableHandle;
    GetPlayableType(): unknown;
    IsPlayableOfType<T>(): boolean;
}
    
interface PlayableConstructor {
    Null: Playable;


    Create(graph: PlayableGraph, inputCount: number): Playable;
}
declare const Playable: PlayableConstructor;
    
interface PlayableGraphConstructor {


    Create(): PlayableGraph;
    Create(name: string): PlayableGraph;
}
declare const PlayableGraph: PlayableGraphConstructor;
    
interface AnimatorTransitionInfo {
    fullPathHash: number;
    nameHash: number;
    userNameHash: number;
    durationUnit: DurationUnit;
    duration: number;
    normalizedTime: number;
    anyState: boolean;


    IsName(name: string): boolean;
    IsUserName(name: string): boolean;
}
    
interface StateMachineBehaviour extends ScriptableObject {


    OnStateEnter(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateEnter(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateExit(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateExit(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateIK(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateIK(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateMachineEnter(animator: Animator, stateMachinePathHash: number): void;
    OnStateMachineEnter(animator: Animator, stateMachinePathHash: number, controller: AnimatorControllerPlayable): void;
    OnStateMachineExit(animator: Animator, stateMachinePathHash: number): void;
    OnStateMachineExit(animator: Animator, stateMachinePathHash: number, controller: AnimatorControllerPlayable): void;
    OnStateMove(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateMove(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateUpdate(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateUpdate(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
}
    
interface AnimatorControllerPlayable extends IPlayable {


    CrossFade(stateName: string, transitionDuration: number): void;
    CrossFade(stateName: string, transitionDuration: number, layer: number): void;
    CrossFade(stateName: string, transitionDuration: number, layer: number, normalizedTime: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number, layer: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number, layer: number, normalizedTime: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number, layer: number, fixedTime: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number, layer: number, fixedTime: number): void;
    Equals(other: AnimatorControllerPlayable): boolean;
    GetAnimatorTransitionInfo(layerIndex: number): AnimatorTransitionInfo;
    GetBool(name: string): boolean;
    GetBool(id: number): boolean;
    GetCurrentAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetCurrentAnimatorClipInfoCount(layerIndex: number): number;
    GetCurrentAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetFloat(name: string): number;
    GetFloat(id: number): number;
    GetHandle(): PlayableHandle;
    GetInteger(name: string): number;
    GetInteger(id: number): number;
    GetLayerCount(): number;
    GetLayerIndex(layerName: string): number;
    GetLayerName(layerIndex: number): string;
    GetLayerWeight(layerIndex: number): number;
    GetNextAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetNextAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetNextAnimatorClipInfoCount(layerIndex: number): number;
    GetNextAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetParameter(index: number): AnimatorControllerParameter;
    GetParameterCount(): number;
    HasState(layerIndex: number, stateID: number): boolean;
    IsInTransition(layerIndex: number): boolean;
    IsParameterControlledByCurve(name: string): boolean;
    IsParameterControlledByCurve(id: number): boolean;
    Play(stateName: string): void;
    Play(stateName: string, layer: number): void;
    Play(stateName: string, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number): void;
    Play(stateNameHash: number, layer: number): void;
    Play(stateNameHash: number, layer: number, normalizedTime: number): void;
    PlayInFixedTime(stateName: string): void;
    PlayInFixedTime(stateName: string, layer: number): void;
    PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void;
    ResetTrigger(name: string): void;
    ResetTrigger(id: number): void;
    SetBool(name: string, value: boolean): void;
    SetBool(id: number, value: boolean): void;
    SetFloat(name: string, value: number): void;
    SetFloat(id: number, value: number): void;
    SetHandle(handle: PlayableHandle): void;
    SetInteger(name: string, value: number): void;
    SetInteger(id: number, value: number): void;
    SetLayerWeight(layerIndex: number, weight: number): void;
    SetTrigger(name: string): void;
    SetTrigger(id: number): void;
}
    
interface AnimatorControllerPlayableConstructor {
    Null: AnimatorControllerPlayable;


    Create(graph: PlayableGraph, controller: RuntimeAnimatorController): AnimatorControllerPlayable;
}
declare const AnimatorControllerPlayable: AnimatorControllerPlayableConstructor;
    
interface AnimationInfo {
    clip: AnimationClip;
    weight: number;


}
    
interface MatchTargetWeightMask {
    positionXYZWeight: Vector3;
    rotationWeight: number;

    constructor(positionXYZWeight: Vector3, rotationWeight: number): MatchTargetWeightMask;

}
    
interface AnimatorConstructor {


    StringToHash(name: string): number;
}
declare const Animator: AnimatorConstructor;
    
interface SelectableConstructor {
    allSelectablesArray: CSArray<Selectable>;
    allSelectableCount: number;
    allSelectables: CSArray<Selectable>;


    AllSelectablesNoAlloc(selectables: CSArray<Selectable>): number;
}
declare const Selectable: SelectableConstructor;
    
    
interface UnityEventBase extends ISerializationCallbackReceiver {


    GetPersistentEventCount(): number;
    GetPersistentListenerState(index: number): UnityEventCallState;
    GetPersistentMethodName(index: number): string;
    GetPersistentTarget(index: number): Object;
    RemoveAllListeners(): void;
    SetPersistentListenerState(index: number, state: UnityEventCallState): void;
    ToString(): string;
}
    
interface UnityEventBaseConstructor {


    GetValidMethodInfo(obj: unknown, functionName: string, argumentTypes: CSArray<unknown>): unknown;
    GetValidMethodInfo(objectType: unknown, functionName: string, argumentTypes: CSArray<unknown>): unknown;
}
declare const UnityEventBase: UnityEventBaseConstructor;
    
interface UnityEvent extends UnityEventBase {

    constructor(): UnityEvent;

    AddListener(call: UnityAction): void;
    Invoke(): void;
    RemoveListener(call: UnityAction): void;
}
    
interface ButtonClickedEvent extends UnityEvent {

    constructor(): ButtonClickedEvent;

}
    
interface MeshRenderer extends Renderer {
    additionalVertexStreams: Mesh;
    enlightenVertexStream: Mesh;
    subMeshStartIndex: number;
    scaleInLightmap: number;
    receiveGI: ReceiveGI;
    stitchLightmapSeams: boolean;

    constructor(): MeshRenderer;

}
    
interface MeshFilter extends Component {
    sharedMesh: Mesh;
    mesh: Mesh;

    constructor(): MeshFilter;

}
    
interface TMP_Text extends MaskableGraphic {
    text: string;
    textPreprocessor: ITextPreprocessor;
    isRightToLeftText: boolean;
    font: TMP_FontAsset;
    fontSharedMaterial: Material;
    fontSharedMaterials: CSArray<Material>;
    fontMaterial: Material;
    fontMaterials: CSArray<Material>;
    color: Color;
    alpha: number;
    enableVertexGradient: boolean;
    colorGradient: VertexGradient;
    colorGradientPreset: TMP_ColorGradient;
    spriteAsset: TMP_SpriteAsset;
    tintAllSprites: boolean;
    styleSheet: TMP_StyleSheet;
    textStyle: TMP_Style;
    overrideColorTags: boolean;
    faceColor: Color32;
    outlineColor: Color32;
    outlineWidth: number;
    fontSize: number;
    fontWeight: FontWeight;
    pixelsPerUnit: number;
    enableAutoSizing: boolean;
    fontSizeMin: number;
    fontSizeMax: number;
    fontStyle: FontStyles;
    isUsingBold: boolean;
    horizontalAlignment: HorizontalAlignmentOptions;
    verticalAlignment: VerticalAlignmentOptions;
    alignment: TextAlignmentOptions;
    characterSpacing: number;
    wordSpacing: number;
    lineSpacing: number;
    lineSpacingAdjustment: number;
    paragraphSpacing: number;
    characterWidthAdjustment: number;
    enableWordWrapping: boolean;
    wordWrappingRatios: number;
    overflowMode: TextOverflowModes;
    isTextOverflowing: boolean;
    firstOverflowCharacterIndex: number;
    linkedTextComponent: TMP_Text;
    isTextTruncated: boolean;
    enableKerning: boolean;
    extraPadding: boolean;
    richText: boolean;
    parseCtrlCharacters: boolean;
    isOverlay: boolean;
    isOrthographic: boolean;
    enableCulling: boolean;
    ignoreVisibility: boolean;
    horizontalMapping: TextureMappingOptions;
    verticalMapping: TextureMappingOptions;
    mappingUvLineOffset: number;
    renderMode: TextRenderFlags;
    geometrySortingOrder: VertexSortingOrder;
    isTextObjectScaleStatic: boolean;
    vertexBufferAutoSizeReduction: boolean;
    firstVisibleCharacter: number;
    maxVisibleCharacters: number;
    maxVisibleWords: number;
    maxVisibleLines: number;
    useMaxVisibleDescender: boolean;
    pageToDisplay: number;
    margin: Vector4;
    textInfo: TMP_TextInfo;
    havePropertiesChanged: boolean;
    isUsingLegacyAnimationComponent: boolean;
    transform: Transform;
    rectTransform: RectTransform;
    autoSizeTextContainer: boolean;
    mesh: Mesh;
    isVolumetricText: boolean;
    bounds: Bounds;
    textBounds: Bounds;
    flexibleHeight: number;
    flexibleWidth: number;
    minWidth: number;
    minHeight: number;
    maxWidth: number;
    maxHeight: number;
    preferredWidth: number;
    preferredHeight: number;
    renderedWidth: number;
    renderedHeight: number;
    layoutPriority: number;


    ClearMesh(): void;
    ClearMesh(uploadGeometry: boolean): void;
    ComputeMarginSize(): void;
    CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void;
    ForceMeshUpdate(ignoreActiveState: boolean, forceTextReparsing: boolean): void;
    GetParsedText(): string;
    GetPreferredValues(): Vector2;
    GetPreferredValues(width: number, height: number): Vector2;
    GetPreferredValues(text: string): Vector2;
    GetPreferredValues(text: string, width: number, height: number): Vector2;
    GetRenderedValues(): Vector2;
    GetRenderedValues(onlyVisibleCharacters: boolean): Vector2;
    GetTextInfo(text: string): TMP_TextInfo;
    SetCharArray(sourceText: CSArray<string>): void;
    SetCharArray(sourceText: CSArray<string>, start: number, length: number): void;
    SetText(sourceText: string, syncTextInputBox: boolean): void;
    SetText(sourceText: string, arg0: number): void;
    SetText(sourceText: string, arg0: number, arg1: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
    SetText(sourceText: unknown): void;
    SetText(sourceText: CSArray<string>): void;
    SetText(sourceText: CSArray<string>, start: number, length: number): void;
    SetVertices(vertices: CSArray<Vector3>): void;
    UpdateGeometry(mesh: Mesh, index: number): void;
    UpdateMeshPadding(): void;
    UpdateVertexData(flags: TMP_VertexDataUpdateFlags): void;
    UpdateVertexData(): void;
}
    
interface ITextPreprocessor {


    PreprocessText(text: string): string;
}
    
interface TMP_Asset extends ScriptableObject {
    hashCode: number;
    material: Material;
    materialHashCode: number;
    instanceID: number;


}
    
interface TMP_FontAsset extends TMP_Asset {
    atlas: Texture2D;
    normalStyle: number;
    normalSpacingOffset: number;
    boldStyle: number;
    boldSpacing: number;
    italicStyle: number;
    tabSize: number;
    version: string;
    sourceFontFile: Font;
    atlasPopulationMode: AtlasPopulationMode;
    faceInfo: FaceInfo;
    glyphTable: CSArray<Glyph>;
    glyphLookupTable: CSDictionary<number, Glyph>;
    characterTable: CSArray<TMP_Character>;
    characterLookupTable: CSDictionary<number, TMP_Character>;
    atlasTexture: Texture2D;
    atlasTextures: CSArray<Texture2D>;
    atlasTextureCount: number;
    isMultiAtlasTexturesEnabled: boolean;
    fontInfo: FaceInfo_Legacy;
    atlasWidth: number;
    atlasHeight: number;
    atlasPadding: number;
    atlasRenderMode: GlyphRenderMode;
    fontFeatureTable: TMP_FontFeatureTable;
    fallbackFontAssetTable: CSArray<TMP_FontAsset>;
    creationSettings: FontAssetCreationSettings;
    fontWeightTable: CSArray<TMP_FontWeightPair>;

    constructor(): TMP_FontAsset;

    ClearFontAssetData(setAtlasSizeToZero: boolean): void;
    HasCharacter(character: number): boolean;
    HasCharacter(character: string, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<string>): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<number>, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string): boolean;
    ReadFontAssetDefinition(): void;
    TryAddCharacters(unicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(unicodes: CSArray<number>, missingUnicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, missingCharacters: CSArray<string>, includeFontFeatures: boolean): boolean;
}
    
interface Font extends Object {
    material: Material;
    fontNames: CSArray<string>;
    dynamic: boolean;
    ascent: number;
    fontSize: number;
    characterInfo: CSArray<CharacterInfo>;
    lineHeight: number;
    textureRebuildCallback: FontTextureRebuildCallback;

    constructor(): Font;
    constructor(name: string): Font;

    GetCharacterInfo(ch: string, info: unknown, size: number, style: FontStyle): boolean;
    GetCharacterInfo(ch: string, info: unknown, size: number): boolean;
    GetCharacterInfo(ch: string, info: unknown): boolean;
    HasCharacter(c: string): boolean;
    RequestCharactersInTexture(characters: string, size: number, style: FontStyle): void;
    RequestCharactersInTexture(characters: string, size: number): void;
    RequestCharactersInTexture(characters: string): void;
}
    
interface CharacterInfo {
    index: number;
    uv: Rect;
    vert: Rect;
    width: number;
    size: number;
    style: FontStyle;
    flipped: boolean;
    advance: number;
    glyphWidth: number;
    glyphHeight: number;
    bearing: number;
    minY: number;
    maxY: number;
    minX: number;
    maxX: number;
    uvBottomLeft: Vector2;
    uvBottomRight: Vector2;
    uvTopRight: Vector2;
    uvTopLeft: Vector2;


}
    
interface FontTextureRebuildCallback {

    constructor(object: unknown, method: unknown): FontTextureRebuildCallback;

    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;
}
    
interface FontConstructor {


    CreateDynamicFontFromOSFont(fontname: string, size: number): Font;
    CreateDynamicFontFromOSFont(fontnames: CSArray<string>, size: number): Font;
    GetMaxVertsForString(str: string): number;
    GetOSInstalledFontNames(): CSArray<string>;
    GetPathsToOSFonts(): CSArray<string>;
}
declare const Font: FontConstructor;
    
interface FaceInfo {
    familyName: string;
    styleName: string;
    pointSize: number;
    scale: number;
    lineHeight: number;
    ascentLine: number;
    capLine: number;
    meanLine: number;
    baseline: number;
    descentLine: number;
    superscriptOffset: number;
    superscriptSize: number;
    subscriptOffset: number;
    subscriptSize: number;
    underlineOffset: number;
    underlineThickness: number;
    strikethroughOffset: number;
    strikethroughThickness: number;
    tabWidth: number;


    Compare(other: FaceInfo): boolean;
}
    
interface Glyph {
    index: number;
    metrics: GlyphMetrics;
    glyphRect: GlyphRect;
    scale: number;
    atlasIndex: number;

    constructor(): Glyph;
    constructor(glyph: Glyph): Glyph;
    constructor(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect): Glyph;
    constructor(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number): Glyph;

    Compare(other: Glyph): boolean;
}
    
interface GlyphMetrics {
    width: number;
    height: number;
    horizontalBearingX: number;
    horizontalBearingY: number;
    horizontalAdvance: number;

    constructor(width: number, height: number, bearingX: number, bearingY: number, advance: number): GlyphMetrics;

    Equals(obj: unknown): boolean;
    Equals(other: GlyphMetrics): boolean;
    GetHashCode(): number;
}
    
interface GlyphRect {
    x: number;
    y: number;
    width: number;
    height: number;

    constructor(x: number, y: number, width: number, height: number): GlyphRect;
    constructor(rect: Rect): GlyphRect;

    Equals(obj: unknown): boolean;
    Equals(other: GlyphRect): boolean;
    GetHashCode(): number;
}
    
interface GlyphRectConstructor {
    zero: GlyphRect;


}
declare const GlyphRect: GlyphRectConstructor;
    
interface TMP_TextElement {
    elementType: TextElementType;
    unicode: number;
    textAsset: TMP_Asset;
    glyph: Glyph;
    glyphIndex: number;
    scale: number;

    constructor(): TMP_TextElement;

}
    
interface TMP_Character extends TMP_TextElement {

    constructor(): TMP_Character;
    constructor(unicode: number, glyph: Glyph): TMP_Character;
    constructor(unicode: number, fontAsset: TMP_FontAsset, glyph: Glyph): TMP_Character;

}
    
interface FaceInfo_Legacy {
    Name: string;
    PointSize: number;
    Scale: number;
    CharacterCount: number;
    LineHeight: number;
    Baseline: number;
    Ascender: number;
    CapHeight: number;
    Descender: number;
    CenterLine: number;
    SuperscriptOffset: number;
    SubscriptOffset: number;
    SubSize: number;
    Underline: number;
    UnderlineThickness: number;
    strikethrough: number;
    strikethroughThickness: number;
    TabWidth: number;
    Padding: number;
    AtlasWidth: number;
    AtlasHeight: number;

    constructor(): FaceInfo_Legacy;

}
    
interface TMP_FontFeatureTable {
    glyphPairAdjustmentRecords: CSArray<TMP_GlyphPairAdjustmentRecord>;

    constructor(): TMP_FontFeatureTable;

    SortGlyphPairAdjustmentRecords(): void;
}
    
interface TMP_GlyphPairAdjustmentRecord {
    firstAdjustmentRecord: TMP_GlyphAdjustmentRecord;
    secondAdjustmentRecord: TMP_GlyphAdjustmentRecord;
    featureLookupFlags: FontFeatureLookupFlags;

    constructor(firstAdjustmentRecord: TMP_GlyphAdjustmentRecord, secondAdjustmentRecord: TMP_GlyphAdjustmentRecord): TMP_GlyphPairAdjustmentRecord;

}
    
interface TMP_GlyphAdjustmentRecord {
    glyphIndex: number;
    glyphValueRecord: TMP_GlyphValueRecord;

    constructor(glyphIndex: number, glyphValueRecord: TMP_GlyphValueRecord): TMP_GlyphAdjustmentRecord;

}
    
interface TMP_GlyphValueRecord {
    xPlacement: number;
    yPlacement: number;
    xAdvance: number;
    yAdvance: number;

    constructor(xPlacement: number, yPlacement: number, xAdvance: number, yAdvance: number): TMP_GlyphValueRecord;

}
    
interface FontAssetCreationSettings {
    sourceFontFileName: string;
    sourceFontFileGUID: string;
    pointSizeSamplingMode: number;
    pointSize: number;
    padding: number;
    packingMode: number;
    atlasWidth: number;
    atlasHeight: number;
    characterSetSelectionMode: number;
    characterSequence: string;
    referencedFontAssetGUID: string;
    referencedTextAssetGUID: string;
    fontStyle: number;
    fontStyleModifier: number;
    renderMode: number;
    includeFontFeatures: boolean;


}
    
interface TMP_FontWeightPair {
    regularTypeface: TMP_FontAsset;
    italicTypeface: TMP_FontAsset;


}
    
interface TMP_FontAssetConstructor {


    CreateFontAsset(font: Font): TMP_FontAsset;
    CreateFontAsset(font: Font, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number, atlasPopulationMode: AtlasPopulationMode, enableMultiAtlasSupport: boolean): TMP_FontAsset;
    GetCharacters(fontAsset: TMP_FontAsset): string;
    GetCharactersArray(fontAsset: TMP_FontAsset): CSArray<number>;
}
declare const TMP_FontAsset: TMP_FontAssetConstructor;
    
interface VertexGradient {
    topLeft: Color;
    topRight: Color;
    bottomLeft: Color;
    bottomRight: Color;

    constructor(color: Color): VertexGradient;
    constructor(color0: Color, color1: Color, color2: Color, color3: Color): VertexGradient;

}
    
interface TMP_ColorGradient extends ScriptableObject {
    colorMode: ColorMode;
    topLeft: Color;
    topRight: Color;
    bottomLeft: Color;
    bottomRight: Color;

    constructor(): TMP_ColorGradient;
    constructor(color: Color): TMP_ColorGradient;
    constructor(color0: Color, color1: Color, color2: Color, color3: Color): TMP_ColorGradient;

}
    
interface TMP_SpriteAsset extends TMP_Asset {
    spriteSheet: Texture;
    spriteInfoList: CSArray<TMP_Sprite>;
    fallbackSpriteAssets: CSArray<TMP_SpriteAsset>;
    version: string;
    faceInfo: FaceInfo;
    spriteCharacterTable: CSArray<TMP_SpriteCharacter>;
    spriteCharacterLookupTable: CSDictionary<number, TMP_SpriteCharacter>;
    spriteGlyphTable: CSArray<TMP_SpriteGlyph>;

    constructor(): TMP_SpriteAsset;

    GetSpriteIndexFromHashcode(hashCode: number): number;
    GetSpriteIndexFromName(name: string): number;
    GetSpriteIndexFromUnicode(unicode: number): number;
    SortGlyphTable(): void;
    UpdateLookupTables(): void;
}
    
interface TMP_TextElement_Legacy {
    id: number;
    x: number;
    y: number;
    width: number;
    height: number;
    xOffset: number;
    yOffset: number;
    xAdvance: number;
    scale: number;

    constructor(): TMP_TextElement_Legacy;

}
    
interface TMP_Sprite extends TMP_TextElement_Legacy {
    name: string;
    hashCode: number;
    unicode: number;
    pivot: Vector2;
    sprite: Sprite;

    constructor(): TMP_Sprite;

}
    
interface TMP_SpriteCharacter extends TMP_TextElement {
    name: string;
    hashCode: number;

    constructor(): TMP_SpriteCharacter;
    constructor(unicode: number, glyph: TMP_SpriteGlyph): TMP_SpriteCharacter;
    constructor(unicode: number, spriteAsset: TMP_SpriteAsset, glyph: TMP_SpriteGlyph): TMP_SpriteCharacter;

}
    
interface TMP_SpriteGlyph extends Glyph {
    sprite: Sprite;

    constructor(): TMP_SpriteGlyph;
    constructor(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number): TMP_SpriteGlyph;
    constructor(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number, sprite: Sprite): TMP_SpriteGlyph;

}
    
interface TMP_SpriteAssetConstructor {


    SearchForSpriteByHashCode(spriteAsset: TMP_SpriteAsset, hashCode: number, includeFallbacks: boolean, spriteIndex: unknown): TMP_SpriteAsset;
    SearchForSpriteByUnicode(spriteAsset: TMP_SpriteAsset, unicode: number, includeFallbacks: boolean, spriteIndex: unknown): TMP_SpriteAsset;
}
declare const TMP_SpriteAsset: TMP_SpriteAssetConstructor;
    
interface TMP_StyleSheet extends ScriptableObject {

    constructor(): TMP_StyleSheet;

    GetStyle(hashCode: number): TMP_Style;
    GetStyle(name: string): TMP_Style;
    RefreshStyles(): void;
}
    
interface TMP_Style {
    name: string;
    hashCode: number;
    styleOpeningDefinition: string;
    styleClosingDefinition: string;
    styleOpeningTagArray: CSArray<number>;
    styleClosingTagArray: CSArray<number>;


    RefreshStyle(): void;
}
    
interface TMP_StyleConstructor {
    NormalStyle: TMP_Style;


}
declare const TMP_Style: TMP_StyleConstructor;
    
interface TMP_TextInfo {
    textComponent: TMP_Text;
    characterCount: number;
    spriteCount: number;
    spaceCount: number;
    wordCount: number;
    linkCount: number;
    lineCount: number;
    pageCount: number;
    materialCount: number;
    characterInfo: CSArray<TMP_CharacterInfo>;
    wordInfo: CSArray<TMP_WordInfo>;
    linkInfo: CSArray<TMP_LinkInfo>;
    lineInfo: CSArray<TMP_LineInfo>;
    pageInfo: CSArray<TMP_PageInfo>;
    meshInfo: CSArray<TMP_MeshInfo>;

    constructor(): TMP_TextInfo;
    constructor(textComponent: TMP_Text): TMP_TextInfo;

    Clear(): void;
    ClearAllMeshInfo(): void;
    ClearLineInfo(): void;
    ClearMeshInfo(updateMesh: boolean): void;
    ClearUnusedVertices(materials: CSArray<MaterialReference>): void;
    CopyMeshInfoVertexData(): CSArray<TMP_MeshInfo>;
    ResetVertexLayout(isVolumetric: boolean): void;
}
    
interface TMP_CharacterInfo {
    character: string;
    index: number;
    stringLength: number;
    elementType: TMP_TextElementType;
    textElement: TMP_TextElement;
    fontAsset: TMP_FontAsset;
    spriteAsset: TMP_SpriteAsset;
    spriteIndex: number;
    material: Material;
    materialReferenceIndex: number;
    isUsingAlternateTypeface: boolean;
    pointSize: number;
    lineNumber: number;
    pageNumber: number;
    vertexIndex: number;
    vertex_BL: TMP_Vertex;
    vertex_TL: TMP_Vertex;
    vertex_TR: TMP_Vertex;
    vertex_BR: TMP_Vertex;
    topLeft: Vector3;
    bottomLeft: Vector3;
    topRight: Vector3;
    bottomRight: Vector3;
    origin: number;
    xAdvance: number;
    ascender: number;
    baseLine: number;
    descender: number;
    aspectRatio: number;
    scale: number;
    color: Color32;
    underlineColor: Color32;
    underlineVertexIndex: number;
    strikethroughColor: Color32;
    strikethroughVertexIndex: number;
    highlightColor: Color32;
    highlightState: HighlightState;
    style: FontStyles;
    isVisible: boolean;


}
    
interface TMP_Vertex {
    position: Vector3;
    uv: Vector2;
    uv2: Vector2;
    uv4: Vector2;
    color: Color32;


}
    
interface TMP_VertexConstructor {
    zero: TMP_Vertex;


}
declare const TMP_Vertex: TMP_VertexConstructor;
    
interface HighlightState {
    color: Color32;
    padding: TMP_Offset;

    constructor(color: Color32, padding: TMP_Offset): HighlightState;

    Equals(obj: unknown): boolean;
    Equals(other: HighlightState): boolean;
    GetHashCode(): number;
}
    
interface TMP_Offset {
    left: number;
    right: number;
    top: number;
    bottom: number;
    horizontal: number;
    vertical: number;

    constructor(left: number, right: number, top: number, bottom: number): TMP_Offset;
    constructor(horizontal: number, vertical: number): TMP_Offset;

    Equals(obj: unknown): boolean;
    Equals(other: TMP_Offset): boolean;
    GetHashCode(): number;
}
    
interface TMP_OffsetConstructor {
    zero: TMP_Offset;


}
declare const TMP_Offset: TMP_OffsetConstructor;
    
interface TMP_WordInfo {
    textComponent: TMP_Text;
    firstCharacterIndex: number;
    lastCharacterIndex: number;
    characterCount: number;


    GetWord(): string;
}
    
interface TMP_LinkInfo {
    textComponent: TMP_Text;
    hashCode: number;
    linkIdFirstCharacterIndex: number;
    linkIdLength: number;
    linkTextfirstCharacterIndex: number;
    linkTextLength: number;


    GetLinkID(): string;
    GetLinkText(): string;
}
    
interface TMP_LineInfo {
    characterCount: number;
    visibleCharacterCount: number;
    spaceCount: number;
    wordCount: number;
    firstCharacterIndex: number;
    firstVisibleCharacterIndex: number;
    lastCharacterIndex: number;
    lastVisibleCharacterIndex: number;
    length: number;
    lineHeight: number;
    ascender: number;
    baseline: number;
    descender: number;
    maxAdvance: number;
    width: number;
    marginLeft: number;
    marginRight: number;
    alignment: HorizontalAlignmentOptions;
    lineExtents: Extents;


}
    
interface Extents {
    min: Vector2;
    max: Vector2;

    constructor(min: Vector2, max: Vector2): Extents;

    ToString(): string;
}
    
interface TMP_PageInfo {
    firstCharacterIndex: number;
    lastCharacterIndex: number;
    ascender: number;
    baseLine: number;
    descender: number;


}
    
interface TMP_MeshInfo {
    mesh: Mesh;
    vertexCount: number;
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    tangents: CSArray<Vector4>;
    uvs0: CSArray<Vector2>;
    uvs2: CSArray<Vector2>;
    colors32: CSArray<Color32>;
    triangles: CSArray<number>;
    material: Material;

    constructor(mesh: Mesh, size: number): TMP_MeshInfo;
    constructor(mesh: Mesh, size: number, isVolumetric: boolean): TMP_MeshInfo;

    Clear(): void;
    Clear(uploadChanges: boolean): void;
    ClearUnusedVertices(): void;
    ClearUnusedVertices(startIndex: number): void;
    ClearUnusedVertices(startIndex: number, updateMesh: boolean): void;
    ResizeMeshInfo(size: number): void;
    ResizeMeshInfo(size: number, isVolumetric: boolean): void;
    SortGeometry(order: VertexSortingOrder): void;
    SortGeometry(sortingOrder: CSArray<number>): void;
    SwapVertexData(src: number, dst: number): void;
}
    
interface MaterialReference {
    index: number;
    fontAsset: TMP_FontAsset;
    spriteAsset: TMP_SpriteAsset;
    material: Material;
    isDefaultMaterial: boolean;
    isFallbackMaterial: boolean;
    fallbackMaterial: Material;
    padding: number;
    referenceCount: number;

    constructor(index: number, fontAsset: TMP_FontAsset, spriteAsset: TMP_SpriteAsset, material: Material, padding: number): MaterialReference;

}
    
interface MaterialReferenceConstructor {


    AddMaterialReference(material: Material, fontAsset: TMP_FontAsset, materialReferences: CSArray<MaterialReference>, materialReferenceIndexLookup: CSDictionary<number, number>): number;
    AddMaterialReference(material: Material, spriteAsset: TMP_SpriteAsset, materialReferences: CSArray<MaterialReference>, materialReferenceIndexLookup: CSDictionary<number, number>): number;
    Contains(materialReferences: CSArray<MaterialReference>, fontAsset: TMP_FontAsset): boolean;
}
declare const MaterialReference: MaterialReferenceConstructor;
    
interface TMP_TextInfoConstructor {


    Resize<T>(array: CSArray<T>, size: number): void;
    Resize<T>(array: CSArray<T>, size: number, isBlockAllocated: boolean): void;
}
declare const TMP_TextInfo: TMP_TextInfoConstructor;
    
interface TextMeshProUGUI extends TMP_Text, ILayoutElement {
    materialForRendering: Material;
    autoSizeTextContainer: boolean;
    mesh: Mesh;
    canvasRenderer: CanvasRenderer;
    maskOffset: Vector4;

    constructor(): TextMeshProUGUI;

    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    ClearMesh(): void;
    ComputeMarginSize(): void;
    Cull(clipRect: Rect, validRect: boolean): void;
    ForceMeshUpdate(ignoreActiveState: boolean, forceTextReparsing: boolean): void;
    GetModifiedMaterial(baseMaterial: Material): Material;
    GetTextInfo(text: string): TMP_TextInfo;
    Rebuild(update: CanvasUpdate): void;
    RecalculateClipping(): void;
    SetAllDirty(): void;
    SetLayoutDirty(): void;
    SetMaterialDirty(): void;
    SetVerticesDirty(): void;
    UpdateFontAsset(): void;
    UpdateGeometry(mesh: Mesh, index: number): void;
    UpdateMeshPadding(): void;
    UpdateVertexData(flags: TMP_VertexDataUpdateFlags): void;
    UpdateVertexData(): void;
}
    
interface Animation extends Behaviour {
    clip: AnimationClip;
    playAutomatically: boolean;
    wrapMode: WrapMode;
    isPlaying: boolean;
    Item: AnimationState;
    animatePhysics: boolean;
    animateOnlyIfVisible: boolean;
    cullingType: AnimationCullingType;
    localBounds: Bounds;

    constructor(): Animation;

    AddClip(clip: AnimationClip, newName: string): void;
    AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number): void;
    AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number, addLoopFrame: boolean): void;
    Blend(animation: string): void;
    Blend(animation: string, targetWeight: number): void;
    Blend(animation: string, targetWeight: number, fadeLength: number): void;
    CrossFade(animation: string): void;
    CrossFade(animation: string, fadeLength: number): void;
    CrossFade(animation: string, fadeLength: number, mode: PlayMode): void;
    CrossFadeQueued(animation: string): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number, queue: QueueMode): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number, queue: QueueMode, mode: PlayMode): AnimationState;
    GetClip(name: string): AnimationClip;
    GetClipCount(): number;
    GetEnumerator(): unknown;
    IsPlaying(name: string): boolean;
    Play(): boolean;
    Play(mode: PlayMode): boolean;
    Play(animation: string): boolean;
    Play(animation: string, mode: PlayMode): boolean;
    Play(mode: AnimationPlayMode): boolean;
    Play(animation: string, mode: AnimationPlayMode): boolean;
    PlayQueued(animation: string): AnimationState;
    PlayQueued(animation: string, queue: QueueMode): AnimationState;
    PlayQueued(animation: string, queue: QueueMode, mode: PlayMode): AnimationState;
    RemoveClip(clip: AnimationClip): void;
    RemoveClip(clipName: string): void;
    Rewind(): void;
    Rewind(name: string): void;
    Sample(): void;
    Stop(): void;
    Stop(name: string): void;
    SyncLayer(layer: number): void;
}
    
interface ClientSceneListener extends MonoBehaviour {
    IsGameSceneLoaded: boolean;
    SceneLoadPercent: number;

    constructor(): ClientSceneListener;

}
    
interface CoreLoadingScreen extends MonoBehaviour {
    progressText: TMP_Text;
    disconnectButton: Button;

    constructor(): CoreLoadingScreen;

    Close(): void;
    SetProgress(text: string, percent: number): void;
}
    
interface TextField {
    multiline: boolean;
    value: string;

    constructor(): TextField;
    constructor(maxLength: number, multiline: boolean, isPasswordField: boolean, maskChar: string): TextField;
    constructor(label: string): TextField;
    constructor(label: string, maxLength: number, multiline: boolean, isPasswordField: boolean, maskChar: string): TextField;

    SelectRange(rangeCursorIndex: number, selectionIndex: number): void;
    SetValueWithoutNotify(newValue: string): void;
}
    
interface TextFieldConstructor {
    ussClassName: string;
    labelUssClassName: string;
    inputUssClassName: string;


}
declare const TextField: TextFieldConstructor;
    
interface GameConfig extends ScriptableObject {
    minimumPlayerVersion: number;
    gameId: string;
    gameScenes: CSArray<Object>;
    packages: CSArray<AirshipPackageDocument>;

    constructor(): GameConfig;

    ToJson(): string;
}
    
interface AirshipPackageDocument {
    id: string;
    version: string;
    game: boolean;
    localSource: boolean;
    disabled: boolean;

    constructor(): AirshipPackageDocument;

}
    
interface GameConfigConstructor {


    Load(): GameConfig;
}
declare const GameConfig: GameConfigConstructor;
    
interface RenderSettings extends Object {


}
    
interface Light extends Behaviour {
    type: LightType;
    shape: LightShape;
    spotAngle: number;
    innerSpotAngle: number;
    color: Color;
    colorTemperature: number;
    useColorTemperature: boolean;
    intensity: number;
    bounceIntensity: number;
    useBoundingSphereOverride: boolean;
    boundingSphereOverride: Vector4;
    useViewFrustumForShadowCasterCull: boolean;
    shadowCustomResolution: number;
    shadowBias: number;
    shadowNormalBias: number;
    shadowNearPlane: number;
    useShadowMatrixOverride: boolean;
    shadowMatrixOverride: Matrix4x4;
    range: number;
    flare: Flare;
    bakingOutput: LightBakingOutput;
    cullingMask: number;
    renderingLayerMask: number;
    lightShadowCasterMode: LightShadowCasterMode;
    shadowRadius: number;
    shadowAngle: number;
    shadows: LightShadows;
    shadowStrength: number;
    shadowResolution: LightShadowResolution;
    shadowSoftness: number;
    shadowSoftnessFade: number;
    layerShadowCullDistances: CSArray<number>;
    cookieSize: number;
    cookie: Texture;
    renderMode: LightRenderMode;
    bakedIndex: number;
    areaSize: Vector2;
    lightmapBakeType: LightmapBakeType;
    commandBufferCount: number;
    shadowConstantBias: number;
    shadowObjectSizeBias: number;
    attenuate: boolean;
    lightmappingMode: LightmappingMode;
    isBaked: boolean;
    alreadyLightmapped: boolean;

    constructor(): Light;

    AddCommandBuffer(evt: LightEvent, buffer: CommandBuffer): void;
    AddCommandBuffer(evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass): void;
    AddCommandBufferAsync(evt: LightEvent, buffer: CommandBuffer, queueType: ComputeQueueType): void;
    AddCommandBufferAsync(evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass, queueType: ComputeQueueType): void;
    GetCommandBuffers(evt: LightEvent): CSArray<CommandBuffer>;
    RemoveAllCommandBuffers(): void;
    RemoveCommandBuffer(evt: LightEvent, buffer: CommandBuffer): void;
    RemoveCommandBuffers(evt: LightEvent): void;
    Reset(): void;
    SetLightDirty(): void;
}
    
interface Flare extends Object {

    constructor(): Flare;

}
    
interface LightBakingOutput {
    probeOcclusionLightIndex: number;
    occlusionMaskChannel: number;
    lightmapBakeType: LightmapBakeType;
    mixedLightingMode: MixedLightingMode;
    isBaked: boolean;


}
    
interface LightConstructor {
    pixelLightCount: number;


    GetLights(type: LightType, layer: number): CSArray<Light>;
}
declare const Light: LightConstructor;
    
interface RenderSettingsConstructor {
    fog: boolean;
    fogStartDistance: number;
    fogEndDistance: number;
    fogMode: FogMode;
    fogColor: Color;
    fogDensity: number;
    ambientMode: AmbientMode;
    ambientSkyColor: Color;
    ambientEquatorColor: Color;
    ambientGroundColor: Color;
    ambientIntensity: number;
    ambientLight: Color;
    subtractiveShadowColor: Color;
    skybox: Material;
    sun: Light;
    ambientProbe: SphericalHarmonicsL2;
    customReflection: Texture;
    reflectionIntensity: number;
    reflectionBounces: number;
    defaultReflectionMode: DefaultReflectionMode;
    defaultReflectionResolution: number;
    haloStrength: number;
    flareStrength: number;
    flareFadeSpeed: number;
    ambientSkyboxAmount: number;


}
declare const RenderSettings: RenderSettingsConstructor;
    
interface ServerBootstrap extends MonoBehaviour {
    startupConfig: StartupConfig;
    playerConfig: PlayerConfig;
    overrideGameBundleId: string;
    overrideGameBundleVersion: string;
    overrideCoreBundleId: string;
    overrideCoreBundleVersion: string;
    overrideStartingScene: string;
    overrideQueueType: string;
    downloadBundles: boolean;
    editorConfig: EasyEditorConfig;
    serverReady: boolean;
    isStartupConfigReady: boolean;

    constructor(): ServerBootstrap;

    FinishedSetup(): void;
    GetJoinCode(): string;
    GetQueueType(): string;
    IsAgonesEnvironment(): boolean;
    Shutdown(): void;
}
    
interface StartupConfig {
    CoreBundleId: string;
    CoreBundleVersion: string;
    GameBundleId: string;
    GameBundleVersion: string;
    StartingSceneName: string;
    CdnUrl: string;
    packages: CSArray<AirshipPackageDocument>;


}
    
interface PlayerConfig extends ScriptableObject {
    playerVersion: number;

    constructor(): PlayerConfig;

}
    
interface EasyEditorConfig extends ScriptableObject {
    useBundlesInEditor: boolean;
    buildBundlesOnPlay: boolean;

    constructor(): EasyEditorConfig;

}
    
interface SceneManager {

    constructor(): SceneManager;

}
    
interface CreateSceneParameters {
    localPhysicsMode: LocalPhysicsMode;

    constructor(physicsMode: LocalPhysicsMode): CreateSceneParameters;

}
    
interface SceneManagerConstructor {
    sceneCount: number;
    sceneCountInBuildSettings: number;


    CreateScene(sceneName: string, parameters: CreateSceneParameters): Scene;
    CreateScene(sceneName: string): Scene;
    GetActiveScene(): Scene;
    GetAllScenes(): CSArray<Scene>;
    GetSceneAt(index: number): Scene;
    GetSceneByBuildIndex(buildIndex: number): Scene;
    GetSceneByName(name: string): Scene;
    GetSceneByPath(scenePath: string): Scene;
    LoadScene(sceneName: string, mode: LoadSceneMode): void;
    LoadScene(sceneName: string): void;
    LoadScene(sceneName: string, parameters: LoadSceneParameters): Scene;
    LoadScene(sceneBuildIndex: number, mode: LoadSceneMode): void;
    LoadScene(sceneBuildIndex: number): void;
    LoadScene(sceneBuildIndex: number, parameters: LoadSceneParameters): Scene;
    LoadSceneAsync(sceneBuildIndex: number, mode: LoadSceneMode): AsyncOperation;
    LoadSceneAsync(sceneBuildIndex: number): AsyncOperation;
    LoadSceneAsync(sceneBuildIndex: number, parameters: LoadSceneParameters): AsyncOperation;
    LoadSceneAsync(sceneName: string, mode: LoadSceneMode): AsyncOperation;
    LoadSceneAsync(sceneName: string): AsyncOperation;
    LoadSceneAsync(sceneName: string, parameters: LoadSceneParameters): AsyncOperation;
    MergeScenes(sourceScene: Scene, destinationScene: Scene): void;
    MoveGameObjectToScene(go: GameObject, scene: Scene): void;
    SetActiveScene(scene: Scene): boolean;
    UnloadScene(scene: Scene): boolean;
    UnloadScene(sceneBuildIndex: number): boolean;
    UnloadScene(sceneName: string): boolean;
    UnloadSceneAsync(sceneBuildIndex: number): AsyncOperation;
    UnloadSceneAsync(sceneName: string): AsyncOperation;
    UnloadSceneAsync(scene: Scene): AsyncOperation;
    UnloadSceneAsync(sceneBuildIndex: number, options: UnloadSceneOptions): AsyncOperation;
    UnloadSceneAsync(sceneName: string, options: UnloadSceneOptions): AsyncOperation;
    UnloadSceneAsync(scene: Scene, options: UnloadSceneOptions): AsyncOperation;
}
declare const SceneManager: SceneManagerConstructor;
    
interface AccessoryBuilder extends MonoBehaviour {
    clothColliders: CSArray<CapsuleCollider>;

    constructor(): AccessoryBuilder;

    AddAccessories(accessories: CSArray<Accessory>, addMode: AccessoryAddMode): CSArray<ActiveAccessory>;
    EquipAccessoryCollection(collection: AccessoryCollection): CSArray<ActiveAccessory>;
    GetAccessoryMeshes(slot: AccessorySlot): CSArray<Renderer>;
    GetAccessoryParticles(slot: AccessorySlot): CSArray<ParticleSystem>;
    GetActiveAccessories(): CSArray<ActiveAccessory>;
    GetActiveAccessoriesBySlot(target: AccessorySlot): CSArray<ActiveAccessory>;
    GetAllAccessoryMeshes(): CSArray<Renderer>;
    RemoveAccessories(): void;
    RemoveAccessorySlot(slot: AccessorySlot): void;
    SetAccessory(accessory: Accessory): ActiveAccessory;
}
    
interface CapsuleCollider extends Collider {
    center: Vector3;
    radius: number;
    height: number;
    direction: number;

    constructor(): CapsuleCollider;

}
    
interface ActiveAccessory {
    accessory: Accessory;
    gameObjects: CSArray<GameObject>;
    renderers: CSArray<Renderer>;


}
    
interface Accessory extends ScriptableObject {
    DisplayName: string;
    AccessorySlot: AccessorySlot;
    Prefab: GameObject;
    Position: Vector3;
    Rotation: Vector3;
    Scale: Vector3;
    MeshDeformed: boolean;
    VisibleInFirstPerson: boolean;
    HasSkinnedMeshes: boolean;

    constructor(): Accessory;

}
    
interface AccessoryCollection extends ScriptableObject {
    accessories: CSArray<Accessory>;

    constructor(): AccessoryCollection;

}
    
interface ParticleSystem extends Component {
    safeCollisionEventSize: number;
    startDelay: number;
    loop: boolean;
    playOnAwake: boolean;
    duration: number;
    playbackSpeed: number;
    enableEmission: boolean;
    emissionRate: number;
    startSpeed: number;
    startSize: number;
    startColor: Color;
    startRotation: number;
    startRotation3D: Vector3;
    startLifetime: number;
    gravityModifier: number;
    maxParticles: number;
    simulationSpace: ParticleSystemSimulationSpace;
    scalingMode: ParticleSystemScalingMode;
    automaticCullingEnabled: boolean;
    isPlaying: boolean;
    isEmitting: boolean;
    isStopped: boolean;
    isPaused: boolean;
    particleCount: number;
    time: number;
    randomSeed: number;
    useAutoRandomSeed: boolean;
    proceduralSimulationSupported: boolean;
    main: MainModule;
    emission: EmissionModule;
    shape: ShapeModule;
    velocityOverLifetime: VelocityOverLifetimeModule;
    limitVelocityOverLifetime: LimitVelocityOverLifetimeModule;
    inheritVelocity: InheritVelocityModule;
    lifetimeByEmitterSpeed: LifetimeByEmitterSpeedModule;
    forceOverLifetime: ForceOverLifetimeModule;
    colorOverLifetime: ColorOverLifetimeModule;
    colorBySpeed: ColorBySpeedModule;
    sizeOverLifetime: SizeOverLifetimeModule;
    sizeBySpeed: SizeBySpeedModule;
    rotationOverLifetime: RotationOverLifetimeModule;
    rotationBySpeed: RotationBySpeedModule;
    externalForces: ExternalForcesModule;
    noise: NoiseModule;
    collision: CollisionModule;
    trigger: TriggerModule;
    subEmitters: SubEmittersModule;
    textureSheetAnimation: TextureSheetAnimationModule;
    lights: LightsModule;
    trails: TrailModule;
    customData: CustomDataModule;

    constructor(): ParticleSystem;

    AllocateAxisOfRotationAttribute(): void;
    AllocateCustomDataAttribute(stream: ParticleSystemCustomData): void;
    AllocateMeshIndexAttribute(): void;
    Clear(withChildren: boolean): void;
    Clear(): void;
    Emit(position: Vector3, velocity: Vector3, size: number, lifetime: number, color: Color32): void;
    Emit(particle: Particle): void;
    Emit(count: number): void;
    Emit(emitParams: EmitParams, count: number): void;
    GetCustomParticleData(customData: CSArray<Vector4>, streamIndex: ParticleSystemCustomData): number;
    GetParticles(particles: CSArray<Particle>, size: number, offset: number): number;
    GetParticles(particles: CSArray<Particle>, size: number): number;
    GetParticles(particles: CSArray<Particle>): number;
    GetParticles(particles: CSArray<Particle>, size: number, offset: number): number;
    GetParticles(particles: CSArray<Particle>, size: number): number;
    GetParticles(particles: CSArray<Particle>): number;
    GetPlaybackState(): PlaybackState;
    GetTrails(): Trails;
    GetTrails(trailData: unknown): number;
    IsAlive(withChildren: boolean): boolean;
    IsAlive(): boolean;
    Pause(withChildren: boolean): void;
    Pause(): void;
    Play(withChildren: boolean): void;
    Play(): void;
    SetCustomParticleData(customData: CSArray<Vector4>, streamIndex: ParticleSystemCustomData): void;
    SetParticles(particles: CSArray<Particle>, size: number, offset: number): void;
    SetParticles(particles: CSArray<Particle>, size: number): void;
    SetParticles(particles: CSArray<Particle>): void;
    SetParticles(particles: CSArray<Particle>, size: number, offset: number): void;
    SetParticles(particles: CSArray<Particle>, size: number): void;
    SetParticles(particles: CSArray<Particle>): void;
    SetPlaybackState(playbackState: PlaybackState): void;
    SetTrails(trailData: Trails): void;
    Simulate(t: number, withChildren: boolean, restart: boolean, fixedTimeStep: boolean): void;
    Simulate(t: number, withChildren: boolean, restart: boolean): void;
    Simulate(t: number, withChildren: boolean): void;
    Simulate(t: number): void;
    Stop(withChildren: boolean, stopBehavior: ParticleSystemStopBehavior): void;
    Stop(withChildren: boolean): void;
    Stop(): void;
    TriggerSubEmitter(subEmitterIndex: number): void;
    TriggerSubEmitter(subEmitterIndex: number, particle: unknown): void;
    TriggerSubEmitter(subEmitterIndex: number, particles: CSArray<Particle>): void;
}
    
interface MainModule {
    randomizeRotationDirection: number;
    emitterVelocity: Vector3;
    duration: number;
    loop: boolean;
    prewarm: boolean;
    startDelay: MinMaxCurve;
    startDelayMultiplier: number;
    startLifetime: MinMaxCurve;
    startLifetimeMultiplier: number;
    startSpeed: MinMaxCurve;
    startSpeedMultiplier: number;
    startSize3D: boolean;
    startSize: MinMaxCurve;
    startSizeMultiplier: number;
    startSizeX: MinMaxCurve;
    startSizeXMultiplier: number;
    startSizeY: MinMaxCurve;
    startSizeYMultiplier: number;
    startSizeZ: MinMaxCurve;
    startSizeZMultiplier: number;
    startRotation3D: boolean;
    startRotation: MinMaxCurve;
    startRotationMultiplier: number;
    startRotationX: MinMaxCurve;
    startRotationXMultiplier: number;
    startRotationY: MinMaxCurve;
    startRotationYMultiplier: number;
    startRotationZ: MinMaxCurve;
    startRotationZMultiplier: number;
    flipRotation: number;
    startColor: MinMaxGradient;
    gravityModifier: MinMaxCurve;
    gravityModifierMultiplier: number;
    simulationSpace: ParticleSystemSimulationSpace;
    customSimulationSpace: Transform;
    simulationSpeed: number;
    useUnscaledTime: boolean;
    scalingMode: ParticleSystemScalingMode;
    playOnAwake: boolean;
    maxParticles: number;
    emitterVelocityMode: ParticleSystemEmitterVelocityMode;
    stopAction: ParticleSystemStopAction;
    ringBufferMode: ParticleSystemRingBufferMode;
    ringBufferLoopRange: Vector2;
    cullingMode: ParticleSystemCullingMode;


}
    
interface MinMaxCurve {
    mode: ParticleSystemCurveMode;
    curveMultiplier: number;
    curveMax: AnimationCurve;
    curveMin: AnimationCurve;
    constantMax: number;
    constantMin: number;
    constant: number;
    curve: AnimationCurve;
    curveScalar: number;

    constructor(constant: number): MinMaxCurve;
    constructor(multiplier: number, curve: AnimationCurve): MinMaxCurve;
    constructor(multiplier: number, min: AnimationCurve, max: AnimationCurve): MinMaxCurve;
    constructor(min: number, max: number): MinMaxCurve;

    Evaluate(time: number): number;
    Evaluate(time: number, lerpFactor: number): number;
}
    
interface MinMaxGradient {
    mode: ParticleSystemGradientMode;
    gradientMax: Gradient;
    gradientMin: Gradient;
    colorMax: Color;
    colorMin: Color;
    color: Color;
    gradient: Gradient;

    constructor(color: Color): MinMaxGradient;
    constructor(gradient: Gradient): MinMaxGradient;
    constructor(min: Color, max: Color): MinMaxGradient;
    constructor(min: Gradient, max: Gradient): MinMaxGradient;

    Evaluate(time: number): Color;
    Evaluate(time: number, lerpFactor: number): Color;
}
    
interface Gradient {
    colorKeys: CSArray<GradientColorKey>;
    alphaKeys: CSArray<GradientAlphaKey>;
    mode: GradientMode;

    constructor(): Gradient;

    Equals(o: unknown): boolean;
    Equals(other: Gradient): boolean;
    Evaluate(time: number): Color;
    GetHashCode(): number;
    SetKeys(colorKeys: CSArray<GradientColorKey>, alphaKeys: CSArray<GradientAlphaKey>): void;
}
    
interface GradientColorKey {
    color: Color;
    time: number;

    constructor(col: Color, time: number): GradientColorKey;

}
    
interface GradientAlphaKey {
    alpha: number;
    time: number;

    constructor(alpha: number, time: number): GradientAlphaKey;

}
    
interface EmissionModule {
    type: ParticleSystemEmissionType;
    rate: MinMaxCurve;
    rateMultiplier: number;
    enabled: boolean;
    rateOverTime: MinMaxCurve;
    rateOverTimeMultiplier: number;
    rateOverDistance: MinMaxCurve;
    rateOverDistanceMultiplier: number;
    burstCount: number;


    GetBurst(index: number): Burst;
    GetBursts(bursts: CSArray<Burst>): number;
    SetBurst(index: number, burst: Burst): void;
    SetBursts(bursts: CSArray<Burst>): void;
    SetBursts(bursts: CSArray<Burst>, size: number): void;
}
    
interface Burst {
    time: number;
    count: MinMaxCurve;
    minCount: number;
    maxCount: number;
    cycleCount: number;
    repeatInterval: number;
    probability: number;

    constructor(_time: number, _count: number): Burst;
    constructor(_time: number, _minCount: number, _maxCount: number): Burst;
    constructor(_time: number, _minCount: number, _maxCount: number, _cycleCount: number, _repeatInterval: number): Burst;
    constructor(_time: number, _count: MinMaxCurve): Burst;
    constructor(_time: number, _count: MinMaxCurve, _cycleCount: number, _repeatInterval: number): Burst;

}
    
interface ShapeModule {
    box: Vector3;
    meshScale: number;
    randomDirection: boolean;
    enabled: boolean;
    shapeType: ParticleSystemShapeType;
    randomDirectionAmount: number;
    sphericalDirectionAmount: number;
    randomPositionAmount: number;
    alignToDirection: boolean;
    radius: number;
    radiusMode: ParticleSystemShapeMultiModeValue;
    radiusSpread: number;
    radiusSpeed: MinMaxCurve;
    radiusSpeedMultiplier: number;
    radiusThickness: number;
    angle: number;
    length: number;
    boxThickness: Vector3;
    meshShapeType: ParticleSystemMeshShapeType;
    mesh: Mesh;
    meshRenderer: MeshRenderer;
    skinnedMeshRenderer: SkinnedMeshRenderer;
    sprite: Sprite;
    spriteRenderer: SpriteRenderer;
    useMeshMaterialIndex: boolean;
    meshMaterialIndex: number;
    useMeshColors: boolean;
    normalOffset: number;
    meshSpawnMode: ParticleSystemShapeMultiModeValue;
    meshSpawnSpread: number;
    meshSpawnSpeed: MinMaxCurve;
    meshSpawnSpeedMultiplier: number;
    arc: number;
    arcMode: ParticleSystemShapeMultiModeValue;
    arcSpread: number;
    arcSpeed: MinMaxCurve;
    arcSpeedMultiplier: number;
    donutRadius: number;
    position: Vector3;
    rotation: Vector3;
    scale: Vector3;
    texture: Texture2D;
    textureClipChannel: ParticleSystemShapeTextureChannel;
    textureClipThreshold: number;
    textureColorAffectsParticles: boolean;
    textureAlphaAffectsParticles: boolean;
    textureBilinearFiltering: boolean;
    textureUVChannel: number;


}
    
interface SkinnedMeshRenderer extends Renderer {
    quality: SkinQuality;
    updateWhenOffscreen: boolean;
    forceMatrixRecalculationPerRender: boolean;
    rootBone: Transform;
    bones: CSArray<Transform>;
    sharedMesh: Mesh;
    skinnedMotionVectors: boolean;
    vertexBufferTarget: Target;

    constructor(): SkinnedMeshRenderer;

    BakeMesh(mesh: Mesh): void;
    BakeMesh(mesh: Mesh, useScale: boolean): void;
    GetBlendShapeWeight(index: number): number;
    GetPreviousVertexBuffer(): GraphicsBuffer;
    GetVertexBuffer(): GraphicsBuffer;
    SetBlendShapeWeight(index: number, value: number): void;
}
    
interface SpriteRenderer extends Renderer {
    sprite: Sprite;
    drawMode: SpriteDrawMode;
    size: Vector2;
    adaptiveModeThreshold: number;
    tileMode: SpriteTileMode;
    color: Color;
    maskInteraction: SpriteMaskInteraction;
    flipX: boolean;
    flipY: boolean;
    spriteSortPoint: SpriteSortPoint;

    constructor(): SpriteRenderer;

    RegisterSpriteChangeCallback(callback: unknown): void;
    UnregisterSpriteChangeCallback(callback: unknown): void;
}
    
interface VelocityOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    y: MinMaxCurve;
    z: MinMaxCurve;
    xMultiplier: number;
    yMultiplier: number;
    zMultiplier: number;
    orbitalX: MinMaxCurve;
    orbitalY: MinMaxCurve;
    orbitalZ: MinMaxCurve;
    orbitalXMultiplier: number;
    orbitalYMultiplier: number;
    orbitalZMultiplier: number;
    orbitalOffsetX: MinMaxCurve;
    orbitalOffsetY: MinMaxCurve;
    orbitalOffsetZ: MinMaxCurve;
    orbitalOffsetXMultiplier: number;
    orbitalOffsetYMultiplier: number;
    orbitalOffsetZMultiplier: number;
    radial: MinMaxCurve;
    radialMultiplier: number;
    speedModifier: MinMaxCurve;
    speedModifierMultiplier: number;
    space: ParticleSystemSimulationSpace;


}
    
interface LimitVelocityOverLifetimeModule {
    enabled: boolean;
    limitX: MinMaxCurve;
    limitXMultiplier: number;
    limitY: MinMaxCurve;
    limitYMultiplier: number;
    limitZ: MinMaxCurve;
    limitZMultiplier: number;
    limit: MinMaxCurve;
    limitMultiplier: number;
    dampen: number;
    separateAxes: boolean;
    space: ParticleSystemSimulationSpace;
    drag: MinMaxCurve;
    dragMultiplier: number;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;


}
    
interface InheritVelocityModule {
    enabled: boolean;
    mode: ParticleSystemInheritVelocityMode;
    curve: MinMaxCurve;
    curveMultiplier: number;


}
    
interface LifetimeByEmitterSpeedModule {
    enabled: boolean;
    curve: MinMaxCurve;
    curveMultiplier: number;
    range: Vector2;


}
    
interface ForceOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    y: MinMaxCurve;
    z: MinMaxCurve;
    xMultiplier: number;
    yMultiplier: number;
    zMultiplier: number;
    space: ParticleSystemSimulationSpace;
    randomized: boolean;


}
    
interface ColorOverLifetimeModule {
    enabled: boolean;
    color: MinMaxGradient;


}
    
interface ColorBySpeedModule {
    enabled: boolean;
    color: MinMaxGradient;
    range: Vector2;


}
    
interface SizeOverLifetimeModule {
    enabled: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;


}
    
interface SizeBySpeedModule {
    enabled: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;
    range: Vector2;


}
    
interface RotationOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;


}
    
interface RotationBySpeedModule {
    enabled: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;
    range: Vector2;


}
    
interface ExternalForcesModule {
    enabled: boolean;
    multiplier: number;
    multiplierCurve: MinMaxCurve;
    influenceFilter: ParticleSystemGameObjectFilter;
    influenceMask: LayerMask;
    influenceCount: number;


    AddInfluence(field: ParticleSystemForceField): void;
    GetInfluence(index: number): ParticleSystemForceField;
    IsAffectedBy(field: ParticleSystemForceField): boolean;
    RemoveAllInfluences(): void;
    RemoveInfluence(index: number): void;
    RemoveInfluence(field: ParticleSystemForceField): void;
    SetInfluence(index: number, field: ParticleSystemForceField): void;
}
    
    
    
interface ParticleSystemForceField extends Behaviour {
    shape: ParticleSystemForceFieldShape;
    startRange: number;
    endRange: number;
    length: number;
    gravityFocus: number;
    rotationRandomness: Vector2;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;
    vectorField: Texture3D;
    directionX: MinMaxCurve;
    directionY: MinMaxCurve;
    directionZ: MinMaxCurve;
    gravity: MinMaxCurve;
    rotationSpeed: MinMaxCurve;
    rotationAttraction: MinMaxCurve;
    drag: MinMaxCurve;
    vectorFieldSpeed: MinMaxCurve;
    vectorFieldAttraction: MinMaxCurve;

    constructor(): ParticleSystemForceField;

}
    
interface Texture3D extends Texture {
    depth: number;
    format: TextureFormat;
    isReadable: boolean;

    constructor(width: number, height: number, depth: number, format: DefaultFormat, flags: TextureCreationFlags): Texture3D;
    constructor(width: number, height: number, depth: number, format: GraphicsFormat, flags: TextureCreationFlags): Texture3D;
    constructor(width: number, height: number, depth: number, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: number): Texture3D;
    constructor(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number): Texture3D;
    constructor(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number, nativeTex: unknown): Texture3D;
    constructor(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean): Texture3D;
    constructor(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean, nativeTex: unknown): Texture3D;

    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    GetPixel(x: number, y: number, z: number): Color;
    GetPixel(x: number, y: number, z: number, mipLevel: number): Color;
    GetPixelBilinear(u: number, v: number, w: number): Color;
    GetPixelBilinear(u: number, v: number, w: number, mipLevel: number): Color;
    GetPixelData<T>(mipLevel: number): CSArray<T>;
    GetPixels(miplevel: number): CSArray<Color>;
    GetPixels(): CSArray<Color>;
    GetPixels32(miplevel: number): CSArray<Color32>;
    GetPixels32(): CSArray<Color32>;
    SetPixel(x: number, y: number, z: number, color: Color): void;
    SetPixel(x: number, y: number, z: number, color: Color, mipLevel: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixels(colors: CSArray<Color>, miplevel: number): void;
    SetPixels(colors: CSArray<Color>): void;
    SetPixels32(colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(colors: CSArray<Color32>): void;
    UpdateExternalTexture(nativeTex: unknown): void;
}
    
interface Texture3DConstructor {


    CreateExternalTexture(width: number, height: number, depth: number, format: TextureFormat, mipChain: boolean, nativeTex: unknown): Texture3D;
}
declare const Texture3D: Texture3DConstructor;
    
interface ParticleSystemForceFieldConstructor {


    FindAll(): CSArray<ParticleSystemForceField>;
}
declare const ParticleSystemForceField: ParticleSystemForceFieldConstructor;
    
interface NoiseModule {
    enabled: boolean;
    separateAxes: boolean;
    strength: MinMaxCurve;
    strengthMultiplier: number;
    strengthX: MinMaxCurve;
    strengthXMultiplier: number;
    strengthY: MinMaxCurve;
    strengthYMultiplier: number;
    strengthZ: MinMaxCurve;
    strengthZMultiplier: number;
    frequency: number;
    damping: boolean;
    octaveCount: number;
    octaveMultiplier: number;
    octaveScale: number;
    quality: ParticleSystemNoiseQuality;
    scrollSpeed: MinMaxCurve;
    scrollSpeedMultiplier: number;
    remapEnabled: boolean;
    remap: MinMaxCurve;
    remapMultiplier: number;
    remapX: MinMaxCurve;
    remapXMultiplier: number;
    remapY: MinMaxCurve;
    remapYMultiplier: number;
    remapZ: MinMaxCurve;
    remapZMultiplier: number;
    positionAmount: MinMaxCurve;
    rotationAmount: MinMaxCurve;
    sizeAmount: MinMaxCurve;


}
    
interface CollisionModule {
    maxPlaneCount: number;
    enabled: boolean;
    type: ParticleSystemCollisionType;
    mode: ParticleSystemCollisionMode;
    dampen: MinMaxCurve;
    dampenMultiplier: number;
    bounce: MinMaxCurve;
    bounceMultiplier: number;
    lifetimeLoss: MinMaxCurve;
    lifetimeLossMultiplier: number;
    minKillSpeed: number;
    maxKillSpeed: number;
    collidesWith: LayerMask;
    enableDynamicColliders: boolean;
    maxCollisionShapes: number;
    quality: ParticleSystemCollisionQuality;
    voxelSize: number;
    radiusScale: number;
    sendCollisionMessages: boolean;
    colliderForce: number;
    multiplyColliderForceByCollisionAngle: boolean;
    multiplyColliderForceByParticleSpeed: boolean;
    multiplyColliderForceByParticleSize: boolean;
    planeCount: number;
    enableInteriorCollisions: boolean;


    AddPlane(transform: Transform): void;
    GetPlane(index: number): Transform;
    RemovePlane(index: number): void;
    RemovePlane(transform: Transform): void;
    SetPlane(index: number, transform: Transform): void;
}
    
interface TriggerModule {
    maxColliderCount: number;
    enabled: boolean;
    inside: ParticleSystemOverlapAction;
    outside: ParticleSystemOverlapAction;
    enter: ParticleSystemOverlapAction;
    exit: ParticleSystemOverlapAction;
    colliderQueryMode: ParticleSystemColliderQueryMode;
    radiusScale: number;
    colliderCount: number;


    AddCollider(collider: Component): void;
    GetCollider(index: number): Component;
    RemoveCollider(index: number): void;
    RemoveCollider(collider: Component): void;
    SetCollider(index: number, collider: Component): void;
}
    
interface SubEmittersModule {
    birth0: ParticleSystem;
    birth1: ParticleSystem;
    collision0: ParticleSystem;
    collision1: ParticleSystem;
    death0: ParticleSystem;
    death1: ParticleSystem;
    enabled: boolean;
    subEmittersCount: number;


    AddSubEmitter(subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties, emitProbability: number): void;
    AddSubEmitter(subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties): void;
    GetSubEmitterEmitProbability(index: number): number;
    GetSubEmitterProperties(index: number): ParticleSystemSubEmitterProperties;
    GetSubEmitterSystem(index: number): ParticleSystem;
    GetSubEmitterType(index: number): ParticleSystemSubEmitterType;
    RemoveSubEmitter(index: number): void;
    RemoveSubEmitter(subEmitter: ParticleSystem): void;
    SetSubEmitterEmitProbability(index: number, emitProbability: number): void;
    SetSubEmitterProperties(index: number, properties: ParticleSystemSubEmitterProperties): void;
    SetSubEmitterSystem(index: number, subEmitter: ParticleSystem): void;
    SetSubEmitterType(index: number, type: ParticleSystemSubEmitterType): void;
}
    
interface TextureSheetAnimationModule {
    flipU: number;
    flipV: number;
    useRandomRow: boolean;
    enabled: boolean;
    mode: ParticleSystemAnimationMode;
    timeMode: ParticleSystemAnimationTimeMode;
    fps: number;
    numTilesX: number;
    numTilesY: number;
    animation: ParticleSystemAnimationType;
    rowMode: ParticleSystemAnimationRowMode;
    frameOverTime: MinMaxCurve;
    frameOverTimeMultiplier: number;
    startFrame: MinMaxCurve;
    startFrameMultiplier: number;
    cycleCount: number;
    rowIndex: number;
    uvChannelMask: UVChannelFlags;
    spriteCount: number;
    speedRange: Vector2;


    AddSprite(sprite: Sprite): void;
    GetSprite(index: number): Sprite;
    RemoveSprite(index: number): void;
    SetSprite(index: number, sprite: Sprite): void;
}
    
interface LightsModule {
    enabled: boolean;
    ratio: number;
    useRandomDistribution: boolean;
    light: Light;
    useParticleColor: boolean;
    sizeAffectsRange: boolean;
    alphaAffectsIntensity: boolean;
    range: MinMaxCurve;
    rangeMultiplier: number;
    intensity: MinMaxCurve;
    intensityMultiplier: number;
    maxLights: number;


}
    
interface TrailModule {
    enabled: boolean;
    mode: ParticleSystemTrailMode;
    ratio: number;
    lifetime: MinMaxCurve;
    lifetimeMultiplier: number;
    minVertexDistance: number;
    textureMode: ParticleSystemTrailTextureMode;
    worldSpace: boolean;
    dieWithParticles: boolean;
    sizeAffectsWidth: boolean;
    sizeAffectsLifetime: boolean;
    inheritParticleColor: boolean;
    colorOverLifetime: MinMaxGradient;
    widthOverTrail: MinMaxCurve;
    widthOverTrailMultiplier: number;
    colorOverTrail: MinMaxGradient;
    generateLightingData: boolean;
    ribbonCount: number;
    shadowBias: number;
    splitSubEmitterRibbons: boolean;
    attachRibbonsToTransform: boolean;


}
    
interface CustomDataModule {
    enabled: boolean;


    GetColor(stream: ParticleSystemCustomData): MinMaxGradient;
    GetMode(stream: ParticleSystemCustomData): ParticleSystemCustomDataMode;
    GetVector(stream: ParticleSystemCustomData, component: number): MinMaxCurve;
    GetVectorComponentCount(stream: ParticleSystemCustomData): number;
    SetColor(stream: ParticleSystemCustomData, gradient: MinMaxGradient): void;
    SetMode(stream: ParticleSystemCustomData, mode: ParticleSystemCustomDataMode): void;
    SetVector(stream: ParticleSystemCustomData, component: number, curve: MinMaxCurve): void;
    SetVectorComponentCount(stream: ParticleSystemCustomData, count: number): void;
}
    
interface Particle {
    position: Vector3;
    velocity: Vector3;
    animatedVelocity: Vector3;
    totalVelocity: Vector3;
    remainingLifetime: number;
    startLifetime: number;
    startColor: Color32;
    randomSeed: number;
    axisOfRotation: Vector3;
    startSize: number;
    startSize3D: Vector3;
    rotation: number;
    rotation3D: Vector3;
    angularVelocity: number;
    angularVelocity3D: Vector3;
    lifetime: number;
    randomValue: number;
    size: number;
    color: Color32;


    GetCurrentColor(system: ParticleSystem): Color32;
    GetCurrentSize(system: ParticleSystem): number;
    GetCurrentSize3D(system: ParticleSystem): Vector3;
    GetMeshIndex(system: ParticleSystem): number;
    SetMeshIndex(index: number): void;
}
    
interface EmitParams {
    particle: Particle;
    position: Vector3;
    applyShapeToPosition: boolean;
    velocity: Vector3;
    startLifetime: number;
    startSize: number;
    startSize3D: Vector3;
    axisOfRotation: Vector3;
    rotation: number;
    rotation3D: Vector3;
    angularVelocity: number;
    angularVelocity3D: Vector3;
    startColor: Color32;
    randomSeed: number;
    meshIndex: number;


    ResetAngularVelocity(): void;
    ResetAxisOfRotation(): void;
    ResetMeshIndex(): void;
    ResetPosition(): void;
    ResetRandomSeed(): void;
    ResetRotation(): void;
    ResetStartColor(): void;
    ResetStartLifetime(): void;
    ResetStartSize(): void;
    ResetVelocity(): void;
}
    
interface PlaybackState {


}
    
interface Trails {
    capacity: number;


}
    
interface ParticleSystemConstructor {


    ResetPreMappedBufferMemory(): void;
    SetMaximumPreMappedBufferCounts(vertexBuffersCount: number, indexBuffersCount: number): void;
}
declare const ParticleSystem: ParticleSystemConstructor;
    
interface AccessoryBuilderConstructor {
    boneKey: string;


    GetBoneItemKey(slot: AccessorySlot): string;
}
declare const AccessoryBuilder: AccessoryBuilderConstructor;
    
interface AvatarMask extends Object {
    humanoidBodyPartCount: number;
    transformCount: number;

    constructor(): AvatarMask;

    AddTransformPath(transform: Transform): void;
    AddTransformPath(transform: Transform, recursive: boolean): void;
    GetHumanoidBodyPartActive(index: AvatarMaskBodyPart): boolean;
    GetTransformActive(index: number): boolean;
    GetTransformPath(index: number): string;
    RemoveTransformPath(transform: Transform): void;
    RemoveTransformPath(transform: Transform, recursive: boolean): void;
    SetHumanoidBodyPartActive(index: AvatarMaskBodyPart, value: boolean): void;
    SetTransformActive(index: number, value: boolean): void;
    SetTransformPath(index: number, path: string): void;
}
    
interface IAlignmentManager {


    GetRotationInfo(sourceTransform: Transform, forward: KnownVectorType, up: KnownVectorType): IRotationInfo;
    GetWorldVectorFromVectorType(sourceTransform: Transform, knownVectorType: KnownVectorType): Vector3;
    InverseQuat(rotation: Quaternion): Quaternion;
}
    
interface IRotationInfo {


    GetWorldRotationForLookingAt(worldForward: Vector3, worldUp: Vector3): Quaternion;
}
    
interface AlignmentManager extends MonoBehaviour, IAlignmentManager {

    constructor(): AlignmentManager;

    GetRotationInfo(sourceTransform: Transform, forward: KnownVectorType, up: KnownVectorType): IRotationInfo;
    GetWorldVectorFromVectorType(sourceTransform: Transform, knownVectorType: KnownVectorType): Vector3;
    InverseQuat(rotation: Quaternion): Quaternion;
}
    
interface AlignmentManagerConstructor {
    Instance: IAlignmentManager;


}
declare const AlignmentManager: AlignmentManagerConstructor;
    
interface VoxelWorld extends MonoBehaviour {
    debugReloadOnScriptReloadMode: boolean;
    radiosityEnabled: boolean;
    globalSunBrightness: number;
    globalSkyBrightness: number;
    globalFogStart: number;
    globalFogEnd: number;
    globalFogColor: Color;
    globalSkySaturation: number;
    globalSunColor: Color;
    globalAmbientLight: Color;
    globalAmbientBrightness: number;
    globalAmbientOcclusion: number;
    globalRadiosityScale: number;
    globalRadiosityDirectLightAmp: number;
    showRadioistyProbes: boolean;
    focusPosition: Vector3;
    voxelWorldFile: VoxelBinaryFile;
    blockDefines: TextAsset;
    worldNetworker: VoxelWorldNetworker;
    chunksFolder: GameObject;
    lightsFolder: GameObject;
    finishedReplicatingChunksFromServer: boolean;
    sceneLights: CSDictionary<number, LightReference>;
    chunks: CSDictionary<unknown, Chunk>;
    worldPositionEditorIndicators: CSDictionary<string, Transform>;
    cubeMap: Cubemap;
    cubeMapPath: string;
    cubeMapSHData: CSArray<float3>;
    lodNearDistance: number;
    lodFarDistance: number;
    lodTransitionSpeed: number;
    pointLights: CSArray<GameObject>;
    radiosityRaySamples: CSArray<CSArray<Vector3>>;
    blocks: VoxelBlocks;
    selectedBlockIndex: number;
    renderingDisabled: boolean;
    finishedLoading: boolean;
    globalSunDirection: Vector3;
    globalSunDirectionNormalized: Vector3;

    constructor(): VoxelWorld;

    AddChunk(key: unknown, chunk: Chunk): void;
    CalculateCheapSunAtPoint(point: Vector3, normal: Vector3): number;
    CalculateDirectLightingForWorldPoint(samplePoint: Vector3, sunPoint: unknown, normal: Vector3, chunk: Chunk): Color;
    CalculateLightingForWorldPoint(samplePoint: Vector3, normal: Vector3): unknown;
    CalculateLightingForWorldPoint(samplePoint: Vector3, sunPoint: unknown, normal: Vector3, chunk: Chunk): unknown;
    CalculatePlaneIntersection(origin: Vector3, dir: Vector3, planeNormal: Vector3, planePoint: Vector3): Vector3;
    CalculatePointLightColorAtPoint(samplePoint: Vector3, normal: Vector3, lightRef: LightReference): number;
    CalculatePointLightColorAtPointShadow(samplePoint: Vector3, normal: Vector3, lightRef: LightReference): Color;
    CalculatePointLightShadowAtPoint(samplePoint: Vector3, normal: Vector3, lightRef: LightReference): number;
    CalculateSunShadowAtPoint(point: Vector3, faceAxis: number, normal: Vector3): number;
    CanSeePoint(pos: Vector3, dest: Vector3, destNormal: Vector3): boolean;
    CreateSamples(): void;
    DirtyMesh(voxel: unknown, priority: boolean): void;
    DirtyNeighborMeshes(voxel: unknown, priority: boolean): void;
    FullWorldUpdate(): void;
    GenerateWorld(populateTerrain: boolean): void;
    GetChunkByChunkPos(pos: unknown): Chunk;
    GetDirectWorldLightingFromRayImpact(pos: Vector3, direction: Vector3, maxDistance: number): Color;
    GetNumBusyChunks(): number;
    GetOrMakeRadiosityProbeFor(pos: unknown): RadiosityProbeSample;
    GetRadiosityProbeColorForWorldPoint(pos: Vector3, normal: Vector3): Color;
    GetRadiosityProbeColorIfVisible(key: unknown, pos: Vector3, normal: Vector3): Color;
    GetRadiosityProbeIfVisible(key: unknown, pos: Vector3, normal: Vector3): RadiosityProbeSample;
    GetVoxelAndChunkAt(pos: unknown): unknown;
    GetVoxelAt(pos: Vector3): number;
    GetWorldLightingFromRayImpact(pos: Vector3, direction: Vector3, maxDistance: number, debugSamples: CSArray<RadiosityProbeSample>): unknown;
    InitializeLightingForChunk(chunk: Chunk): void;
    InvokeOnFinishedReplicatingChunksFromServer(): void;
    LoadEmptyWorld(blockDefines: TextAsset, cubeMapPath: string): void;
    LoadWorldFromVoxelBinaryFile(file: VoxelBinaryFile, blockDefines: TextAsset): void;
    OnRenderObject(): void;
    PlaceGrassOnTopOfGrass(): void;
    RaycastIndirectLightingAtPoint(pos: Vector3, normal: Vector3): Color;
    RaycastVoxel(pos: Vector3, direction: Vector3, maxDistance: number): VoxelRaycastResult;
    RaycastVoxel_Internal(pos: Vector3, direction: Vector3, maxDistance: number, debug: boolean): unknown;
    RaycastVoxelForLighting(pos: Vector3, direction: Vector3, maxDistance: number, debug: boolean): number;
    RaycastVoxelForRadiosity(pos: Vector3, direction: Vector3, maxDistance: number, debug: boolean): unknown;
    ReadVoxelAt(pos: Vector3): number;
    RegenerateAllMeshes(): void;
    ReloadTextureAtlas(): void;
    SampleSphericalHarmonics(shMap: CSArray<float3>, unitVector: Vector3): Color;
    SaveToFile(): void;
    SpawnDebugSphere(pos: Vector3, col: Color, radius: number): GameObject;
    Update(): void;
    UpdateLights(): void;
    UpdatePropertiesForAllChunksForRendering(): void;
    UpdateSceneLights(): void;
    Vector3ToNearestIndex(normal: Vector3): number;
    WriteVoxelAt(pos: Vector3, num: number, priority: boolean): void;
}
    
interface VoxelBinaryFile extends ScriptableObject {
    chunks: CSArray<SaveChunk>;
    worldPositions: CSArray<WorldPosition>;
    pointLights: CSArray<SavePointLight>;
    cubeMapPath: string;
    globalSkySaturation: number;
    globalSunColor: Color;
    globalSunBrightness: number;
    globalAmbientLight: Color;
    globalAmbientBrightness: number;
    globalAmbientOcclusion: number;
    globalRadiosityScale: number;
    globalRadiosityDirectLightAmp: number;
    globalFogStart: number;
    globalFogEnd: number;
    globalFogColor: Color;

    constructor(): VoxelBinaryFile;

    CreateFromVoxelWorld(world: VoxelWorld): void;
    CreateVoxelWorld(world: VoxelWorld): void;
    GetChunks(): CSArray<SaveChunk>;
    GetMapObjects(): CSArray<WorldPosition>;
    GetPointlights(): CSArray<SavePointLight>;
}
    
interface SaveChunk {
    key: unknown;
    data: CSArray<number>;

    constructor(key: unknown, data: CSArray<number>): SaveChunk;

}
    
interface WorldPosition {
    name: string;
    position: Vector3;
    rotation: Quaternion;

    constructor(name: string, position: Vector3, rotation: Quaternion): WorldPosition;

}
    
interface SavePointLight {
    name: string;
    color: Color;
    position: Vector3;
    rotation: Quaternion;
    intensity: number;
    range: number;
    castShadows: boolean;
    highQualityLight: boolean;


}
    
interface VoxelWorldNetworker extends NetworkBehaviour {
    world: VoxelWorld;

    constructor(): VoxelWorldNetworker;

    Awake(): void;
    Awake___UserLogic(): void;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnSpawnServer(connection: NetworkConnection): void;
    OnStartClient(): void;
    RpcLogic___TargetAddPointLights_178810215(conn: NetworkConnection, dtos: CSArray<PointLightDto>): void;
    RpcLogic___TargetDirtyLights_328543758(conn: NetworkConnection): void;
    RpcLogic___TargetFinishedSendingWorldRpc_328543758(conn: NetworkConnection): void;
    RpcLogic___TargetSetLightingProperties_2623000413(conn: NetworkConnection, globalSunBrightness: number, globalSkyBrightness: number, globalSkySaturation: number, globalSunColor: Color, globalAmbientLight: Color, globalAmbientBrightness: number, globalAmbientOcclusion: number, globalRadiosityScale: number, globalRadiosityDirectLightAmp: number, globalFogStart: number, globalFogEnd: number, globalFogColor: Color): void;
    RpcLogic___TargetWriteChunksRpc_517074003(conn: NetworkConnection, positions: CSArray<unknown>, chunks: CSArray<Chunk>): void;
    RpcLogic___TargetWriteVoxelRpc_1359590914(conn: NetworkConnection, pos: unknown, voxel: number): void;
    TargetAddPointLights(conn: NetworkConnection, dtos: CSArray<PointLightDto>): void;
    TargetDirtyLights(conn: NetworkConnection): void;
    TargetFinishedSendingWorldRpc(conn: NetworkConnection): void;
    TargetSetLightingProperties(conn: NetworkConnection, globalSunBrightness: number, globalSkyBrightness: number, globalSkySaturation: number, globalSunColor: Color, globalAmbientLight: Color, globalAmbientBrightness: number, globalAmbientOcclusion: number, globalRadiosityScale: number, globalRadiosityDirectLightAmp: number, globalFogStart: number, globalFogEnd: number, globalFogColor: Color): void;
    TargetWriteChunksRpc(conn: NetworkConnection, positions: CSArray<unknown>, chunks: CSArray<Chunk>): void;
    TargetWriteVoxelRpc(conn: NetworkConnection, pos: unknown, voxel: number): void;
}
    
interface PointLightDto {
    color: Color;
    position: Vector3;
    rotation: Quaternion;
    intensity: number;
    range: number;
    castShadows: boolean;
    highQualityLight: boolean;


}
    
interface Chunk {
    readWriteVoxel: CSArray<number>;
    materialPropertiesDirty: boolean;
    world: VoxelWorld;
    bottomLeftInt: unknown;
    bounds: Bounds;
    probes: CSArray<RadiosityProbe>;
    probeCount: number;
    numUpdates: number;
    updatingRadiosity: boolean;
    bakedLightingDirty: boolean;
    lightingConverged: number;
    previousEnergy: number;
    currentCamera: Camera;
    chunkKey: unknown;
    colliders: CSArray<BoxCollider>;
    meshPersistantData: PersistantData;

    constructor(srcPosition: unknown): Chunk;

    AddLight(id: number, light: LightReference): void;
    Busy(): boolean;
    Clear(): void;
    ForceRemoveAllLightReferences(): void;
    Free(): void;
    GetDetailLightArray(): CSArray<LightReference>;
    GetGameObject(): GameObject;
    GetHighQualityLightArray(): CSArray<LightReference>;
    GetKey(): unknown;
    GetLocalVoxelAt(localPos: unknown): number;
    GetLocalVoxelAt(localX: number, localY: number, localZ: number): number;
    GetPriorityUpdate(): boolean;
    GetTimeOfLastRadiosityUpdate(): string;
    GetVoxelAt(worldPos: unknown): number;
    HasVoxels(): boolean;
    IsGeometryDirty(): boolean;
    MainThreadAddSamplesToProbes(): void;
    MainthreadForceCollisionForVoxel(pos: Vector3): void;
    MainthreadUpdateMesh(world: VoxelWorld): boolean;
    NeedsToRunUpdate(): boolean;
    RemoveLight(id: number): void;
    SetGeometryDirty(dirty: boolean, priority: boolean): void;
    SetWorld(world: VoxelWorld): void;
    UpdateMaterialPropertiesForChunk(): void;
    WriteVoxel(worldPos: unknown, num: number): void;
}
    
interface RadiosityProbe {
    position: Vector3;
    enabled: boolean;
    debugging: boolean;

    constructor(world: VoxelWorld, position: Vector3, chunk: Chunk, sample: RadiosityProbeSample, enabled: boolean): RadiosityProbe;

    AddSamples(): number;
    CalculateDirectColor(): number;
    CalculateIndirectColor(): number;
}
    
interface BoxCollider extends Collider {
    extents: Vector3;
    center: Vector3;
    size: Vector3;

    constructor(): BoxCollider;

}
    
interface PersistantData {
    detailLightArray: CSArray<LightReference>;
    highQualityLightArray: CSArray<LightReference>;

    constructor(): PersistantData;

}
    
interface LightReference {
    position: Vector3;
    radius: number;
    radiusSquare: number;
    lightRef: unknown;
    dirty: boolean;
    chunkKeys: CSArray<unknown>;
    instanceId: number;
    highQualityLight: boolean;
    color: Color;
    shadow: boolean;

    constructor(light: PointLight): LightReference;

    ForceAddAllLightReferencesToChunks(world: VoxelWorld): void;
    RemoveLightReferenceFromWorld(world: VoxelWorld): void;
    Update(): void;
}
    
interface ChunkConstructor {


    TestAABBSphere(aabb: Bounds, sphereCenter: Vector3, sphereRadius: number): boolean;
    WorldPosToLocalPos(globalCoord: Vector3): Vector3;
    WorldPosToLocalPos(globalCoord: unknown): unknown;
    WorldPosToProbeIndex(globalCoord: unknown): number;
    WorldPosToVoxelIndex(globalCoord: unknown): number;
}
declare const Chunk: ChunkConstructor;
    
interface float3 {
    x: number;
    y: number;
    z: number;
    xxxx: float4;
    xxxy: float4;
    xxxz: float4;
    xxyx: float4;
    xxyy: float4;
    xxyz: float4;
    xxzx: float4;
    xxzy: float4;
    xxzz: float4;
    xyxx: float4;
    xyxy: float4;
    xyxz: float4;
    xyyx: float4;
    xyyy: float4;
    xyyz: float4;
    xyzx: float4;
    xyzy: float4;
    xyzz: float4;
    xzxx: float4;
    xzxy: float4;
    xzxz: float4;
    xzyx: float4;
    xzyy: float4;
    xzyz: float4;
    xzzx: float4;
    xzzy: float4;
    xzzz: float4;
    yxxx: float4;
    yxxy: float4;
    yxxz: float4;
    yxyx: float4;
    yxyy: float4;
    yxyz: float4;
    yxzx: float4;
    yxzy: float4;
    yxzz: float4;
    yyxx: float4;
    yyxy: float4;
    yyxz: float4;
    yyyx: float4;
    yyyy: float4;
    yyyz: float4;
    yyzx: float4;
    yyzy: float4;
    yyzz: float4;
    yzxx: float4;
    yzxy: float4;
    yzxz: float4;
    yzyx: float4;
    yzyy: float4;
    yzyz: float4;
    yzzx: float4;
    yzzy: float4;
    yzzz: float4;
    zxxx: float4;
    zxxy: float4;
    zxxz: float4;
    zxyx: float4;
    zxyy: float4;
    zxyz: float4;
    zxzx: float4;
    zxzy: float4;
    zxzz: float4;
    zyxx: float4;
    zyxy: float4;
    zyxz: float4;
    zyyx: float4;
    zyyy: float4;
    zyyz: float4;
    zyzx: float4;
    zyzy: float4;
    zyzz: float4;
    zzxx: float4;
    zzxy: float4;
    zzxz: float4;
    zzyx: float4;
    zzyy: float4;
    zzyz: float4;
    zzzx: float4;
    zzzy: float4;
    zzzz: float4;
    xxx: float3;
    xxy: float3;
    xxz: float3;
    xyx: float3;
    xyy: float3;
    xyz: float3;
    xzx: float3;
    xzy: float3;
    xzz: float3;
    yxx: float3;
    yxy: float3;
    yxz: float3;
    yyx: float3;
    yyy: float3;
    yyz: float3;
    yzx: float3;
    yzy: float3;
    yzz: float3;
    zxx: float3;
    zxy: float3;
    zxz: float3;
    zyx: float3;
    zyy: float3;
    zyz: float3;
    zzx: float3;
    zzy: float3;
    zzz: float3;
    xx: float2;
    xy: float2;
    xz: float2;
    yx: float2;
    yy: float2;
    yz: float2;
    zx: float2;
    zy: float2;
    zz: float2;
    Item: number;

    constructor(x: number, y: number, z: number): float3;
    constructor(x: number, yz: float2): float3;
    constructor(xy: float2, z: number): float3;
    constructor(xyz: float3): float3;
    constructor(v: number): float3;
    constructor(v: boolean): float3;
    constructor(v: bool3): float3;
    constructor(v: number): float3;
    constructor(v: int3): float3;
    constructor(v: number): float3;
    constructor(v: uint3): float3;
    constructor(v: half): float3;
    constructor(v: half3): float3;
    constructor(v: number): float3;
    constructor(v: double3): float3;

    Equals(rhs: float3): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface float4 {
    x: number;
    y: number;
    z: number;
    w: number;
    xxxx: float4;
    xxxy: float4;
    xxxz: float4;
    xxxw: float4;
    xxyx: float4;
    xxyy: float4;
    xxyz: float4;
    xxyw: float4;
    xxzx: float4;
    xxzy: float4;
    xxzz: float4;
    xxzw: float4;
    xxwx: float4;
    xxwy: float4;
    xxwz: float4;
    xxww: float4;
    xyxx: float4;
    xyxy: float4;
    xyxz: float4;
    xyxw: float4;
    xyyx: float4;
    xyyy: float4;
    xyyz: float4;
    xyyw: float4;
    xyzx: float4;
    xyzy: float4;
    xyzz: float4;
    xyzw: float4;
    xywx: float4;
    xywy: float4;
    xywz: float4;
    xyww: float4;
    xzxx: float4;
    xzxy: float4;
    xzxz: float4;
    xzxw: float4;
    xzyx: float4;
    xzyy: float4;
    xzyz: float4;
    xzyw: float4;
    xzzx: float4;
    xzzy: float4;
    xzzz: float4;
    xzzw: float4;
    xzwx: float4;
    xzwy: float4;
    xzwz: float4;
    xzww: float4;
    xwxx: float4;
    xwxy: float4;
    xwxz: float4;
    xwxw: float4;
    xwyx: float4;
    xwyy: float4;
    xwyz: float4;
    xwyw: float4;
    xwzx: float4;
    xwzy: float4;
    xwzz: float4;
    xwzw: float4;
    xwwx: float4;
    xwwy: float4;
    xwwz: float4;
    xwww: float4;
    yxxx: float4;
    yxxy: float4;
    yxxz: float4;
    yxxw: float4;
    yxyx: float4;
    yxyy: float4;
    yxyz: float4;
    yxyw: float4;
    yxzx: float4;
    yxzy: float4;
    yxzz: float4;
    yxzw: float4;
    yxwx: float4;
    yxwy: float4;
    yxwz: float4;
    yxww: float4;
    yyxx: float4;
    yyxy: float4;
    yyxz: float4;
    yyxw: float4;
    yyyx: float4;
    yyyy: float4;
    yyyz: float4;
    yyyw: float4;
    yyzx: float4;
    yyzy: float4;
    yyzz: float4;
    yyzw: float4;
    yywx: float4;
    yywy: float4;
    yywz: float4;
    yyww: float4;
    yzxx: float4;
    yzxy: float4;
    yzxz: float4;
    yzxw: float4;
    yzyx: float4;
    yzyy: float4;
    yzyz: float4;
    yzyw: float4;
    yzzx: float4;
    yzzy: float4;
    yzzz: float4;
    yzzw: float4;
    yzwx: float4;
    yzwy: float4;
    yzwz: float4;
    yzww: float4;
    ywxx: float4;
    ywxy: float4;
    ywxz: float4;
    ywxw: float4;
    ywyx: float4;
    ywyy: float4;
    ywyz: float4;
    ywyw: float4;
    ywzx: float4;
    ywzy: float4;
    ywzz: float4;
    ywzw: float4;
    ywwx: float4;
    ywwy: float4;
    ywwz: float4;
    ywww: float4;
    zxxx: float4;
    zxxy: float4;
    zxxz: float4;
    zxxw: float4;
    zxyx: float4;
    zxyy: float4;
    zxyz: float4;
    zxyw: float4;
    zxzx: float4;
    zxzy: float4;
    zxzz: float4;
    zxzw: float4;
    zxwx: float4;
    zxwy: float4;
    zxwz: float4;
    zxww: float4;
    zyxx: float4;
    zyxy: float4;
    zyxz: float4;
    zyxw: float4;
    zyyx: float4;
    zyyy: float4;
    zyyz: float4;
    zyyw: float4;
    zyzx: float4;
    zyzy: float4;
    zyzz: float4;
    zyzw: float4;
    zywx: float4;
    zywy: float4;
    zywz: float4;
    zyww: float4;
    zzxx: float4;
    zzxy: float4;
    zzxz: float4;
    zzxw: float4;
    zzyx: float4;
    zzyy: float4;
    zzyz: float4;
    zzyw: float4;
    zzzx: float4;
    zzzy: float4;
    zzzz: float4;
    zzzw: float4;
    zzwx: float4;
    zzwy: float4;
    zzwz: float4;
    zzww: float4;
    zwxx: float4;
    zwxy: float4;
    zwxz: float4;
    zwxw: float4;
    zwyx: float4;
    zwyy: float4;
    zwyz: float4;
    zwyw: float4;
    zwzx: float4;
    zwzy: float4;
    zwzz: float4;
    zwzw: float4;
    zwwx: float4;
    zwwy: float4;
    zwwz: float4;
    zwww: float4;
    wxxx: float4;
    wxxy: float4;
    wxxz: float4;
    wxxw: float4;
    wxyx: float4;
    wxyy: float4;
    wxyz: float4;
    wxyw: float4;
    wxzx: float4;
    wxzy: float4;
    wxzz: float4;
    wxzw: float4;
    wxwx: float4;
    wxwy: float4;
    wxwz: float4;
    wxww: float4;
    wyxx: float4;
    wyxy: float4;
    wyxz: float4;
    wyxw: float4;
    wyyx: float4;
    wyyy: float4;
    wyyz: float4;
    wyyw: float4;
    wyzx: float4;
    wyzy: float4;
    wyzz: float4;
    wyzw: float4;
    wywx: float4;
    wywy: float4;
    wywz: float4;
    wyww: float4;
    wzxx: float4;
    wzxy: float4;
    wzxz: float4;
    wzxw: float4;
    wzyx: float4;
    wzyy: float4;
    wzyz: float4;
    wzyw: float4;
    wzzx: float4;
    wzzy: float4;
    wzzz: float4;
    wzzw: float4;
    wzwx: float4;
    wzwy: float4;
    wzwz: float4;
    wzww: float4;
    wwxx: float4;
    wwxy: float4;
    wwxz: float4;
    wwxw: float4;
    wwyx: float4;
    wwyy: float4;
    wwyz: float4;
    wwyw: float4;
    wwzx: float4;
    wwzy: float4;
    wwzz: float4;
    wwzw: float4;
    wwwx: float4;
    wwwy: float4;
    wwwz: float4;
    wwww: float4;
    xxx: float3;
    xxy: float3;
    xxz: float3;
    xxw: float3;
    xyx: float3;
    xyy: float3;
    xyz: float3;
    xyw: float3;
    xzx: float3;
    xzy: float3;
    xzz: float3;
    xzw: float3;
    xwx: float3;
    xwy: float3;
    xwz: float3;
    xww: float3;
    yxx: float3;
    yxy: float3;
    yxz: float3;
    yxw: float3;
    yyx: float3;
    yyy: float3;
    yyz: float3;
    yyw: float3;
    yzx: float3;
    yzy: float3;
    yzz: float3;
    yzw: float3;
    ywx: float3;
    ywy: float3;
    ywz: float3;
    yww: float3;
    zxx: float3;
    zxy: float3;
    zxz: float3;
    zxw: float3;
    zyx: float3;
    zyy: float3;
    zyz: float3;
    zyw: float3;
    zzx: float3;
    zzy: float3;
    zzz: float3;
    zzw: float3;
    zwx: float3;
    zwy: float3;
    zwz: float3;
    zww: float3;
    wxx: float3;
    wxy: float3;
    wxz: float3;
    wxw: float3;
    wyx: float3;
    wyy: float3;
    wyz: float3;
    wyw: float3;
    wzx: float3;
    wzy: float3;
    wzz: float3;
    wzw: float3;
    wwx: float3;
    wwy: float3;
    wwz: float3;
    www: float3;
    xx: float2;
    xy: float2;
    xz: float2;
    xw: float2;
    yx: float2;
    yy: float2;
    yz: float2;
    yw: float2;
    zx: float2;
    zy: float2;
    zz: float2;
    zw: float2;
    wx: float2;
    wy: float2;
    wz: float2;
    ww: float2;
    Item: number;

    constructor(x: number, y: number, z: number, w: number): float4;
    constructor(x: number, y: number, zw: float2): float4;
    constructor(x: number, yz: float2, w: number): float4;
    constructor(x: number, yzw: float3): float4;
    constructor(xy: float2, z: number, w: number): float4;
    constructor(xy: float2, zw: float2): float4;
    constructor(xyz: float3, w: number): float4;
    constructor(xyzw: float4): float4;
    constructor(v: number): float4;
    constructor(v: boolean): float4;
    constructor(v: bool4): float4;
    constructor(v: number): float4;
    constructor(v: int4): float4;
    constructor(v: number): float4;
    constructor(v: uint4): float4;
    constructor(v: half): float4;
    constructor(v: half4): float4;
    constructor(v: number): float4;
    constructor(v: double4): float4;

    Equals(rhs: float4): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface float2 {
    x: number;
    y: number;
    xxxx: float4;
    xxxy: float4;
    xxyx: float4;
    xxyy: float4;
    xyxx: float4;
    xyxy: float4;
    xyyx: float4;
    xyyy: float4;
    yxxx: float4;
    yxxy: float4;
    yxyx: float4;
    yxyy: float4;
    yyxx: float4;
    yyxy: float4;
    yyyx: float4;
    yyyy: float4;
    xxx: float3;
    xxy: float3;
    xyx: float3;
    xyy: float3;
    yxx: float3;
    yxy: float3;
    yyx: float3;
    yyy: float3;
    xx: float2;
    xy: float2;
    yx: float2;
    yy: float2;
    Item: number;

    constructor(x: number, y: number): float2;
    constructor(xy: float2): float2;
    constructor(v: number): float2;
    constructor(v: boolean): float2;
    constructor(v: bool2): float2;
    constructor(v: number): float2;
    constructor(v: int2): float2;
    constructor(v: number): float2;
    constructor(v: uint2): float2;
    constructor(v: half): float2;
    constructor(v: half2): float2;
    constructor(v: number): float2;
    constructor(v: double2): float2;

    Equals(rhs: float2): boolean;
    Equals(o: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface float2Constructor {
    zero: float2;


}
declare const float2: float2Constructor;
    
interface float4Constructor {
    zero: float4;


}
declare const float4: float4Constructor;
    
interface float3Constructor {
    zero: float3;


}
declare const float3: float3Constructor;
    
interface VoxelBlocks {
    atlas: TexturePacker;
    materials: CSDictionary<string, Material>;
    loadedBlocks: CSDictionary<number, BlockDefinition>;
    rootAssetPath: string;
    m_bundlePaths: CSArray<string>;

    constructor(): VoxelBlocks;

    AddSolidMaskToVoxelValue(voxelValue: number): number;
    GetBlock(index: number): BlockDefinition;
    GetBlockDefinitionFromIndex(index: number): BlockDefinition;
    GetBlockDefinitionFromName(name: string): BlockDefinition;
    GetBlockId(name: string): number;
    Load(contentsOfBlockDefines: string, loadTexturesDirectlyFromDisk: boolean): void;
}
    
interface TexturePacker {
    diffuse: RenderTexture;
    normals: RenderTexture;

    constructor(): TexturePacker;

    Dispose(): void;
    GetColor(texture: string): Color;
    GetUVs(texture: string): Rect;
    PackTextures(textures: CSDictionary<string, TextureSet>, desiredPadding: number, width: number, height: number, numMips: number, normalizedSize: number): void;
}
    
interface TextureSet {
    diffuse: Texture2D;
    normals: Texture2D;
    roughTexture: Texture2D;
    metalTexture: Texture2D;
    emissiveTexture: Texture2D;
    roughness: number;
    metallic: number;
    normalScale: number;
    emissive: number;
    brightness: number;

    constructor(diffuse: Texture2D, normals: Texture2D, roughTex: Texture2D, metalTex: Texture2D, emissiveTex: Texture2D, roughness: number, metallic: number, normalScale: number, emissive: number, brightness: number): TextureSet;

}
    
interface TexturePackerConstructor {


    CustomBlit(renderTarget: RenderTexture, sourceTexture: Texture, material: Material, destX: number, destY: number, destWidth: number, destHeight: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number): void;
    DoPadding(target: RenderTexture, source: Texture2D, rect: Rect, pad: number, flipMaterial: Material): void;
}
declare const TexturePacker: TexturePackerConstructor;
    
interface BlockDefinition {
    prefab: boolean;
    metallic: number;
    roughness: number;
    normalScale: number;
    emissive: number;
    brightness: number;
    solid: boolean;
    randomRotation: boolean;
    mesh: MeshCopy;
    meshLod: MeshCopy;
    usesTiles: boolean;
    meshTiles: CSDictionary<number, MeshCopy>;
    meshTileProcessingOrder: CSArray<number>;
    usesContexts: boolean;
    meshContexts: CSDictionary<number, MeshCopy>;
    detail: boolean;
    meshTexturePath: string;
    topTexturePath: string;
    sideTexturePath: string;
    bottomTexturePath: string;
    editorTexture: Texture2D;
    topUvs: Rect;
    bottomUvs: Rect;
    sideUvs: Rect;
    doOcclusion: boolean;
    materials: CSArray<string>;
    meshMaterialName: string;
    averageColor: CSArray<Color>;
    minecraftConversions: CSArray<string>;
    name: string;
    topTexture: string;
    topMaterial: string;
    material: string;
    bottomTexture: string;
    sideTexture: string;
    meshTexture: string;
    meshPath: string;
    meshPathLod: string;
    index: number;

    constructor(): BlockDefinition;

    GetUvsForFace(i: number): Rect;
}
    
interface MeshCopy {
    quaternions: CSArray<unknown>;
    rotation: CSDictionary<number, PrecalculatedRotation>;
    uvs: CSArray<Vector2>;
    triangles: CSArray<number>;
    colors: CSArray<Color>;
    srcVertices: CSArray<Vector3>;
    srcNormals: CSArray<Vector3>;
    meshMaterial: Material;
    meshMaterialName: string;

    constructor(mesh: Mesh): MeshCopy;
    constructor(assetPath: string, showError: boolean): MeshCopy;

    AdjustUVs(uvs: Rect): void;
}
    
interface PrecalculatedRotation {
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;

    constructor(vertices: CSArray<Vector3>, normals: CSArray<Vector3>, rot: Rotations, quat: Quaternion): PrecalculatedRotation;

}
    
interface VoxelBlocksConstructor {
    meshTileOffsets: CSDictionary<number, Vector3>;
    meshTileSizes: CSDictionary<number, unknown>;
    TileSizeNames: CSArray<string>;
    ContextBlockNames: CSArray<string>;


}
declare const VoxelBlocks: VoxelBlocksConstructor;
    
interface RadiosityProbeSample {
    position: Vector3;
    color: Color;

    constructor(position: Vector3, color: Color): RadiosityProbeSample;

}
    
interface VoxelRaycastResult {
    Hit: boolean;
    Distance: number;
    HitPosition: Vector3;
    HitNormal: Vector3;


}
    
interface VoxelWorldConstructor {
    runThreaded: boolean;
    doVisuals: boolean;
    showDebugSpheres: boolean;
    showDebugBounds: boolean;
    chunkSize: number;
    radiositySize: number;
    lightingConvergedCount: number;
    numSoftShadowSamples: number;
    softShadowRadius: number;
    radiosityRunawayClamp: number;
    probeMaxRange: number;
    maxSamplesPerFrame: number;
    maxRadiositySamples: number;
    skyCountsAsLightForRadiosity: boolean;


    Abs(input: Vector3): Vector3;
    DeleteChildGameObjects(parent: GameObject): void;
    Floor(input: Vector3): Vector3;
    FloorInt(input: Vector3): unknown;
    GenerateRaySamples(normal: Vector3, sampleCount: number): CSArray<Vector3>;
    HashCoordinates(x: number, y: number, z: number): number;
    Sign(input: Vector3): Vector3;
    VoxelDataToBlockId(block: number): number;
    VoxelDataToBlockId(block: number): number;
    VoxelIsSolid(voxel: number): boolean;
}
declare const VoxelWorld: VoxelWorldConstructor;
    
interface DebugUtil extends Debug {

    constructor(): DebugUtil;

}
    
interface DebugUtilConstructor {


    DrawArc(startAngle: number, endAngle: number, position: Vector3, orientation: Quaternion, radius: number, color: Color, drawChord: boolean, drawSector: boolean, arcSegments: number, durationSec: number): void;
    DrawBox(position: Vector3, orientation: Quaternion, halfSize: Vector3, color: Color, durationSec: number): void;
    DrawCircle(position: Vector3, rotation: Quaternion, radius: number, segments: number, color: Color, durationSec: number): void;
    DrawQuad(pointA: Vector3, pointB: Vector3, pointC: Vector3, pointD: Vector3, color: Color, durationSec: number): void;
    DrawRect(origin: Vector3, orientation: Quaternion, extent: Vector2, color: Color, durationSec: number): void;
    DrawSingleLine(startPosition: Vector3, endPosition: Vector3, color: Color, durationSec: number): void;
    DrawSphere(position: Vector3, orientation: Quaternion, radius: number, color: Color, segments: number, durationSec: number): void;
}
declare const DebugUtil: DebugUtilConstructor;
    
interface CollisionWatcher extends MonoBehaviour {

    constructor(): CollisionWatcher;

}
    
interface TriggerWatcher extends MonoBehaviour {

    constructor(): TriggerWatcher;

}
    
interface PhysicsExt {

    constructor(): PhysicsExt;

}
    
interface SphereCastReturnData {
    HitCount: number;
    RaycastHits: CSArray<RaycastHit>;

    constructor(hitCount: number, raycastHits: CSArray<RaycastHit>): SphereCastReturnData;

}
    
interface PhysicsExtConstructor {


    EasySphereCast(start: Vector3, direction: Vector3, radius: number, distance: number, layerMask: number): SphereCastReturnData;
}
declare const PhysicsExt: PhysicsExtConstructor;
    
interface ServerConsole extends MonoBehaviour {
    RemoteLogging: boolean;

    constructor(): ServerConsole;

}
    
interface Application {

    constructor(): Application;

}
    
interface LogCallback {

    constructor(object: unknown, method: unknown): LogCallback;

    BeginInvoke(condition: string, stackTrace: string, type: LogType, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(condition: string, stackTrace: string, type: LogType): void;
}
    
interface AdvertisingIdentifierCallback {

    constructor(object: unknown, method: unknown): AdvertisingIdentifierCallback;

    BeginInvoke(advertisingId: string, trackingEnabled: boolean, errorMsg: string, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(advertisingId: string, trackingEnabled: boolean, errorMsg: string): void;
}
    
interface ApplicationConstructor {
    isLoadingLevel: boolean;
    streamedBytes: number;
    webSecurityEnabled: boolean;
    isPlaying: boolean;
    isFocused: boolean;
    buildGUID: string;
    runInBackground: boolean;
    isBatchMode: boolean;
    dataPath: string;
    streamingAssetsPath: string;
    persistentDataPath: string;
    temporaryCachePath: string;
    absoluteURL: string;
    unityVersion: string;
    version: string;
    installerName: string;
    identifier: string;
    installMode: ApplicationInstallMode;
    sandboxType: ApplicationSandboxType;
    productName: string;
    companyName: string;
    cloudProjectId: string;
    targetFrameRate: number;
    stackTraceLogType: StackTraceLogType;
    consoleLogPath: string;
    backgroundLoadingPriority: ThreadPriority;
    genuine: boolean;
    genuineCheckAvailable: boolean;
    isShowingSplashScreen: boolean;
    platform: RuntimePlatform;
    isMobilePlatform: boolean;
    isConsolePlatform: boolean;
    systemLanguage: SystemLanguage;
    internetReachability: NetworkReachability;
    isPlayer: boolean;
    levelCount: number;
    loadedLevel: number;
    loadedLevelName: string;
    isEditor: boolean;


    CancelQuit(): void;
    CanStreamedLevelBeLoaded(levelIndex: number): boolean;
    CanStreamedLevelBeLoaded(levelName: string): boolean;
    CaptureScreenshot(filename: string, superSize: number): void;
    CaptureScreenshot(filename: string): void;
    DontDestroyOnLoad(o: Object): void;
    ExternalCall(functionName: string, args: CSArray<unknown>): void;
    ExternalEval(script: string): void;
    ForceCrash(mode: number): void;
    GetBuildTags(): CSArray<string>;
    GetStackTraceLogType(logType: LogType): StackTraceLogType;
    GetStreamProgressForLevel(levelIndex: number): number;
    GetStreamProgressForLevel(levelName: string): number;
    HasProLicense(): boolean;
    HasUserAuthorization(mode: UserAuthorization): boolean;
    IsPlaying(obj: Object): boolean;
    LoadLevel(index: number): void;
    LoadLevel(name: string): void;
    LoadLevelAdditive(index: number): void;
    LoadLevelAdditive(name: string): void;
    LoadLevelAdditiveAsync(index: number): AsyncOperation;
    LoadLevelAdditiveAsync(levelName: string): AsyncOperation;
    LoadLevelAsync(index: number): AsyncOperation;
    LoadLevelAsync(levelName: string): AsyncOperation;
    OpenURL(url: string): void;
    Quit(exitCode: number): void;
    Quit(): void;
    RegisterLogCallback(handler: LogCallback): void;
    RegisterLogCallbackThreaded(handler: LogCallback): void;
    RequestAdvertisingIdentifierAsync(delegateMethod: AdvertisingIdentifierCallback): boolean;
    RequestUserAuthorization(mode: UserAuthorization): AsyncOperation;
    SetBuildTags(buildTags: CSArray<string>): void;
    SetStackTraceLogType(logType: LogType, stackTraceType: StackTraceLogType): void;
    Unload(): void;
    UnloadLevel(index: number): boolean;
    UnloadLevel(scenePath: string): boolean;
}
declare const Application: ApplicationConstructor;
    
interface ClientNetworkConnector extends MonoBehaviour {

    constructor(): ClientNetworkConnector;

    Disconnect(): void;
}
    
interface ParticleSystemRenderer extends Renderer {
    alignment: ParticleSystemRenderSpace;
    renderMode: ParticleSystemRenderMode;
    meshDistribution: ParticleSystemMeshDistribution;
    sortMode: ParticleSystemSortMode;
    lengthScale: number;
    velocityScale: number;
    cameraVelocityScale: number;
    normalDirection: number;
    shadowBias: number;
    sortingFudge: number;
    minParticleSize: number;
    maxParticleSize: number;
    pivot: Vector3;
    flip: Vector3;
    maskInteraction: SpriteMaskInteraction;
    trailMaterial: Material;
    enableGPUInstancing: boolean;
    allowRoll: boolean;
    freeformStretching: boolean;
    rotateWithStretchDirection: boolean;
    mesh: Mesh;
    meshCount: number;
    activeVertexStreamsCount: number;
    supportsMeshInstancing: boolean;

    constructor(): ParticleSystemRenderer;

    AreVertexStreamsEnabled(streams: ParticleSystemVertexStreams): boolean;
    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    BakeTrailsMesh(mesh: Mesh, useTransform: boolean): void;
    BakeTrailsMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    DisableVertexStreams(streams: ParticleSystemVertexStreams): void;
    EnableVertexStreams(streams: ParticleSystemVertexStreams): void;
    GetActiveVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    GetEnabledVertexStreams(streams: ParticleSystemVertexStreams): ParticleSystemVertexStreams;
    GetMeshes(meshes: CSArray<Mesh>): number;
    GetMeshWeightings(weightings: CSArray<number>): number;
    SetActiveVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    SetMeshes(meshes: CSArray<Mesh>, size: number): void;
    SetMeshes(meshes: CSArray<Mesh>): void;
    SetMeshWeightings(weightings: CSArray<number>, size: number): void;
    SetMeshWeightings(weightings: CSArray<number>): void;
}
    
interface Profiler {


}
    
interface ProfilerCategory {
    Name: string;
    Color: Color32;

    constructor(categoryName: string): ProfilerCategory;
    constructor(categoryName: string, color: ProfilerCategoryColor): ProfilerCategory;

    ToString(): string;
}
    
interface ProfilerCategoryConstructor {
    Render: ProfilerCategory;
    Scripts: ProfilerCategory;
    Gui: ProfilerCategory;
    Physics: ProfilerCategory;
    Animation: ProfilerCategory;
    Ai: ProfilerCategory;
    Audio: ProfilerCategory;
    Video: ProfilerCategory;
    Particles: ProfilerCategory;
    Lighting: ProfilerCategory;
    Network: ProfilerCategory;
    Loading: ProfilerCategory;
    Vr: ProfilerCategory;
    Input: ProfilerCategory;
    Memory: ProfilerCategory;
    VirtualTexturing: ProfilerCategory;
    FileIO: ProfilerCategory;
    Internal: ProfilerCategory;


}
declare const ProfilerCategory: ProfilerCategoryConstructor;
    
interface ProfilerConstructor {
    supported: boolean;
    logFile: string;
    enableBinaryLog: boolean;
    maxUsedMemory: number;
    enabled: boolean;
    enableAllocationCallstacks: boolean;
    areaCount: number;
    maxNumberOfSamplesPerFrame: number;
    usedHeapSize: number;
    usedHeapSizeLong: number;


    AddFramesFromFile(file: string): void;
    BeginSample(name: string): void;
    BeginSample(name: string, targetObject: Object): void;
    BeginThreadProfiling(threadGroupName: string, threadName: string): void;
    EmitFrameMetaData(id: unknown, tag: number, data: unknown): void;
    EmitFrameMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitFrameMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitSessionMetaData(id: unknown, tag: number, data: unknown): void;
    EmitSessionMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitSessionMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EndSample(): void;
    EndThreadProfiling(): void;
    GetAllCategories(categories: CSArray<ProfilerCategory>): void;
    GetAllCategories(categories: CSArray<ProfilerCategory>): void;
    GetAllocatedMemoryForGraphicsDriver(): number;
    GetAreaEnabled(area: ProfilerArea): boolean;
    GetCategoriesCount(): number;
    GetMonoHeapSize(): number;
    GetMonoHeapSizeLong(): number;
    GetMonoUsedSize(): number;
    GetMonoUsedSizeLong(): number;
    GetRuntimeMemorySize(o: Object): number;
    GetRuntimeMemorySizeLong(o: Object): number;
    GetTempAllocatorSize(): number;
    GetTotalAllocatedMemory(): number;
    GetTotalAllocatedMemoryLong(): number;
    GetTotalFragmentationInfo(stats: CSArray<number>): number;
    GetTotalReservedMemory(): number;
    GetTotalReservedMemoryLong(): number;
    GetTotalUnusedReservedMemory(): number;
    GetTotalUnusedReservedMemoryLong(): number;
    IsCategoryEnabled(category: ProfilerCategory): boolean;
    SetAreaEnabled(area: ProfilerArea, enabled: boolean): void;
    SetCategoryEnabled(category: ProfilerCategory, enabled: boolean): void;
    SetTempAllocatorRequestedSize(size: number): boolean;
}
declare const Profiler: ProfilerConstructor;
    
interface IBeginDragHandler extends IEventSystemHandler {


    OnBeginDrag(eventData: PointerEventData): void;
}
    
interface IDragHandler extends IEventSystemHandler {


    OnDrag(eventData: PointerEventData): void;
}
    
interface IEndDragHandler extends IEventSystemHandler {


    OnEndDrag(eventData: PointerEventData): void;
}
    
interface IScrollHandler extends IEventSystemHandler {


    OnScroll(eventData: PointerEventData): void;
}
    
interface IUpdateSelectedHandler extends IEventSystemHandler {


    OnUpdateSelected(eventData: BaseEventData): void;
}
    
interface TMP_InputField extends Selectable, IBeginDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, IUpdateSelectedHandler, ILayoutElement, ISubmitHandler, IPointerClickHandler {
    shouldHideMobileInput: boolean;
    shouldHideSoftKeyboard: boolean;
    text: string;
    isFocused: boolean;
    caretBlinkRate: number;
    caretWidth: number;
    textViewport: RectTransform;
    textComponent: TMP_Text;
    placeholder: Graphic;
    verticalScrollbar: Scrollbar;
    scrollSensitivity: number;
    caretColor: Color;
    customCaretColor: boolean;
    selectionColor: Color;
    onEndEdit: SubmitEvent;
    onSubmit: SubmitEvent;
    onSelect: SelectionEvent;
    onDeselect: SelectionEvent;
    onTextSelection: TextSelectionEvent;
    onEndTextSelection: TextSelectionEvent;
    onValueChanged: OnChangeEvent;
    onTouchScreenKeyboardStatusChanged: TouchScreenKeyboardEvent;
    onValidateInput: OnValidateInput;
    characterLimit: number;
    pointSize: number;
    fontAsset: TMP_FontAsset;
    onFocusSelectAll: boolean;
    resetOnDeActivation: boolean;
    restoreOriginalTextOnEscape: boolean;
    isRichTextEditingAllowed: boolean;
    contentType: ContentType;
    lineType: LineType;
    lineLimit: number;
    inputType: InputType;
    keyboardType: TouchScreenKeyboardType;
    characterValidation: CharacterValidation;
    inputValidator: TMP_InputValidator;
    readOnly: boolean;
    richText: boolean;
    multiLine: boolean;
    asteriskChar: string;
    wasCanceled: boolean;
    caretPosition: number;
    selectionAnchorPosition: number;
    selectionFocusPosition: number;
    stringPosition: number;
    selectionStringAnchorPosition: number;
    selectionStringFocusPosition: number;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    ActivateInputField(): void;
    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    DeactivateInputField(clearSelection: boolean): void;
    ForceLabelUpdate(): void;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    MoveTextEnd(shift: boolean): void;
    MoveTextStart(shift: boolean): void;
    MoveToEndOfLine(shift: boolean, ctrl: boolean): void;
    MoveToStartOfLine(shift: boolean, ctrl: boolean): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnControlClick(): void;
    OnDeselect(eventData: BaseEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnScroll(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    OnUpdateSelected(eventData: BaseEventData): void;
    ProcessEvent(e: Event): void;
    Rebuild(update: CanvasUpdate): void;
    ReleaseSelection(): void;
    SetGlobalFontAsset(fontAsset: TMP_FontAsset): void;
    SetGlobalPointSize(pointSize: number): void;
    SetTextWithoutNotify(input: string): void;
}
    
interface IInitializePotentialDragHandler extends IEventSystemHandler {


    OnInitializePotentialDrag(eventData: PointerEventData): void;
}
    
interface Scrollbar extends Selectable, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, ICanvasElement {
    handleRect: RectTransform;
    direction: Direction;
    value: number;
    size: number;
    numberOfSteps: number;
    onValueChanged: ScrollEvent;


    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetDirection(direction: Direction, includeRectLayouts: boolean): void;
    SetValueWithoutNotify(input: number): void;
}
    
interface ScrollEvent {

    constructor(): ScrollEvent;

}
    
interface SubmitEvent {

    constructor(): SubmitEvent;

}
    
interface SelectionEvent {

    constructor(): SelectionEvent;

}
    
interface TextSelectionEvent {

    constructor(): TextSelectionEvent;

}
    
interface OnChangeEvent {

    constructor(): OnChangeEvent;

}
    
interface TouchScreenKeyboardEvent {

    constructor(): TouchScreenKeyboardEvent;

}
    
interface OnValidateInput {

    constructor(object: unknown, method: unknown): OnValidateInput;

    BeginInvoke(text: string, charIndex: number, addedChar: string, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): string;
    Invoke(text: string, charIndex: number, addedChar: string): string;
}
    
interface TMP_InputValidator extends ScriptableObject {


    Validate(text: CSArray<string>, pos: unknown, ch: string): string;
}
    
interface Event {
    mouseRay: Ray;
    shift: boolean;
    control: boolean;
    alt: boolean;
    command: boolean;
    capsLock: boolean;
    numeric: boolean;
    functionKey: boolean;
    isKey: boolean;
    isMouse: boolean;
    isScrollWheel: boolean;
    rawType: EventType;
    mousePosition: Vector2;
    delta: Vector2;
    pointerType: PointerType;
    button: number;
    modifiers: EventModifiers;
    pressure: number;
    clickCount: number;
    character: string;
    keyCode: KeyCode;
    displayIndex: number;
    type: EventType;
    commandName: string;

    constructor(): Event;
    constructor(displayIndex: number): Event;
    constructor(other: Event): Event;

    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GetTypeForControl(controlID: number): EventType;
    ToString(): string;
    Use(): void;
}
    
interface EventConstructor {
    current: Event;


    GetEventCount(): number;
    KeyboardEvent(key: string): Event;
    PopEvent(outEvent: Event): boolean;
}
declare const Event: EventConstructor;
    
interface Rigidbody2D extends Component {
    position: Vector2;
    rotation: number;
    velocity: Vector2;
    angularVelocity: number;
    useAutoMass: boolean;
    mass: number;
    sharedMaterial: PhysicsMaterial2D;
    centerOfMass: Vector2;
    worldCenterOfMass: Vector2;
    inertia: number;
    drag: number;
    angularDrag: number;
    gravityScale: number;
    bodyType: RigidbodyType2D;
    useFullKinematicContacts: boolean;
    isKinematic: boolean;
    fixedAngle: boolean;
    freezeRotation: boolean;
    constraints: RigidbodyConstraints2D;
    simulated: boolean;
    interpolation: RigidbodyInterpolation2D;
    sleepMode: RigidbodySleepMode2D;
    collisionDetectionMode: CollisionDetectionMode2D;
    attachedColliderCount: number;

    constructor(): Rigidbody2D;

    AddForce(force: Vector2): void;
    AddForce(force: Vector2, mode: ForceMode2D): void;
    AddForceAtPosition(force: Vector2, position: Vector2): void;
    AddForceAtPosition(force: Vector2, position: Vector2, mode: ForceMode2D): void;
    AddRelativeForce(relativeForce: Vector2): void;
    AddRelativeForce(relativeForce: Vector2, mode: ForceMode2D): void;
    AddTorque(torque: number): void;
    AddTorque(torque: number, mode: ForceMode2D): void;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    ClosestPoint(position: Vector2): Vector2;
    Distance(collider: Collider2D): ColliderDistance2D;
    GetAttachedColliders(results: CSArray<Collider2D>): number;
    GetAttachedColliders(results: CSArray<Collider2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetPoint(point: Vector2): Vector2;
    GetPointVelocity(point: Vector2): Vector2;
    GetRelativePoint(relativePoint: Vector2): Vector2;
    GetRelativePointVelocity(relativePoint: Vector2): Vector2;
    GetRelativeVector(relativeVector: Vector2): Vector2;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    GetVector(vector: Vector2): Vector2;
    IsAwake(): boolean;
    IsSleeping(): boolean;
    IsTouching(collider: Collider2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(): boolean;
    IsTouchingLayers(layerMask: number): boolean;
    MovePosition(position: Vector2): void;
    MoveRotation(angle: number): void;
    MoveRotation(rotation: Quaternion): void;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): boolean;
    SetRotation(angle: number): void;
    SetRotation(rotation: Quaternion): void;
    Sleep(): void;
    WakeUp(): void;
}
    
interface PhysicsMaterial2D extends Object {
    bounciness: number;
    friction: number;

    constructor(): PhysicsMaterial2D;
    constructor(name: string): PhysicsMaterial2D;

}
    
interface RaycastHit2D {
    centroid: Vector2;
    point: Vector2;
    normal: Vector2;
    distance: number;
    fraction: number;
    collider: Collider2D;
    rigidbody: Rigidbody2D;
    transform: Transform;


    CompareTo(other: RaycastHit2D): number;
}
    
interface Collider2D extends Behaviour {
    density: number;
    isTrigger: boolean;
    usedByEffector: boolean;
    usedByComposite: boolean;
    composite: CompositeCollider2D;
    offset: Vector2;
    attachedRigidbody: Rigidbody2D;
    shapeCount: number;
    bounds: Bounds;
    errorState: ColliderErrorState2D;
    sharedMaterial: PhysicsMaterial2D;
    friction: number;
    bounciness: number;

    constructor(): Collider2D;

    Cast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    ClosestPoint(position: Vector2): Vector2;
    CreateMesh(useBodyPosition: boolean, useBodyRotation: boolean): Mesh;
    Distance(collider: Collider2D): ColliderDistance2D;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetShapeHash(): number;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D, shapeIndex: number, shapeCount: number): number;
    IsTouching(collider: Collider2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(): boolean;
    IsTouchingLayers(layerMask: number): boolean;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): boolean;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
}
    
interface CompositeCollider2D extends Collider2D {
    geometryType: GeometryType;
    generationType: GenerationType;
    vertexDistance: number;
    edgeRadius: number;
    offsetDistance: number;
    pathCount: number;
    pointCount: number;

    constructor(): CompositeCollider2D;

    GenerateGeometry(): void;
    GetPath(index: number, points: CSArray<Vector2>): number;
    GetPath(index: number, points: CSArray<Vector2>): number;
    GetPathPointCount(index: number): number;
}
    
interface ContactFilter2D {
    useTriggers: boolean;
    useLayerMask: boolean;
    useDepth: boolean;
    useOutsideDepth: boolean;
    useNormalAngle: boolean;
    useOutsideNormalAngle: boolean;
    layerMask: LayerMask;
    minDepth: number;
    maxDepth: number;
    minNormalAngle: number;
    maxNormalAngle: number;
    isFiltering: boolean;


    ClearDepth(): void;
    ClearLayerMask(): void;
    ClearNormalAngle(): void;
    IsFilteringDepth(obj: GameObject): boolean;
    IsFilteringLayerMask(obj: GameObject): boolean;
    IsFilteringNormalAngle(normal: Vector2): boolean;
    IsFilteringNormalAngle(angle: number): boolean;
    IsFilteringTrigger(collider: Collider2D): boolean;
    NoFilter(): ContactFilter2D;
    SetDepth(minDepth: number, maxDepth: number): void;
    SetLayerMask(layerMask: LayerMask): void;
    SetNormalAngle(minNormalAngle: number, maxNormalAngle: number): void;
}
    
interface ContactFilter2DConstructor {
    NormalAngleUpperLimit: number;


}
declare const ContactFilter2D: ContactFilter2DConstructor;
    
interface ColliderDistance2D {
    pointA: Vector2;
    pointB: Vector2;
    normal: Vector2;
    distance: number;
    isOverlapped: boolean;
    isValid: boolean;


}
    
interface ContactPoint2D {
    point: Vector2;
    normal: Vector2;
    separation: number;
    normalImpulse: number;
    tangentImpulse: number;
    relativeVelocity: Vector2;
    collider: Collider2D;
    otherCollider: Collider2D;
    rigidbody: Rigidbody2D;
    otherRigidbody: Rigidbody2D;
    enabled: boolean;


}
    
interface PhysicsShapeGroup2D {
    shapeCount: number;
    vertexCount: number;
    localToWorldMatrix: Matrix4x4;

    constructor(shapeCapacity: number, vertexCapacity: number): PhysicsShapeGroup2D;

    Add(physicsShapeGroup: PhysicsShapeGroup2D): void;
    AddBox(center: Vector2, size: Vector2, angle: number, edgeRadius: number): number;
    AddCapsule(vertex0: Vector2, vertex1: Vector2, radius: number): number;
    AddCircle(center: Vector2, radius: number): number;
    AddEdges(vertices: CSArray<Vector2>, edgeRadius: number): number;
    AddEdges(vertices: CSArray<Vector2>, useAdjacentStart: boolean, useAdjacentEnd: boolean, adjacentStart: Vector2, adjacentEnd: Vector2, edgeRadius: number): number;
    AddPolygon(vertices: CSArray<Vector2>): number;
    Clear(): void;
    DeleteShape(shapeIndex: number): void;
    GetShape(shapeIndex: number): PhysicsShape2D;
    GetShapeData(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;
    GetShapeData(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;
    GetShapeVertex(shapeIndex: number, vertexIndex: number): Vector2;
    GetShapeVertices(shapeIndex: number, vertices: CSArray<Vector2>): void;
    SetShapeAdjacentVertices(shapeIndex: number, useAdjacentStart: boolean, useAdjacentEnd: boolean, adjacentStart: Vector2, adjacentEnd: Vector2): void;
    SetShapeRadius(shapeIndex: number, radius: number): void;
    SetShapeVertex(shapeIndex: number, vertexIndex: number, vertex: Vector2): void;
}
    
interface PhysicsShape2D {
    shapeType: PhysicsShapeType2D;
    radius: number;
    vertexStartIndex: number;
    vertexCount: number;
    useAdjacentStart: boolean;
    useAdjacentEnd: boolean;
    adjacentStart: Vector2;
    adjacentEnd: Vector2;


}
    
interface Slider extends Selectable, IInitializePotentialDragHandler, IDragHandler, ICanvasElement {
    fillRect: RectTransform;
    handleRect: RectTransform;
    direction: Direction;
    minValue: number;
    maxValue: number;
    wholeNumbers: boolean;
    value: number;
    normalizedValue: number;
    onValueChanged: SliderEvent;


    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetDirection(direction: Direction, includeRectLayouts: boolean): void;
    SetValueWithoutNotify(input: number): void;
}
    
interface SliderEvent {

    constructor(): SliderEvent;

}
    
interface CanvasHitDetector extends MonoBehaviour {

    constructor(): CanvasHitDetector;

    IsPointerOverUI(): boolean;
}
    
interface AudioBehaviour extends Behaviour {

    constructor(): AudioBehaviour;

}
    
interface AudioSource extends AudioBehaviour {
    panLevel: number;
    pan: number;
    volume: number;
    pitch: number;
    time: number;
    timeSamples: number;
    clip: AudioClip;
    outputAudioMixerGroup: AudioMixerGroup;
    gamepadSpeakerOutputType: GamepadSpeakerOutputType;
    isPlaying: boolean;
    isVirtual: boolean;
    loop: boolean;
    ignoreListenerVolume: boolean;
    playOnAwake: boolean;
    ignoreListenerPause: boolean;
    velocityUpdateMode: AudioVelocityUpdateMode;
    panStereo: number;
    spatialBlend: number;
    spatialize: boolean;
    spatializePostEffects: boolean;
    reverbZoneMix: number;
    bypassEffects: boolean;
    bypassListenerEffects: boolean;
    bypassReverbZones: boolean;
    dopplerLevel: number;
    spread: number;
    priority: number;
    mute: boolean;
    minDistance: number;
    maxDistance: number;
    rolloffMode: AudioRolloffMode;
    minVolume: number;
    maxVolume: number;
    rolloffFactor: number;

    constructor(): AudioSource;

    DisableGamepadOutput(): boolean;
    GetAmbisonicDecoderFloat(index: number, value: unknown): boolean;
    GetCustomCurve(type: AudioSourceCurveType): AnimationCurve;
    GetOutputData(numSamples: number, channel: number): CSArray<number>;
    GetOutputData(samples: CSArray<number>, channel: number): void;
    GetSpatializerFloat(index: number, value: unknown): boolean;
    GetSpectrumData(numSamples: number, channel: number, window: FFTWindow): CSArray<number>;
    GetSpectrumData(samples: CSArray<number>, channel: number, window: FFTWindow): void;
    Pause(): void;
    Play(): void;
    Play(delay: number): void;
    PlayDelayed(delay: number): void;
    PlayOneShot(clip: AudioClip): void;
    PlayOneShot(clip: AudioClip, volumeScale: number): void;
    PlayOnGamepad(slot: number): boolean;
    PlayScheduled(time: number): void;
    SetAmbisonicDecoderFloat(index: number, value: number): boolean;
    SetCustomCurve(type: AudioSourceCurveType, curve: AnimationCurve): void;
    SetGamepadSpeakerMixLevel(slot: number, mixLevel: number): boolean;
    SetGamepadSpeakerMixLevelDefault(slot: number): boolean;
    SetGamepadSpeakerRestrictedAudio(slot: number, restricted: boolean): boolean;
    SetScheduledEndTime(time: number): void;
    SetScheduledStartTime(time: number): void;
    SetSpatializerFloat(index: number, value: number): boolean;
    Stop(): void;
    UnPause(): void;
}
    
interface AudioClip extends Object {
    length: number;
    samples: number;
    channels: number;
    frequency: number;
    isReadyToPlay: boolean;
    loadType: AudioClipLoadType;
    preloadAudioData: boolean;
    ambisonic: boolean;
    loadInBackground: boolean;
    loadState: AudioDataLoadState;


    GetData(data: CSArray<number>, offsetSamples: number): boolean;
    LoadAudioData(): boolean;
    SetData(data: CSArray<number>, offsetSamples: number): boolean;
    UnloadAudioData(): boolean;
}
    
interface PCMReaderCallback {

    constructor(object: unknown, method: unknown): PCMReaderCallback;

    BeginInvoke(data: CSArray<number>, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(data: CSArray<number>): void;
}
    
interface PCMSetPositionCallback {

    constructor(object: unknown, method: unknown): PCMSetPositionCallback;

    BeginInvoke(position: number, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(position: number): void;
}
    
interface AudioClipConstructor {


    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean, pcmreadercallback: PCMReaderCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean, pcmreadercallback: PCMReaderCallback, pcmsetpositioncallback: PCMSetPositionCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: PCMReaderCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: PCMReaderCallback, pcmsetpositioncallback: PCMSetPositionCallback): AudioClip;
}
declare const AudioClip: AudioClipConstructor;
    
interface ISubAssetNotDuplicatable {


}
    
interface AudioMixerGroup extends Object, ISubAssetNotDuplicatable {
    audioMixer: AudioMixer;


}
    
interface AudioMixer extends Object {
    outputAudioMixerGroup: AudioMixerGroup;
    updateMode: AudioMixerUpdateMode;


    ClearFloat(name: string): boolean;
    FindMatchingGroups(subPath: string): CSArray<AudioMixerGroup>;
    FindSnapshot(name: string): AudioMixerSnapshot;
    GetFloat(name: string, value: unknown): boolean;
    SetFloat(name: string, value: number): boolean;
    TransitionToSnapshots(snapshots: CSArray<AudioMixerSnapshot>, weights: CSArray<number>, timeToReach: number): void;
}
    
interface AudioMixerSnapshot extends Object, ISubAssetNotDuplicatable {
    audioMixer: AudioMixer;


    TransitionTo(timeToReach: number): void;
}
    
interface AudioSourceConstructor {


    GamepadSpeakerSupportsOutputType(outputType: GamepadSpeakerOutputType): boolean;
    PlayClipAtPoint(clip: AudioClip, position: Vector3): void;
    PlayClipAtPoint(clip: AudioClip, position: Vector3, volume: number): void;
}
declare const AudioSource: AudioSourceConstructor;
    
interface ITween {


    Cancel(): void;
    GetTotalDuration(includeDelay: boolean): number;
}
    
interface Tween<DriverValueType> extends MonoBehaviour, ITween {


    Await(): void;
    Cancel(): void;
    GetTotalDuration(includeDelay: boolean): number;
    OnGetFrom(): DriverValueType;
    OnInitialize(): boolean;
    OnUpdate(easedTime: number): void;
    SetDelay(delay: number, goToFirstFrameImmediately: boolean): Tween<DriverValueType>;
    SetEase(ease: EaseType): Tween<DriverValueType>;
    SetEaseBackIn(): Tween<DriverValueType>;
    SetEaseBackInOut(): Tween<DriverValueType>;
    SetEaseBackOut(): Tween<DriverValueType>;
    SetEaseBounceIn(): Tween<DriverValueType>;
    SetEaseBounceInOut(): Tween<DriverValueType>;
    SetEaseBounceOut(): Tween<DriverValueType>;
    SetEaseCircIn(): Tween<DriverValueType>;
    SetEaseCircInOut(): Tween<DriverValueType>;
    SetEaseCircOut(): Tween<DriverValueType>;
    SetEaseCubicIn(): Tween<DriverValueType>;
    SetEaseCubicInOut(): Tween<DriverValueType>;
    SetEaseCubicOut(): Tween<DriverValueType>;
    SetEaseElasticIn(): Tween<DriverValueType>;
    SetEaseElasticInOut(): Tween<DriverValueType>;
    SetEaseElasticOut(): Tween<DriverValueType>;
    SetEaseExpoIn(): Tween<DriverValueType>;
    SetEaseExpoInOut(): Tween<DriverValueType>;
    SetEaseExpoOut(): Tween<DriverValueType>;
    SetEaseLinear(): Tween<DriverValueType>;
    SetEaseQuadIn(): Tween<DriverValueType>;
    SetEaseQuadInOut(): Tween<DriverValueType>;
    SetEaseQuadOut(): Tween<DriverValueType>;
    SetEaseQuartIn(): Tween<DriverValueType>;
    SetEaseQuartInOut(): Tween<DriverValueType>;
    SetEaseQuartOut(): Tween<DriverValueType>;
    SetEaseQuintIn(): Tween<DriverValueType>;
    SetEaseQuintInOut(): Tween<DriverValueType>;
    SetEaseQuintOut(): Tween<DriverValueType>;
    SetEaseSineIn(): Tween<DriverValueType>;
    SetEaseSineInOut(): Tween<DriverValueType>;
    SetEaseSineOut(): Tween<DriverValueType>;
    SetFrom(valueFrom: DriverValueType): Tween<DriverValueType>;
    SetInfinite(): Tween<DriverValueType>;
    SetLoopCount(loopCount: number): Tween<DriverValueType>;
    SetOnCancel(onCancel: unknown): Tween<DriverValueType>;
    SetOnComplete(onComplete: unknown): Tween<DriverValueType>;
    SetOnStart(onStart: unknown): Tween<DriverValueType>;
    SetOvershooting(overshooting: number): Tween<DriverValueType>;
    SetPaused(isPaused: boolean): Tween<DriverValueType>;
    SetPingPong(): Tween<DriverValueType>;
    SetRandomTime(): Tween<DriverValueType>;
    SetTime(time: number): Tween<DriverValueType>;
    SetUseUnscaledTime(useUnscaledTime: boolean): Tween<DriverValueType>;
    Yield(): unknown;
}
    
interface Bridge {


}
    
interface BridgeConstructor {


    GetAverageFPS(): number;
    GetCurrentFPS(): number;
    GetVolume(): number;
    IsFullScreen(): boolean;
    MakeSprite(texture2D: Texture2D): Sprite;
    MakeVector2(x: number, y: number): Vector2;
    SetFullScreen(value: boolean): void;
    SetParentToSceneRoot(transform: Transform): void;
    SetVolume(volume: number): void;
}
declare const Bridge: BridgeConstructor;
    
interface CanvasGroup extends Behaviour, ICanvasRaycastFilter {
    alpha: number;
    interactable: boolean;
    blocksRaycasts: boolean;
    ignoreParentGroups: boolean;

    constructor(): CanvasGroup;

    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;
}
    
interface AutoShutdownBridge extends MonoBehaviour {

    constructor(): AutoShutdownBridge;

    SetBundlesLoaded(assetBundlesLoaded: boolean): void;
}
    
interface ScreenCapture {


}
    
interface ScreenCaptureConstructor {


    CaptureScreenshot(filename: string): void;
    CaptureScreenshot(filename: string, superSize: number): void;
    CaptureScreenshot(filename: string, stereoCaptureMode: StereoScreenCaptureMode): void;
    CaptureScreenshotAsTexture(): Texture2D;
    CaptureScreenshotAsTexture(superSize: number): Texture2D;
    CaptureScreenshotAsTexture(stereoCaptureMode: StereoScreenCaptureMode): Texture2D;
    CaptureScreenshotIntoRenderTexture(renderTexture: RenderTexture): void;
}
declare const ScreenCapture: ScreenCaptureConstructor;
    
interface CharacterController extends Collider {
    velocity: Vector3;
    isGrounded: boolean;
    collisionFlags: CollisionFlags;
    radius: number;
    height: number;
    center: Vector3;
    slopeLimit: number;
    stepOffset: number;
    skinWidth: number;
    minMoveDistance: number;
    detectCollisions: boolean;
    enableOverlapRecovery: boolean;

    constructor(): CharacterController;

    Move(motion: Vector3): CollisionFlags;
    SimpleMove(speed: Vector3): boolean;
}
    
interface ProjectileTrajectoryRenderer extends MonoBehaviour {
    maxIterations: number;
    maxSegmentCount: number;
    segmentStepModulo: number;

    constructor(): ProjectileTrajectoryRenderer;

    SetDrawingEnabled(enabled: boolean): void;
    UpdateInfo(startingPoint: Vector3, velocity: Vector3, drag: number, gravity: number): void;
}
    
interface ProjectileLauncher extends NetworkBehaviour {

    constructor(): ProjectileLauncher;

    Awake(): void;
    Awake___UserLogic(): void;
    ClientFire(projectilePath: string, itemTypeId: number, position: Vector3, velocity: Vector3, gravity: number, drag: number): EasyProjectile;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
}
    
interface EasyProjectile extends MonoBehaviour {
    gravity: number;
    drag: number;
    itemTypeId: number;

    constructor(): EasyProjectile;

    Initialize(startingVelocity: Vector3, gravity: number, drag: number, passedTime: number, itemTypeId: number): void;
}
    
interface ProjectileValidateEvent {
    shooter: GameObject;
    validated: boolean;
    projectilePath: string;
    position: Vector3;
    velocity: Vector3;
    gravity: number;
    drag: number;
    itemTypeId: number;


}
    
interface TrailRenderer extends Renderer {
    time: number;
    startWidth: number;
    endWidth: number;
    widthMultiplier: number;
    autodestruct: boolean;
    emitting: boolean;
    numCornerVertices: number;
    numCapVertices: number;
    minVertexDistance: number;
    startColor: Color;
    endColor: Color;
    positionCount: number;
    shadowBias: number;
    generateLightingData: boolean;
    textureMode: LineTextureMode;
    alignment: LineAlignment;
    widthCurve: AnimationCurve;
    colorGradient: Gradient;
    numPositions: number;

    constructor(): TrailRenderer;

    AddPosition(position: Vector3): void;
    AddPositions(positions: CSArray<Vector3>): void;
    AddPositions(positions: CSArray<Vector3>): void;
    AddPositions(positions: CSArray<Vector3>): void;
    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    Clear(): void;
    GetPosition(index: number): Vector3;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    SetPosition(index: number, position: Vector3): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
}
    
interface EntityAnimationEventData {
    key: number;

    constructor(): EntityAnimationEventData;

}
    
interface WindowCore {


}
    
interface WindowProxy extends MonoBehaviour {

    constructor(): WindowProxy;

    HasFocus(): boolean;
}
    
interface WindowCoreConstructor {
    Window: WindowProxy;


    SetWindowProxy(window: WindowProxy): void;
}
declare const WindowCore: WindowCoreConstructor;
    
interface EasyCoreAPI extends MonoBehaviour {
    IsInitialized: boolean;
    IdToken: string;

    constructor(): EasyCoreAPI;

    EmitAsync(eventName: string, jsonEvent: string): OnCompleteHook;
    GetCoreUserData(): CoreUserData;
    InitializeGameCoordinatorAsync(): OnCompleteHook;
    SendAsync(url: string, method: string, utf8Body: string, jsonParams: string, jsonHeaders: string): OnCompleteHook;
}
    
interface OnCompleteHook {

    constructor(): OnCompleteHook;

    Run(operationResult: OperationResult): void;
}
    
interface OperationResult {
    IsSuccess: boolean;
    ReturnString: string;

    constructor(isSuccess: boolean, returnString: string): OperationResult;

}
    
interface CoreUserData {
    UserId: string;
    DisplayName: string;
    Email: string;
    IsAnonymous: boolean;
    IsEmailVerified: boolean;
    PhoneNumber: string;
    ProviderId: string;
    LastSignInTimestamp: number;
    CreationTimestamp: number;

    constructor(): CoreUserData;

}
    
interface EasyCoreAPIConstructor {
    Instance: EasyCoreAPI;


}
declare const EasyCoreAPI: EasyCoreAPIConstructor;
    
interface GameCoordinatorMessageHook {

    constructor(): GameCoordinatorMessageHook;

    Run(messageName: string, message: string): void;
}
    
interface MoveModifier {
    speedMultiplier: number;
    blockSprint: boolean;
    blockJump: boolean;

    constructor(): MoveModifier;

}
    
interface DynamicVariables extends ScriptableObject {
    collectionId: string;
    strings: CSArray<unknown>;
    numbers: CSArray<unknown>;
    vectors: CSArray<unknown>;

    constructor(): DynamicVariables;

    GetNumber(key: string): number;
    GetString(key: string): string;
    GetVector3(key: string): Vector3;
    Register(): void;
    ReplicateAll(): void;
    ReplicateNumber(key: string): void;
    ReplicateString(key: string): void;
    ReplicateVector3(key: string): void;
    SetNumber(key: string, val: number): void;
    SetString(key: string, val: string): void;
    SetVector3(key: string, val: Vector3): void;
}
    
interface ProjectileHitEvent {
    raycastHit: RaycastHit;
    velocity: Vector3;


}
    
interface MaterialColor extends MonoBehaviour {
    colorSettings: CSArray<ColorSetting>;

    constructor(): MaterialColor;

    DoUpdate(): void;
    GetColor(materialIndex: number): ColorSetting;
    SetAllColors(diffuseColor: Color, combine: boolean): void;
    SetColor(settings: ColorSetting, materialIndex: number): boolean;
}
    
interface ColorSetting {
    materialColor: Color;
    emissiveColor: Color;
    emissiveMix: number;
    block: MaterialPropertyBlock;
    reference: string;

    constructor(materialColor: Color, emissiveColor: Color, emissiveMix: number): ColorSetting;

    CopyFrom(otherSettings: ColorSetting): void;
}
    
interface DefaultObjectPool extends ObjectPool {
    Cache: CSArray<CSDictionary<number, CSArray<NetworkObject>>>;

    constructor(): DefaultObjectPool;

    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    ClearPool(): void;
    ClearPool(collectionId: number): void;
    RetrieveObject(prefabId: number, asServer: boolean): NetworkObject;
    RetrieveObject(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    StoreObject(instantiated: NetworkObject, asServer: boolean): void;
}
    
interface AirshipObjectPool extends DefaultObjectPool {
    maxSpawnPerFrame: number;

    constructor(): AirshipObjectPool;

    SlowlyCacheObjects(prefab: NetworkObject, count: number): void;
}
    
interface MainMenuLoadingScreen extends MonoBehaviour {
    canvas: Canvas;
    progressText: TMP_Text;

    constructor(): MainMenuLoadingScreen;

    Close(): void;
    SetProgress(text: string, percent: number): void;
}

