/* eslint-disable */

/**
* Types generated by Unity.
* To generate, use the menu action: Typescript > Generate Types
*
* DO NOT EDIT!
*/

declare const enum HideFlags {
    None = 0,
    HideInHierarchy = 1,
    HideInInspector = 2,
    DontSaveInEditor = 4,
    NotEditable = 8,
    DontSaveInBuild = 16,
    DontUnloadUnusedAsset = 32,
    DontSave = 52,
    HideAndDontSave = 61,
}
declare const enum FindObjectsInactive {
    Exclude = 0,
    Include = 1,
}
declare const enum FindObjectsSortMode {
    None = 0,
    InstanceID = 1,
}
declare const enum Space {
    World = 0,
    Self = 1,
}
declare const enum SendMessageOptions {
    RequireReceiver = 0,
    DontRequireReceiver = 1,
}
declare const enum PrimitiveType {
    Sphere = 0,
    Capsule = 1,
    Cylinder = 2,
    Cube = 3,
    Plane = 4,
    Quad = 5,
}
declare const enum RigidbodyConstraints {
    None = 0,
    FreezePositionX = 2,
    FreezePositionY = 4,
    FreezePositionZ = 8,
    FreezePosition = 14,
    FreezeRotationX = 16,
    FreezeRotationY = 32,
    FreezeRotationZ = 64,
    FreezeRotation = 112,
    FreezeAll = 126,
}
declare const enum CollisionDetectionMode {
    Discrete = 0,
    Continuous = 1,
    ContinuousDynamic = 2,
    ContinuousSpeculative = 3,
}
declare const enum RigidbodyInterpolation {
    None = 0,
    Interpolate = 1,
    Extrapolate = 2,
}
declare const enum ForceMode {
    Force = 0,
    Impulse = 1,
    VelocityChange = 2,
    Acceleration = 5,
}
declare const enum QueryTriggerInteraction {
    UseGlobal = 0,
    Ignore = 1,
    Collide = 2,
}
declare const enum ArticulationJointType {
    FixedJoint = 0,
    PrismaticJoint = 1,
    RevoluteJoint = 2,
    SphericalJoint = 3,
}
declare const enum ArticulationDofLock {
    LockedMotion = 0,
    LimitedMotion = 1,
    FreeMotion = 2,
}
declare const enum ArticulationDriveType {
    Force = 0,
    Acceleration = 1,
    Target = 2,
    Velocity = 3,
}
declare const enum ArticulationDriveAxis {
    X = 0,
    Y = 1,
    Z = 2,
}
declare const enum GeometryType {
    Sphere = 0,
    Capsule = 2,
    Box = 3,
    ConvexMesh = 4,
    TriangleMesh = 5,
    Terrain = 6,
    Invalid = -1,
}
declare const enum PhysicMaterialCombine {
    Average = 0,
    Multiply = 1,
    Minimum = 2,
    Maximum = 3,
}
declare const enum SimulationMode {
    FixedUpdate = 0,
    Update = 1,
    Script = 2,
}
declare const enum SimulationStage {
    None = 0,
    PrepareSimulation = 1,
    RunSimulation = 2,
    PublishSimulationResults = 4,
    All = 7,
}
declare const enum SimulationOption {
    None = 0,
    SyncTransforms = 1,
    IgnoreEmptyScenes = 2,
    All = 3,
}
declare const enum MeshColliderCookingOptions {
    None = 0,
    InflateConvexMesh = 1,
    CookForFasterSimulation = 2,
    EnableMeshCleaning = 4,
    WeldColocatedVertices = 8,
    UseFastMidphase = 16,
}
declare const enum CompositeOperation {
    None = 0,
    Merge = 1,
    Intersect = 2,
    Difference = 3,
    Flip = 4,
}
declare const enum GeometryType {
    Outlines = 0,
    Polygons = 1,
}
declare const enum GenerationType {
    Synchronous = 0,
    Manual = 1,
}
declare const enum RigidbodyType2D {
    Dynamic = 0,
    Kinematic = 1,
    Static = 2,
}
declare const enum RigidbodyConstraints2D {
    None = 0,
    FreezePositionX = 1,
    FreezePositionY = 2,
    FreezePosition = 3,
    FreezeRotation = 4,
    FreezeAll = 7,
}
declare const enum RigidbodyInterpolation2D {
    None = 0,
    Interpolate = 1,
    Extrapolate = 2,
}
declare const enum RigidbodySleepMode2D {
    NeverSleep = 0,
    StartAwake = 1,
    StartAsleep = 2,
}
declare const enum CollisionDetectionMode2D {
    None = 0,
    Discrete = 0,
    Continuous = 1,
}
declare const enum ForceMode2D {
    Force = 0,
    Impulse = 1,
}
declare const enum PhysicsShapeType2D {
    Circle = 0,
    Capsule = 1,
    Polygon = 2,
    Edges = 3,
}
declare const enum ColliderErrorState2D {
    None = 0,
    NoShapes = 1,
    RemovedShapes = 2,
}
declare const enum IndexFormat {
    UInt16 = 0,
    UInt32 = 1,
}
declare const enum Target {
    Vertex = 1,
    Index = 2,
    CopySource = 4,
    CopyDestination = 8,
    Structured = 16,
    Raw = 32,
    Append = 64,
    Counter = 128,
    IndirectArguments = 256,
    Constant = 512,
}
declare const enum SkinWeights {
    None = 0,
    OneBone = 1,
    TwoBones = 2,
    FourBones = 4,
    Unlimited = 255,
}
declare const enum UsageFlags {
    None = 0,
    LockBufferForWrite = 1,
}
declare const enum BlendShapeBufferLayout {
    PerShape = 0,
    PerVertex = 1,
}
declare const enum MeshTopology {
    Triangles = 0,
    Quads = 2,
    Lines = 3,
    LineStrip = 4,
    Points = 5,
}
declare const enum VertexAttribute {
    Position = 0,
    Normal = 1,
    Tangent = 2,
    Color = 3,
    TexCoord0 = 4,
    TexCoord1 = 5,
    TexCoord2 = 6,
    TexCoord3 = 7,
    TexCoord4 = 8,
    TexCoord5 = 9,
    TexCoord6 = 10,
    TexCoord7 = 11,
    BlendWeight = 12,
    BlendIndices = 13,
}
declare const enum VertexAttributeFormat {
    Float32 = 0,
    Float16 = 1,
    UNorm8 = 2,
    SNorm8 = 3,
    UNorm16 = 4,
    SNorm16 = 5,
    UInt8 = 6,
    SInt8 = 7,
    UInt16 = 8,
    SInt16 = 9,
    UInt32 = 10,
    SInt32 = 11,
}
declare const enum MeshUpdateFlags {
    Default = 0,
    DontValidateIndices = 1,
    DontResetBoneBounds = 2,
    DontNotifyMeshUsers = 4,
    DontRecalculateBounds = 8,
}
declare const enum CapsuleDirection2D {
    Vertical = 0,
    Horizontal = 1,
}
declare const enum SimulationMode2D {
    FixedUpdate = 0,
    Update = 1,
    Script = 2,
}
declare const enum LogType {
    Error = 0,
    Assert = 1,
    Warning = 2,
    Log = 3,
    Exception = 4,
}
declare const enum LogOption {
    None = 0,
    NoStacktrace = 1,
}
declare const enum GraphicsFormat {
    None = 0,
    R8_SRGB = 1,
    R8G8_SRGB = 2,
    R8G8B8_SRGB = 3,
    R8G8B8A8_SRGB = 4,
    R8_UNorm = 5,
    R8G8_UNorm = 6,
    R8G8B8_UNorm = 7,
    R8G8B8A8_UNorm = 8,
    R8_SNorm = 9,
    R8G8_SNorm = 10,
    R8G8B8_SNorm = 11,
    R8G8B8A8_SNorm = 12,
    R8_UInt = 13,
    R8G8_UInt = 14,
    R8G8B8_UInt = 15,
    R8G8B8A8_UInt = 16,
    R8_SInt = 17,
    R8G8_SInt = 18,
    R8G8B8_SInt = 19,
    R8G8B8A8_SInt = 20,
    R16_UNorm = 21,
    R16G16_UNorm = 22,
    R16G16B16_UNorm = 23,
    R16G16B16A16_UNorm = 24,
    R16_SNorm = 25,
    R16G16_SNorm = 26,
    R16G16B16_SNorm = 27,
    R16G16B16A16_SNorm = 28,
    R16_UInt = 29,
    R16G16_UInt = 30,
    R16G16B16_UInt = 31,
    R16G16B16A16_UInt = 32,
    R16_SInt = 33,
    R16G16_SInt = 34,
    R16G16B16_SInt = 35,
    R16G16B16A16_SInt = 36,
    R32_UInt = 37,
    R32G32_UInt = 38,
    R32G32B32_UInt = 39,
    R32G32B32A32_UInt = 40,
    R32_SInt = 41,
    R32G32_SInt = 42,
    R32G32B32_SInt = 43,
    R32G32B32A32_SInt = 44,
    R16_SFloat = 45,
    R16G16_SFloat = 46,
    R16G16B16_SFloat = 47,
    R16G16B16A16_SFloat = 48,
    R32_SFloat = 49,
    R32G32_SFloat = 50,
    R32G32B32_SFloat = 51,
    R32G32B32A32_SFloat = 52,
    B8G8R8_SRGB = 56,
    B8G8R8A8_SRGB = 57,
    B8G8R8_UNorm = 58,
    B8G8R8A8_UNorm = 59,
    B8G8R8_SNorm = 60,
    B8G8R8A8_SNorm = 61,
    B8G8R8_UInt = 62,
    B8G8R8A8_UInt = 63,
    B8G8R8_SInt = 64,
    B8G8R8A8_SInt = 65,
    R4G4B4A4_UNormPack16 = 66,
    B4G4R4A4_UNormPack16 = 67,
    R5G6B5_UNormPack16 = 68,
    B5G6R5_UNormPack16 = 69,
    R5G5B5A1_UNormPack16 = 70,
    B5G5R5A1_UNormPack16 = 71,
    A1R5G5B5_UNormPack16 = 72,
    E5B9G9R9_UFloatPack32 = 73,
    B10G11R11_UFloatPack32 = 74,
    A2B10G10R10_UNormPack32 = 75,
    A2B10G10R10_UIntPack32 = 76,
    A2B10G10R10_SIntPack32 = 77,
    A2R10G10B10_UNormPack32 = 78,
    A2R10G10B10_UIntPack32 = 79,
    A2R10G10B10_SIntPack32 = 80,
    A2R10G10B10_XRSRGBPack32 = 81,
    A2R10G10B10_XRUNormPack32 = 82,
    R10G10B10_XRSRGBPack32 = 83,
    R10G10B10_XRUNormPack32 = 84,
    A10R10G10B10_XRSRGBPack32 = 85,
    A10R10G10B10_XRUNormPack32 = 86,
    D16_UNorm = 90,
    D24_UNorm = 91,
    D24_UNorm_S8_UInt = 92,
    D32_SFloat = 93,
    D32_SFloat_S8_UInt = 94,
    S8_UInt = 95,
    RGB_DXT1_SRGB = 96,
    RGBA_DXT1_SRGB = 96,
    RGB_DXT1_UNorm = 97,
    RGBA_DXT1_UNorm = 97,
    RGBA_DXT3_SRGB = 98,
    RGBA_DXT3_UNorm = 99,
    RGBA_DXT5_SRGB = 100,
    RGBA_DXT5_UNorm = 101,
    R_BC4_UNorm = 102,
    R_BC4_SNorm = 103,
    RG_BC5_UNorm = 104,
    RG_BC5_SNorm = 105,
    RGB_BC6H_UFloat = 106,
    RGB_BC6H_SFloat = 107,
    RGBA_BC7_SRGB = 108,
    RGBA_BC7_UNorm = 109,
    RGB_PVRTC_2Bpp_SRGB = 110,
    RGB_PVRTC_2Bpp_UNorm = 111,
    RGB_PVRTC_4Bpp_SRGB = 112,
    RGB_PVRTC_4Bpp_UNorm = 113,
    RGBA_PVRTC_2Bpp_SRGB = 114,
    RGBA_PVRTC_2Bpp_UNorm = 115,
    RGBA_PVRTC_4Bpp_SRGB = 116,
    RGBA_PVRTC_4Bpp_UNorm = 117,
    RGB_ETC_UNorm = 118,
    RGB_ETC2_SRGB = 119,
    RGB_ETC2_UNorm = 120,
    RGB_A1_ETC2_SRGB = 121,
    RGB_A1_ETC2_UNorm = 122,
    RGBA_ETC2_SRGB = 123,
    RGBA_ETC2_UNorm = 124,
    R_EAC_UNorm = 125,
    R_EAC_SNorm = 126,
    RG_EAC_UNorm = 127,
    RG_EAC_SNorm = 128,
    RGBA_ASTC4X4_SRGB = 129,
    RGBA_ASTC4X4_UNorm = 130,
    RGBA_ASTC5X5_SRGB = 131,
    RGBA_ASTC5X5_UNorm = 132,
    RGBA_ASTC6X6_SRGB = 133,
    RGBA_ASTC6X6_UNorm = 134,
    RGBA_ASTC8X8_SRGB = 135,
    RGBA_ASTC8X8_UNorm = 136,
    RGBA_ASTC10X10_SRGB = 137,
    RGBA_ASTC10X10_UNorm = 138,
    RGBA_ASTC12X12_SRGB = 139,
    RGBA_ASTC12X12_UNorm = 140,
    YUV2 = 141,
    DepthAuto = 142,
    ShadowAuto = 143,
    VideoAuto = 144,
    RGBA_ASTC4X4_UFloat = 145,
    RGBA_ASTC5X5_UFloat = 146,
    RGBA_ASTC6X6_UFloat = 147,
    RGBA_ASTC8X8_UFloat = 148,
    RGBA_ASTC10X10_UFloat = 149,
    RGBA_ASTC12X12_UFloat = 150,
    D16_UNorm_S8_UInt = 151,
}
declare const enum TextureDimension {
    None = 0,
    Any = 1,
    Tex2D = 2,
    Tex3D = 3,
    Cube = 4,
    Tex2DArray = 5,
    CubeArray = 6,
    Unknown = -1,
}
declare const enum TextureWrapMode {
    Repeat = 0,
    Clamp = 1,
    Mirror = 2,
    MirrorOnce = 3,
}
declare const enum FilterMode {
    Point = 0,
    Bilinear = 1,
    Trilinear = 2,
}
declare const enum GraphicsTextureDescriptorFlags {
    None = 0,
    RenderTarget = 1,
    RandomWriteTarget = 2,
}
declare const enum GraphicsTextureState {
    Constructed = 0,
    Initializing = 1,
    InitializedOnRenderThread = 2,
    DestroyQueued = 3,
    Destroyed = 4,
}
declare const enum AnisotropicFiltering {
    Disable = 0,
    Enable = 1,
    ForceEnable = 2,
}
declare const enum TextureFormat {
    Alpha8 = 1,
    ARGB4444 = 2,
    RGB24 = 3,
    RGBA32 = 4,
    ARGB32 = 5,
    RGB565 = 7,
    R16 = 9,
    DXT1 = 10,
    DXT5 = 12,
    RGBA4444 = 13,
    BGRA32 = 14,
    RHalf = 15,
    RGHalf = 16,
    RGBAHalf = 17,
    RFloat = 18,
    RGFloat = 19,
    RGBAFloat = 20,
    YUY2 = 21,
    RGB9e5Float = 22,
    BC6H = 24,
    BC7 = 25,
    BC4 = 26,
    BC5 = 27,
    DXT1Crunched = 28,
    DXT5Crunched = 29,
    PVRTC_RGB2 = 30,
    PVRTC_RGBA2 = 31,
    PVRTC_RGB4 = 32,
    PVRTC_RGBA4 = 33,
    ETC_RGB4 = 34,
    EAC_R = 41,
    EAC_R_SIGNED = 42,
    EAC_RG = 43,
    EAC_RG_SIGNED = 44,
    ETC2_RGB = 45,
    ETC2_RGBA1 = 46,
    ETC2_RGBA8 = 47,
    ASTC_4x4 = 48,
    ASTC_5x5 = 49,
    ASTC_6x6 = 50,
    ASTC_8x8 = 51,
    ASTC_10x10 = 52,
    ASTC_12x12 = 53,
    RG16 = 62,
    R8 = 63,
    ETC_RGB4Crunched = 64,
    ETC2_RGBA8Crunched = 65,
    ASTC_HDR_4x4 = 66,
    ASTC_HDR_5x5 = 67,
    ASTC_HDR_6x6 = 68,
    ASTC_HDR_8x8 = 69,
    ASTC_HDR_10x10 = 70,
    ASTC_HDR_12x12 = 71,
    RG32 = 72,
    RGB48 = 73,
    RGBA64 = 74,
    R8_SIGNED = 75,
    RG16_SIGNED = 76,
    RGB24_SIGNED = 77,
    RGBA32_SIGNED = 78,
    R16_SIGNED = 79,
    RG32_SIGNED = 80,
    RGB48_SIGNED = 81,
    RGBA64_SIGNED = 82,
    ETC_RGBA8_3DS = -61,
    ETC_RGB4_3DS = -60,
    ASTC_RGBA_12x12 = -59,
    ASTC_RGBA_10x10 = -58,
    ASTC_RGBA_8x8 = -57,
    ASTC_RGBA_6x6 = -56,
    ASTC_RGBA_5x5 = -55,
    ASTC_RGBA_4x4 = -54,
    ASTC_RGB_12x12 = -53,
    ASTC_RGB_10x10 = -52,
    ASTC_RGB_8x8 = -51,
    ASTC_RGB_6x6 = -50,
    ASTC_RGB_5x5 = -49,
    ASTC_RGB_4x4 = -48,
}
declare const enum SpritePackingMode {
    Tight = 0,
    Rectangle = 1,
}
declare const enum SpritePackingRotation {
    None = 0,
    FlipHorizontal = 1,
    FlipVertical = 2,
    Rotate180 = 3,
    Any = 15,
}
declare const enum SpriteMeshType {
    FullRect = 0,
    Tight = 1,
}
declare const enum DefaultFormat {
    LDR = 0,
    HDR = 1,
    DepthStencil = 2,
    Shadow = 3,
    Video = 4,
}
declare const enum TextureCreationFlags {
    None = 0,
    MipChain = 1,
    DontInitializePixels = 4,
    Crunch = 64,
    DontUploadUponCreate = 1024,
    IgnoreMipmapLimit = 2048,
}
declare const enum ConditionOverrideType {
    AddMissing = 1,
    UseManager = 2,
    IgnoreManager = 3,
}
declare const enum ObserverConditionType {
    Normal = 1,
    Timed = 2,
}
declare const enum Channel {
    Reliable = 0,
    Unreliable = 1,
}
declare const enum AutoPackType {
    Unpacked = 0,
    Packed = 1,
    PackedLess = 2,
}
declare const enum RemoteTimeoutType {
    Disabled = 0,
    Release = 1,
    Development = 2,
}
declare const enum HostVisibilityUpdateTypes {
    Manager = 1,
    Spawned = 2,
}
declare const enum LocalConnectionState {
    Stopped = 0,
    Starting = 1,
    Started = 2,
    Stopping = 3,
}
declare const enum RemoteConnectionState {
    Stopped = 0,
    Started = 2,
}
declare const enum IPAddressType {
    IPv4 = 0,
    IPv6 = 1,
}
declare const enum PhysicsMode {
    Unity = 0,
    TimeManager = 1,
    Disabled = 2,
}
declare const enum TickType {
    Tick = 0,
    LocalTick = 1,
    LastPacketTick = 2,
}
declare const enum TickRounding {
    RoundUp = 0,
    RoundDown = 1,
    RoundNearest = 2,
}
declare const enum LoadSceneMode {
    Single = 0,
    Additive = 1,
}
declare const enum LocalPhysicsMode {
    None = 0,
    Physics2D = 1,
    Physics3D = 2,
}
declare const enum SceneScopeType {
    Global = 0,
    Connections = 1,
}
declare const enum ReplaceOption {
    All = 0,
    OnlineOnly = 1,
    None = 2,
}
declare const enum ServerUnloadMode {
    UnloadUnused = 0,
    KeepUnused = 1,
}
declare const enum PhysicsType {
    TwoDimensional = 1,
    ThreeDimensional = 2,
    Both = 4,
}
declare const enum RollbackPhysicsType {
    Physics = 1,
    Physics2D = 2,
}
declare const enum LoggingType {
    Off = 0,
    Error = 1,
    Warning = 2,
    Common = 3,
}
declare const enum DataSource {
    Unset = 0,
    Server = 1,
    Client = 2,
}
declare const enum DataOrderType {
    Default = 0,
    Last = 1,
}
declare const enum DespawnType {
    Destroy = 0,
    Pool = 1,
}
declare const enum OldTickOption {
    Discard = 0,
    SetLastRemoteTick = 1,
    SetRemoteTick = 2,
}
declare const enum KickReason {
    Unset = 0,
    ExploitAttempt = 1,
    MalformedData = 2,
    ExploitExcessiveData = 3,
    ExcessiveData = 4,
    UnexpectedProblem = 5,
    UnusualActivity = 6,
}
declare const enum RenderingPath {
    VertexLit = 0,
    Forward = 1,
    DeferredLighting = 2,
    DeferredShading = 3,
    UsePlayerSettings = -1,
}
declare const enum OpaqueSortMode {
    Default = 0,
    FrontToBack = 1,
    NoDistanceSort = 2,
}
declare const enum TransparencySortMode {
    Default = 0,
    Perspective = 1,
    Orthographic = 2,
    CustomAxis = 3,
}
declare const enum CameraType {
    Game = 1,
    SceneView = 2,
    Preview = 4,
    VR = 8,
    Reflection = 16,
}
declare const enum CameraClearFlags {
    Skybox = 1,
    Color = 2,
    SolidColor = 2,
    Depth = 3,
    Nothing = 4,
}
declare const enum DepthTextureMode {
    None = 0,
    Depth = 1,
    DepthNormals = 2,
    MotionVectors = 4,
}
declare const enum GateFitMode {
    None = 0,
    Vertical = 1,
    Horizontal = 2,
    Fill = 3,
    Overscan = 4,
}
declare const enum VRTextureUsage {
    None = 0,
    OneEye = 1,
    TwoEyes = 2,
    DeviceSpecific = 3,
}
declare const enum RenderTextureMemoryless {
    None = 0,
    Color = 1,
    Depth = 2,
    MSAA = 4,
}
declare const enum RenderTextureFormat {
    ARGB32 = 0,
    Depth = 1,
    ARGBHalf = 2,
    Shadowmap = 3,
    RGB565 = 4,
    ARGB4444 = 5,
    ARGB1555 = 6,
    Default = 7,
    ARGB2101010 = 8,
    DefaultHDR = 9,
    ARGB64 = 10,
    ARGBFloat = 11,
    RGFloat = 12,
    RGHalf = 13,
    RFloat = 14,
    RHalf = 15,
    R8 = 16,
    ARGBInt = 17,
    RGInt = 18,
    RInt = 19,
    BGRA32 = 20,
    RGB111110Float = 22,
    RG32 = 23,
    RGBAUShort = 24,
    RG16 = 25,
    BGRA10101010_XR = 26,
    BGR101010_XR = 27,
    R16 = 28,
}
declare const enum ShadowSamplingMode {
    CompareDepths = 0,
    RawDepth = 1,
    None = 2,
}
declare const enum RenderTextureCreationFlags {
    MipMap = 1,
    AutoGenerateMips = 2,
    SRGB = 4,
    EyeTexture = 8,
    EnableRandomWrite = 16,
    CreatedFromScript = 32,
    AllowVerticalFlip = 128,
    NoResolvedColorSurface = 256,
    DynamicallyScalable = 1024,
    BindMS = 2048,
    DynamicallyScalableExplicit = 65536,
}
declare const enum MonoOrStereoscopicEye {
    Left = 0,
    Right = 1,
    Mono = 2,
}
declare const enum RenderTextureReadWrite {
    Default = 0,
    Linear = 1,
    sRGB = 2,
}
declare const enum StereoTargetEyeMask {
    None = 0,
    Left = 1,
    Right = 2,
    Both = 3,
}
declare const enum SceneViewFilterMode {
    Off = 0,
    ShowFiltered = 1,
}
declare const enum CameraEvent {
    BeforeDepthTexture = 0,
    AfterDepthTexture = 1,
    BeforeDepthNormalsTexture = 2,
    AfterDepthNormalsTexture = 3,
    BeforeGBuffer = 4,
    AfterGBuffer = 5,
    BeforeLighting = 6,
    AfterLighting = 7,
    BeforeFinalPass = 8,
    AfterFinalPass = 9,
    BeforeForwardOpaque = 10,
    AfterForwardOpaque = 11,
    BeforeImageEffectsOpaque = 12,
    AfterImageEffectsOpaque = 13,
    BeforeSkybox = 14,
    AfterSkybox = 15,
    BeforeForwardAlpha = 16,
    AfterForwardAlpha = 17,
    BeforeImageEffects = 18,
    AfterImageEffects = 19,
    AfterEverything = 20,
    BeforeReflections = 21,
    AfterReflections = 22,
    BeforeHaloAndLensFlares = 23,
    AfterHaloAndLensFlares = 24,
}
declare const enum RenderBufferLoadAction {
    Load = 0,
    Clear = 1,
    DontCare = 2,
}
declare const enum RenderBufferStoreAction {
    Store = 0,
    Resolve = 1,
    StoreAndResolve = 2,
    DontCare = 3,
}
declare const enum SubPassFlags {
    None = 0,
    ReadOnlyDepth = 2,
    ReadOnlyStencil = 4,
    ReadOnlyDepthStencil = 6,
}
declare const enum ShaderKeywordType {
    None = 0,
    BuiltinDefault = 2,
    BuiltinExtra = 6,
    BuiltinAutoStripped = 10,
    UserDefined = 16,
    Plugin = 32,
}
declare const enum ShaderPropertyFlags {
    None = 0,
    HideInInspector = 1,
    PerRendererData = 2,
    NoScaleOffset = 4,
    Normal = 8,
    HDR = 16,
    Gamma = 32,
    NonModifiableTextureData = 64,
    MainTexture = 128,
    MainColor = 256,
}
declare const enum ShaderPropertyType {
    Color = 0,
    Vector = 1,
    Float = 2,
    Range = 3,
    Texture = 4,
    Int = 5,
}
declare const enum ShaderHardwareTier {
    Tier1 = 0,
    Tier2 = 1,
    Tier3 = 2,
}
declare const enum ShadowCastingMode {
    Off = 0,
    On = 1,
    TwoSided = 2,
    ShadowsOnly = 3,
}
declare const enum MotionVectorGenerationMode {
    Camera = 0,
    Object = 1,
    ForceNoMotion = 2,
}
declare const enum LightProbeUsage {
    Off = 0,
    BlendProbes = 1,
    UseProxyVolume = 2,
    CustomProvided = 4,
}
declare const enum ReflectionProbeUsage {
    Off = 0,
    BlendProbes = 1,
    BlendProbesAndSkybox = 2,
    Simple = 3,
}
declare const enum RayTracingMode {
    Off = 0,
    Static = 1,
    DynamicTransform = 2,
    DynamicGeometry = 3,
}
declare const enum RayTracingAccelerationStructureBuildFlags {
    None = 0,
    PreferFastTrace = 1,
    PreferFastBuild = 2,
    MinimizeMemory = 4,
}
declare const enum ReflectionProbeType {
    Cube = 0,
    Card = 1,
}
declare const enum ReflectionProbeClearFlags {
    Skybox = 1,
    SolidColor = 2,
}
declare const enum ReflectionProbeMode {
    Baked = 0,
    Realtime = 1,
    Custom = 2,
}
declare const enum ReflectionProbeRefreshMode {
    OnAwake = 0,
    EveryFrame = 1,
    ViaScripting = 2,
}
declare const enum ReflectionProbeTimeSlicingMode {
    AllFacesAtOnce = 0,
    IndividualFaces = 1,
    NoTimeSlicing = 2,
}
declare const enum RenderTextureSubElement {
    Color = 0,
    Depth = 1,
    Stencil = 2,
    Default = 3,
}
declare const enum TexGenMode {
    None = 0,
    SphereMap = 1,
    Object = 2,
    EyeLinear = 3,
    CubeReflect = 4,
    CubeNormal = 5,
}
declare const enum MaterialGlobalIlluminationFlags {
    None = 0,
    RealtimeEmissive = 1,
    BakedEmissive = 2,
    AnyEmissive = 3,
    EmissiveIsBlack = 4,
}
declare const enum MaterialPropertyType {
    Float = 0,
    Int = 1,
    Vector = 2,
    Matrix = 3,
    Texture = 4,
    ConstantBuffer = 5,
    ComputeBuffer = 6,
}
declare const enum RTClearFlags {
    None = 0,
    Color = 1,
    Depth = 2,
    ColorDepth = 3,
    Stencil = 4,
    ColorStencil = 5,
    DepthStencil = 6,
    All = 7,
}
declare const enum SynchronisationStage {
    VertexProcessing = 0,
    PixelProcessing = 1,
}
declare const enum GraphicsFenceType {
    AsyncQueueSynchronisation = 0,
    CPUSynchronisation = 1,
}
declare const enum SynchronisationStageFlags {
    VertexProcessing = 1,
    PixelProcessing = 2,
    ComputeProcessing = 4,
    AllGPUOperations = 7,
}
declare const enum CustomMarkerCallbackFlags {
    CustomMarkerCallbackDefault = 0,
    CustomMarkerCallbackForceInvalidateStateTracking = 4,
}
declare const enum CameraLateLatchMatrixType {
    View = 0,
    InverseView = 1,
    ViewProjection = 2,
    InverseViewProjection = 3,
}
declare const enum CommandBufferExecutionFlags {
    None = 0,
    AsyncCompute = 2,
}
declare const enum FoveatedRenderingMode {
    Disabled = 0,
    Enabled = 1,
}
declare const enum CubemapFace {
    PositiveX = 0,
    NegativeX = 1,
    PositiveY = 2,
    NegativeY = 3,
    PositiveZ = 4,
    NegativeZ = 5,
    Unknown = -1,
}
declare const enum RenderTargetFlags {
    None = 0,
    ReadOnlyDepth = 1,
    ReadOnlyStencil = 2,
    ReadOnlyDepthStencil = 3,
}
declare const enum SinglePassStereoMode {
    None = 0,
    SideBySide = 1,
    Instancing = 2,
    Multiview = 3,
}
declare const enum ComputeQueueType {
    Default = 0,
    Background = 1,
    Urgent = 2,
}
declare const enum StereoscopicEye {
    Left = 0,
    Right = 1,
}
declare const enum RenderRequestMode {
    None = 0,
    ObjectId = 1,
    Depth = 2,
    VertexNormal = 3,
    WorldPosition = 4,
    EntityId = 5,
    BaseColor = 6,
    SpecularColor = 7,
    Metallic = 8,
    Emission = 9,
    Normal = 10,
    Smoothness = 11,
    Occlusion = 12,
    DiffuseColor = 13,
}
declare const enum RenderRequestOutputSpace {
    UV0 = 0,
    UV1 = 1,
    UV2 = 2,
    UV3 = 3,
    UV4 = 4,
    UV5 = 5,
    UV6 = 6,
    UV7 = 7,
    UV8 = 8,
    ScreenSpace = -1,
}
declare const enum IMECompositionMode {
    Auto = 0,
    On = 1,
    Off = 2,
}
declare const enum DeviceOrientation {
    Unknown = 0,
    Portrait = 1,
    PortraitUpsideDown = 2,
    LandscapeLeft = 3,
    LandscapeRight = 4,
    FaceUp = 5,
    FaceDown = 6,
}
declare const enum LocationServiceStatus {
    Stopped = 0,
    Initializing = 1,
    Running = 2,
    Failed = 3,
}
declare const enum TouchPhase {
    Began = 0,
    Moved = 1,
    Stationary = 2,
    Ended = 3,
    Canceled = 4,
}
declare const enum TouchType {
    Direct = 0,
    Indirect = 1,
    Stylus = 2,
}
declare const enum KeyCode {
    None = 0,
    Backspace = 8,
    Tab = 9,
    Clear = 12,
    Return = 13,
    Pause = 19,
    Escape = 27,
    Space = 32,
    Exclaim = 33,
    DoubleQuote = 34,
    Hash = 35,
    Dollar = 36,
    Percent = 37,
    Ampersand = 38,
    Quote = 39,
    LeftParen = 40,
    RightParen = 41,
    Asterisk = 42,
    Plus = 43,
    Comma = 44,
    Minus = 45,
    Period = 46,
    Slash = 47,
    Alpha0 = 48,
    Alpha1 = 49,
    Alpha2 = 50,
    Alpha3 = 51,
    Alpha4 = 52,
    Alpha5 = 53,
    Alpha6 = 54,
    Alpha7 = 55,
    Alpha8 = 56,
    Alpha9 = 57,
    Colon = 58,
    Semicolon = 59,
    Less = 60,
    Equals = 61,
    Greater = 62,
    Question = 63,
    At = 64,
    LeftBracket = 91,
    Backslash = 92,
    RightBracket = 93,
    Caret = 94,
    Underscore = 95,
    BackQuote = 96,
    A = 97,
    B = 98,
    C = 99,
    D = 100,
    E = 101,
    F = 102,
    G = 103,
    H = 104,
    I = 105,
    J = 106,
    K = 107,
    L = 108,
    M = 109,
    N = 110,
    O = 111,
    P = 112,
    Q = 113,
    R = 114,
    S = 115,
    T = 116,
    U = 117,
    V = 118,
    W = 119,
    X = 120,
    Y = 121,
    Z = 122,
    LeftCurlyBracket = 123,
    Pipe = 124,
    RightCurlyBracket = 125,
    Tilde = 126,
    Delete = 127,
    Keypad0 = 256,
    Keypad1 = 257,
    Keypad2 = 258,
    Keypad3 = 259,
    Keypad4 = 260,
    Keypad5 = 261,
    Keypad6 = 262,
    Keypad7 = 263,
    Keypad8 = 264,
    Keypad9 = 265,
    KeypadPeriod = 266,
    KeypadDivide = 267,
    KeypadMultiply = 268,
    KeypadMinus = 269,
    KeypadPlus = 270,
    KeypadEnter = 271,
    KeypadEquals = 272,
    UpArrow = 273,
    DownArrow = 274,
    RightArrow = 275,
    LeftArrow = 276,
    Insert = 277,
    Home = 278,
    End = 279,
    PageUp = 280,
    PageDown = 281,
    F1 = 282,
    F2 = 283,
    F3 = 284,
    F4 = 285,
    F5 = 286,
    F6 = 287,
    F7 = 288,
    F8 = 289,
    F9 = 290,
    F10 = 291,
    F11 = 292,
    F12 = 293,
    F13 = 294,
    F14 = 295,
    F15 = 296,
    Numlock = 300,
    CapsLock = 301,
    ScrollLock = 302,
    RightShift = 303,
    LeftShift = 304,
    RightControl = 305,
    LeftControl = 306,
    RightAlt = 307,
    LeftAlt = 308,
    RightMeta = 309,
    RightCommand = 309,
    RightApple = 309,
    LeftMeta = 310,
    LeftCommand = 310,
    LeftApple = 310,
    LeftWindows = 311,
    RightWindows = 312,
    AltGr = 313,
    Help = 315,
    Print = 316,
    SysReq = 317,
    Break = 318,
    Menu = 319,
    WheelUp = 321,
    WheelDown = 322,
    Mouse0 = 323,
    Mouse1 = 324,
    Mouse2 = 325,
    Mouse3 = 326,
    Mouse4 = 327,
    Mouse5 = 328,
    Mouse6 = 329,
    JoystickButton0 = 330,
    JoystickButton1 = 331,
    JoystickButton2 = 332,
    JoystickButton3 = 333,
    JoystickButton4 = 334,
    JoystickButton5 = 335,
    JoystickButton6 = 336,
    JoystickButton7 = 337,
    JoystickButton8 = 338,
    JoystickButton9 = 339,
    JoystickButton10 = 340,
    JoystickButton11 = 341,
    JoystickButton12 = 342,
    JoystickButton13 = 343,
    JoystickButton14 = 344,
    JoystickButton15 = 345,
    JoystickButton16 = 346,
    JoystickButton17 = 347,
    JoystickButton18 = 348,
    JoystickButton19 = 349,
    Joystick1Button0 = 350,
    Joystick1Button1 = 351,
    Joystick1Button2 = 352,
    Joystick1Button3 = 353,
    Joystick1Button4 = 354,
    Joystick1Button5 = 355,
    Joystick1Button6 = 356,
    Joystick1Button7 = 357,
    Joystick1Button8 = 358,
    Joystick1Button9 = 359,
    Joystick1Button10 = 360,
    Joystick1Button11 = 361,
    Joystick1Button12 = 362,
    Joystick1Button13 = 363,
    Joystick1Button14 = 364,
    Joystick1Button15 = 365,
    Joystick1Button16 = 366,
    Joystick1Button17 = 367,
    Joystick1Button18 = 368,
    Joystick1Button19 = 369,
    Joystick2Button0 = 370,
    Joystick2Button1 = 371,
    Joystick2Button2 = 372,
    Joystick2Button3 = 373,
    Joystick2Button4 = 374,
    Joystick2Button5 = 375,
    Joystick2Button6 = 376,
    Joystick2Button7 = 377,
    Joystick2Button8 = 378,
    Joystick2Button9 = 379,
    Joystick2Button10 = 380,
    Joystick2Button11 = 381,
    Joystick2Button12 = 382,
    Joystick2Button13 = 383,
    Joystick2Button14 = 384,
    Joystick2Button15 = 385,
    Joystick2Button16 = 386,
    Joystick2Button17 = 387,
    Joystick2Button18 = 388,
    Joystick2Button19 = 389,
    Joystick3Button0 = 390,
    Joystick3Button1 = 391,
    Joystick3Button2 = 392,
    Joystick3Button3 = 393,
    Joystick3Button4 = 394,
    Joystick3Button5 = 395,
    Joystick3Button6 = 396,
    Joystick3Button7 = 397,
    Joystick3Button8 = 398,
    Joystick3Button9 = 399,
    Joystick3Button10 = 400,
    Joystick3Button11 = 401,
    Joystick3Button12 = 402,
    Joystick3Button13 = 403,
    Joystick3Button14 = 404,
    Joystick3Button15 = 405,
    Joystick3Button16 = 406,
    Joystick3Button17 = 407,
    Joystick3Button18 = 408,
    Joystick3Button19 = 409,
    Joystick4Button0 = 410,
    Joystick4Button1 = 411,
    Joystick4Button2 = 412,
    Joystick4Button3 = 413,
    Joystick4Button4 = 414,
    Joystick4Button5 = 415,
    Joystick4Button6 = 416,
    Joystick4Button7 = 417,
    Joystick4Button8 = 418,
    Joystick4Button9 = 419,
    Joystick4Button10 = 420,
    Joystick4Button11 = 421,
    Joystick4Button12 = 422,
    Joystick4Button13 = 423,
    Joystick4Button14 = 424,
    Joystick4Button15 = 425,
    Joystick4Button16 = 426,
    Joystick4Button17 = 427,
    Joystick4Button18 = 428,
    Joystick4Button19 = 429,
    Joystick5Button0 = 430,
    Joystick5Button1 = 431,
    Joystick5Button2 = 432,
    Joystick5Button3 = 433,
    Joystick5Button4 = 434,
    Joystick5Button5 = 435,
    Joystick5Button6 = 436,
    Joystick5Button7 = 437,
    Joystick5Button8 = 438,
    Joystick5Button9 = 439,
    Joystick5Button10 = 440,
    Joystick5Button11 = 441,
    Joystick5Button12 = 442,
    Joystick5Button13 = 443,
    Joystick5Button14 = 444,
    Joystick5Button15 = 445,
    Joystick5Button16 = 446,
    Joystick5Button17 = 447,
    Joystick5Button18 = 448,
    Joystick5Button19 = 449,
    Joystick6Button0 = 450,
    Joystick6Button1 = 451,
    Joystick6Button2 = 452,
    Joystick6Button3 = 453,
    Joystick6Button4 = 454,
    Joystick6Button5 = 455,
    Joystick6Button6 = 456,
    Joystick6Button7 = 457,
    Joystick6Button8 = 458,
    Joystick6Button9 = 459,
    Joystick6Button10 = 460,
    Joystick6Button11 = 461,
    Joystick6Button12 = 462,
    Joystick6Button13 = 463,
    Joystick6Button14 = 464,
    Joystick6Button15 = 465,
    Joystick6Button16 = 466,
    Joystick6Button17 = 467,
    Joystick6Button18 = 468,
    Joystick6Button19 = 469,
    Joystick7Button0 = 470,
    Joystick7Button1 = 471,
    Joystick7Button2 = 472,
    Joystick7Button3 = 473,
    Joystick7Button4 = 474,
    Joystick7Button5 = 475,
    Joystick7Button6 = 476,
    Joystick7Button7 = 477,
    Joystick7Button8 = 478,
    Joystick7Button9 = 479,
    Joystick7Button10 = 480,
    Joystick7Button11 = 481,
    Joystick7Button12 = 482,
    Joystick7Button13 = 483,
    Joystick7Button14 = 484,
    Joystick7Button15 = 485,
    Joystick7Button16 = 486,
    Joystick7Button17 = 487,
    Joystick7Button18 = 488,
    Joystick7Button19 = 489,
    Joystick8Button0 = 490,
    Joystick8Button1 = 491,
    Joystick8Button2 = 492,
    Joystick8Button3 = 493,
    Joystick8Button4 = 494,
    Joystick8Button5 = 495,
    Joystick8Button6 = 496,
    Joystick8Button7 = 497,
    Joystick8Button8 = 498,
    Joystick8Button9 = 499,
    Joystick8Button10 = 500,
    Joystick8Button11 = 501,
    Joystick8Button12 = 502,
    Joystick8Button13 = 503,
    Joystick8Button14 = 504,
    Joystick8Button15 = 505,
    Joystick8Button16 = 506,
    Joystick8Button17 = 507,
    Joystick8Button18 = 508,
    Joystick8Button19 = 509,
}
declare const enum PenStatus {
    None = 0,
    Contact = 1,
    Barrel = 2,
    Inverted = 4,
    Eraser = 8,
}
declare const enum PenEventType {
    NoContact = 0,
    PenDown = 1,
    PenUp = 2,
}
declare const enum InputButton {
    Left = 0,
    Right = 1,
    Middle = 2,
}
declare const enum MoveDirection {
    Left = 0,
    Up = 1,
    Right = 2,
    Down = 3,
    None = 4,
}
declare const enum Mode {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
    Automatic = 3,
    Explicit = 4,
}
declare const enum Transition {
    None = 0,
    ColorTint = 1,
    SpriteSwap = 2,
    Animation = 3,
}
declare const enum CanvasUpdate {
    Prelayout = 0,
    Layout = 1,
    PostLayout = 2,
    PreRender = 3,
    LatePreRender = 4,
    MaxUpdateValue = 5,
}
declare const enum Edge {
    Left = 0,
    Right = 1,
    Top = 2,
    Bottom = 3,
}
declare const enum Axis {
    Horizontal = 0,
    Vertical = 1,
}
declare const enum RenderMode {
    ScreenSpaceOverlay = 0,
    ScreenSpaceCamera = 1,
    WorldSpace = 2,
}
declare const enum AdditionalCanvasShaderChannels {
    None = 0,
    TexCoord1 = 1,
    TexCoord2 = 2,
    TexCoord3 = 4,
    Normal = 8,
    Tangent = 16,
}
declare const enum StandaloneRenderResize {
    Enabled = 0,
    Disabled = 1,
}
declare const enum Type {
    Simple = 0,
    Sliced = 1,
    Tiled = 2,
    Filled = 3,
}
declare const enum FillMethod {
    Horizontal = 0,
    Vertical = 1,
    Radial90 = 2,
    Radial180 = 3,
    Radial360 = 4,
}
declare const enum AnimatorUpdateMode {
    Normal = 0,
    Fixed = 1,
    AnimatePhysics = 1,
    UnscaledTime = 2,
}
declare const enum AnimatorControllerParameterType {
    Float = 1,
    Int = 3,
    Bool = 4,
    Trigger = 9,
}
declare const enum AnimatorCullingMode {
    AlwaysAnimate = 0,
    CullUpdateTransforms = 1,
    BasedOnRenderers = 1,
    CullCompletely = 2,
}
declare const enum AnimatorRecorderMode {
    Offline = 0,
    Playback = 1,
    Record = 2,
}
declare const enum WrapMode {
    Default = 0,
    Once = 1,
    Clamp = 1,
    Loop = 2,
    PingPong = 4,
    ClampForever = 8,
}
declare const enum AnimationBlendMode {
    Blend = 0,
    Additive = 1,
}
declare const enum WeightedMode {
    None = 0,
    In = 1,
    Out = 2,
    Both = 3,
}
declare const enum DirectorUpdateMode {
    DSPClock = 0,
    GameTime = 1,
    UnscaledGameTime = 2,
    Manual = 3,
}
declare const enum DurationUnit {
    Fixed = 0,
    Normalized = 1,
}
declare const enum HumanBodyBones {
    Hips = 0,
    LeftUpperLeg = 1,
    RightUpperLeg = 2,
    LeftLowerLeg = 3,
    RightLowerLeg = 4,
    LeftFoot = 5,
    RightFoot = 6,
    Spine = 7,
    Chest = 8,
    Neck = 9,
    Head = 10,
    LeftShoulder = 11,
    RightShoulder = 12,
    LeftUpperArm = 13,
    RightUpperArm = 14,
    LeftLowerArm = 15,
    RightLowerArm = 16,
    LeftHand = 17,
    RightHand = 18,
    LeftToes = 19,
    RightToes = 20,
    LeftEye = 21,
    RightEye = 22,
    Jaw = 23,
    LeftThumbProximal = 24,
    LeftThumbIntermediate = 25,
    LeftThumbDistal = 26,
    LeftIndexProximal = 27,
    LeftIndexIntermediate = 28,
    LeftIndexDistal = 29,
    LeftMiddleProximal = 30,
    LeftMiddleIntermediate = 31,
    LeftMiddleDistal = 32,
    LeftRingProximal = 33,
    LeftRingIntermediate = 34,
    LeftRingDistal = 35,
    LeftLittleProximal = 36,
    LeftLittleIntermediate = 37,
    LeftLittleDistal = 38,
    RightThumbProximal = 39,
    RightThumbIntermediate = 40,
    RightThumbDistal = 41,
    RightIndexProximal = 42,
    RightIndexIntermediate = 43,
    RightIndexDistal = 44,
    RightMiddleProximal = 45,
    RightMiddleIntermediate = 46,
    RightMiddleDistal = 47,
    RightRingProximal = 48,
    RightRingIntermediate = 49,
    RightRingDistal = 50,
    RightLittleProximal = 51,
    RightLittleIntermediate = 52,
    RightLittleDistal = 53,
    UpperChest = 54,
    LastBone = 55,
}
declare const enum AvatarIKHint {
    LeftKnee = 0,
    RightKnee = 1,
    LeftElbow = 2,
    RightElbow = 3,
}
declare const enum AvatarIKGoal {
    LeftFoot = 0,
    RightFoot = 1,
    LeftHand = 2,
    RightHand = 3,
}
declare const enum AvatarTarget {
    Root = 0,
    Body = 1,
    LeftFoot = 2,
    RightFoot = 3,
    LeftHand = 4,
    RightHand = 5,
}
declare const enum UnityEventCallState {
    Off = 0,
    EditorAndRuntime = 1,
    RuntimeOnly = 2,
}
declare const enum ReceiveGI {
    Lightmaps = 1,
    LightProbes = 2,
}
declare const enum FontStyle {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    BoldAndItalic = 3,
}
declare const enum AtlasPopulationMode {
    Static = 0,
    Dynamic = 1,
    DynamicOS = 2,
}
declare const enum GlyphClassDefinitionType {
    Undefined = 0,
    Base = 1,
    Ligature = 2,
    Mark = 3,
    Component = 4,
}
declare const enum TextElementType {
    Character = 1,
    Sprite = 2,
}
declare const enum GlyphRenderMode {
    SMOOTH = 4117,
    RASTER = 4118,
    SMOOTH_HINTED = 4121,
    RASTER_HINTED = 4122,
    SDF = 4134,
    SDFAA = 4165,
    SDFAA_HINTED = 4169,
    SDF8 = 8230,
    SDF16 = 16422,
    SDF32 = 32806,
    COLOR = 69652,
    COLOR_HINTED = 69656,
}
declare const enum FontFeatureLookupFlags {
    None = 0,
    IgnoreLigatures = 4,
    IgnoreSpacingAdjustments = 256,
}
declare const enum ColorMode {
    Single = 0,
    HorizontalGradient = 1,
    VerticalGradient = 2,
    FourCornersGradient = 3,
}
declare const enum FontWeight {
    Thin = 100,
    ExtraLight = 200,
    Light = 300,
    Regular = 400,
    Medium = 500,
    SemiBold = 600,
    Bold = 700,
    Heavy = 800,
    Black = 900,
}
declare const enum FontStyles {
    Normal = 0,
    Bold = 1,
    Italic = 2,
    Underline = 4,
    LowerCase = 8,
    UpperCase = 16,
    SmallCaps = 32,
    Strikethrough = 64,
    Superscript = 128,
    Subscript = 256,
    Highlight = 512,
}
declare const enum HorizontalAlignmentOptions {
    Left = 1,
    Center = 2,
    Right = 4,
    Justified = 8,
    Flush = 16,
    Geometry = 32,
}
declare const enum VerticalAlignmentOptions {
    Top = 256,
    Middle = 512,
    Bottom = 1024,
    Baseline = 2048,
    Geometry = 4096,
    Capline = 8192,
}
declare const enum TextAlignmentOptions {
    TopLeft = 257,
    Top = 258,
    TopRight = 260,
    TopJustified = 264,
    TopFlush = 272,
    TopGeoAligned = 288,
    Left = 513,
    Center = 514,
    Right = 516,
    Justified = 520,
    Flush = 528,
    CenterGeoAligned = 544,
    BottomLeft = 1025,
    Bottom = 1026,
    BottomRight = 1028,
    BottomJustified = 1032,
    BottomFlush = 1040,
    BottomGeoAligned = 1056,
    BaselineLeft = 2049,
    Baseline = 2050,
    BaselineRight = 2052,
    BaselineJustified = 2056,
    BaselineFlush = 2064,
    BaselineGeoAligned = 2080,
    MidlineLeft = 4097,
    Midline = 4098,
    MidlineRight = 4100,
    MidlineJustified = 4104,
    MidlineFlush = 4112,
    MidlineGeoAligned = 4128,
    CaplineLeft = 8193,
    Capline = 8194,
    CaplineRight = 8196,
    CaplineJustified = 8200,
    CaplineFlush = 8208,
    CaplineGeoAligned = 8224,
    Converted = 65535,
}
declare const enum TextWrappingModes {
    NoWrap = 0,
    Normal = 1,
    PreserveWhitespace = 2,
    PreserveWhitespaceNoWrap = 3,
}
declare const enum TextOverflowModes {
    Overflow = 0,
    Ellipsis = 1,
    Masking = 2,
    Truncate = 3,
    ScrollRect = 4,
    Page = 5,
    Linked = 6,
}
declare const enum OTL_FeatureTag {
    kern = 1801810542,
    liga = 1818847073,
    mark = 1835102827,
    mkmk = 1835756907,
}
declare const enum TextureMappingOptions {
    Character = 0,
    Line = 1,
    Paragraph = 2,
    MatchAspect = 3,
}
declare const enum TextRenderFlags {
    DontRender = 0,
    Render = 255,
}
declare const enum VertexSortingOrder {
    Normal = 0,
    Reverse = 1,
}
declare const enum TMP_TextElementType {
    Character = 0,
    Sprite = 1,
}
declare const enum TMP_VertexDataUpdateFlags {
    None = 0,
    Vertices = 1,
    Uv0 = 2,
    Uv2 = 4,
    Uv4 = 8,
    Colors32 = 16,
    All = 255,
}
declare const enum AnimationUpdateMode {
    Normal = 0,
    Fixed = 1,
}
declare const enum AnimationCullingType {
    AlwaysAnimate = 0,
    BasedOnRenderers = 1,
    BasedOnClipBounds = 2,
    BasedOnUserBounds = 3,
}
declare const enum PlayMode {
    StopSameLayer = 0,
    StopAll = 4,
}
declare const enum QueueMode {
    CompleteOthers = 0,
    PlayNow = 2,
}
declare const enum AnimationPlayMode {
    Stop = 0,
    Queue = 1,
    Mix = 2,
}
declare const enum FogMode {
    Linear = 1,
    Exponential = 2,
    ExponentialSquared = 3,
}
declare const enum AmbientMode {
    Skybox = 0,
    Trilight = 1,
    Flat = 3,
    Custom = 4,
}
declare const enum LightType {
    Spot = 0,
    Directional = 1,
    Point = 2,
    Area = 3,
    Rectangle = 3,
    Disc = 4,
    Pyramid = 5,
    Box = 6,
    Tube = 7,
}
declare const enum LightShape {
    Cone = 0,
    Pyramid = 1,
    Box = 2,
}
declare const enum LightmapBakeType {
    Mixed = 1,
    Baked = 2,
    Realtime = 4,
}
declare const enum MixedLightingMode {
    IndirectOnly = 0,
    Subtractive = 1,
    Shadowmask = 2,
}
declare const enum LightShadowCasterMode {
    Default = 0,
    NonLightmappedOnly = 1,
    Everything = 2,
}
declare const enum LightShadows {
    None = 0,
    Hard = 1,
    Soft = 2,
}
declare const enum LightShadowResolution {
    Low = 0,
    Medium = 1,
    High = 2,
    VeryHigh = 3,
    FromQualitySettings = -1,
}
declare const enum LightRenderMode {
    Auto = 0,
    ForcePixel = 1,
    ForceVertex = 2,
}
declare const enum LightmappingMode {
    Mixed = 1,
    Baked = 2,
    Realtime = 4,
}
declare const enum LightEvent {
    BeforeShadowMap = 0,
    AfterShadowMap = 1,
    BeforeScreenspaceMask = 2,
    AfterScreenspaceMask = 3,
    BeforeShadowMapPass = 4,
    AfterShadowMapPass = 5,
}
declare const enum ShadowMapPass {
    PointlightPositiveX = 1,
    PointlightNegativeX = 2,
    PointlightPositiveY = 4,
    PointlightNegativeY = 8,
    PointlightPositiveZ = 16,
    PointlightNegativeZ = 32,
    Pointlight = 63,
    DirectionalCascade0 = 64,
    DirectionalCascade1 = 128,
    DirectionalCascade2 = 256,
    DirectionalCascade3 = 512,
    Directional = 960,
    Spotlight = 1024,
    All = 2047,
    AreaLight = 2048,
}
declare const enum DefaultReflectionMode {
    Skybox = 0,
    Custom = 1,
}
declare const enum UnloadSceneOptions {
    None = 0,
    UnloadAllEmbeddedSceneObjects = 1,
}
declare const enum SkinQuality {
    Auto = 0,
    Bone1 = 1,
    Bone2 = 2,
    Bone4 = 4,
}
declare const enum AccessorySlot {
    Root = 0,
    Head = 1,
    Hair = 2,
    Face = 3,
    Neck = 4,
    Torso = 5,
    RightHand = 6,
    LeftHand = 7,
    Waist = 8,
    Legs = 9,
    Feet = 10,
    Ears = 11,
    Nose = 12,
    TorsoOuter = 13,
    TorsoInner = 14,
    Backpack = 15,
    Hands = 16,
    HandsOuter = 17,
    LeftWrist = 18,
    RightWrist = 19,
    LegsOuter = 20,
    LegsInner = 21,
    FeetInner = 22,
    LeftFoot = 23,
    RightFoot = 24,
}
declare const enum VisibilityMode {
    THIRD_PERSON = 0,
    FIRST_PERSON = 1,
    BOTH = 2,
}
declare const enum AccessoryAddMode {
    ReplaceAll = 0,
    Replace = 1,
    Additive = 2,
    AddIfNone = 3,
}
declare const enum ParticleSystemSimulationSpace {
    Local = 0,
    World = 1,
    Custom = 2,
}
declare const enum ParticleSystemScalingMode {
    Hierarchy = 0,
    Local = 1,
    Shape = 2,
}
declare const enum ParticleSystemCurveMode {
    Constant = 0,
    Curve = 1,
    TwoCurves = 2,
    TwoConstants = 3,
}
declare const enum ParticleSystemGradientMode {
    Color = 0,
    Gradient = 1,
    TwoColors = 2,
    TwoGradients = 3,
    RandomColor = 4,
}
declare const enum GradientMode {
    Blend = 0,
    Fixed = 1,
    PerceptualBlend = 2,
}
declare const enum ColorSpace {
    Gamma = 0,
    Linear = 1,
    Uninitialized = -1,
}
declare const enum ParticleSystemGravitySource {
    Physics3D = 0,
    Physics2D = 1,
}
declare const enum ParticleSystemEmitterVelocityMode {
    Transform = 0,
    Rigidbody = 1,
    Custom = 2,
}
declare const enum ParticleSystemStopAction {
    None = 0,
    Disable = 1,
    Destroy = 2,
    Callback = 3,
}
declare const enum ParticleSystemRingBufferMode {
    Disabled = 0,
    PauseUntilReplaced = 1,
    LoopUntilReplaced = 2,
}
declare const enum ParticleSystemCullingMode {
    Automatic = 0,
    PauseAndCatchup = 1,
    Pause = 2,
    AlwaysSimulate = 3,
}
declare const enum ParticleSystemEmissionType {
    Time = 0,
    Distance = 1,
}
declare const enum ParticleSystemShapeType {
    Sphere = 0,
    SphereShell = 1,
    Hemisphere = 2,
    HemisphereShell = 3,
    Cone = 4,
    Box = 5,
    Mesh = 6,
    ConeShell = 7,
    ConeVolume = 8,
    ConeVolumeShell = 9,
    Circle = 10,
    CircleEdge = 11,
    SingleSidedEdge = 12,
    MeshRenderer = 13,
    SkinnedMeshRenderer = 14,
    BoxShell = 15,
    BoxEdge = 16,
    Donut = 17,
    Rectangle = 18,
    Sprite = 19,
    SpriteRenderer = 20,
}
declare const enum ParticleSystemShapeMultiModeValue {
    Random = 0,
    Loop = 1,
    PingPong = 2,
    BurstSpread = 3,
}
declare const enum ParticleSystemMeshShapeType {
    Vertex = 0,
    Edge = 1,
    Triangle = 2,
}
declare const enum SpriteDrawMode {
    Simple = 0,
    Sliced = 1,
    Tiled = 2,
}
declare const enum SpriteTileMode {
    Continuous = 0,
    Adaptive = 1,
}
declare const enum SpriteMaskInteraction {
    None = 0,
    VisibleInsideMask = 1,
    VisibleOutsideMask = 2,
}
declare const enum SpriteSortPoint {
    Center = 0,
    Pivot = 1,
}
declare const enum ParticleSystemShapeTextureChannel {
    Red = 0,
    Green = 1,
    Blue = 2,
    Alpha = 3,
}
declare const enum ParticleSystemInheritVelocityMode {
    Initial = 0,
    Current = 1,
}
declare const enum ParticleSystemGameObjectFilter {
    LayerMask = 0,
    List = 1,
    LayerMaskAndList = 2,
}
declare const enum ParticleSystemForceFieldShape {
    Sphere = 0,
    Hemisphere = 1,
    Cylinder = 2,
    Box = 3,
}
declare const enum ParticleSystemNoiseQuality {
    Low = 0,
    Medium = 1,
    High = 2,
}
declare const enum ParticleSystemCollisionType {
    Planes = 0,
    World = 1,
}
declare const enum ParticleSystemCollisionMode {
    Collision3D = 0,
    Collision2D = 1,
}
declare const enum ParticleSystemCollisionQuality {
    High = 0,
    Medium = 1,
    Low = 2,
}
declare const enum ParticleSystemOverlapAction {
    Ignore = 0,
    Kill = 1,
    Callback = 2,
}
declare const enum ParticleSystemColliderQueryMode {
    Disabled = 0,
    One = 1,
    All = 2,
}
declare const enum ParticleSystemSubEmitterType {
    Birth = 0,
    Collision = 1,
    Death = 2,
    Trigger = 3,
    Manual = 4,
}
declare const enum ParticleSystemSubEmitterProperties {
    InheritNothing = 0,
    InheritColor = 1,
    InheritSize = 2,
    InheritRotation = 4,
    InheritLifetime = 8,
    InheritDuration = 16,
    InheritEverything = 31,
}
declare const enum ParticleSystemAnimationMode {
    Grid = 0,
    Sprites = 1,
}
declare const enum ParticleSystemAnimationTimeMode {
    Lifetime = 0,
    Speed = 1,
    FPS = 2,
}
declare const enum ParticleSystemAnimationType {
    WholeSheet = 0,
    SingleRow = 1,
}
declare const enum ParticleSystemAnimationRowMode {
    Custom = 0,
    Random = 1,
    MeshIndex = 2,
}
declare const enum UVChannelFlags {
    UV0 = 1,
    UV1 = 2,
    UV2 = 4,
    UV3 = 8,
}
declare const enum ParticleSystemTrailMode {
    PerParticle = 0,
    Ribbon = 1,
}
declare const enum ParticleSystemTrailTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3,
    Static = 4,
}
declare const enum ParticleSystemCustomData {
    Custom1 = 0,
    Custom2 = 1,
}
declare const enum ParticleSystemCustomDataMode {
    Disabled = 0,
    Vector = 1,
    Color = 2,
}
declare const enum ParticleSystemStopBehavior {
    StopEmittingAndClear = 0,
    StopEmitting = 1,
}
declare const enum FadeMode {
    FixedSpeed = 0,
    FixedDuration = 1,
    FromStart = 2,
    NormalizedSpeed = 3,
    NormalizedDuration = 4,
    NormalizedFromStart = 5,
}
declare const enum AvatarMaskBodyPart {
    Root = 0,
    Body = 1,
    Head = 2,
    LeftLeg = 3,
    RightLeg = 4,
    LeftArm = 5,
    RightArm = 6,
    LeftFingers = 7,
    RightFingers = 8,
    LeftFootIK = 9,
    RightFootIK = 10,
    LeftHandIK = 11,
    RightHandIK = 12,
    LastBodyPart = 13,
}
declare const enum ApplicationInstallMode {
    Unknown = 0,
    Store = 1,
    DeveloperBuild = 2,
    Adhoc = 3,
    Enterprise = 4,
    Editor = 5,
}
declare const enum ApplicationSandboxType {
    Unknown = 0,
    NotSandboxed = 1,
    Sandboxed = 2,
    SandboxBroken = 3,
}
declare const enum StackTraceLogType {
    None = 0,
    ScriptOnly = 1,
    Full = 2,
}
declare const enum ThreadPriority {
    Low = 0,
    BelowNormal = 1,
    Normal = 2,
    High = 4,
}
declare const enum RuntimePlatform {
    OSXEditor = 0,
    OSXPlayer = 1,
    WindowsPlayer = 2,
    OSXWebPlayer = 3,
    OSXDashboardPlayer = 4,
    WindowsWebPlayer = 5,
    WindowsEditor = 7,
    IPhonePlayer = 8,
    PS3 = 9,
    XBOX360 = 10,
    Android = 11,
    NaCl = 12,
    LinuxPlayer = 13,
    FlashPlayer = 15,
    LinuxEditor = 16,
    WebGLPlayer = 17,
    MetroPlayerX86 = 18,
    WSAPlayerX86 = 18,
    MetroPlayerX64 = 19,
    WSAPlayerX64 = 19,
    MetroPlayerARM = 20,
    WSAPlayerARM = 20,
    WP8Player = 21,
    BB10Player = 22,
    BlackBerryPlayer = 22,
    TizenPlayer = 23,
    PSP2 = 24,
    PS4 = 25,
    PSM = 26,
    XboxOne = 27,
    SamsungTVPlayer = 28,
    WiiU = 30,
    tvOS = 31,
    Switch = 32,
    Lumin = 33,
    Stadia = 34,
    LinuxHeadlessSimulation = 35,
    GameCoreXboxSeries = 36,
    GameCoreXboxOne = 37,
    PS5 = 38,
    EmbeddedLinuxArm64 = 39,
    EmbeddedLinuxArm32 = 40,
    EmbeddedLinuxX64 = 41,
    EmbeddedLinuxX86 = 42,
    LinuxServer = 43,
    WindowsServer = 44,
    OSXServer = 45,
    QNXArm32 = 46,
    QNXArm64 = 47,
    QNXX64 = 48,
    QNXX86 = 49,
    GameCoreScarlett = -1,
    CloudRendering = -1,
}
declare const enum SystemLanguage {
    Afrikaans = 0,
    Arabic = 1,
    Basque = 2,
    Belarusian = 3,
    Bulgarian = 4,
    Catalan = 5,
    Chinese = 6,
    Czech = 7,
    Danish = 8,
    Dutch = 9,
    English = 10,
    Estonian = 11,
    Faroese = 12,
    Finnish = 13,
    French = 14,
    German = 15,
    Greek = 16,
    Hebrew = 17,
    Hungarian = 18,
    Hugarian = 18,
    Icelandic = 19,
    Indonesian = 20,
    Italian = 21,
    Japanese = 22,
    Korean = 23,
    Latvian = 24,
    Lithuanian = 25,
    Norwegian = 26,
    Polish = 27,
    Portuguese = 28,
    Romanian = 29,
    Russian = 30,
    SerboCroatian = 31,
    Slovak = 32,
    Slovenian = 33,
    Spanish = 34,
    Swedish = 35,
    Thai = 36,
    Turkish = 37,
    Ukrainian = 38,
    Vietnamese = 39,
    ChineseSimplified = 40,
    ChineseTraditional = 41,
    Hindi = 42,
    Unknown = 43,
}
declare const enum NetworkReachability {
    NotReachable = 0,
    ReachableViaCarrierDataNetwork = 1,
    ReachableViaLocalAreaNetwork = 2,
}
declare const enum UserAuthorization {
    WebCam = 1,
    Microphone = 2,
}
declare const enum ParticleSystemRenderSpace {
    View = 0,
    World = 1,
    Local = 2,
    Facing = 3,
    Velocity = 4,
}
declare const enum ParticleSystemRenderMode {
    Billboard = 0,
    Stretch = 1,
    HorizontalBillboard = 2,
    VerticalBillboard = 3,
    Mesh = 4,
    None = 5,
}
declare const enum ParticleSystemMeshDistribution {
    UniformRandom = 0,
    NonUniformRandom = 1,
}
declare const enum ParticleSystemSortMode {
    None = 0,
    Distance = 1,
    OldestInFront = 2,
    YoungestInFront = 3,
    Depth = 4,
    DistanceReverse = 5,
    DepthReverse = 6,
}
declare const enum ParticleSystemVertexStreams {
    None = 0,
    Position = 1,
    Normal = 2,
    Tangent = 4,
    Color = 8,
    UV = 16,
    UV2BlendAndFrame = 32,
    CenterAndVertexID = 64,
    Size = 128,
    Rotation = 256,
    Velocity = 512,
    Lifetime = 1024,
    Custom1 = 2048,
    Custom2 = 4096,
    Random = 8192,
    All = 2147483647,
}
declare const enum ParticleSystemBakeMeshOptions {
    Default = 0,
    BakeRotationAndScale = 1,
    BakePosition = 2,
}
declare const enum ParticleSystemBakeTextureOptions {
    BakeRotationAndScale = 1,
    BakePosition = 2,
    PerVertex = 4,
    Default = 4,
    PerParticle = 8,
    IncludeParticleIndices = 16,
}
declare const enum ParticleSystemVertexStream {
    Position = 0,
    Normal = 1,
    Tangent = 2,
    Color = 3,
    UV = 4,
    UV2 = 5,
    UV3 = 6,
    UV4 = 7,
    AnimBlend = 8,
    AnimFrame = 9,
    Center = 10,
    VertexID = 11,
    SizeX = 12,
    SizeXY = 13,
    SizeXYZ = 14,
    Rotation = 15,
    Rotation3D = 16,
    RotationSpeed = 17,
    RotationSpeed3D = 18,
    Velocity = 19,
    Speed = 20,
    AgePercent = 21,
    InvStartLifetime = 22,
    StableRandomX = 23,
    StableRandomXY = 24,
    StableRandomXYZ = 25,
    StableRandomXYZW = 26,
    VaryingRandomX = 27,
    VaryingRandomXY = 28,
    VaryingRandomXYZ = 29,
    VaryingRandomXYZW = 30,
    Custom1X = 31,
    Custom1XY = 32,
    Custom1XYZ = 33,
    Custom1XYZW = 34,
    Custom2X = 35,
    Custom2XY = 36,
    Custom2XYZ = 37,
    Custom2XYZW = 38,
    NoiseSumX = 39,
    NoiseSumXY = 40,
    NoiseSumXYZ = 41,
    NoiseImpulseX = 42,
    NoiseImpulseXY = 43,
    NoiseImpulseXYZ = 44,
    MeshIndex = 45,
    ParticleIndex = 46,
    ColorPackedAsTwoFloats = 47,
    MeshAxisOfRotation = 48,
    NextTrailCenter = 49,
    PreviousTrailCenter = 50,
    PercentageAlongTrail = 51,
    TrailWidth = 52,
}
declare const enum ProfilerArea {
    CPU = 0,
    GPU = 1,
    Rendering = 2,
    Memory = 3,
    Audio = 4,
    Video = 5,
    Physics = 6,
    Physics2D = 7,
    NetworkMessages = 8,
    NetworkOperations = 9,
    UI = 10,
    UIDetails = 11,
    GlobalIllumination = 12,
    VirtualTexturing = 13,
}
declare const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    TopToBottom = 3,
}
declare const enum ContentType {
    Standard = 0,
    Autocorrected = 1,
    IntegerNumber = 2,
    DecimalNumber = 3,
    Alphanumeric = 4,
    Name = 5,
    EmailAddress = 6,
    Password = 7,
    Pin = 8,
    Custom = 9,
}
declare const enum LineType {
    SingleLine = 0,
    MultiLineSubmit = 1,
    MultiLineNewline = 2,
}
declare const enum InputType {
    Standard = 0,
    AutoCorrect = 1,
    Password = 2,
}
declare const enum Status {
    Visible = 0,
    Done = 1,
    Canceled = 2,
    LostFocus = 3,
}
declare const enum TouchScreenKeyboardType {
    Default = 0,
    ASCIICapable = 1,
    NumbersAndPunctuation = 2,
    URL = 3,
    NumberPad = 4,
    PhonePad = 5,
    NamePhonePad = 6,
    EmailAddress = 7,
    NintendoNetworkAccount = 8,
    Social = 9,
    Search = 10,
    DecimalPad = 11,
    OneTimeCode = 12,
}
declare const enum CharacterValidation {
    None = 0,
    Digit = 1,
    Integer = 2,
    Decimal = 3,
    Alphanumeric = 4,
    Name = 5,
    Regex = 6,
    EmailAddress = 7,
    CustomValidator = 8,
}
declare const enum EventType {
    MouseDown = 0,
    mouseDown = 0,
    MouseUp = 1,
    mouseUp = 1,
    MouseMove = 2,
    mouseMove = 2,
    mouseDrag = 3,
    MouseDrag = 3,
    KeyDown = 4,
    keyDown = 4,
    keyUp = 5,
    KeyUp = 5,
    ScrollWheel = 6,
    scrollWheel = 6,
    Repaint = 7,
    repaint = 7,
    Layout = 8,
    layout = 8,
    DragUpdated = 9,
    dragUpdated = 9,
    dragPerform = 10,
    DragPerform = 10,
    ignore = 11,
    Ignore = 11,
    used = 12,
    Used = 12,
    ValidateCommand = 13,
    ExecuteCommand = 14,
    DragExited = 15,
    ContextClick = 16,
    MouseEnterWindow = 20,
    MouseLeaveWindow = 21,
    TouchDown = 30,
    TouchUp = 31,
    TouchMove = 32,
    TouchEnter = 33,
    TouchLeave = 34,
    TouchStationary = 35,
}
declare const enum PointerType {
    Mouse = 0,
    Touch = 1,
    Pen = 2,
}
declare const enum EventModifiers {
    None = 0,
    Shift = 1,
    Control = 2,
    Alt = 4,
    Command = 8,
    Numeric = 16,
    CapsLock = 32,
    FunctionKey = 64,
}
declare const enum Direction {
    LeftToRight = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    TopToBottom = 3,
}
declare const enum AudioClipLoadType {
    DecompressOnLoad = 0,
    CompressedInMemory = 1,
    Streaming = 2,
}
declare const enum AudioDataLoadState {
    Unloaded = 0,
    Loading = 1,
    Loaded = 2,
    Failed = 3,
}
declare const enum AudioMixerUpdateMode {
    Normal = 0,
    UnscaledTime = 1,
}
declare const enum GamepadSpeakerOutputType {
    Speaker = 0,
    Vibration = 1,
    SecondaryVibration = 2,
}
declare const enum AudioVelocityUpdateMode {
    Auto = 0,
    Fixed = 1,
    Dynamic = 2,
}
declare const enum AudioRolloffMode {
    Logarithmic = 0,
    Linear = 1,
    Custom = 2,
}
declare const enum AudioSourceCurveType {
    CustomRolloff = 0,
    SpatialBlend = 1,
    ReverbZoneMix = 2,
    Spread = 3,
}
declare const enum FFTWindow {
    Rectangular = 0,
    Triangle = 1,
    Hamming = 2,
    Hanning = 3,
    Blackman = 4,
    BlackmanHarris = 5,
}
declare const enum EaseType {
    Linear = 0,
    SineIn = 10,
    SineOut = 11,
    SineInOut = 12,
    QuadIn = 20,
    QuadOut = 21,
    QuadInOut = 22,
    CubicIn = 30,
    CubicOut = 31,
    CubicInOut = 32,
    QuartIn = 40,
    QuartOut = 41,
    QuartInOut = 42,
    QuintIn = 50,
    QuintOut = 51,
    QuintInOut = 52,
    ExpoIn = 60,
    ExpoOut = 61,
    ExpoInOut = 62,
    CircIn = 70,
    CircOut = 71,
    CircInOut = 72,
    BackIn = 80,
    BackOut = 81,
    BackInOut = 82,
    ElasticIn = 90,
    ElasticOut = 91,
    ElasticInOut = 92,
    BounceIn = 100,
    BounceOut = 101,
    BounceInOut = 102,
}
declare const enum StereoScreenCaptureMode {
    LeftEye = 1,
    RightEye = 2,
    BothEyes = 3,
}
declare const enum CollisionType {
    None = 0,
    Solid = 1,
    Slope = 2,
}
declare const enum ContextStyle {
    None = 0,
    GreedyMeshingTiles = 1,
    ContextBlocks = 2,
    QuarterTiles = 3,
}
declare const enum CollisionFlags {
    None = 0,
    Sides = 1,
    CollidedSides = 1,
    Above = 2,
    CollidedAbove = 2,
    Below = 4,
    CollidedBelow = 4,
}
declare const enum LineTextureMode {
    Stretch = 0,
    Tile = 1,
    DistributePerSegment = 2,
    RepeatPerSegment = 3,
    Static = 4,
}
declare const enum LineAlignment {
    View = 0,
    Local = 1,
    TransformZ = 1,
}
declare const enum EntityAnimationEventKey {
    FOOTSTEP = 0,
    JUMP = 1,
    LAND = 2,
    SLIDE_START = 3,
    SLIDE_END = 4,
    DEFAULT = -1,
}
declare const enum ToggleTransition {
    None = 0,
    Fade = 1,
}
declare const enum TextAnchor {
    UpperLeft = 0,
    UpperCenter = 1,
    UpperRight = 2,
    MiddleLeft = 3,
    MiddleCenter = 4,
    MiddleRight = 5,
    LowerLeft = 6,
    LowerCenter = 7,
    LowerRight = 8,
}
declare const enum FitMode {
    Unconstrained = 0,
    MinSize = 1,
    PreferredSize = 2,
}
declare const enum MovementType {
    Unrestricted = 0,
    Elastic = 1,
    Clamped = 2,
}
declare const enum ScrollbarVisibility {
    Permanent = 0,
    AutoHide = 1,
    AutoHideAndExpandViewport = 2,
}
declare const enum SynchronizedProperty {
    None = 0,
    Parent = 1,
    Position = 2,
    Rotation = 4,
    Scale = 8,
}
declare const enum SaveFolder {
    ApplicationData = 0,
    PicturesFolder = 1,
    Documents = 2,
}
declare const enum LogContext {
    Client = 0,
    Server = 1,
}
declare const enum BlendMode {
    Normal = 0,
    Additive = 1,
    Screen = 2,
    Multiply = 3,
}
declare const enum ColorBleedMode {
    ImageColor = 0,
    ShadowColor = 1,
    Black = 2,
    White = 3,
    Plugin = 4,
}
declare const enum AirshipPlatform {
    IPhone = 0,
    Android = 1,
    Mac = 2,
    Windows = 3,
    Linux = 4,
}
declare const enum BuildTarget {
    StandaloneOSX = 2,
    StandaloneOSXUniversal = 3,
    StandaloneOSXIntel = 4,
    StandaloneWindows = 5,
    WebPlayer = 6,
    WebPlayerStreamed = 7,
    iOS = 9,
    PS3 = 10,
    XBOX360 = 11,
    Android = 13,
    StandaloneLinux = 17,
    StandaloneWindows64 = 19,
    WebGL = 20,
    WSAPlayer = 21,
    StandaloneLinux64 = 24,
    StandaloneLinuxUniversal = 25,
    WP8Player = 26,
    StandaloneOSXIntel64 = 27,
    BlackBerry = 28,
    Tizen = 29,
    PSP2 = 30,
    PS4 = 31,
    PSM = 32,
    XboxOne = 33,
    SamsungTV = 34,
    N3DS = 35,
    WiiU = 36,
    tvOS = 37,
    Switch = 38,
    Lumin = 39,
    Stadia = 40,
    LinuxHeadlessSimulation = 41,
    CloudRendering = 41,
    GameCoreScarlett = 42,
    GameCoreXboxSeries = 42,
    GameCoreXboxOne = 43,
    PS5 = 44,
    EmbeddedLinux = 45,
    QNX = 46,
    Bratwurst = 47,
    NoTarget = -2,
    MetroPlayer = -1,
    iPhone = -1,
    BB10 = -1,
}

    
interface RaycastHit {
    collider: Collider;
    colliderInstanceID: number;
    point: Vector3;
    normal: Vector3;
    barycentricCoordinate: Vector3;
    distance: number;
    triangleIndex: number;
    textureCoord: Vector2;
    textureCoord2: Vector2;
    transform: Transform;
    rigidbody: Rigidbody;
    articulationBody: ArticulationBody;
    lightmapCoord: Vector2;
    textureCoord1: Vector2;


}
    
    
    
    
    
    
    
    
    
interface FrustumPlanes {
    left: number;
    right: number;
    bottom: number;
    top: number;
    zNear: number;
    zFar: number;


}
    
    
    
interface Plane {
    normal: Vector3;
    distance: number;
    flipped: Plane;


    ClosestPointOnPlane(point: Vector3): Vector3;
    Flip(): void;
    GetDistanceToPoint(point: Vector3): number;
    GetSide(point: Vector3): boolean;
    Raycast(ray: Ray, enter: unknown): boolean;
    SameSide(inPt0: Vector3, inPt1: Vector3): boolean;
    Set3Points(a: Vector3, b: Vector3, c: Vector3): void;
    SetNormalAndPosition(inNormal: Vector3, inPoint: Vector3): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
    Translate(translation: Vector3): void;
}
    
    
    
interface PlaneConstructor {

    new(inNormal: Vector3, inPoint: Vector3): Plane;
    new(inNormal: Vector3, d: number): Plane;
    new(a: Vector3, b: Vector3, c: Vector3): Plane;

    Translate(plane: Plane, translation: Vector3): Plane;
}
declare const Plane: PlaneConstructor;
    
    
    
interface Scene {
    handle: number;
    path: string;
    name: string;
    isLoaded: boolean;
    buildIndex: number;
    isDirty: boolean;
    rootCount: number;
    isSubScene: boolean;


    Equals(other: unknown): boolean;
    GetHashCode(): number;
    GetRootGameObjects(): CSArray<GameObject>;
    GetRootGameObjects(rootGameObjects: CSArray<GameObject>): void;
    IsValid(): boolean;
}
    
interface TagHandle {


    ToString(): string;
}
    
interface TagHandleConstructor {


    GetExistingTag(tagName: string): TagHandle;
}
declare const TagHandle: TagHandleConstructor;
    
    
    
    
    
    
    
    
interface Rigidbody extends Component {
    velocity: Vector3;
    angularVelocity: Vector3;
    drag: number;
    angularDrag: number;
    mass: number;
    useGravity: boolean;
    maxDepenetrationVelocity: number;
    isKinematic: boolean;
    freezeRotation: boolean;
    constraints: RigidbodyConstraints;
    collisionDetectionMode: CollisionDetectionMode;
    automaticCenterOfMass: boolean;
    centerOfMass: Vector3;
    worldCenterOfMass: Vector3;
    automaticInertiaTensor: boolean;
    inertiaTensorRotation: Quaternion;
    inertiaTensor: Vector3;
    detectCollisions: boolean;
    position: Vector3;
    rotation: Quaternion;
    interpolation: RigidbodyInterpolation;
    solverIterations: number;
    sleepThreshold: number;
    maxAngularVelocity: number;
    maxLinearVelocity: number;
    solverVelocityIterations: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    sleepVelocity: number;
    sleepAngularVelocity: number;
    useConeFriction: boolean;
    solverIterationCount: number;
    solverVelocityIterationCount: number;


    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number, mode: ForceMode): void;
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number): void;
    AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number): void;
    AddForce(force: Vector3, mode: ForceMode): void;
    AddForce(force: Vector3): void;
    AddForce(x: number, y: number, z: number, mode: ForceMode): void;
    AddForce(x: number, y: number, z: number): void;
    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
    AddForceAtPosition(force: Vector3, position: Vector3): void;
    AddRelativeForce(force: Vector3, mode: ForceMode): void;
    AddRelativeForce(force: Vector3): void;
    AddRelativeForce(x: number, y: number, z: number, mode: ForceMode): void;
    AddRelativeForce(x: number, y: number, z: number): void;
    AddRelativeTorque(torque: Vector3, mode: ForceMode): void;
    AddRelativeTorque(torque: Vector3): void;
    AddRelativeTorque(x: number, y: number, z: number, mode: ForceMode): void;
    AddRelativeTorque(x: number, y: number, z: number): void;
    AddTorque(torque: Vector3, mode: ForceMode): void;
    AddTorque(torque: Vector3): void;
    AddTorque(x: number, y: number, z: number, mode: ForceMode): void;
    AddTorque(x: number, y: number, z: number): void;
    ClosestPointOnBounds(position: Vector3): Vector3;
    GetAccumulatedForce(step: number): Vector3;
    GetAccumulatedForce(): Vector3;
    GetAccumulatedTorque(step: number): Vector3;
    GetAccumulatedTorque(): Vector3;
    GetPointVelocity(worldPoint: Vector3): Vector3;
    GetRelativePointVelocity(relativePoint: Vector3): Vector3;
    IsSleeping(): boolean;
    Move(position: Vector3, rotation: Quaternion): void;
    MovePosition(position: Vector3): void;
    MoveRotation(rot: Quaternion): void;
    PublishTransform(): void;
    ResetCenterOfMass(): void;
    ResetInertiaTensor(): void;
    SetDensity(density: number): void;
    SetMaxAngularVelocity(a: number): void;
    Sleep(): void;
    SweepTest(direction: Vector3, hitInfo: unknown, maxDistance: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SweepTest(direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    SweepTest(direction: Vector3, hitInfo: unknown): boolean;
    SweepTestAll(direction: Vector3, maxDistance: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    SweepTestAll(direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    SweepTestAll(direction: Vector3): CSArray<RaycastHit>;
    WakeUp(): void;
}
    
    
    
interface RigidbodyConstructor {

    new(): Rigidbody;

}
declare const Rigidbody: RigidbodyConstructor;
    
interface Behaviour extends Component {
    enabled: boolean;
    isActiveAndEnabled: boolean;


}
    
interface BehaviourConstructor {

    new(): Behaviour;

}
declare const Behaviour: BehaviourConstructor;
    
interface ArticulationBody extends Behaviour {
    jointType: ArticulationJointType;
    anchorPosition: Vector3;
    parentAnchorPosition: Vector3;
    anchorRotation: Quaternion;
    parentAnchorRotation: Quaternion;
    isRoot: boolean;
    matchAnchors: boolean;
    linearLockX: ArticulationDofLock;
    linearLockY: ArticulationDofLock;
    linearLockZ: ArticulationDofLock;
    swingYLock: ArticulationDofLock;
    swingZLock: ArticulationDofLock;
    twistLock: ArticulationDofLock;
    xDrive: ArticulationDrive;
    yDrive: ArticulationDrive;
    zDrive: ArticulationDrive;
    immovable: boolean;
    useGravity: boolean;
    linearDamping: number;
    angularDamping: number;
    jointFriction: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    velocity: Vector3;
    angularVelocity: Vector3;
    mass: number;
    automaticCenterOfMass: boolean;
    centerOfMass: Vector3;
    worldCenterOfMass: Vector3;
    automaticInertiaTensor: boolean;
    inertiaTensor: Vector3;
    inertiaTensorRotation: Quaternion;
    sleepThreshold: number;
    solverIterations: number;
    solverVelocityIterations: number;
    maxAngularVelocity: number;
    maxLinearVelocity: number;
    maxJointVelocity: number;
    maxDepenetrationVelocity: number;
    jointPosition: ArticulationReducedSpace;
    jointVelocity: ArticulationReducedSpace;
    jointAcceleration: ArticulationReducedSpace;
    jointForce: ArticulationReducedSpace;
    driveForce: ArticulationReducedSpace;
    dofCount: number;
    index: number;
    collisionDetectionMode: CollisionDetectionMode;
    computeParentAnchor: boolean;


    AddForce(force: Vector3, mode: ForceMode): void;
    AddForce(force: Vector3): void;
    AddForceAtPosition(force: Vector3, position: Vector3, mode: ForceMode): void;
    AddForceAtPosition(force: Vector3, position: Vector3): void;
    AddRelativeForce(force: Vector3, mode: ForceMode): void;
    AddRelativeForce(force: Vector3): void;
    AddRelativeTorque(torque: Vector3, mode: ForceMode): void;
    AddRelativeTorque(torque: Vector3): void;
    AddTorque(torque: Vector3, mode: ForceMode): void;
    AddTorque(torque: Vector3): void;
    GetAccumulatedForce(step: number): Vector3;
    GetAccumulatedForce(): Vector3;
    GetAccumulatedTorque(step: number): Vector3;
    GetAccumulatedTorque(): Vector3;
    GetClosestPoint(point: Vector3): Vector3;
    GetDenseJacobian(jacobian: unknown): number;
    GetDofStartIndices(dofStartIndices: CSArray<number>): number;
    GetDriveForces(forces: CSArray<number>): number;
    GetDriveTargets(targets: CSArray<number>): number;
    GetDriveTargetVelocities(targetVelocities: CSArray<number>): number;
    GetJointAccelerations(accelerations: CSArray<number>): number;
    GetJointCoriolisCentrifugalForces(forces: CSArray<number>): number;
    GetJointExternalForces(forces: CSArray<number>, step: number): number;
    GetJointForces(forces: CSArray<number>): number;
    GetJointForcesForAcceleration(acceleration: ArticulationReducedSpace): ArticulationReducedSpace;
    GetJointGravityForces(forces: CSArray<number>): number;
    GetJointPositions(positions: CSArray<number>): number;
    GetJointVelocities(velocities: CSArray<number>): number;
    GetPointVelocity(worldPoint: Vector3): Vector3;
    GetRelativePointVelocity(relativePoint: Vector3): Vector3;
    IsSleeping(): boolean;
    PublishTransform(): void;
    ResetCenterOfMass(): void;
    ResetInertiaTensor(): void;
    SetDriveDamping(axis: ArticulationDriveAxis, value: number): void;
    SetDriveForceLimit(axis: ArticulationDriveAxis, value: number): void;
    SetDriveLimits(axis: ArticulationDriveAxis, lower: number, upper: number): void;
    SetDriveStiffness(axis: ArticulationDriveAxis, value: number): void;
    SetDriveTarget(axis: ArticulationDriveAxis, value: number): void;
    SetDriveTargets(targets: CSArray<number>): void;
    SetDriveTargetVelocities(targetVelocities: CSArray<number>): void;
    SetDriveTargetVelocity(axis: ArticulationDriveAxis, value: number): void;
    SetJointAccelerations(accelerations: CSArray<number>): void;
    SetJointForces(forces: CSArray<number>): void;
    SetJointPositions(positions: CSArray<number>): void;
    SetJointVelocities(velocities: CSArray<number>): void;
    Sleep(): void;
    SnapAnchorToClosestContact(): void;
    TeleportRoot(position: Vector3, rotation: Quaternion): void;
    WakeUp(): void;
}
    
interface ArticulationDrive {
    lowerLimit: number;
    upperLimit: number;
    stiffness: number;
    damping: number;
    forceLimit: number;
    target: number;
    targetVelocity: number;
    driveType: ArticulationDriveType;


}
    
interface ArticulationReducedSpace {
    dofCount: number;
    Item: number;


}
    
interface ArticulationReducedSpaceConstructor {

    new(a: number): ArticulationReducedSpace;
    new(a: number, b: number): ArticulationReducedSpace;
    new(a: number, b: number, c: number): ArticulationReducedSpace;

}
declare const ArticulationReducedSpace: ArticulationReducedSpaceConstructor;
    
interface ArticulationBodyConstructor {

    new(): ArticulationBody;

}
declare const ArticulationBody: ArticulationBodyConstructor;
    
interface Bounds {
    center: Vector3;
    size: Vector3;
    extents: Vector3;
    min: Vector3;
    max: Vector3;


    ClosestPoint(point: Vector3): Vector3;
    Contains(point: Vector3): boolean;
    Encapsulate(point: Vector3): void;
    Encapsulate(bounds: Bounds): void;
    Equals(other: unknown): boolean;
    Equals(other: Bounds): boolean;
    Expand(amount: number): void;
    Expand(amount: Vector3): void;
    GetHashCode(): number;
    IntersectRay(ray: Ray): boolean;
    IntersectRay(ray: Ray, distance: unknown): boolean;
    Intersects(bounds: Bounds): boolean;
    SetMinMax(min: Vector3, max: Vector3): void;
    SqrDistance(point: Vector3): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface BoundsConstructor {

    new(center: Vector3, size: Vector3): Bounds;

}
declare const Bounds: BoundsConstructor;
    
interface GeometryHolder {
    Type: GeometryType;


    As<T>(): T;
}
    
interface GeometryHolderConstructor {

    new(): GeometryHolder;

    Create<T>(geometry: T): GeometryHolder;
}
declare const GeometryHolder: GeometryHolderConstructor;
    
interface PhysicMaterial extends Object {
    bounciness: number;
    dynamicFriction: number;
    staticFriction: number;
    frictionCombine: PhysicMaterialCombine;
    bounceCombine: PhysicMaterialCombine;
    bouncyness: number;
    frictionDirection2: Vector3;
    dynamicFriction2: number;
    staticFriction2: number;
    frictionDirection: Vector3;


}
    
interface PhysicMaterialConstructor {

    new(): PhysicMaterial;
    new(name: string): PhysicMaterial;

}
declare const PhysicMaterial: PhysicMaterialConstructor;
    
    
interface Vector2 {
    x: number;
    y: number;
    Item: number;
    normalized: Vector2;
    magnitude: number;
    sqrMagnitude: number;


    Equals(other: unknown): boolean;
    Equals(other: Vector2): boolean;
    GetHashCode(): number;
    Normalize(): void;
    Scale(scale: Vector2): void;
    Set(newX: number, newY: number): void;
    SqrMagnitude(): number;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Vector2Constructor {
    kEpsilon: number;
    kEpsilonNormalSqrt: number;
    zero: Vector2;
    one: Vector2;
    up: Vector2;
    down: Vector2;
    left: Vector2;
    right: Vector2;
    positiveInfinity: Vector2;
    negativeInfinity: Vector2;

    new(x: number, y: number): Vector2;

    Angle(from: Vector2, to: Vector2): number;
    ClampMagnitude(vector: Vector2, maxLength: number): Vector2;
    Distance(a: Vector2, b: Vector2): number;
    Dot(lhs: Vector2, rhs: Vector2): number;
    Lerp(a: Vector2, b: Vector2, t: number): Vector2;
    LerpUnclamped(a: Vector2, b: Vector2, t: number): Vector2;
    Max(lhs: Vector2, rhs: Vector2): Vector2;
    Min(lhs: Vector2, rhs: Vector2): Vector2;
    MoveTowards(current: Vector2, target: Vector2, maxDistanceDelta: number): Vector2;
    Perpendicular(inDirection: Vector2): Vector2;
    Reflect(inDirection: Vector2, inNormal: Vector2): Vector2;
    Scale(a: Vector2, b: Vector2): Vector2;
    SignedAngle(from: Vector2, to: Vector2): number;
    SmoothDamp(current: Vector2, target: Vector2, currentVelocity: unknown, smoothTime: number, maxSpeed: number): Vector2;
    SmoothDamp(current: Vector2, target: Vector2, currentVelocity: unknown, smoothTime: number): Vector2;
    SmoothDamp(current: Vector2, target: Vector2, currentVelocity: unknown, smoothTime: number, maxSpeed: number, deltaTime: number): Vector2;
    SqrMagnitude(a: Vector2): number;
}
declare const Vector2: Vector2Constructor;
    
interface Physics {


}
    
interface PhysicsScene {


    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>): number;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    Equals(other: unknown): boolean;
    Equals(other: PhysicsScene): boolean;
    GetHashCode(): number;
    InterpolateBodies(): void;
    IsEmpty(): boolean;
    IsValid(): boolean;
    OverlapBox(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapBox(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>): number;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapSphere(position: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, raycastHits: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    ResetInterpolationPoses(): void;
    RunSimulationStages(step: number, stages: SimulationStage, options: SimulationOption): void;
    Simulate(step: number): void;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    ToString(): string;
}
    
interface PhysicsConstructor {
    IgnoreRaycastLayer: number;
    DefaultRaycastLayers: number;
    AllLayers: number;
    kIgnoreRaycastLayer: number;
    kDefaultRaycastLayers: number;
    kAllLayers: number;
    gravity: Vector3;
    defaultContactOffset: number;
    sleepThreshold: number;
    queriesHitTriggers: boolean;
    queriesHitBackfaces: boolean;
    bounceThreshold: number;
    defaultMaxDepenetrationVelocity: number;
    defaultSolverIterations: number;
    defaultSolverVelocityIterations: number;
    simulationMode: SimulationMode;
    defaultMaxAngularSpeed: number;
    improvedPatchFriction: boolean;
    invokeCollisionCallbacks: boolean;
    defaultPhysicsScene: PhysicsScene;
    autoSyncTransforms: boolean;
    reuseCollisionCallbacks: boolean;
    interCollisionDistance: number;
    interCollisionStiffness: number;
    interCollisionSettingsToggle: boolean;
    clothGravity: Vector3;
    minPenetrationForPenalty: number;
    bounceTreshold: number;
    sleepVelocity: number;
    sleepAngularVelocity: number;
    maxAngularVelocity: number;
    solverIterationCount: number;
    solverVelocityIterationCount: number;
    penetrationPenaltyForce: number;
    autoSimulation: boolean;

    new(): Physics;

    BakeMesh(meshID: number, convex: boolean, cookingOptions: MeshColliderCookingOptions): void;
    BakeMesh(meshID: number, convex: boolean): void;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number, layerMask: number): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion, maxDistance: number): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown, orientation: Quaternion): boolean;
    BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: unknown): boolean;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number): CSArray<RaycastHit>;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion): CSArray<RaycastHit>;
    BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3): CSArray<RaycastHit>;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion): number;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number): number;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number): number;
    BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: CSArray<RaycastHit>): number;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: unknown): boolean;
    CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3): CSArray<RaycastHit>;
    CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number): number;
    CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>): number;
    CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layermask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number): boolean;
    CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion): boolean;
    CheckBox(center: Vector3, halfExtents: Vector3): boolean;
    CheckCapsule(start: Vector3, end: Vector3, radius: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CheckCapsule(start: Vector3, end: Vector3, radius: number, layerMask: number): boolean;
    CheckCapsule(start: Vector3, end: Vector3, radius: number): boolean;
    CheckSphere(position: Vector3, radius: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    CheckSphere(position: Vector3, radius: number, layerMask: number): boolean;
    CheckSphere(position: Vector3, radius: number): boolean;
    ClosestPoint(point: Vector3, collider: Collider, position: Vector3, rotation: Quaternion): Vector3;
    ComputePenetration(colliderA: Collider, positionA: Vector3, rotationA: Quaternion, colliderB: Collider, positionB: Vector3, rotationB: Quaternion, direction: unknown, distance: unknown): boolean;
    GetIgnoreCollision(collider1: Collider, collider2: Collider): boolean;
    GetIgnoreLayerCollision(layer1: number, layer2: number): boolean;
    IgnoreCollision(collider1: Collider, collider2: Collider, ignore: boolean): void;
    IgnoreCollision(collider1: Collider, collider2: Collider): void;
    IgnoreLayerCollision(layer1: number, layer2: number, ignore: boolean): void;
    IgnoreLayerCollision(layer1: number, layer2: number): void;
    Linecast(start: Vector3, end: Vector3, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Linecast(start: Vector3, end: Vector3, layerMask: number): boolean;
    Linecast(start: Vector3, end: Vector3): boolean;
    Linecast(start: Vector3, end: Vector3, hitInfo: unknown, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Linecast(start: Vector3, end: Vector3, hitInfo: unknown, layerMask: number): boolean;
    Linecast(start: Vector3, end: Vector3, hitInfo: unknown): boolean;
    OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<Collider>;
    OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number): CSArray<Collider>;
    OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion): CSArray<Collider>;
    OverlapBox(center: Vector3, halfExtents: Vector3): CSArray<Collider>;
    OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion, mask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion, mask: number): number;
    OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>, orientation: Quaternion): number;
    OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: CSArray<Collider>): number;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<Collider>;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, layerMask: number): CSArray<Collider>;
    OverlapCapsule(point0: Vector3, point1: Vector3, radius: number): CSArray<Collider>;
    OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>, layerMask: number): number;
    OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: CSArray<Collider>): number;
    OverlapSphere(position: Vector3, radius: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<Collider>;
    OverlapSphere(position: Vector3, radius: number, layerMask: number): CSArray<Collider>;
    OverlapSphere(position: Vector3, radius: number): CSArray<Collider>;
    OverlapSphereNonAlloc(position: Vector3, radius: number, results: CSArray<Collider>, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    OverlapSphereNonAlloc(position: Vector3, radius: number, results: CSArray<Collider>, layerMask: number): number;
    OverlapSphereNonAlloc(position: Vector3, radius: number, results: CSArray<Collider>): number;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number): boolean;
    Raycast(origin: Vector3, direction: Vector3, maxDistance: number): boolean;
    Raycast(origin: Vector3, direction: Vector3): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    Raycast(origin: Vector3, direction: Vector3, hitInfo: unknown): boolean;
    Raycast(ray: Ray, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(ray: Ray, maxDistance: number, layerMask: number): boolean;
    Raycast(ray: Ray, maxDistance: number): boolean;
    Raycast(ray: Ray): boolean;
    Raycast(ray: Ray, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    Raycast(ray: Ray, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    Raycast(ray: Ray, hitInfo: unknown, maxDistance: number): boolean;
    Raycast(ray: Ray, hitInfo: unknown): boolean;
    RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    RaycastAll(origin: Vector3, direction: Vector3): CSArray<RaycastHit>;
    RaycastAll(ray: Ray, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    RaycastAll(ray: Ray, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    RaycastAll(ray: Ray, maxDistance: number): CSArray<RaycastHit>;
    RaycastAll(ray: Ray): CSArray<RaycastHit>;
    RaycastNonAlloc(ray: Ray, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    RaycastNonAlloc(ray: Ray, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    RaycastNonAlloc(ray: Ray, results: CSArray<RaycastHit>, maxDistance: number): number;
    RaycastNonAlloc(ray: Ray, results: CSArray<RaycastHit>): number;
    RaycastNonAlloc(origin: Vector3, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    RaycastNonAlloc(origin: Vector3, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    RaycastNonAlloc(origin: Vector3, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number): number;
    RaycastNonAlloc(origin: Vector3, direction: Vector3, results: CSArray<RaycastHit>): number;
    RebuildBroadphaseRegions(worldBounds: Bounds, subdivisions: number): void;
    Simulate(step: number): void;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown, maxDistance: number): boolean;
    SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: unknown): boolean;
    SphereCast(ray: Ray, radius: number, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(ray: Ray, radius: number, maxDistance: number, layerMask: number): boolean;
    SphereCast(ray: Ray, radius: number, maxDistance: number): boolean;
    SphereCast(ray: Ray, radius: number): boolean;
    SphereCast(ray: Ray, radius: number, hitInfo: unknown, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): boolean;
    SphereCast(ray: Ray, radius: number, hitInfo: unknown, maxDistance: number, layerMask: number): boolean;
    SphereCast(ray: Ray, radius: number, hitInfo: unknown, maxDistance: number): boolean;
    SphereCast(ray: Ray, radius: number, hitInfo: unknown): boolean;
    SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number): CSArray<RaycastHit>;
    SphereCastAll(origin: Vector3, radius: number, direction: Vector3): CSArray<RaycastHit>;
    SphereCastAll(ray: Ray, radius: number, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): CSArray<RaycastHit>;
    SphereCastAll(ray: Ray, radius: number, maxDistance: number, layerMask: number): CSArray<RaycastHit>;
    SphereCastAll(ray: Ray, radius: number, maxDistance: number): CSArray<RaycastHit>;
    SphereCastAll(ray: Ray, radius: number): CSArray<RaycastHit>;
    SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>, maxDistance: number): number;
    SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: CSArray<RaycastHit>): number;
    SphereCastNonAlloc(ray: Ray, radius: number, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: QueryTriggerInteraction): number;
    SphereCastNonAlloc(ray: Ray, radius: number, results: CSArray<RaycastHit>, maxDistance: number, layerMask: number): number;
    SphereCastNonAlloc(ray: Ray, radius: number, results: CSArray<RaycastHit>, maxDistance: number): number;
    SphereCastNonAlloc(ray: Ray, radius: number, results: CSArray<RaycastHit>): number;
    SyncTransforms(): void;
}
declare const Physics: PhysicsConstructor;
    
interface Physics2D {


}
    
interface PhysicsScene2D {
    subStepCount: number;
    subStepLostTime: number;


    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Equals(other: unknown): boolean;
    Equals(other: PhysicsScene2D): boolean;
    GetHashCode(): number;
    GetRayIntersection(ray: Ray, distance: number, layerMask: number): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    IsEmpty(): boolean;
    IsValid(): boolean;
    Linecast(start: Vector2, end: Vector2, layerMask: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number): number;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircle(point: Vector2, radius: number, layerMask: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D): Collider2D;
    OverlapCircle(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2, layerMask: number): Collider2D;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D): Collider2D;
    OverlapPoint(point: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(origin: Vector2, direction: Vector2, distance: number, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Simulate(deltaTime: number): boolean;
    Simulate(deltaTime: number, simulationLayers: number): boolean;
    ToString(): string;
}
    
interface RaycastHit2D {
    centroid: Vector2;
    point: Vector2;
    normal: Vector2;
    distance: number;
    fraction: number;
    collider: Collider2D;
    rigidbody: Rigidbody2D;
    transform: Transform;


    CompareTo(other: RaycastHit2D): number;
}
    
interface Collider2D extends Behaviour {
    density: number;
    isTrigger: boolean;
    usedByEffector: boolean;
    compositeOperation: CompositeOperation;
    compositeOrder: number;
    composite: CompositeCollider2D;
    offset: Vector2;
    attachedRigidbody: Rigidbody2D;
    localToWorldMatrix: Matrix4x4;
    shapeCount: number;
    bounds: Bounds;
    errorState: ColliderErrorState2D;
    compositeCapable: boolean;
    sharedMaterial: PhysicsMaterial2D;
    layerOverridePriority: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    forceSendLayers: LayerMask;
    forceReceiveLayers: LayerMask;
    contactCaptureLayers: LayerMask;
    callbackLayers: LayerMask;
    friction: number;
    bounciness: number;
    usedByComposite: boolean;


    Cast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(position: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    Cast(position: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number, ignoreSiblingColliders: boolean): number;
    ClosestPoint(position: Vector2): Vector2;
    CreateMesh(useBodyPosition: boolean, useBodyRotation: boolean): Mesh;
    CreateMesh(useBodyPosition: boolean, useBodyRotation: boolean, useDelaunay: boolean): Mesh;
    Distance(collider: Collider2D): ColliderDistance2D;
    Distance(thisPosition: Vector2, thisAngle: number, collider: Collider2D, position: Vector2, angle: number): ColliderDistance2D;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetShapeBounds(bounds: CSArray<Bounds>, useRadii: boolean, useWorldSpace: boolean): Bounds;
    GetShapeHash(): number;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D, shapeIndex: number, shapeCount: number): number;
    IsTouching(collider: Collider2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(): boolean;
    IsTouchingLayers(layerMask: number): boolean;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(results: CSArray<Collider2D>): number;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): boolean;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    Raycast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
}
    
interface CompositeCollider2D extends Collider2D {
    geometryType: GeometryType;
    generationType: GenerationType;
    useDelaunayMesh: boolean;
    vertexDistance: number;
    edgeRadius: number;
    offsetDistance: number;
    pathCount: number;
    pointCount: number;


    GenerateGeometry(): void;
    GetCompositedColliders(colliders: CSArray<Collider2D>): number;
    GetPath(index: number, points: CSArray<Vector2>): number;
    GetPath(index: number, points: CSArray<Vector2>): number;
    GetPathPointCount(index: number): number;
}
    
interface CompositeCollider2DConstructor {

    new(): CompositeCollider2D;

}
declare const CompositeCollider2D: CompositeCollider2DConstructor;
    
interface Rigidbody2D extends Component {
    position: Vector2;
    rotation: number;
    velocity: Vector2;
    velocityX: number;
    velocityY: number;
    angularVelocity: number;
    useAutoMass: boolean;
    mass: number;
    sharedMaterial: PhysicsMaterial2D;
    centerOfMass: Vector2;
    worldCenterOfMass: Vector2;
    inertia: number;
    drag: number;
    angularDrag: number;
    gravityScale: number;
    bodyType: RigidbodyType2D;
    useFullKinematicContacts: boolean;
    isKinematic: boolean;
    freezeRotation: boolean;
    constraints: RigidbodyConstraints2D;
    simulated: boolean;
    interpolation: RigidbodyInterpolation2D;
    sleepMode: RigidbodySleepMode2D;
    collisionDetectionMode: CollisionDetectionMode2D;
    attachedColliderCount: number;
    totalForce: Vector2;
    totalTorque: number;
    excludeLayers: LayerMask;
    includeLayers: LayerMask;
    localToWorldMatrix: Matrix4x4;
    fixedAngle: boolean;


    AddForce(force: Vector2): void;
    AddForce(force: Vector2, mode: ForceMode2D): void;
    AddForceAtPosition(force: Vector2, position: Vector2): void;
    AddForceAtPosition(force: Vector2, position: Vector2, mode: ForceMode2D): void;
    AddForceX(force: number, mode: ForceMode2D): void;
    AddForceY(force: number, mode: ForceMode2D): void;
    AddRelativeForce(relativeForce: Vector2): void;
    AddRelativeForce(relativeForce: Vector2, mode: ForceMode2D): void;
    AddRelativeForceX(force: number, mode: ForceMode2D): void;
    AddRelativeForceY(force: number, mode: ForceMode2D): void;
    AddTorque(torque: number): void;
    AddTorque(torque: number, mode: ForceMode2D): void;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(position: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    Cast(position: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    ClosestPoint(position: Vector2): Vector2;
    Distance(collider: Collider2D): ColliderDistance2D;
    Distance(thisPosition: Vector2, thisAngle: number, collider: Collider2D, position: Vector2, angle: number): ColliderDistance2D;
    GetAttachedColliders(results: CSArray<Collider2D>): number;
    GetAttachedColliders(results: CSArray<Collider2D>): number;
    GetAttachedColliders(results: CSArray<Collider2D>, findTriggers: boolean): number;
    GetAttachedColliders(results: CSArray<Collider2D>, findTriggers: boolean): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetPoint(point: Vector2): Vector2;
    GetPointVelocity(point: Vector2): Vector2;
    GetRelativePoint(relativePoint: Vector2): Vector2;
    GetRelativePointVelocity(relativePoint: Vector2): Vector2;
    GetRelativeVector(relativeVector: Vector2): Vector2;
    GetShapes(physicsShapeGroup: PhysicsShapeGroup2D): number;
    GetVector(vector: Vector2): Vector2;
    IsAwake(): boolean;
    IsSleeping(): boolean;
    IsTouching(collider: Collider2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(): boolean;
    IsTouchingLayers(layerMask: number): boolean;
    MovePosition(position: Vector2): void;
    MovePositionAndRotation(position: Vector2, angle: number): void;
    MovePositionAndRotation(position: Vector2, rotation: Quaternion): void;
    MoveRotation(angle: number): void;
    MoveRotation(rotation: Quaternion): void;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(results: CSArray<Collider2D>): number;
    Overlap(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, results: CSArray<Collider2D>): number;
    Overlap(position: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): boolean;
    SetRotation(angle: number): void;
    SetRotation(rotation: Quaternion): void;
    Sleep(): void;
    Slide(velocity: Vector2, deltaTime: number, slideMovement: SlideMovement): SlideResults;
    WakeUp(): void;
}
    
interface PhysicsMaterial2D extends Object {
    bounciness: number;
    friction: number;


}
    
interface PhysicsMaterial2DConstructor {

    new(): PhysicsMaterial2D;
    new(name: string): PhysicsMaterial2D;

}
declare const PhysicsMaterial2D: PhysicsMaterial2DConstructor;
    
interface ContactFilter2D {
    useTriggers: boolean;
    useLayerMask: boolean;
    useDepth: boolean;
    useOutsideDepth: boolean;
    useNormalAngle: boolean;
    useOutsideNormalAngle: boolean;
    layerMask: LayerMask;
    minDepth: number;
    maxDepth: number;
    minNormalAngle: number;
    maxNormalAngle: number;
    isFiltering: boolean;


    ClearDepth(): void;
    ClearLayerMask(): void;
    ClearNormalAngle(): void;
    IsFilteringDepth(obj: GameObject): boolean;
    IsFilteringLayerMask(obj: GameObject): boolean;
    IsFilteringNormalAngle(normal: Vector2): boolean;
    IsFilteringNormalAngle(angle: number): boolean;
    IsFilteringTrigger(collider: Collider2D): boolean;
    NoFilter(): ContactFilter2D;
    SetDepth(minDepth: number, maxDepth: number): void;
    SetLayerMask(layerMask: LayerMask): void;
    SetNormalAngle(minNormalAngle: number, maxNormalAngle: number): void;
}
    
interface ContactFilter2DConstructor {
    NormalAngleUpperLimit: number;


}
declare const ContactFilter2D: ContactFilter2DConstructor;
    
interface ColliderDistance2D {
    pointA: Vector2;
    pointB: Vector2;
    normal: Vector2;
    distance: number;
    isOverlapped: boolean;
    isValid: boolean;


}
    
interface ContactPoint2D {
    point: Vector2;
    normal: Vector2;
    separation: number;
    normalImpulse: number;
    tangentImpulse: number;
    relativeVelocity: Vector2;
    collider: Collider2D;
    otherCollider: Collider2D;
    rigidbody: Rigidbody2D;
    otherRigidbody: Rigidbody2D;
    enabled: boolean;


}
    
interface PhysicsShapeGroup2D {
    shapeCount: number;
    vertexCount: number;
    localToWorldMatrix: Matrix4x4;


    Add(physicsShapeGroup: PhysicsShapeGroup2D): void;
    AddBox(center: Vector2, size: Vector2, angle: number, edgeRadius: number): number;
    AddCapsule(vertex0: Vector2, vertex1: Vector2, radius: number): number;
    AddCircle(center: Vector2, radius: number): number;
    AddEdges(vertices: CSArray<Vector2>, edgeRadius: number): number;
    AddEdges(vertices: CSArray<Vector2>, useAdjacentStart: boolean, useAdjacentEnd: boolean, adjacentStart: Vector2, adjacentEnd: Vector2, edgeRadius: number): number;
    AddPolygon(vertices: CSArray<Vector2>): number;
    Clear(): void;
    DeleteShape(shapeIndex: number): void;
    GetShape(shapeIndex: number): PhysicsShape2D;
    GetShapeData(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;
    GetShapeData(shapes: CSArray<PhysicsShape2D>, vertices: CSArray<Vector2>): void;
    GetShapeVertex(shapeIndex: number, vertexIndex: number): Vector2;
    GetShapeVertices(shapeIndex: number, vertices: CSArray<Vector2>): void;
    SetShapeAdjacentVertices(shapeIndex: number, useAdjacentStart: boolean, useAdjacentEnd: boolean, adjacentStart: Vector2, adjacentEnd: Vector2): void;
    SetShapeRadius(shapeIndex: number, radius: number): void;
    SetShapeVertex(shapeIndex: number, vertexIndex: number, vertex: Vector2): void;
}
    
interface PhysicsShape2D {
    shapeType: PhysicsShapeType2D;
    radius: number;
    vertexStartIndex: number;
    vertexCount: number;
    useAdjacentStart: boolean;
    useAdjacentEnd: boolean;
    adjacentStart: Vector2;
    adjacentEnd: Vector2;


}
    
interface PhysicsShapeGroup2DConstructor {

    new(shapeCapacity: number, vertexCapacity: number): PhysicsShapeGroup2D;

}
declare const PhysicsShapeGroup2D: PhysicsShapeGroup2DConstructor;
    
interface SlideResults {
    remainingVelocity: Vector2;
    position: Vector2;
    iterationsUsed: number;
    slideHit: RaycastHit2D;
    surfaceHit: RaycastHit2D;


}
    
interface SlideMovement {
    maxIterations: number;
    surfaceSlideAngle: number;
    gravitySlipAngle: number;
    surfaceUp: Vector2;
    surfaceAnchor: Vector2;
    gravity: Vector2;
    startPosition: Vector2;
    selectedCollider: Collider2D;
    layerMask: LayerMask;
    useLayerMask: boolean;
    useStartPosition: boolean;
    useNoMove: boolean;
    useSimulationMove: boolean;
    useAttachedTriggers: boolean;


    SetLayerMask(mask: LayerMask): void;
    SetStartPosition(position: Vector2): void;
}
    
interface SlideMovementConstructor {

    new(): SlideMovement;

}
declare const SlideMovement: SlideMovementConstructor;
    
interface Rigidbody2DConstructor {

    new(): Rigidbody2D;

}
declare const Rigidbody2D: Rigidbody2DConstructor;
    
interface Mesh extends Object {
    uv1: CSArray<Vector2>;
    indexFormat: IndexFormat;
    vertexBufferCount: number;
    vertexBufferTarget: Target;
    indexBufferTarget: Target;
    blendShapeCount: number;
    bindposeCount: number;
    bindposes: CSArray<Matrix4x4>;
    isReadable: boolean;
    vertexCount: number;
    subMeshCount: number;
    bounds: Bounds;
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    tangents: CSArray<Vector4>;
    uv: CSArray<Vector2>;
    uv2: CSArray<Vector2>;
    uv3: CSArray<Vector2>;
    uv4: CSArray<Vector2>;
    uv5: CSArray<Vector2>;
    uv6: CSArray<Vector2>;
    uv7: CSArray<Vector2>;
    uv8: CSArray<Vector2>;
    colors: CSArray<Color>;
    colors32: CSArray<Color32>;
    vertexAttributeCount: number;
    triangles: CSArray<number>;
    boneWeights: CSArray<BoneWeight>;
    skinWeightBufferLayout: SkinWeights;


    AddBlendShapeFrame(shapeName: string, frameWeight: number, deltaVertices: CSArray<Vector3>, deltaNormals: CSArray<Vector3>, deltaTangents: CSArray<Vector3>): void;
    Clear(keepVertexLayout: boolean): void;
    Clear(): void;
    ClearBlendShapes(): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean, useMatrices: boolean, hasLightmapData: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean, useMatrices: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>, mergeSubMeshes: boolean): void;
    CombineMeshes(combine: CSArray<CombineInstance>): void;
    GetAllBoneWeights(): CSArray<BoneWeight1>;
    GetBaseVertex(submesh: number): number;
    GetBindposes(): CSArray<Matrix4x4>;
    GetBindposes(bindposes: CSArray<Matrix4x4>): void;
    GetBlendShapeBuffer(layout: BlendShapeBufferLayout): GraphicsBuffer;
    GetBlendShapeBuffer(): GraphicsBuffer;
    GetBlendShapeBufferRange(blendShapeIndex: number): BlendShapeBufferRange;
    GetBlendShapeFrameCount(shapeIndex: number): number;
    GetBlendShapeFrameVertices(shapeIndex: number, frameIndex: number, deltaVertices: CSArray<Vector3>, deltaNormals: CSArray<Vector3>, deltaTangents: CSArray<Vector3>): void;
    GetBlendShapeFrameWeight(shapeIndex: number, frameIndex: number): number;
    GetBlendShapeIndex(blendShapeName: string): number;
    GetBlendShapeName(shapeIndex: number): string;
    GetBonesPerVertex(): CSArray<number>;
    GetBoneWeightBuffer(layout: SkinWeights): GraphicsBuffer;
    GetBoneWeights(boneWeights: CSArray<BoneWeight>): void;
    GetColors(colors: CSArray<Color>): void;
    GetColors(colors: CSArray<Color32>): void;
    GetIndexBuffer(): GraphicsBuffer;
    GetIndexCount(submesh: number): number;
    GetIndexStart(submesh: number): number;
    GetIndices(submesh: number): CSArray<number>;
    GetIndices(submesh: number, applyBaseVertex: boolean): CSArray<number>;
    GetIndices(indices: CSArray<number>, submesh: number): void;
    GetIndices(indices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetIndices(indices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetNativeIndexBufferPtr(): unknown;
    GetNativeVertexBufferPtr(index: number): unknown;
    GetNormals(normals: CSArray<Vector3>): void;
    GetSubMesh(index: number): SubMeshDescriptor;
    GetTangents(tangents: CSArray<Vector4>): void;
    GetTopology(submesh: number): MeshTopology;
    GetTriangles(submesh: number): CSArray<number>;
    GetTriangles(submesh: number, applyBaseVertex: boolean): CSArray<number>;
    GetTriangles(triangles: CSArray<number>, submesh: number): void;
    GetTriangles(triangles: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetTriangles(triangles: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetUVDistributionMetric(uvSetIndex: number): number;
    GetUVs(channel: number, uvs: CSArray<Vector2>): void;
    GetUVs(channel: number, uvs: CSArray<Vector3>): void;
    GetUVs(channel: number, uvs: CSArray<Vector4>): void;
    GetVertexAttribute(index: number): VertexAttributeDescriptor;
    GetVertexAttributeDimension(attr: VertexAttribute): number;
    GetVertexAttributeFormat(attr: VertexAttribute): VertexAttributeFormat;
    GetVertexAttributeOffset(attr: VertexAttribute): number;
    GetVertexAttributes(): CSArray<VertexAttributeDescriptor>;
    GetVertexAttributes(attributes: CSArray<VertexAttributeDescriptor>): number;
    GetVertexAttributes(attributes: CSArray<VertexAttributeDescriptor>): number;
    GetVertexAttributeStream(attr: VertexAttribute): number;
    GetVertexBuffer(index: number): GraphicsBuffer;
    GetVertexBufferStride(stream: number): number;
    GetVertices(vertices: CSArray<Vector3>): void;
    HasVertexAttribute(attr: VertexAttribute): boolean;
    MarkDynamic(): void;
    MarkModified(): void;
    Optimize(): void;
    OptimizeIndexBuffers(): void;
    OptimizeReorderVertexBuffer(): void;
    RecalculateBounds(): void;
    RecalculateBounds(flags: MeshUpdateFlags): void;
    RecalculateNormals(): void;
    RecalculateNormals(flags: MeshUpdateFlags): void;
    RecalculateTangents(): void;
    RecalculateTangents(flags: MeshUpdateFlags): void;
    RecalculateUVDistributionMetric(uvSetIndex: number, uvAreaThreshold: number): void;
    RecalculateUVDistributionMetrics(uvAreaThreshold: number): void;
    SetBindposes(poses: CSArray<Matrix4x4>): void;
    SetBoneWeights(bonesPerVertex: CSArray<number>, weights: CSArray<BoneWeight1>): void;
    SetColors(inColors: CSArray<Color>): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color>): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color32>): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors(inColors: CSArray<Color32>): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number): void;
    SetColors(inColors: CSArray<Color32>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetColors<T>(inColors: CSArray<T>): void;
    SetColors<T>(inColors: CSArray<T>, start: number, length: number): void;
    SetColors<T>(inColors: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, flags: MeshUpdateFlags): void;
    SetIndexBufferParams(indexCount: number, format: IndexFormat): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices<T>(indices: CSArray<T>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices<T>(indices: CSArray<T>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetIndices(indices: CSArray<number>, indicesStart: number, indicesLength: number, topology: MeshTopology, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetNormals(inNormals: CSArray<Vector3>): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetNormals(inNormals: CSArray<Vector3>): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number): void;
    SetNormals(inNormals: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetNormals<T>(inNormals: CSArray<T>): void;
    SetNormals<T>(inNormals: CSArray<T>, start: number, length: number): void;
    SetNormals<T>(inNormals: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetSubMesh(index: number, desc: SubMeshDescriptor, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes(desc: CSArray<SubMeshDescriptor>, flags: MeshUpdateFlags): void;
    SetSubMeshes<T>(desc: CSArray<T>, start: number, count: number, flags: MeshUpdateFlags): void;
    SetSubMeshes<T>(desc: CSArray<T>, flags: MeshUpdateFlags): void;
    SetTangents(inTangents: CSArray<Vector4>): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTangents(inTangents: CSArray<Vector4>): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number): void;
    SetTangents(inTangents: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTangents<T>(inTangents: CSArray<T>): void;
    SetTangents<T>(inTangents: CSArray<T>, start: number, length: number): void;
    SetTangents<T>(inTangents: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetTriangles(triangles: CSArray<number>, submesh: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetTriangles(triangles: CSArray<number>, trianglesStart: number, trianglesLength: number, submesh: number, calculateBounds: boolean, baseVertex: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector2>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number): void;
    SetUVs(channel: number, uvs: CSArray<Vector4>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>, start: number, length: number): void;
    SetUVs<T>(channel: number, uvs: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferData<T>(data: CSArray<T>, dataStart: number, meshBufferStart: number, count: number, stream: number, flags: MeshUpdateFlags): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertices(inVertices: CSArray<Vector3>): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertices(inVertices: CSArray<Vector3>): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number): void;
    SetVertices(inVertices: CSArray<Vector3>, start: number, length: number, flags: MeshUpdateFlags): void;
    SetVertices<T>(inVertices: CSArray<T>): void;
    SetVertices<T>(inVertices: CSArray<T>, start: number, length: number): void;
    SetVertices<T>(inVertices: CSArray<T>, start: number, length: number, flags: MeshUpdateFlags): void;
    UploadMeshData(markNoLongerReadable: boolean): void;
}
    
    
    
interface Color32 {
    r: number;
    g: number;
    b: number;
    a: number;
    Item: number;


    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Color32Constructor {

    new(r: number, g: number, b: number, a: number): Color32;

    Lerp(a: Color32, b: Color32, t: number): Color32;
    LerpUnclamped(a: Color32, b: Color32, t: number): Color32;
}
declare const Color32: Color32Constructor;
    
interface BoneWeight {
    weight0: number;
    weight1: number;
    weight2: number;
    weight3: number;
    boneIndex0: number;
    boneIndex1: number;
    boneIndex2: number;
    boneIndex3: number;


    Equals(other: unknown): boolean;
    Equals(other: BoneWeight): boolean;
    GetHashCode(): number;
}
    
interface CombineInstance {
    mesh: Mesh;
    subMeshIndex: number;
    transform: Matrix4x4;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;


}
    
interface BoneWeight1 {
    weight: number;
    boneIndex: number;


    Equals(other: unknown): boolean;
    Equals(other: BoneWeight1): boolean;
    GetHashCode(): number;
}
    
interface GraphicsBuffer {
    count: number;
    stride: number;
    target: Target;
    usageFlags: UsageFlags;
    bufferHandle: GraphicsBufferHandle;
    name: string;


    Dispose(): void;
    GetData(data: unknown): void;
    GetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    GetNativeBufferPtr(): unknown;
    IsValid(): boolean;
    LockBufferForWrite<T>(bufferStartIndex: number, count: number): CSArray<T>;
    Release(): void;
    SetCounterValue(counterValue: number): void;
    SetData(data: unknown): void;
    SetData<T>(data: CSArray<T>): void;
    SetData<T>(data: CSArray<T>): void;
    SetData(data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    UnlockBufferAfterWrite<T>(countWritten: number): void;
}
    
interface GraphicsBufferHandle {
    value: number;


    CompareTo(other: GraphicsBufferHandle): number;
    Equals(obj: unknown): boolean;
    Equals(other: GraphicsBufferHandle): boolean;
    GetHashCode(): number;
}
    
interface ComputeBuffer {
    count: number;
    stride: number;
    name: string;


    BeginWrite<T>(computeBufferStartIndex: number, count: number): CSArray<T>;
    Dispose(): void;
    EndWrite<T>(countWritten: number): void;
    GetData(data: unknown): void;
    GetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    GetNativeBufferPtr(): unknown;
    IsValid(): boolean;
    Release(): void;
    SetCounterValue(counterValue: number): void;
    SetData(data: unknown): void;
    SetData<T>(data: CSArray<T>): void;
    SetData<T>(data: CSArray<T>): void;
    SetData(data: unknown, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, managedBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
    SetData<T>(data: CSArray<T>, nativeBufferStartIndex: number, computeBufferStartIndex: number, count: number): void;
}
    
interface ComputeBufferConstructor {

    new(count: number, stride: number): ComputeBuffer;
    new(count: number, stride: number, type: ComputeBufferType): ComputeBuffer;
    new(count: number, stride: number, type: ComputeBufferType, usage: ComputeBufferMode): ComputeBuffer;

    CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
}
declare const ComputeBuffer: ComputeBufferConstructor;
    
interface GraphicsBufferConstructor {

    new(target: Target, count: number, stride: number): GraphicsBuffer;
    new(target: Target, usageFlags: UsageFlags, count: number, stride: number): GraphicsBuffer;

    CopyCount(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCount(src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCount(src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyCount(src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
}
declare const GraphicsBuffer: GraphicsBufferConstructor;
    
interface BlendShapeBufferRange {
    startIndex: number;
    endIndex: number;


}
    
interface SubMeshDescriptor {
    bounds: Bounds;
    topology: MeshTopology;
    indexStart: number;
    indexCount: number;
    baseVertex: number;
    firstVertex: number;
    vertexCount: number;


    ToString(): string;
}
    
interface SubMeshDescriptorConstructor {

    new(indexStart: number, indexCount: number, topology: MeshTopology): SubMeshDescriptor;

}
declare const SubMeshDescriptor: SubMeshDescriptorConstructor;
    
interface VertexAttributeDescriptor {
    attribute: VertexAttribute;
    format: VertexAttributeFormat;
    dimension: number;
    stream: number;


    Equals(other: unknown): boolean;
    Equals(other: VertexAttributeDescriptor): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface VertexAttributeDescriptorConstructor {

    new(attribute: VertexAttribute, format: VertexAttributeFormat, dimension: number, stream: number): VertexAttributeDescriptor;

}
declare const VertexAttributeDescriptor: VertexAttributeDescriptorConstructor;
    
interface MeshDataArray {
    Length: number;
    Item: MeshData;


    Dispose(): void;
}
    
interface MeshData {
    vertexCount: number;
    vertexBufferCount: number;
    indexFormat: IndexFormat;
    subMeshCount: number;


    GetColors(outColors: CSArray<Color>): void;
    GetColors(outColors: CSArray<Color32>): void;
    GetIndexData<T>(): CSArray<T>;
    GetIndices(outIndices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetIndices(outIndices: CSArray<number>, submesh: number, applyBaseVertex: boolean): void;
    GetNormals(outNormals: CSArray<Vector3>): void;
    GetSubMesh(index: number): SubMeshDescriptor;
    GetTangents(outTangents: CSArray<Vector4>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector2>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector3>): void;
    GetUVs(channel: number, outUVs: CSArray<Vector4>): void;
    GetVertexAttributeDimension(attr: VertexAttribute): number;
    GetVertexAttributeFormat(attr: VertexAttribute): VertexAttributeFormat;
    GetVertexAttributeOffset(attr: VertexAttribute): number;
    GetVertexAttributeStream(attr: VertexAttribute): number;
    GetVertexBufferStride(stream: number): number;
    GetVertexData<T>(stream: number): CSArray<T>;
    GetVertices(outVertices: CSArray<Vector3>): void;
    HasVertexAttribute(attr: VertexAttribute): boolean;
    SetIndexBufferParams(indexCount: number, format: IndexFormat): void;
    SetSubMesh(index: number, desc: SubMeshDescriptor, flags: MeshUpdateFlags): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
    SetVertexBufferParams(vertexCount: number, attributes: CSArray<VertexAttributeDescriptor>): void;
}
    
interface MeshConstructor {

    new(): Mesh;

    AcquireReadOnlyMeshData(mesh: Mesh): MeshDataArray;
    AcquireReadOnlyMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AcquireReadOnlyMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AllocateWritableMeshData(meshCount: number): MeshDataArray;
    AllocateWritableMeshData(mesh: Mesh): MeshDataArray;
    AllocateWritableMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    AllocateWritableMeshData(meshes: CSArray<Mesh>): MeshDataArray;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, mesh: Mesh, flags: MeshUpdateFlags): void;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, meshes: CSArray<Mesh>, flags: MeshUpdateFlags): void;
    ApplyAndDisposeWritableMeshData(data: MeshDataArray, meshes: CSArray<Mesh>, flags: MeshUpdateFlags): void;
}
declare const Mesh: MeshConstructor;
    
interface Collider2DConstructor {

    new(): Collider2D;

}
declare const Collider2D: Collider2DConstructor;
    
interface PhysicsScene2DConstructor {


    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(position: Vector2, angle: number, collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapCollider(position: Vector2, angle: number, collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
}
declare const PhysicsScene2D: PhysicsScene2DConstructor;
    
interface PhysicsJobOptions2D {
    useMultithreading: boolean;
    useConsistencySorting: boolean;
    interpolationPosesPerJob: number;
    newContactsPerJob: number;
    collideContactsPerJob: number;
    clearFlagsPerJob: number;
    clearBodyForcesPerJob: number;
    syncDiscreteFixturesPerJob: number;
    syncContinuousFixturesPerJob: number;
    findNearestContactsPerJob: number;
    updateTriggerContactsPerJob: number;
    islandSolverCostThreshold: number;
    islandSolverBodyCostScale: number;
    islandSolverContactCostScale: number;
    islandSolverJointCostScale: number;
    islandSolverBodiesPerJob: number;
    islandSolverContactsPerJob: number;


}
    
interface Physics2DConstructor {
    IgnoreRaycastLayer: number;
    DefaultRaycastLayers: number;
    AllLayers: number;
    MaxPolygonShapeVertices: number;
    defaultPhysicsScene: PhysicsScene2D;
    velocityIterations: number;
    positionIterations: number;
    gravity: Vector2;
    queriesHitTriggers: boolean;
    queriesStartInColliders: boolean;
    callbacksOnDisable: boolean;
    reuseCollisionCallbacks: boolean;
    autoSyncTransforms: boolean;
    simulationMode: SimulationMode2D;
    simulationLayers: LayerMask;
    useSubStepping: boolean;
    useSubStepContacts: boolean;
    minSubStepFPS: number;
    maxSubStepCount: number;
    jobOptions: PhysicsJobOptions2D;
    bounceThreshold: number;
    maxLinearCorrection: number;
    maxAngularCorrection: number;
    maxTranslationSpeed: number;
    maxRotationSpeed: number;
    defaultContactOffset: number;
    baumgarteScale: number;
    baumgarteTOIScale: number;
    timeToSleep: number;
    linearSleepTolerance: number;
    angularSleepTolerance: number;
    raycastsHitTriggers: boolean;
    raycastsStartInColliders: boolean;
    deleteStopsCallbacks: boolean;
    changeStopsCallbacks: boolean;
    minPenetrationForPenalty: number;
    velocityThreshold: number;
    autoSimulation: boolean;
    colliderAwakeColor: Color;
    colliderAsleepColor: Color;
    colliderContactColor: Color;
    colliderAABBColor: Color;
    contactArrowScale: number;
    alwaysShowColliders: boolean;
    showCollidersFilled: boolean;
    showColliderSleep: boolean;
    showColliderContacts: boolean;
    showColliderAABB: boolean;

    new(): Physics2D;

    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    BoxCast(origin: Vector2, size: Vector2, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    BoxCastAll(origin: Vector2, size: Vector2, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>): number;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    BoxCastNonAlloc(origin: Vector2, size: Vector2, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CapsuleCast(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    CapsuleCastAll(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>): number;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    CapsuleCastNonAlloc(origin: Vector2, size: Vector2, capsuleDirection: CapsuleDirection2D, angle: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CircleCast(origin: Vector2, radius: number, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    CircleCastAll(origin: Vector2, radius: number, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>): number;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    CircleCastNonAlloc(origin: Vector2, radius: number, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    ClosestPoint(position: Vector2, collider: Collider2D): Vector2;
    ClosestPoint(position: Vector2, rigidbody: Rigidbody2D): Vector2;
    Distance(colliderA: Collider2D, colliderB: Collider2D): ColliderDistance2D;
    Distance(colliderA: Collider2D, positionA: Vector2, angleA: number, colliderB: Collider2D, positionB: Vector2, angleB: number): ColliderDistance2D;
    GetContacts(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(collider: Collider2D, colliders: CSArray<Collider2D>): number;
    GetContacts(collider: Collider2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, contacts: CSArray<ContactPoint2D>): number;
    GetContacts(rigidbody: Rigidbody2D, colliders: CSArray<Collider2D>): number;
    GetContacts(rigidbody: Rigidbody2D, contactFilter: ContactFilter2D, colliders: CSArray<Collider2D>): number;
    GetIgnoreCollision(collider1: Collider2D, collider2: Collider2D): boolean;
    GetIgnoreLayerCollision(layer1: number, layer2: number): boolean;
    GetLayerCollisionMask(layer: number): number;
    GetRayIntersection(ray: Ray): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number, layerMask: number): RaycastHit2D;
    GetRayIntersection(ray: Ray, distance: number, results: CSArray<RaycastHit2D>, layerMask: number): number;
    GetRayIntersectionAll(ray: Ray): CSArray<RaycastHit2D>;
    GetRayIntersectionAll(ray: Ray, distance: number): CSArray<RaycastHit2D>;
    GetRayIntersectionAll(ray: Ray, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    GetRayIntersectionNonAlloc(ray: Ray, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    GetRayIntersectionNonAlloc(ray: Ray, results: CSArray<RaycastHit2D>): number;
    GetRayIntersectionNonAlloc(ray: Ray, results: CSArray<RaycastHit2D>, distance: number): number;
    IgnoreCollision(collider1: Collider2D, collider2: Collider2D): void;
    IgnoreCollision(collider1: Collider2D, collider2: Collider2D, ignore: boolean): void;
    IgnoreLayerCollision(layer1: number, layer2: number): void;
    IgnoreLayerCollision(layer1: number, layer2: number, ignore: boolean): void;
    IsTouching(collider1: Collider2D, collider2: Collider2D): boolean;
    IsTouching(collider1: Collider2D, collider2: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouching(collider: Collider2D, contactFilter: ContactFilter2D): boolean;
    IsTouchingLayers(collider: Collider2D): boolean;
    IsTouchingLayers(collider: Collider2D, layerMask: number): boolean;
    Linecast(start: Vector2, end: Vector2): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number, minDepth: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Linecast(start: Vector2, end: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    LinecastAll(start: Vector2, end: Vector2): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    LinecastAll(start: Vector2, end: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    LinecastNonAlloc(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>): number;
    LinecastNonAlloc(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number): number;
    LinecastNonAlloc(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number, minDepth: number): number;
    LinecastNonAlloc(start: Vector2, end: Vector2, results: CSArray<RaycastHit2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapArea(pointA: Vector2, pointB: Vector2): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapArea(pointA: Vector2, pointB: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapAreaAll(pointA: Vector2, pointB: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapAreaNonAlloc(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>): number;
    OverlapAreaNonAlloc(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapAreaNonAlloc(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapAreaNonAlloc(pointA: Vector2, pointB: Vector2, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBox(point: Vector2, size: Vector2, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapBoxAll(point: Vector2, size: Vector2, angle: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapBoxNonAlloc(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>): number;
    OverlapBoxNonAlloc(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapBoxNonAlloc(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapBoxNonAlloc(point: Vector2, size: Vector2, angle: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsule(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapCapsuleAll(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapCapsuleNonAlloc(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>): number;
    OverlapCapsuleNonAlloc(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCapsuleNonAlloc(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapCapsuleNonAlloc(point: Vector2, size: Vector2, direction: CapsuleDirection2D, angle: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapCircle(point: Vector2, radius: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number, minDepth: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircle(point: Vector2, radius: number, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCircleAll(point: Vector2, radius: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapCircleAll(point: Vector2, radius: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapCircleNonAlloc(point: Vector2, radius: number, results: CSArray<Collider2D>): number;
    OverlapCircleNonAlloc(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapCircleNonAlloc(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapCircleNonAlloc(point: Vector2, radius: number, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapCollider(collider: Collider2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number, minDepth: number): Collider2D;
    OverlapPoint(point: Vector2, layerMask: number, minDepth: number, maxDepth: number): Collider2D;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPoint(point: Vector2, contactFilter: ContactFilter2D, results: CSArray<Collider2D>): number;
    OverlapPointAll(point: Vector2): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number, minDepth: number): CSArray<Collider2D>;
    OverlapPointAll(point: Vector2, layerMask: number, minDepth: number, maxDepth: number): CSArray<Collider2D>;
    OverlapPointNonAlloc(point: Vector2, results: CSArray<Collider2D>): number;
    OverlapPointNonAlloc(point: Vector2, results: CSArray<Collider2D>, layerMask: number): number;
    OverlapPointNonAlloc(point: Vector2, results: CSArray<Collider2D>, layerMask: number, minDepth: number): number;
    OverlapPointNonAlloc(point: Vector2, results: CSArray<Collider2D>, layerMask: number, minDepth: number, maxDepth: number): number;
    Raycast(origin: Vector2, direction: Vector2): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): RaycastHit2D;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>): number;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    Raycast(origin: Vector2, direction: Vector2, contactFilter: ContactFilter2D, results: CSArray<RaycastHit2D>, distance: number): number;
    RaycastAll(origin: Vector2, direction: Vector2): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number): CSArray<RaycastHit2D>;
    RaycastAll(origin: Vector2, direction: Vector2, distance: number, layerMask: number, minDepth: number, maxDepth: number): CSArray<RaycastHit2D>;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number): number;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>): number;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number): number;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number): number;
    RaycastNonAlloc(origin: Vector2, direction: Vector2, results: CSArray<RaycastHit2D>, distance: number, layerMask: number, minDepth: number, maxDepth: number): number;
    SetLayerCollisionMask(layer: number, layerMask: number): void;
    Simulate(deltaTime: number): boolean;
    Simulate(deltaTime: number, simulationLayers: number): boolean;
    SyncTransforms(): void;
}
declare const Physics2D: Physics2DConstructor;
    
interface MonoBehaviour extends Behaviour {
    destroyCancellationToken: unknown;
    useGUILayout: boolean;
    didStart: boolean;
    didAwake: boolean;
    runInEditMode: boolean;


    CancelInvoke(): void;
    CancelInvoke(methodName: string): void;
    Invoke(methodName: string, time: number): void;
    InvokeRepeating(methodName: string, time: number, repeatRate: number): void;
    IsInvoking(): boolean;
    IsInvoking(methodName: string): boolean;
    StartCoroutine(methodName: string): Coroutine;
    StartCoroutine(methodName: string, value: unknown): Coroutine;
    StartCoroutine(routine: unknown): Coroutine;
    StartCoroutine_Auto(routine: unknown): Coroutine;
    StopAllCoroutines(): void;
    StopCoroutine(routine: unknown): void;
    StopCoroutine(routine: Coroutine): void;
    StopCoroutine(methodName: string): void;
}
    
interface YieldInstruction {


}
    
interface YieldInstructionConstructor {

    new(): YieldInstruction;

}
declare const YieldInstruction: YieldInstructionConstructor;
    
interface Coroutine extends YieldInstruction {


}
    
interface MonoBehaviourConstructor {

    new(): MonoBehaviour;

    print(message: unknown): void;
}
declare const MonoBehaviour: MonoBehaviourConstructor;
    
interface Debug {


}
    
interface StartupLog {
    timestamp: number;
    logType: LogType;
    message: string;


}
    
interface DebugConstructor {
    unityLogger: unknown;
    developerConsoleEnabled: boolean;
    developerConsoleVisible: boolean;
    isDebugBuild: boolean;
    logger: unknown;

    new(): Debug;

    Assert(condition: boolean): void;
    Assert(condition: boolean, context: Object): void;
    Assert(condition: boolean, message: unknown): void;
    Assert(condition: boolean, message: string): void;
    Assert(condition: boolean, message: unknown, context: Object): void;
    Assert(condition: boolean, message: string, context: Object): void;
    Assert(condition: boolean, format: string, args: CSArray<unknown>): void;
    AssertFormat(condition: boolean, format: string, args: CSArray<unknown>): void;
    AssertFormat(condition: boolean, context: Object, format: string, args: CSArray<unknown>): void;
    Break(): void;
    ClearDeveloperConsole(): void;
    DebugBreak(): void;
    DrawLine(start: Vector3, end: Vector3, color: Color, duration: number): void;
    DrawLine(start: Vector3, end: Vector3, color: Color): void;
    DrawLine(start: Vector3, end: Vector3): void;
    DrawLine(start: Vector3, end: Vector3, color: Color, duration: number, depthTest: boolean): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color): void;
    DrawRay(start: Vector3, dir: Vector3): void;
    DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number, depthTest: boolean): void;
    ExtractStackTraceNoAlloc(buffer: unknown, bufferMax: number, projectFolder: string): number;
    Log(message: unknown): void;
    Log(message: unknown, context: Object): void;
    LogAssertion(message: unknown): void;
    LogAssertion(message: unknown, context: Object): void;
    LogAssertionFormat(format: string, args: CSArray<unknown>): void;
    LogAssertionFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogError(message: unknown): void;
    LogError(message: unknown, context: Object): void;
    LogErrorFormat(format: string, args: CSArray<unknown>): void;
    LogErrorFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogException(exception: unknown): void;
    LogException(exception: unknown, context: Object): void;
    LogFormat(format: string, args: CSArray<unknown>): void;
    LogFormat(context: Object, format: string, args: CSArray<unknown>): void;
    LogFormat(logType: LogType, logOptions: LogOption, context: Object, format: string, args: CSArray<unknown>): void;
    LogWarning(message: unknown): void;
    LogWarning(message: unknown, context: Object): void;
    LogWarningFormat(format: string, args: CSArray<unknown>): void;
    LogWarningFormat(context: Object, format: string, args: CSArray<unknown>): void;
    RetrieveStartupLogs(): CSArray<StartupLog>;
}
declare const Debug: DebugConstructor;
    
interface Sprite extends Object {
    bounds: Bounds;
    rect: Rect;
    border: Vector4;
    texture: Texture2D;
    pixelsPerUnit: number;
    spriteAtlasTextureScale: number;
    associatedAlphaSplitTexture: Texture2D;
    pivot: Vector2;
    packed: boolean;
    packingMode: SpritePackingMode;
    packingRotation: SpritePackingRotation;
    textureRect: Rect;
    textureRectOffset: Vector2;
    vertices: CSArray<Vector2>;
    triangles: CSArray<number>;
    uv: CSArray<Vector2>;


    AddScriptableObject(obj: ScriptableObject): boolean;
    GetPhysicsShape(shapeIdx: number, physicsShape: CSArray<Vector2>): number;
    GetPhysicsShapeCount(): number;
    GetPhysicsShapePointCount(shapeIdx: number): number;
    GetScriptableObjects(scriptableObjects: CSArray<ScriptableObject>): number;
    GetScriptableObjectsCount(): number;
    GetSecondaryTextureCount(): number;
    GetSecondaryTextures(secondaryTexture: CSArray<SecondarySpriteTexture>): number;
    OverrideGeometry(vertices: CSArray<Vector2>, triangles: CSArray<number>): void;
    OverridePhysicsShape(physicsShapes: CSArray<CSArray<Vector2>>): void;
    RemoveScriptableObjectAt(i: number): boolean;
    SetScriptableObjectAt(obj: ScriptableObject, i: number): boolean;
}
    
interface Rect {
    x: number;
    y: number;
    position: Vector2;
    center: Vector2;
    min: Vector2;
    max: Vector2;
    width: number;
    height: number;
    size: Vector2;
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
    left: number;
    right: number;
    top: number;
    bottom: number;


    Contains(point: Vector2): boolean;
    Contains(point: Vector3): boolean;
    Contains(point: Vector3, allowInverse: boolean): boolean;
    Equals(other: unknown): boolean;
    Equals(other: Rect): boolean;
    GetHashCode(): number;
    Overlaps(other: Rect): boolean;
    Overlaps(other: Rect, allowInverse: boolean): boolean;
    Set(x: number, y: number, width: number, height: number): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface RectConstructor {
    zero: Rect;

    new(x: number, y: number, width: number, height: number): Rect;
    new(position: Vector2, size: Vector2): Rect;
    new(source: Rect): Rect;

    MinMaxRect(xmin: number, ymin: number, xmax: number, ymax: number): Rect;
    NormalizedToPoint(rectangle: Rect, normalizedRectCoordinates: Vector2): Vector2;
    PointToNormalized(rectangle: Rect, point: Vector2): Vector2;
}
declare const Rect: RectConstructor;
    
interface Texture extends Object {
    mipmapCount: number;
    graphicsFormat: GraphicsFormat;
    width: number;
    height: number;
    dimension: TextureDimension;
    isReadable: boolean;
    wrapMode: TextureWrapMode;
    wrapModeU: TextureWrapMode;
    wrapModeV: TextureWrapMode;
    wrapModeW: TextureWrapMode;
    filterMode: FilterMode;
    anisoLevel: number;
    mipMapBias: number;
    texelSize: Vector2;
    updateCount: number;
    isDataSRGB: boolean;
    imageContentsHash: Hash128;
    graphicsTexture: GraphicsTexture;


    GetNativeTextureID(): number;
    GetNativeTexturePtr(): unknown;
    IncrementUpdateCount(): void;
}
    
interface Hash128 {
    isValid: boolean;


    Append(data: string): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(data: CSArray<T>): void;
    Append<T>(data: CSArray<T>, start: number, count: number): void;
    Append<T>(val: unknown): void;
    Append(val: number): void;
    Append(val: number): void;
    Append(data: unknown, size: number): void;
    CompareTo(rhs: Hash128): number;
    CompareTo(obj: unknown): number;
    Equals(obj: unknown): boolean;
    Equals(obj: Hash128): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface Hash128Constructor {

    new(u32_0: number, u32_1: number, u32_2: number, u32_3: number): Hash128;
    new(u64_0: number, u64_1: number): Hash128;

    Compute(data: string): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(data: CSArray<T>): Hash128;
    Compute<T>(data: CSArray<T>, start: number, count: number): Hash128;
    Compute<T>(val: unknown): Hash128;
    Compute(val: number): Hash128;
    Compute(val: number): Hash128;
    Compute(data: unknown, size: number): Hash128;
    Parse(hashString: string): Hash128;
}
declare const Hash128: Hash128Constructor;
    
interface GraphicsTexture {
    descriptor: GraphicsTextureDescriptor;
    state: GraphicsTextureState;


    Dispose(): void;
}
    
interface GraphicsTextureDescriptor {
    width: number;
    height: number;
    depth: number;
    arrayLength: number;
    format: GraphicsFormat;
    dimension: TextureDimension;
    mipCount: number;
    numSamples: number;
    flags: GraphicsTextureDescriptorFlags;


}
    
interface GraphicsTextureConstructor {
    active: GraphicsTexture;

    new(desc: GraphicsTextureDescriptor): GraphicsTexture;

}
declare const GraphicsTexture: GraphicsTextureConstructor;
    
interface TextureConstructor {
    GenerateAllMips: number;
    masterTextureLimit: number;
    globalMipmapLimit: number;
    anisotropicFiltering: AnisotropicFiltering;
    totalTextureMemory: number;
    desiredTextureMemory: number;
    targetTextureMemory: number;
    currentTextureMemory: number;
    nonStreamingTextureMemory: number;
    streamingMipmapUploadCount: number;
    streamingRendererCount: number;
    streamingTextureCount: number;
    nonStreamingTextureCount: number;
    streamingTexturePendingLoadCount: number;
    streamingTextureLoadingCount: number;
    streamingTextureForceLoadAll: boolean;
    streamingTextureDiscardUnusedMips: boolean;
    allowThreadedTextureCreation: boolean;


    SetGlobalAnisotropicFilteringLimits(forcedMin: number, globalMax: number): void;
    SetStreamingTextureMaterialDebugProperties(): void;
}
declare const Texture: TextureConstructor;
    
interface Texture2D extends Texture {
    format: TextureFormat;
    mipmapLimitGroup: string;
    activeMipmapLimit: number;
    isReadable: boolean;
    vtOnly: boolean;
    streamingMipmaps: boolean;
    streamingMipmapsPriority: number;
    requestedMipmapLevel: number;
    minimumMipmapLevel: number;
    calculatedMipmapLevel: number;
    desiredMipmapLevel: number;
    loadingMipmapLevel: number;
    loadedMipmapLevel: number;
    alphaIsTransparency: boolean;
    ignoreMipmapLimit: boolean;


    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    ClearMinimumMipmapLevel(): void;
    ClearRequestedMipmapLevel(): void;
    Compress(highQuality: boolean): void;
    GetPixel(x: number, y: number): Color;
    GetPixel(x: number, y: number, mipLevel: number): Color;
    GetPixelBilinear(u: number, v: number): Color;
    GetPixelBilinear(u: number, v: number, mipLevel: number): Color;
    GetPixelData<T>(mipLevel: number): CSArray<T>;
    GetPixels(x: number, y: number, blockWidth: number, blockHeight: number, miplevel: number): CSArray<Color>;
    GetPixels(x: number, y: number, blockWidth: number, blockHeight: number): CSArray<Color>;
    GetPixels(miplevel: number): CSArray<Color>;
    GetPixels(): CSArray<Color>;
    GetPixels32(miplevel: number): CSArray<Color32>;
    GetPixels32(): CSArray<Color32>;
    GetRawTextureData(): CSArray<number>;
    GetRawTextureData<T>(): CSArray<T>;
    IsRequestedMipmapLevelLoaded(): boolean;
    LoadRawTextureData(data: unknown, size: number): void;
    LoadRawTextureData(data: CSArray<number>): void;
    LoadRawTextureData<T>(data: CSArray<T>): void;
    PackTextures(textures: CSArray<Texture2D>, padding: number, maximumAtlasSize: number, makeNoLongerReadable: boolean): CSArray<Rect>;
    PackTextures(textures: CSArray<Texture2D>, padding: number, maximumAtlasSize: number): CSArray<Rect>;
    PackTextures(textures: CSArray<Texture2D>, padding: number): CSArray<Rect>;
    ReadPixels(source: Rect, destX: number, destY: number, recalculateMipMaps: boolean): void;
    ReadPixels(source: Rect, destX: number, destY: number): void;
    Reinitialize(width: number, height: number): boolean;
    Reinitialize(width: number, height: number, format: TextureFormat, hasMipMap: boolean): boolean;
    Reinitialize(width: number, height: number, format: GraphicsFormat, hasMipMap: boolean): boolean;
    Resize(width: number, height: number): boolean;
    Resize(width: number, height: number, format: TextureFormat, hasMipMap: boolean): boolean;
    Resize(width: number, height: number, format: GraphicsFormat, hasMipMap: boolean): boolean;
    SetPixel(x: number, y: number, color: Color): void;
    SetPixel(x: number, y: number, color: Color, mipLevel: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color>, miplevel: number): void;
    SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color>): void;
    SetPixels(colors: CSArray<Color>, miplevel: number): void;
    SetPixels(colors: CSArray<Color>): void;
    SetPixels32(colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(colors: CSArray<Color32>): void;
    SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: CSArray<Color32>): void;
    UpdateExternalTexture(nativeTex: unknown): void;
}
    
interface Texture2DConstructor {
    whiteTexture: Texture2D;
    blackTexture: Texture2D;
    redTexture: Texture2D;
    grayTexture: Texture2D;
    linearGrayTexture: Texture2D;
    normalTexture: Texture2D;

    new(width: number, height: number, format: DefaultFormat, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, mipmapLimitGroupName: string, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: DefaultFormat, mipCount: number, flags: TextureCreationFlags, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, mipmapLimitGroupName: string, flags: TextureCreationFlags): Texture2D;
    new(width: number, height: number, format: GraphicsFormat, mipCount: number, flags: TextureCreationFlags, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean, mipmapLimitDescriptor: MipmapLimitDescriptor): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipCount: number, linear: boolean, createUninitialized: boolean, ignoreMipmapLimit: boolean, mipmapLimitGroupName: string): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean, linear: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean, linear: boolean, createUninitialized: boolean): Texture2D;
    new(width: number, height: number, textureFormat: TextureFormat, mipChain: boolean): Texture2D;
    new(width: number, height: number): Texture2D;

    CreateExternalTexture(width: number, height: number, format: TextureFormat, mipChain: boolean, linear: boolean, nativeTex: unknown): Texture2D;
    GenerateAtlas(sizes: CSArray<Vector2>, padding: number, atlasSize: number, results: CSArray<Rect>): boolean;
}
declare const Texture2D: Texture2DConstructor;
    
interface ScriptableObject extends Object {


    SetDirty(): void;
}
    
interface ScriptableObjectConstructor {

    new(): ScriptableObject;

    CreateInstance(className: string): ScriptableObject;
    CreateInstance(type: unknown): ScriptableObject;
    CreateInstance<T>(): T;
}
declare const ScriptableObject: ScriptableObjectConstructor;
    
interface SecondarySpriteTexture {
    name: string;
    texture: Texture2D;


}
    
interface SpriteConstructor {


    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: boolean): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4, generateFallbackPhysicsShape: boolean, secondaryTextures: CSArray<SecondarySpriteTexture>): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType, border: Vector4): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: SpriteMeshType): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number): Sprite;
    Create(texture: Texture2D, rect: Rect, pivot: Vector2): Sprite;
}
declare const Sprite: SpriteConstructor;
    
interface TextAsset extends Object {
    bytes: CSArray<number>;
    text: string;
    dataSize: number;


    GetData<T>(): CSArray<T>;
    ToString(): string;
}
    
interface TextAssetConstructor {

    new(): TextAsset;
    new(text: string): TextAsset;

}
declare const TextAsset: TextAssetConstructor;
    
interface Resources {


}
    
interface AsyncOperation extends YieldInstruction {
    isDone: boolean;
    progress: number;
    priority: number;
    allowSceneActivation: boolean;


}
    
interface AsyncOperationConstructor {

    new(): AsyncOperation;

}
declare const AsyncOperation: AsyncOperationConstructor;
    
interface ResourceRequest extends AsyncOperation {
    asset: Object;


}
    
interface ResourceRequestConstructor {

    new(): ResourceRequest;

}
declare const ResourceRequest: ResourceRequestConstructor;
    
interface ResourcesConstructor {

    new(): Resources;

    FindObjectsOfTypeAll(type: unknown): CSArray<Object>;
    FindObjectsOfTypeAll<T>(): CSArray<T>;
    GetBuiltinResource(type: unknown, path: string): Object;
    GetBuiltinResource<T>(path: string): T;
    InstanceIDIsValid(instanceId: number): boolean;
    InstanceIDsToValidArray(instanceIDs: CSArray<number>, validArray: CSArray<boolean>): void;
    InstanceIDsToValidArray(instanceIDs: unknown, validArray: unknown): void;
    InstanceIDToObject(instanceID: number): Object;
    InstanceIDToObjectList(instanceIDs: CSArray<number>, objects: CSArray<Object>): void;
    Load(path: string): Object;
    Load<T>(path: string): T;
    Load(path: string, systemTypeInstance: unknown): Object;
    LoadAll(path: string, systemTypeInstance: unknown): CSArray<Object>;
    LoadAll(path: string): CSArray<Object>;
    LoadAll<T>(path: string): CSArray<T>;
    LoadAssetAtPath(assetPath: string, type: unknown): Object;
    LoadAssetAtPath<T>(assetPath: string): T;
    LoadAsync(path: string): ResourceRequest;
    LoadAsync<T>(path: string): ResourceRequest;
    LoadAsync(path: string, type: unknown): ResourceRequest;
    UnloadAsset(assetToUnload: Object): void;
    UnloadUnusedAssets(): AsyncOperation;
}
declare const Resources: ResourcesConstructor;
    
interface AgonesCore {


}
    
interface AgonesProxy extends MonoBehaviour {


    Connect(): void;
    Ready(): void;
    Shutdown(): void;
}
    
interface AgonesProxyConstructor {

    new(): AgonesProxy;

}
declare const AgonesProxy: AgonesProxyConstructor;
    
interface AgonesCoreConstructor {
    Agones: AgonesProxy;

    new(): AgonesCore;

    SetAgonesProxy(agones: AgonesProxy): void;
}
declare const AgonesCore: AgonesCoreConstructor;
    
interface RunCore {


}
    
interface RunCoreConstructor {
    launchInDedicatedServerMode: boolean;

    new(): RunCore;

    IsClient(): boolean;
    IsClone(): boolean;
    IsEditor(): boolean;
    IsServer(): boolean;
    OnLoad(): void;
}
declare const RunCore: RunCoreConstructor;
    
interface NetworkCore {


}
    
interface Net extends MonoBehaviour {


    BroadcastToAllClients(blob: BinaryBlob, reliable: number): void;
    BroadcastToAllExceptClient(ignoredClientId: number, blob: BinaryBlob, reliable: number): void;
    BroadcastToClient(clientId: number, blob: BinaryBlob, reliable: number): void;
    BroadcastToClients(clientIds: CSArray<number>, blob: BinaryBlob, reliable: number): void;
    BroadcastToServer(blob: BinaryBlob, reliable: number): void;
}
    
interface BinaryBlob {
    m_dataSize: number;
    m_data: CSArray<number>;


    GetDictionary(): CSDictionary<unknown, unknown>;
}
    
interface BinaryBlobConstructor {

    new(): BinaryBlob;
    new(bytes: CSArray<number>): BinaryBlob;

}
declare const BinaryBlob: BinaryBlobConstructor;
    
interface NetConstructor {

    new(): Net;

}
declare const Net: NetConstructor;
    
interface NetworkManager extends MonoBehaviour {
    Initialized: boolean;
    IsServer: boolean;
    IsServerOnly: boolean;
    IsClient: boolean;
    IsClientOnly: boolean;
    IsHost: boolean;
    IsOffline: boolean;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    ObserverManager: ObserverManager;
    Authenticator: Authenticator;
    DebugManager: DebugManager;
    StatisticsManager: StatisticsManager;
    ObjectPool: ObjectPool;
    RollbackManager: RollbackManager;
    SpawnablePrefabs: PrefabObjects;
    RuntimeSpawnablePrefabs: CSDictionary<number, PrefabObjects>;


    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    CanLog(loggingType: LoggingType): boolean;
    GetInstance<T>(): T;
    GetInstance<T>(warn: boolean): T;
    GetPooledInstantiated(prefab: NetworkObject, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: NetworkObject, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: NetworkObject, collectionId: number, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: GameObject, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: GameObject, collectionId: number, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefab: GameObject, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefabId: number, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    GetPooledInstantiated(prefabId: number, collectionId: number, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    GetPrefab(prefabId: number, asServer: boolean): NetworkObject;
    GetPrefabIndex(prefab: GameObject, asServer: boolean): number;
    GetPrefabObjects<T>(spawnableCollectionId: number, createIfMissing: boolean): PrefabObjects;
    HasInstance<T>(): boolean;
    Log(value: string): void;
    Log(loggingType: LoggingType, value: string): void;
    LogError(value: string): void;
    LogWarning(value: string): void;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    RemoveSpawnableCollection(spawnableCollectionId: number): boolean;
    StorePooledInstantiated(instantiated: NetworkObject, prefabId: number, asServer: boolean): void;
    StorePooledInstantiated(instantiated: NetworkObject, asServer: boolean): void;
    TryGetInstance<T>(result: unknown): boolean;
    TryRegisterInstance<T>(component: T): boolean;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
}
    
interface ServerManager extends MonoBehaviour {
    Clients: CSDictionary<number, NetworkConnection>;
    Started: boolean;
    Objects: ServerObjects;
    NetworkManager: NetworkManager;
    Authenticator: Authenticator;


    AnyServerStarted(excludedIndex: unknown): boolean;
    Broadcast<T>(connection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(connections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(networkObject: NetworkObject, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Broadcast<T>(message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(connections: CSArray<NetworkConnection>, excludedConnection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(connections: CSArray<NetworkConnection>, excludedConnections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(excludedConnection: NetworkConnection, message: T, requireAuthenticated: boolean, channel: Channel): void;
    BroadcastExcept<T>(excludedConnections: CSArray<NetworkConnection>, message: T, requireAuthenticated: boolean, channel: Channel): void;
    Despawn(go: GameObject, despawnType: unknown): void;
    Despawn(networkObject: NetworkObject, despawnType: unknown): void;
    GetAuthenticator(): Authenticator;
    GetStartOnHeadless(): boolean;
    Kick(conn: NetworkConnection, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(clientId: number, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(conn: NetworkConnection, reader: Reader, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    OneServerStarted(): boolean;
    RegisterBroadcast<T>(handler: unknown, requireAuthentication: boolean): void;
    SetAuthenticator(value: Authenticator): void;
    SetRemoteClientTimeout(timeoutType: RemoteTimeoutType, duration: number): void;
    SetStartOnHeadless(value: boolean): void;
    Spawn(go: GameObject, ownerConnection: NetworkConnection, scene: Scene): void;
    Spawn(nob: NetworkObject, ownerConnection: NetworkConnection, scene: Scene): void;
    StartConnection(): boolean;
    StartConnection(port: number): boolean;
    StopConnection(sendDisconnectMessage: boolean): boolean;
    UnregisterBroadcast<T>(handler: unknown): void;
}
    
interface NetworkConnection {
    ClientId: number;
    Objects: CSArray<NetworkObject>;
    CustomData: unknown;
    PacketTick: EstimatedTick;
    LocalTick: EstimatedTick;
    LevelOfDetails: CSDictionary<NetworkObject, LevelOfDetailData>;
    NetworkManager: NetworkManager;
    TransportIndex: number;
    Authenticated: boolean;
    IsActive: boolean;
    IsValid: boolean;
    FirstObject: NetworkObject;
    Scenes: CSArray<Scene>;
    Disconnecting: boolean;
    Tick: number;
    LocalReplicateTick: number;
    IsHost: boolean;
    IsLocalClient: boolean;


    Broadcast<T>(message: T, requireAuthenticated: boolean, channel: Channel): void;
    Disconnect(immediately: boolean): void;
    Equals(obj: unknown): boolean;
    Equals(nc: NetworkConnection): boolean;
    GetAddress(): string;
    GetHashCode(): number;
    Kick(kickReason: KickReason, loggingType: LoggingType, log: string): void;
    Kick(reader: Reader, kickReason: KickReason, loggingType: LoggingType, log: string): void;
    LoadedStartScenes(): boolean;
    LoadedStartScenes(asServer: boolean): boolean;
    SetFirstObject(nob: NetworkObject): void;
    ToString(): string;
}
    
    
interface NetworkObserver extends MonoBehaviour {
    OverrideType: ConditionOverrideType;
    UpdateHostVisibility: boolean;
    ObserverConditions: CSArray<ObserverCondition>;


    GetObserverCondition<T>(): ObserverCondition;
    SetUpdateHostVisibility(value: boolean): void;
}
    
interface ObserverCondition extends ScriptableObject {
    NetworkObject: NetworkObject;


    Clone(): ObserverCondition;
    ConditionMet(connection: NetworkConnection, currentlyAdded: boolean, notProcessed: unknown): boolean;
    Deinitialize(destroyed: boolean): void;
    GetConditionType(): ObserverConditionType;
    GetIsEnabled(): boolean;
    Initialize(networkObject: NetworkObject): void;
    SetIsEnabled(value: boolean): void;
    Timed(): boolean;
}
    
interface NetworkObserverConstructor {

    new(): NetworkObserver;

}
declare const NetworkObserver: NetworkObserverConstructor;
    
interface NetworkBehaviour extends MonoBehaviour {
    OnStartServerCalled: boolean;
    OnStartClientCalled: boolean;
    IsSpawned: boolean;
    ComponentIndex: number;
    NetworkObject: NetworkObject;
    IsReconciling: boolean;
    IsDeinitializing: boolean;
    NetworkManager: NetworkManager;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    ObserverManager: ObserverManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    PredictionManager: PredictionManager;
    RollbackManager: RollbackManager;
    NetworkObserver: NetworkObserver;
    IsClientInitialized: boolean;
    IsClient: boolean;
    IsClientOnly: boolean;
    IsServerInitialized: boolean;
    IsServer: boolean;
    IsServerOnly: boolean;
    IsHost: boolean;
    IsOffline: boolean;
    IsNetworked: boolean;
    Observers: CSArray<NetworkConnection>;
    IsOwner: boolean;
    Owner: NetworkConnection;
    OwnerId: number;
    ObjectId: number;
    LocalConnection: NetworkConnection;


    CanLog(loggingType: LoggingType): boolean;
    ClearBuffedRpcs(): void;
    ClearReplicateCache(asServer: boolean): void;
    ClearReplicateCache(): void;
    ClearReplicateCache_Virtual(asServer: boolean): void;
    Despawn(go: GameObject, despawnType: unknown): void;
    Despawn(nob: NetworkObject, despawnType: unknown): void;
    Despawn(despawnType: unknown): void;
    GetInstance<T>(): T;
    GetLastReconcileTick(): number;
    GetLastReplicateTick(): number;
    GiveOwnership(newOwner: NetworkConnection): void;
    NetworkInitializeIfDisabled(): void;
    OnDespawnServer(connection: NetworkConnection): void;
    OnOwnershipClient(prevOwner: NetworkConnection): void;
    OnOwnershipServer(prevOwner: NetworkConnection): void;
    OnSpawnServer(connection: NetworkConnection): void;
    OnStartClient(): void;
    OnStartNetwork(): void;
    OnStartServer(): void;
    OnStopClient(): void;
    OnStopNetwork(): void;
    OnStopServer(): void;
    OwnerMatches(connection: NetworkConnection): boolean;
    Reconcile_Client<T, T2>(reconcileDel: unknown, replicateULDel: unknown, replicates: CSArray<T2>, data: T, channel: Channel): void;
    Reconcile_ExitEarly_A(asServer: boolean, channel: unknown): boolean;
    Reconcile_Reader<T>(reader: PooledReader, data: unknown, channel: Channel): void;
    Reconcile_Server<T>(methodHash: number, data: T, channel: Channel): void;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    RegisterObserversRpc(hash: number, del: ClientRpcDelegate): void;
    RegisterReconcileRpc(hash: number, del: ReconcileRpcDelegate): void;
    RegisterReplicateRpc(hash: number, del: ReplicateRpcDelegate): void;
    RegisterServerRpc(hash: number, del: ServerRpcDelegate): void;
    RegisterSyncVarRead(del: SyncVarReadDelegate): void;
    RegisterTargetRpc(hash: number, del: ClientRpcDelegate): void;
    RemoveOwnership(): void;
    Replicate_ExitEarly_A(asServer: boolean, replaying: boolean, allowServerControl: boolean): boolean;
    Replicate_NonOwner<T>(del: unknown, q: unknown, serverControlData: T, allowServerControl: boolean, channel: Channel): void;
    Replicate_Owner<T>(del: unknown, methodHash: number, replicates: CSArray<T>, data: T, channel: Channel): void;
    Replicate_Reader<T>(reader: PooledReader, sender: NetworkConnection, arrBuffer: CSArray<T>, replicates: unknown, channel: Channel): void;
    ResetSyncVarFields(): void;
    SendObserversRpc(hash: number, methodWriter: PooledWriter, channel: Channel, orderType: DataOrderType, bufferLast: boolean, excludeServer: boolean, excludeOwner: boolean): void;
    SendServerRpc(hash: number, methodWriter: PooledWriter, channel: Channel, orderType: DataOrderType): void;
    SendTargetRpc(hash: number, methodWriter: PooledWriter, channel: Channel, orderType: DataOrderType, target: NetworkConnection, excludeServer: boolean, validateTarget: boolean): void;
    Spawn(go: GameObject, ownerConnection: NetworkConnection, scene: Scene): void;
    Spawn(nob: NetworkObject, ownerConnection: NetworkConnection, scene: Scene): void;
    ToString(): string;
    TryRegisterInstance<T>(component: T): boolean;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
}
    
interface ClientManager extends MonoBehaviour {
    Connection: NetworkConnection;
    Clients: CSDictionary<number, NetworkConnection>;
    Started: boolean;
    Objects: ClientObjects;
    NetworkManager: NetworkManager;
    LevelOfDetailInterval: number;


    Broadcast<T>(message: T, channel: Channel): void;
    GetTransportIndex(): number;
    RegisterBroadcast<T>(handler: unknown): void;
    SetRemoteServerTimeout(timeoutType: RemoteTimeoutType, duration: number): void;
    StartConnection(): boolean;
    StartConnection(address: string): boolean;
    StartConnection(address: string, port: number): boolean;
    StopConnection(): boolean;
    UnregisterBroadcast<T>(handler: unknown): void;
}
    
interface ManagedObjects {
    Spawned: CSDictionary<number, NetworkObject>;
    SceneObjects: CSDictionary<number, NetworkObject>;


}
    
interface ManagedObjectsConstructor {


    InitializePrefab(prefab: NetworkObject, index: number, collectionId: unknown): void;
}
declare const ManagedObjects: ManagedObjectsConstructor;
    
interface ClientObjects extends ManagedObjects {


    WriteDepawn(nob: NetworkObject, writer: Writer): void;
    WriteSpawn(nob: NetworkObject, writer: Writer): void;
}
    
interface Writer {
    Position: number;
    Length: number;
    NetworkManager: NetworkManager;
    Capacity: number;


    EnsureBufferCapacity(count: number): void;
    EnsureBufferLength(count: number): void;
    FastInsertByte(value: number, index: number): void;
    GetArraySegment(): CSArray<number>;
    GetBuffer(): CSArray<number>;
    Reserve(count: number): void;
    Reset(manager: NetworkManager): void;
    ToString(): string;
    Write<T>(value: T): void;
    WriteArray<T>(value: CSArray<T>, offset: number, count: number): void;
    WriteArray<T>(value: CSArray<T>, offset: number): void;
    WriteArray<T>(value: CSArray<T>): void;
    WriteArraySegment(value: CSArray<number>): void;
    WriteArraySegmentAndSize(value: CSArray<number>): void;
    WriteBoolean(value: boolean): void;
    WriteByte(value: number): void;
    WriteBytes(value: CSArray<number>, offset: number, count: number): void;
    WriteBytesAndSize(value: CSArray<number>, offset: number, count: number): void;
    WriteBytesAndSize(value: CSArray<number>): void;
    WriteChannel(channel: Channel): void;
    WriteChar(value: string): void;
    WriteColor(value: Color, packType: AutoPackType): void;
    WriteColor32(value: Color32): void;
    WriteDateTime(dt: string): void;
    WriteDecimal(value: number): void;
    WriteDictionary<TKey, TValue>(dict: CSDictionary<TKey, TValue>): void;
    WriteDouble(value: number): void;
    WriteGameObject(go: GameObject): void;
    WriteGuidAllocated(value: unknown): void;
    WriteInt16(value: number): void;
    WriteInt32(value: number, packType: AutoPackType): void;
    WriteInt64(value: number, packType: AutoPackType): void;
    WriteList<T>(value: CSArray<T>): void;
    WriteList<T>(value: CSArray<T>, offset: number, count: number): void;
    WriteList<T>(value: CSArray<T>, offset: number): void;
    WriteListCache<T>(lc: unknown): void;
    WriteMatrix4x4(value: Matrix4x4): void;
    WriteNetworkBehaviour(nb: NetworkBehaviour): void;
    WriteNetworkBehaviourId(nb: NetworkBehaviour): void;
    WriteNetworkConnection(connection: NetworkConnection): void;
    WriteNetworkConnectionId(id: number): void;
    WriteNetworkObject(nob: NetworkObject): void;
    WriteNetworkObjectId(nob: NetworkObject): void;
    WriteNetworkObjectId(objectId: number): void;
    WritePackedWhole(value: number): void;
    WritePlane(value: Plane): void;
    WriteQuaternion(value: Quaternion, packType: AutoPackType): void;
    WriteRay(value: Ray): void;
    WriteRay2D(value: Ray2D): void;
    WriteRect(value: Rect): void;
    WriteSByte(value: number): void;
    WriteSingle(value: number, packType: AutoPackType): void;
    WriteString(value: string): void;
    WriteTickUnpacked(value: number): void;
    WriteTransform(t: Transform): void;
    WriteUInt16(value: number): void;
    WriteUInt32(value: number, packType: AutoPackType): void;
    WriteUInt64(value: number, packType: AutoPackType): void;
    WriteVector2(value: Vector2): void;
    WriteVector2Int(value: Vector2Int, packType: AutoPackType): void;
    WriteVector3(value: Vector3): void;
    WriteVector3Int(value: unknown, packType: AutoPackType): void;
    WriteVector4(value: Vector4): void;
    ZigZagEncode(value: number): number;
}
    
interface Ray2D {
    origin: Vector2;
    direction: Vector2;


    GetPoint(distance: number): Vector2;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Ray2DConstructor {

    new(origin: Vector2, direction: Vector2): Ray2D;

}
declare const Ray2D: Ray2DConstructor;
    
interface Vector2Int {
    x: number;
    y: number;
    Item: number;
    magnitude: number;
    sqrMagnitude: number;


    Clamp(min: Vector2Int, max: Vector2Int): void;
    Equals(other: unknown): boolean;
    Equals(other: Vector2Int): boolean;
    GetHashCode(): number;
    Scale(scale: Vector2Int): void;
    Set(x: number, y: number): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface Vector2IntConstructor {
    zero: Vector2Int;
    one: Vector2Int;
    up: Vector2Int;
    down: Vector2Int;
    left: Vector2Int;
    right: Vector2Int;

    new(x: number, y: number): Vector2Int;

    CeilToInt(v: Vector2): Vector2Int;
    Distance(a: Vector2Int, b: Vector2Int): number;
    FloorToInt(v: Vector2): Vector2Int;
    Max(lhs: Vector2Int, rhs: Vector2Int): Vector2Int;
    Min(lhs: Vector2Int, rhs: Vector2Int): Vector2Int;
    RoundToInt(v: Vector2): Vector2Int;
    Scale(a: Vector2Int, b: Vector2Int): Vector2Int;
}
declare const Vector2Int: Vector2IntConstructor;
    
interface WriterConstructor {
    UNSET_COLLECTION_SIZE_VALUE: number;

    new(): Writer;

}
declare const Writer: WriterConstructor;
    
interface ClientManagerConstructor {

    new(): ClientManager;

}
declare const ClientManager: ClientManagerConstructor;
    
interface ObserverManager extends MonoBehaviour {
    UpdateHostVisibility: boolean;


    SetUpdateHostVisibility(value: boolean, updateType: HostVisibilityUpdateTypes): void;
}
    
interface ObserverManagerConstructor {

    new(): ObserverManager;

    GetLevelOfDetailInterval(lodIndex: number): number;
}
declare const ObserverManager: ObserverManagerConstructor;
    
interface TransportManager extends MonoBehaviour {
    Transport: Transport;
    HasIntermediateLayer: boolean;
    LatencySimulator: LatencySimulator;


    GetLowestMTU(channel: number): number;
    GetMTU(channel: number): number;
    GetMTU(transportIndex: number, channel: number): number;
    GetMTU<T>(channel: number): number;
    GetTransport(index: number): Transport;
    GetTransport<T>(): T;
    IsLocalTransport(connectionId: number): boolean;
}
    
interface Transport extends MonoBehaviour {
    NetworkManager: NetworkManager;
    Index: number;


    GetClientAddress(): string;
    GetConnectionAddress(connectionId: number): string;
    GetConnectionState(server: boolean): LocalConnectionState;
    GetConnectionState(connectionId: number): RemoteConnectionState;
    GetMaximumClients(): number;
    GetMTU(channel: number): number;
    GetPort(): number;
    GetServerBindAddress(addressType: IPAddressType): string;
    GetTimeout(asServer: boolean): number;
    HandleClientConnectionState(connectionStateArgs: ClientConnectionStateArgs): void;
    HandleClientReceivedDataArgs(receivedDataArgs: ClientReceivedDataArgs): void;
    HandleRemoteConnectionState(connectionStateArgs: RemoteConnectionStateArgs): void;
    HandleServerConnectionState(connectionStateArgs: ServerConnectionStateArgs): void;
    HandleServerReceivedDataArgs(receivedDataArgs: ServerReceivedDataArgs): void;
    Initialize(networkManager: NetworkManager, transportIndex: number): void;
    IsLocalTransport(connectionid: number): boolean;
    IterateIncoming(server: boolean): void;
    IterateOutgoing(server: boolean): void;
    SendToClient(channelId: number, segment: CSArray<number>, connectionId: number): void;
    SendToServer(channelId: number, segment: CSArray<number>): void;
    SetClientAddress(address: string): void;
    SetMaximumClients(value: number): void;
    SetPort(port: number): void;
    SetServerBindAddress(address: string, addressType: IPAddressType): void;
    SetTimeout(value: number, asServer: boolean): void;
    Shutdown(): void;
    StartConnection(server: boolean): boolean;
    StopConnection(server: boolean): boolean;
    StopConnection(connectionId: number, immediately: boolean): boolean;
}
    
interface ClientConnectionStateArgs {
    ConnectionState: LocalConnectionState;
    TransportIndex: number;


}
    
interface ClientConnectionStateArgsConstructor {

    new(connectionState: LocalConnectionState, transportIndex: number): ClientConnectionStateArgs;

}
declare const ClientConnectionStateArgs: ClientConnectionStateArgsConstructor;
    
interface ClientReceivedDataArgs {
    Data: CSArray<number>;
    Channel: Channel;
    TransportIndex: number;


}
    
interface ClientReceivedDataArgsConstructor {

    new(data: CSArray<number>, channel: Channel, transportIndex: number): ClientReceivedDataArgs;

}
declare const ClientReceivedDataArgs: ClientReceivedDataArgsConstructor;
    
interface RemoteConnectionStateArgs {
    TransportIndex: number;
    ConnectionState: RemoteConnectionState;
    ConnectionId: number;


}
    
interface RemoteConnectionStateArgsConstructor {

    new(connectionState: RemoteConnectionState, connectionId: number, transportIndex: number): RemoteConnectionStateArgs;

}
declare const RemoteConnectionStateArgs: RemoteConnectionStateArgsConstructor;
    
interface ServerConnectionStateArgs {
    TransportIndex: number;
    ConnectionState: LocalConnectionState;


}
    
interface ServerConnectionStateArgsConstructor {

    new(connectionState: LocalConnectionState, transportIndex: number): ServerConnectionStateArgs;

}
declare const ServerConnectionStateArgs: ServerConnectionStateArgsConstructor;
    
interface ServerReceivedDataArgs {
    Data: CSArray<number>;
    Channel: Channel;
    ConnectionId: number;
    TransportIndex: number;
    FinalizeMethod: unknown;


}
    
interface ServerReceivedDataArgsConstructor {

    new(data: CSArray<number>, channel: Channel, connectionId: number, transportIndex: number): ServerReceivedDataArgs;
    new(data: CSArray<number>, channel: Channel, connectionId: number, transportIndex: number, finalizeMethod: unknown): ServerReceivedDataArgs;

}
declare const ServerReceivedDataArgs: ServerReceivedDataArgsConstructor;
    
interface LatencySimulator {


    AddOutgoing(channelId: number, segment: CSArray<number>, toServer: boolean, connectionId: number): void;
    GetEnabled(): boolean;
    GetLatency(): number;
    GetOutOfOrder(): number;
    GetPacketLost(): number;
    Initialize(manager: NetworkManager, transport: Transport): void;
    IterateOutgoing(toServer: boolean): void;
    RemovePendingForConnection(connectionId: number): void;
    Reset(): void;
    SetEnabled(value: boolean): void;
    SetLatency(value: number): void;
    SetOutOfOrder(value: number): void;
    SetPacketLoss(value: number): void;
}
    
interface LatencySimulatorConstructor {

    new(): LatencySimulator;

}
declare const LatencySimulator: LatencySimulatorConstructor;
    
interface TransportManagerConstructor {
    PACKET_ID_BYTES: number;
    OBJECT_ID_BYTES: number;
    COMPONENT_INDEX_BYTES: number;
    TICK_BYTES: number;
    SPLIT_INDICATOR_SIZE: number;
    CHANNEL_COUNT: number;

    new(): TransportManager;

}
declare const TransportManager: TransportManagerConstructor;
    
interface TimeManager extends MonoBehaviour {
    RoundTripTime: number;
    LastPacketTick: number;
    Tick: number;
    TickDelta: number;
    FrameTicked: boolean;
    ServerUptime: number;
    ClientUptime: number;
    TickRate: number;
    PhysicsMode: PhysicsMode;
    LocalTick: number;


    GetPreciseTick(tick: number): PreciseTick;
    GetPreciseTick(tickType: TickType): PreciseTick;
    GetTickPercent(): number;
    LocalTickToTick(localTick: number): number;
    SetPhysicsMode(mode: PhysicsMode): void;
    SetTickRate(value: number): void;
    TicksToTime(tickType: TickType): number;
    TicksToTime(pt: PreciseTick): number;
    TicksToTime(ticks: number): number;
    TickToLocalTick(tick: number): number;
    TimePassed(currentTick: number, previousTick: number): number;
    TimePassed(preciseTick: PreciseTick, allowNegative: boolean): number;
    TimePassed(previousTick: number, allowNegative: boolean): number;
    TimeToTicks(time: number, rounding: TickRounding): number;
}
    
interface PreciseTick {
    Tick: number;
    Percent: number;


}
    
interface PreciseTickConstructor {

    new(tick: number, percent: number): PreciseTick;

}
declare const PreciseTick: PreciseTickConstructor;
    
interface TimeManagerConstructor {
    UNSET_TICK: number;

    new(): TimeManager;

}
declare const TimeManager: TimeManagerConstructor;
    
interface SceneManager extends MonoBehaviour {
    SceneConnections: CSDictionary<Scene, CSArray<NetworkConnection>>;
    NetworkManager: NetworkManager;


    AddConnectionToScene(conn: NetworkConnection, scene: Scene): void;
    AddOwnerToDefaultScene(nob: NetworkObject): void;
    GetSceneProcessor(): SceneProcessorBase;
    LoadConnectionScenes(conn: NetworkConnection, sceneLoadData: SceneLoadData): void;
    LoadConnectionScenes(conns: CSArray<NetworkConnection>, sceneLoadData: SceneLoadData): void;
    LoadConnectionScenes(sceneLoadData: SceneLoadData): void;
    LoadGlobalScenes(sceneLoadData: SceneLoadData): void;
    RemoveAllConnectionsFromScene(scene: Scene): void;
    RemoveConnectionsFromNonGlobalScenes(conns: CSArray<NetworkConnection>): void;
    RemoveConnectionsFromScene(conns: CSArray<NetworkConnection>, scene: Scene): void;
    SetSceneProcessor(value: SceneProcessorBase): void;
    UnloadConnectionScenes(connection: NetworkConnection, sceneUnloadData: SceneUnloadData): void;
    UnloadConnectionScenes(connections: CSArray<NetworkConnection>, sceneUnloadData: SceneUnloadData): void;
    UnloadConnectionScenes(sceneUnloadData: SceneUnloadData): void;
    UnloadGlobalScenes(sceneUnloadData: SceneUnloadData): void;
}
    
interface SceneProcessorBase extends MonoBehaviour {


    ActivateLoadedScenes(): void;
    AddLoadedScene(scene: Scene): void;
    AsyncsIsDone(): unknown;
    BeginLoadAsync(sceneName: string, parameters: LoadSceneParameters): void;
    BeginUnloadAsync(scene: Scene): void;
    FindOrCreateScene(name: string): Scene;
    GetDelayedDestroyScene(): Scene;
    GetFallbackActiveScene(): Scene;
    GetLoadedScenes(): CSArray<Scene>;
    GetMovedObjectsScene(): Scene;
    GetPercentComplete(): number;
    Initialize(manager: SceneManager): void;
    IsPercentComplete(): boolean;
    LoadEnd(queueData: LoadQueueData): void;
    LoadStart(queueData: LoadQueueData): void;
    UnloadEnd(queueData: LoadQueueData): void;
    UnloadEnd(queueData: UnloadQueueData): void;
    UnloadStart(queueData: LoadQueueData): void;
    UnloadStart(queueData: UnloadQueueData): void;
}
    
interface LoadSceneParameters {
    loadSceneMode: LoadSceneMode;
    localPhysicsMode: LocalPhysicsMode;


}
    
interface LoadSceneParametersConstructor {

    new(mode: LoadSceneMode): LoadSceneParameters;
    new(mode: LoadSceneMode, physicsMode: LocalPhysicsMode): LoadSceneParameters;

}
declare const LoadSceneParameters: LoadSceneParametersConstructor;
    
interface LoadQueueData {
    ScopeType: SceneScopeType;
    Connections: CSArray<NetworkConnection>;
    SceneLoadData: SceneLoadData;
    GlobalScenes: CSArray<string>;
    AsServer: boolean;


}
    
interface SceneLoadData {
    PreferredActiveScene: SceneLookupData;
    SceneLookupDatas: CSArray<SceneLookupData>;
    MovedNetworkObjects: CSArray<NetworkObject>;
    ReplaceScenes: ReplaceOption;
    Params: LoadParams;
    Options: LoadOptions;


    GetFirstLookupScene(): Scene;
}
    
interface SceneLookupData {
    Handle: number;
    Name: string;
    NameOnly: string;
    IsValid: boolean;


    Equals(sld: SceneLookupData): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GetScene(foundByHandle: unknown, warnIfDuplicates: boolean): Scene;
    ToString(): string;
}
    
interface SceneLookupDataConstructor {

    new(): SceneLookupData;
    new(scene: Scene): SceneLookupData;
    new(name: string): SceneLookupData;
    new(handle: number): SceneLookupData;
    new(handle: number, name: string): SceneLookupData;

    CreateData(scene: Scene): SceneLookupData;
    CreateData(name: string): SceneLookupData;
    CreateData(handle: number): SceneLookupData;
    CreateData(scenes: CSArray<Scene>): CSArray<SceneLookupData>;
    CreateData(names: CSArray<string>): CSArray<SceneLookupData>;
    CreateData(handles: CSArray<number>): CSArray<SceneLookupData>;
    CreateData(scenes: CSArray<Scene>): CSArray<SceneLookupData>;
    CreateData(names: CSArray<string>): CSArray<SceneLookupData>;
    CreateData(handles: CSArray<number>): CSArray<SceneLookupData>;
    ValidateData(data: SceneLookupData): CSArray<SceneLookupData>;
    ValidateData(datas: CSArray<SceneLookupData>): CSArray<SceneLookupData>;
}
declare const SceneLookupData: SceneLookupDataConstructor;
    
interface LoadParams {
    ServerParams: CSArray<unknown>;
    ClientParams: CSArray<number>;


}
    
interface LoadParamsConstructor {

    new(): LoadParams;

}
declare const LoadParams: LoadParamsConstructor;
    
interface LoadOptions {
    AutomaticallyUnload: boolean;
    AllowStacking: boolean;
    LocalPhysics: LocalPhysicsMode;
    ReloadScenes: boolean;
    Addressables: boolean;


}
    
interface LoadOptionsConstructor {

    new(): LoadOptions;

}
declare const LoadOptions: LoadOptionsConstructor;
    
interface SceneLoadDataConstructor {

    new(): SceneLoadData;
    new(scene: Scene): SceneLoadData;
    new(sceneName: string): SceneLoadData;
    new(sceneHandle: number): SceneLoadData;
    new(sceneHandle: number, sceneName: string): SceneLoadData;
    new(sceneLookupData: SceneLookupData): SceneLoadData;
    new(scenes: CSArray<Scene>): SceneLoadData;
    new(sceneNames: CSArray<string>): SceneLoadData;
    new(sceneHandles: CSArray<number>): SceneLoadData;
    new(scenes: CSArray<Scene>): SceneLoadData;
    new(sceneNames: CSArray<string>): SceneLoadData;
    new(sceneHandles: CSArray<number>): SceneLoadData;
    new(sceneLookupDatas: CSArray<SceneLookupData>): SceneLoadData;
    new(scene: Scene, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    new(scenes: CSArray<Scene>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    new(sceneNames: CSArray<string>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    new(sceneHandles: CSArray<number>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;
    new(sceneLookupDatas: CSArray<SceneLookupData>, movedNetworkObjects: CSArray<NetworkObject>): SceneLoadData;

}
declare const SceneLoadData: SceneLoadDataConstructor;
    
interface LoadQueueDataConstructor {

    new(): LoadQueueData;

}
declare const LoadQueueData: LoadQueueDataConstructor;
    
interface UnloadQueueData {
    ScopeType: SceneScopeType;
    Connections: CSArray<NetworkConnection>;
    SceneUnloadData: SceneUnloadData;
    GlobalScenes: CSArray<string>;
    AsServer: boolean;


}
    
interface SceneUnloadData {
    PreferredActiveScene: SceneLookupData;
    SceneLookupDatas: CSArray<SceneLookupData>;
    Params: UnloadParams;
    Options: UnloadOptions;


}
    
interface UnloadParams {
    ServerParams: CSArray<unknown>;
    ClientParams: CSArray<number>;


}
    
interface UnloadParamsConstructor {

    new(): UnloadParams;

}
declare const UnloadParams: UnloadParamsConstructor;
    
interface UnloadOptions {
    Mode: ServerUnloadMode;
    Addressables: boolean;


}
    
interface UnloadOptionsConstructor {

    new(): UnloadOptions;

}
declare const UnloadOptions: UnloadOptionsConstructor;
    
interface SceneUnloadDataConstructor {

    new(): SceneUnloadData;
    new(scene: Scene): SceneUnloadData;
    new(sceneName: string): SceneUnloadData;
    new(sceneHandle: number): SceneUnloadData;
    new(sceneLookupData: SceneLookupData): SceneUnloadData;
    new(scenes: CSArray<Scene>): SceneUnloadData;
    new(sceneNames: CSArray<string>): SceneUnloadData;
    new(sceneHandles: CSArray<number>): SceneUnloadData;
    new(scenes: CSArray<Scene>): SceneUnloadData;
    new(sceneNames: CSArray<string>): SceneUnloadData;
    new(sceneHandles: CSArray<number>): SceneUnloadData;
    new(sceneLookupDatas: CSArray<SceneLookupData>): SceneUnloadData;

}
declare const SceneUnloadData: SceneUnloadDataConstructor;
    
interface UnloadQueueDataConstructor {

    new(): UnloadQueueData;

}
declare const UnloadQueueData: UnloadQueueDataConstructor;
    
interface SceneManagerConstructor {

    new(): SceneManager;

    GetScene(sceneName: string, nm: NetworkManager, warnIfDuplicates: boolean): Scene;
    GetScene(sceneHandle: number): Scene;
}
declare const SceneManager: SceneManagerConstructor;
    
interface PredictionManager extends MonoBehaviour {
    LastReconcileTick: number;
    LastReplicateTick: number;
    QueuedInputs: number;


    AddRigidbodyCount(c: Component): void;
    GetMaximumServerReplicates(): number;
    InvokeOnReconcile(nb: NetworkBehaviour, before: boolean): void;
    IsReplaying(): boolean;
    IsReplaying(scene: Scene): boolean;
    RemoveRigidbodyCount(c: Component): void;
    SetMaximumServerReplicates(value: number): void;
}
    
interface PredictionManagerConstructor {

    new(): PredictionManager;

}
declare const PredictionManager: PredictionManagerConstructor;
    
interface RollbackManager extends MonoBehaviour {


    Return(): void;
    Rollback(pt: PreciseTick, physicsType: PhysicsType, asOwner: boolean): void;
    Rollback(pt: PreciseTick, physicsType: RollbackPhysicsType, asOwner: boolean): void;
    Rollback(scene: Scene, pt: PreciseTick, physicsType: RollbackPhysicsType, asOwner: boolean): void;
    Rollback(sceneHandle: number, pt: PreciseTick, physicsType: RollbackPhysicsType, asOwner: boolean): void;
    Rollback(origin: Vector3, normalizedDirection: Vector3, distance: number, pt: PreciseTick, asOwner: boolean): void;
    Rollback(scene: Scene, origin: Vector3, normalizedDirection: Vector3, distance: number, pt: PreciseTick, asOwner: boolean): void;
    Rollback(sceneHandle: number, origin: Vector3, normalizedDirection: Vector3, distance: number, pt: PreciseTick, asOwner: boolean): void;
    Rollback(origin: Vector2, normalizedDirection: Vector2, distance: number, pt: PreciseTick, asOwner: boolean): void;
}
    
interface RollbackManagerConstructor {

    new(): RollbackManager;

}
declare const RollbackManager: RollbackManagerConstructor;
    
interface Reader {
    Source: DataSource;
    NetworkManager: NetworkManager;
    Position: number;
    Capacity: number;
    Offset: number;
    Length: number;
    Remaining: number;
    NetworkConnection: NetworkConnection;


    BlockCopy(target: CSArray<number>, targetOffset: number, count: number): void;
    Clear(): void;
    GetArraySegmentBuffer(): CSArray<number>;
    GetByteBuffer(): CSArray<number>;
    GetByteBufferAllocated(): CSArray<number>;
    GetRemainingData(): CSArray<number>;
    Read<T>(): T;
    ReadArray<T>(collection: CSArray<T>): number;
    ReadArrayAllocated<T>(): CSArray<T>;
    ReadArraySegment(count: number): CSArray<number>;
    ReadArraySegmentAndSize(): CSArray<number>;
    ReadBoolean(): boolean;
    ReadByte(): number;
    ReadBytes(buffer: CSArray<number>, count: number): void;
    ReadBytesAllocated(count: number): CSArray<number>;
    ReadBytesAndSize(target: CSArray<number>): number;
    ReadBytesAndSizeAllocated(): CSArray<number>;
    ReadChannel(): Channel;
    ReadChar(): string;
    ReadColor(packType: AutoPackType): Color;
    ReadColor32(): Color32;
    ReadDateTime(): string;
    ReadDecimal(): number;
    ReadDictionary<TKey, TValue>(): CSDictionary<TKey, TValue>;
    ReadDictionaryAllocated<TKey, TValue>(): CSDictionary<TKey, TValue>;
    ReadDouble(): number;
    ReadGameObject(): GameObject;
    ReadGuid(): unknown;
    ReadInt16(): number;
    ReadInt32(packType: AutoPackType): number;
    ReadInt64(packType: AutoPackType): number;
    ReadList<T>(collection: CSArray<T>, allowNullification: boolean): number;
    ReadListAllocated<T>(): CSArray<T>;
    ReadListCache<T>(listCache: unknown): number;
    ReadListCacheAllocated<T>(): unknown;
    ReadMatrix4x4(): Matrix4x4;
    ReadNetworkBehaviour(objectId: unknown, componentIndex: unknown, readSpawningObjects: CSArray<number>): NetworkBehaviour;
    ReadNetworkBehaviour(): NetworkBehaviour;
    ReadNetworkConnection(): NetworkConnection;
    ReadNetworkConnectionId(): number;
    ReadNetworkObject(): NetworkObject;
    ReadNetworkObject(objectOrPrefabId: unknown, readSpawningObjects: CSArray<number>): NetworkObject;
    ReadNetworkObjectId(): number;
    ReadPackedWhole(): number;
    ReadPlane(): Plane;
    ReadQuaternion(packType: AutoPackType): Quaternion;
    ReadRay(): Ray;
    ReadRay2D(): Ray2D;
    ReadRect(): Rect;
    ReadSByte(): number;
    ReadSingle(packType: AutoPackType): number;
    ReadString(): string;
    ReadTickUnpacked(): number;
    ReadTransform(): Transform;
    ReadUInt16(): number;
    ReadUInt32(packType: AutoPackType): number;
    ReadUInt64(packType: AutoPackType): number;
    ReadVector2(): Vector2;
    ReadVector2Int(packType: AutoPackType): Vector2Int;
    ReadVector3(): Vector3;
    ReadVector3Int(packType: AutoPackType): unknown;
    ReadVector4(): Vector4;
    RemainingToString(): string;
    Skip(value: number): void;
    ToString(): string;
    ZigZagDecode(value: number): number;
}
    
interface ReaderConstructor {
    LastNetworkObject: NetworkObject;
    LastNetworkBehaviour: NetworkBehaviour;

    new(bytes: CSArray<number>, networkManager: NetworkManager, networkConnection: NetworkConnection, source: DataSource): Reader;
    new(segment: CSArray<number>, networkManager: NetworkManager, networkConnection: NetworkConnection, source: DataSource): Reader;

}
declare const Reader: ReaderConstructor;
    
interface PooledReader extends Reader {


    Dispose(): void;
    Store(): void;
}
    
interface IReconcileData {


    Dispose(): void;
    GetTick(): number;
    SetTick(value: number): void;
}
    
interface ClientRpcDelegate {


    BeginInvoke(reader: PooledReader, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel): void;
}
    
interface ClientRpcDelegateConstructor {

    new(object: unknown, method: unknown): ClientRpcDelegate;

}
declare const ClientRpcDelegate: ClientRpcDelegateConstructor;
    
interface ReconcileRpcDelegate {


    BeginInvoke(reader: PooledReader, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel): void;
}
    
interface ReconcileRpcDelegateConstructor {

    new(object: unknown, method: unknown): ReconcileRpcDelegate;

}
declare const ReconcileRpcDelegate: ReconcileRpcDelegateConstructor;
    
interface ReplicateRpcDelegate {


    BeginInvoke(reader: PooledReader, sender: NetworkConnection, channel: Channel, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, sender: NetworkConnection, channel: Channel): void;
}
    
interface ReplicateRpcDelegateConstructor {

    new(object: unknown, method: unknown): ReplicateRpcDelegate;

}
declare const ReplicateRpcDelegate: ReplicateRpcDelegateConstructor;
    
interface ServerRpcDelegate {


    BeginInvoke(reader: PooledReader, channel: Channel, sender: NetworkConnection, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(reader: PooledReader, channel: Channel, sender: NetworkConnection): void;
}
    
interface ServerRpcDelegateConstructor {

    new(object: unknown, method: unknown): ServerRpcDelegate;

}
declare const ServerRpcDelegate: ServerRpcDelegateConstructor;
    
interface SyncVarReadDelegate {


    BeginInvoke(reader: PooledReader, index: number, asServer: boolean, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): boolean;
    Invoke(reader: PooledReader, index: number, asServer: boolean): boolean;
}
    
interface SyncVarReadDelegateConstructor {

    new(object: unknown, method: unknown): SyncVarReadDelegate;

}
declare const SyncVarReadDelegate: SyncVarReadDelegateConstructor;
    
interface PooledWriter extends Writer {


    Dispose(): void;
    DisposeLength(): void;
    Store(): void;
    StoreLength(): void;
}
    
interface PooledWriterConstructor {

    new(): PooledWriter;

}
declare const PooledWriter: PooledWriterConstructor;
    
interface PredictedSpawn extends NetworkBehaviour {


    Awake(): void;
    Awake___UserLogic(): void;
    GetAllowDespawning(): boolean;
    GetAllowSpawning(): boolean;
    GetAllowSyncTypes(): boolean;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnTryDepawnServer(despawner: NetworkConnection): boolean;
    OnTryDespawnClient(): boolean;
    OnTrySpawnClient(owner: NetworkConnection): boolean;
    OnTrySpawnServer(spawner: NetworkConnection, owner: NetworkConnection): boolean;
    SetAllowDespawning(value: boolean): void;
    SetAllowSpawning(value: boolean): void;
    SetAllowSyncTypes(value: boolean): void;
}
    
interface PredictedSpawnConstructor {

    new(): PredictedSpawn;

}
declare const PredictedSpawn: PredictedSpawnConstructor;
    
    
interface EstimatedTick {
    LocalTick: number;
    RemoteTick: number;
    LastRemoteTick: number;
    IsUnset: boolean;


    IsCurrent(tm: TimeManager): boolean;
    LocalTickDifference(tm: TimeManager): number;
    Reset(): void;
    Update(tm: TimeManager, remoteTick: number, oldTickOption: OldTickOption): boolean;
    Value(tm: TimeManager): number;
    Value(tm: TimeManager, isCurrent: unknown): number;
}
    
interface IResettable {


    InitializeState(): void;
    ResetState(): void;
}
    
interface LevelOfDetailData extends IResettable {
    CurrentLevelOfDetail: number;
    PreviousLevelOfDetail: number;


    InitializeState(): void;
    ResetState(): void;
}
    
interface LevelOfDetailDataConstructor {

    new(): LevelOfDetailData;

}
declare const LevelOfDetailData: LevelOfDetailDataConstructor;
    
interface NetworkConnectionConstructor {
    UNSET_CLIENTID_VALUE: number;

    new(): NetworkConnection;
    new(manager: NetworkManager, clientId: number, transportIndex: number, asServer: boolean): NetworkConnection;

}
declare const NetworkConnection: NetworkConnectionConstructor;
    
interface ServerObjects extends ManagedObjects {


    AddTimedNetworkObserver(networkObject: NetworkObject): void;
    RebuildObservers(timedOnly: boolean): void;
    RebuildObservers(nob: NetworkObject, timedOnly: boolean): void;
    RebuildObservers(connection: NetworkConnection, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, timedOnly: boolean): void;
    RebuildObservers(connections: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, conn: NetworkConnection, timedOnly: boolean): void;
    RebuildObservers(networkObject: NetworkObject, connections: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, conns: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, timedOnly: boolean): void;
    RebuildObservers(connections: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, conn: NetworkConnection, timedOnly: boolean): void;
    RebuildObservers(networkObject: NetworkObject, connections: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nobs: CSArray<NetworkObject>, conns: CSArray<NetworkConnection>, timedOnly: boolean): void;
    RebuildObservers(nob: NetworkObject, conn: NetworkConnection, timedOnly: boolean): void;
    RecentlyDespawned(objectId: number, ticks: number): boolean;
    RemoveTimedNetworkObserver(networkObject: NetworkObject): void;
}
    
interface Authenticator extends MonoBehaviour {
    Initialized: boolean;


    InitializeOnce(networkManager: NetworkManager): void;
    OnRemoteConnection(connection: NetworkConnection): void;
}
    
interface ServerManagerConstructor {
    MAXIMUM_REMOTE_CLIENT_TIMEOUT_DURATION: number;

    new(): ServerManager;

}
declare const ServerManager: ServerManagerConstructor;
    
interface DebugManager extends MonoBehaviour {
    WriteSceneObjectDetails: boolean;
    ObserverRpcLinks: boolean;
    TargetRpcLinks: boolean;
    ReplicateRpcLinks: boolean;
    ReconcileRpcLinks: boolean;
    ServerRpcLinks: boolean;


}
    
interface DebugManagerConstructor {

    new(): DebugManager;

}
declare const DebugManager: DebugManagerConstructor;
    
interface StatisticsManager extends MonoBehaviour {
    NetworkTraffic: NetworkTraficStatistics;


}
    
interface NetworkTraficStatistics {
    UpdateClient: boolean;
    UpdateServer: boolean;


    LocalClientReceivedData(dataLength: number): void;
    LocalServerReceivedData(dataLength: number): void;
    SetUpdateClient(update: boolean): void;
    SetUpdateServer(update: boolean): void;
}
    
interface NetworkTraficStatisticsConstructor {

    new(): NetworkTraficStatistics;

    FormatBytesToLargest(bytes: number): string;
}
declare const NetworkTraficStatistics: NetworkTraficStatisticsConstructor;
    
interface StatisticsManagerConstructor {

    new(): StatisticsManager;

}
declare const StatisticsManager: StatisticsManagerConstructor;
    
interface ObjectPool extends MonoBehaviour {


    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    InitializeOnce(nm: NetworkManager): void;
    RetrieveObject(prefabId: number, asServer: boolean): NetworkObject;
    RetrieveObject(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    RetrieveObject(prefabId: number, collectionId: number, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    StoreObject(instantiated: NetworkObject, asServer: boolean): void;
}
    
interface PrefabObjects extends ScriptableObject {
    CollectionId: number;


    AddObject(networkObject: NetworkObject, checkForDuplicates: boolean): void;
    AddObject(dualPrefab: DualPrefab, checkForDuplicates: boolean): void;
    AddObjects(networkObjects: CSArray<NetworkObject>, checkForDuplicates: boolean): void;
    AddObjects(networkObjects: CSArray<NetworkObject>, checkForDuplicates: boolean): void;
    AddObjects(dualPrefab: CSArray<DualPrefab>, checkForDuplicates: boolean): void;
    AddObjects(dualPrefab: CSArray<DualPrefab>, checkForDuplicates: boolean): void;
    Clear(): void;
    GetObject(asServer: boolean, id: number): NetworkObject;
    GetObjectCount(): number;
    InitializePrefabRange(startIndex: number): void;
    RemoveNull(): void;
}
    
interface DualPrefab {
    Server: NetworkObject;
    Client: NetworkObject;


}
    
interface NetworkManagerConstructor {
    Instances: CSArray<NetworkManager>;
    EmptyConnection: NetworkConnection;

    new(): NetworkManager;

    StaticCanLog(loggingType: LoggingType): boolean;
    StaticLog(value: string): void;
    StaticLogError(value: string): void;
    StaticLogWarning(value: string): void;
}
declare const NetworkManager: NetworkManagerConstructor;
    
interface NetworkCoreConstructor {
    Net: Net;
    NetworkManager: NetworkManager;

    new(): NetworkCore;

    Despawn(obj: GameObject): void;
    SetNet(net: Net): void;
    Spawn(obj: GameObject, clientId: number): void;
    Spawn(obj: GameObject): void;
}
declare const NetworkCore: NetworkCoreConstructor;
    
interface Camera extends Behaviour {
    nearClipPlane: number;
    farClipPlane: number;
    fieldOfView: number;
    renderingPath: RenderingPath;
    actualRenderingPath: RenderingPath;
    allowHDR: boolean;
    allowMSAA: boolean;
    allowDynamicResolution: boolean;
    forceIntoRenderTexture: boolean;
    orthographicSize: number;
    orthographic: boolean;
    opaqueSortMode: OpaqueSortMode;
    transparencySortMode: TransparencySortMode;
    transparencySortAxis: Vector3;
    depth: number;
    aspect: number;
    velocity: Vector3;
    cullingMask: number;
    eventMask: number;
    layerCullSpherical: boolean;
    cameraType: CameraType;
    overrideSceneCullingMask: number;
    layerCullDistances: CSArray<number>;
    useOcclusionCulling: boolean;
    cullingMatrix: Matrix4x4;
    backgroundColor: Color;
    clearFlags: CameraClearFlags;
    depthTextureMode: DepthTextureMode;
    clearStencilAfterLightingPass: boolean;
    usePhysicalProperties: boolean;
    iso: number;
    shutterSpeed: number;
    aperture: number;
    focusDistance: number;
    focalLength: number;
    bladeCount: number;
    curvature: Vector2;
    barrelClipping: number;
    anamorphism: number;
    sensorSize: Vector2;
    lensShift: Vector2;
    gateFit: GateFitMode;
    rect: Rect;
    pixelRect: Rect;
    pixelWidth: number;
    pixelHeight: number;
    scaledPixelWidth: number;
    scaledPixelHeight: number;
    targetTexture: RenderTexture;
    activeTexture: RenderTexture;
    targetDisplay: number;
    cameraToWorldMatrix: Matrix4x4;
    worldToCameraMatrix: Matrix4x4;
    projectionMatrix: Matrix4x4;
    nonJitteredProjectionMatrix: Matrix4x4;
    useJitteredProjectionMatrixForTransparentRendering: boolean;
    previousViewProjectionMatrix: Matrix4x4;
    scene: Scene;
    stereoEnabled: boolean;
    stereoSeparation: number;
    stereoConvergence: number;
    areVRStereoViewMatricesWithinSingleCullTolerance: boolean;
    stereoTargetEye: StereoTargetEyeMask;
    stereoActiveEye: MonoOrStereoscopicEye;
    sceneViewFilterMode: SceneViewFilterMode;
    renderCloudsInSceneView: boolean;
    commandBufferCount: number;
    isOrthoGraphic: boolean;
    near: number;
    far: number;
    fov: number;
    hdr: boolean;
    stereoMirrorMode: boolean;


    AddCommandBuffer(evt: CameraEvent, buffer: CommandBuffer): void;
    AddCommandBufferAsync(evt: CameraEvent, buffer: CommandBuffer, queueType: ComputeQueueType): void;
    CalculateFrustumCorners(viewport: Rect, z: number, eye: MonoOrStereoscopicEye, outCorners: CSArray<Vector3>): void;
    CalculateObliqueMatrix(clipPlane: Vector4): Matrix4x4;
    CopyFrom(other: Camera): void;
    CopyStereoDeviceProjectionMatrixToNonJittered(eye: StereoscopicEye): void;
    DoClear(): void;
    GetCommandBuffers(evt: CameraEvent): CSArray<CommandBuffer>;
    GetGateFittedFieldOfView(): number;
    GetGateFittedLensShift(): Vector2;
    GetScreenHeight(): number;
    GetScreenWidth(): number;
    GetStereoNonJitteredProjectionMatrix(eye: StereoscopicEye): Matrix4x4;
    GetStereoProjectionMatrices(): CSArray<Matrix4x4>;
    GetStereoProjectionMatrix(eye: StereoscopicEye): Matrix4x4;
    GetStereoViewMatrices(): CSArray<Matrix4x4>;
    GetStereoViewMatrix(eye: StereoscopicEye): Matrix4x4;
    RemoveAllCommandBuffers(): void;
    RemoveCommandBuffer(evt: CameraEvent, buffer: CommandBuffer): void;
    RemoveCommandBuffers(evt: CameraEvent): void;
    Render(): void;
    RenderDontRestore(): void;
    RenderToCubemap(cubemap: Cubemap, faceMask: number): boolean;
    RenderToCubemap(cubemap: Cubemap): boolean;
    RenderToCubemap(cubemap: RenderTexture, faceMask: number): boolean;
    RenderToCubemap(cubemap: RenderTexture): boolean;
    RenderToCubemap(cubemap: RenderTexture, faceMask: number, stereoEye: MonoOrStereoscopicEye): boolean;
    RenderWithShader(shader: Shader, replacementTag: string): void;
    Reset(): void;
    ResetAspect(): void;
    ResetCullingMatrix(): void;
    ResetFieldOfView(): void;
    ResetProjectionMatrix(): void;
    ResetReplacementShader(): void;
    ResetStereoProjectionMatrices(): void;
    ResetStereoViewMatrices(): void;
    ResetTransparencySortSettings(): void;
    ResetWorldToCameraMatrix(): void;
    ScreenPointToRay(pos: Vector3, eye: MonoOrStereoscopicEye): Ray;
    ScreenPointToRay(pos: Vector3): Ray;
    ScreenToViewportPoint(position: Vector3): Vector3;
    ScreenToWorldPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    ScreenToWorldPoint(position: Vector3): Vector3;
    SetReplacementShader(shader: Shader, replacementTag: string): void;
    SetStereoProjectionMatrices(leftMatrix: Matrix4x4, rightMatrix: Matrix4x4): void;
    SetStereoProjectionMatrix(eye: StereoscopicEye, matrix: Matrix4x4): void;
    SetStereoViewMatrices(leftMatrix: Matrix4x4, rightMatrix: Matrix4x4): void;
    SetStereoViewMatrix(eye: StereoscopicEye, matrix: Matrix4x4): void;
    SetTargetBuffers(colorBuffer: RenderBuffer, depthBuffer: RenderBuffer): void;
    SetTargetBuffers(colorBuffer: CSArray<RenderBuffer>, depthBuffer: RenderBuffer): void;
    SubmitRenderRequest<RequestData>(renderRequest: RequestData): void;
    SubmitRenderRequests(renderRequests: CSArray<RenderRequest>): void;
    TryGetCullingParameters(cullingParameters: unknown): boolean;
    TryGetCullingParameters(stereoAware: boolean, cullingParameters: unknown): boolean;
    ViewportPointToRay(pos: Vector3, eye: MonoOrStereoscopicEye): Ray;
    ViewportPointToRay(pos: Vector3): Ray;
    ViewportToScreenPoint(position: Vector3): Vector3;
    ViewportToWorldPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    ViewportToWorldPoint(position: Vector3): Vector3;
    WorldToScreenPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    WorldToScreenPoint(position: Vector3): Vector3;
    WorldToViewportPoint(position: Vector3, eye: MonoOrStereoscopicEye): Vector3;
    WorldToViewportPoint(position: Vector3): Vector3;
}
    
interface RenderTexture extends Texture {
    width: number;
    height: number;
    dimension: TextureDimension;
    graphicsFormat: GraphicsFormat;
    useMipMap: boolean;
    sRGB: boolean;
    vrUsage: VRTextureUsage;
    memorylessMode: RenderTextureMemoryless;
    format: RenderTextureFormat;
    stencilFormat: GraphicsFormat;
    depthStencilFormat: GraphicsFormat;
    autoGenerateMips: boolean;
    volumeDepth: number;
    antiAliasing: number;
    bindTextureMS: boolean;
    enableRandomWrite: boolean;
    useDynamicScale: boolean;
    useDynamicScaleExplicit: boolean;
    isPowerOfTwo: boolean;
    colorBuffer: RenderBuffer;
    depthBuffer: RenderBuffer;
    depth: number;
    descriptor: RenderTextureDescriptor;
    generateMips: boolean;
    isCubemap: boolean;
    isVolume: boolean;


    ApplyDynamicScale(): void;
    ConvertToEquirect(equirect: RenderTexture, eye: MonoOrStereoscopicEye): void;
    Create(): boolean;
    DiscardContents(discardColor: boolean, discardDepth: boolean): void;
    DiscardContents(): void;
    GenerateMips(): void;
    GetNativeDepthBufferPtr(): unknown;
    GetTexelOffset(): Vector2;
    IsCreated(): boolean;
    MarkRestoreExpected(): void;
    Release(): void;
    ResolveAntiAliasedSurface(): void;
    ResolveAntiAliasedSurface(target: RenderTexture): void;
    SetBorderColor(color: Color): void;
    SetGlobalShaderProperty(propertyName: string): void;
}
    
interface RenderBuffer {


    GetNativeRenderBufferPtr(): unknown;
}
    
interface RenderTextureDescriptor {
    width: number;
    height: number;
    msaaSamples: number;
    volumeDepth: number;
    mipCount: number;
    graphicsFormat: GraphicsFormat;
    stencilFormat: GraphicsFormat;
    depthStencilFormat: GraphicsFormat;
    colorFormat: RenderTextureFormat;
    sRGB: boolean;
    depthBufferBits: number;
    dimension: TextureDimension;
    shadowSamplingMode: ShadowSamplingMode;
    vrUsage: VRTextureUsage;
    flags: RenderTextureCreationFlags;
    memoryless: RenderTextureMemoryless;
    useMipMap: boolean;
    autoGenerateMips: boolean;
    enableRandomWrite: boolean;
    bindMS: boolean;
    useDynamicScale: boolean;
    useDynamicScaleExplicit: boolean;


}
    
interface RenderTextureDescriptorConstructor {

    new(width: number, height: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthBufferBits: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number, mipCount: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: RenderTextureFormat, depthBufferBits: number, mipCount: number, readWrite: RenderTextureReadWrite): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthBufferBits: number, mipCount: number): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat): RenderTextureDescriptor;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: number): RenderTextureDescriptor;

}
declare const RenderTextureDescriptor: RenderTextureDescriptorConstructor;
    
interface RenderTextureConstructor {
    active: RenderTexture;
    enabled: boolean;

    new(desc: RenderTextureDescriptor): RenderTexture;
    new(textureToCopy: RenderTexture): RenderTexture;
    new(width: number, height: number, depth: number, format: DefaultFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: GraphicsFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: GraphicsFormat, mipCount: number): RenderTexture;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat, mipCount: number): RenderTexture;
    new(width: number, height: number, colorFormat: GraphicsFormat, depthStencilFormat: GraphicsFormat): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat): RenderTexture;
    new(width: number, height: number, depth: number): RenderTexture;
    new(width: number, height: number, depth: number, format: RenderTextureFormat, mipCount: number): RenderTexture;

    GetTemporary(desc: RenderTextureDescriptor): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: boolean): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number, memorylessMode: RenderTextureMemoryless): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat, antiAliasing: number): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: GraphicsFormat): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage, useDynamicScale: boolean): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless, vrUsage: VRTextureUsage): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, memorylessMode: RenderTextureMemoryless): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number, format: RenderTextureFormat): RenderTexture;
    GetTemporary(width: number, height: number, depthBuffer: number): RenderTexture;
    GetTemporary(width: number, height: number): RenderTexture;
    ReleaseTemporary(temp: RenderTexture): void;
    SupportsStencil(rt: RenderTexture): boolean;
}
declare const RenderTexture: RenderTextureConstructor;
    
interface CommandBuffer {
    name: string;
    sizeInBytes: number;


    BeginRenderPass(width: number, height: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>): void;
    BeginRenderPass(width: number, height: number, volumeDepth: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>): void;
    BeginRenderPass(width: number, height: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>, debugNameUtf8: unknown): void;
    BeginRenderPass(width: number, height: number, volumeDepth: number, samples: number, attachments: CSArray<AttachmentDescriptor>, depthAttachmentIndex: number, subPasses: CSArray<SubPassDescriptor>, debugNameUtf8: unknown): void;
    BeginSample(name: string): void;
    BeginSample(sampler: CustomSampler): void;
    BeginSample(marker: ProfilerMarker): void;
    Blit(source: Texture, dest: RenderTargetIdentifier): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, mat: Material): void;
    Blit(source: Texture, dest: RenderTargetIdentifier, mat: Material, pass: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, scale: Vector2, offset: Vector2, sourceDepthSlice: number, destDepthSlice: number): void;
    Blit(source: RenderTargetIdentifier, dest: RenderTargetIdentifier, mat: Material, pass: number, destDepthSlice: number): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure, relativeOrigin: Vector3): void;
    BuildRayTracingAccelerationStructure(accelerationStructure: RayTracingAccelerationStructure, buildSettings: BuildSettings): void;
    Clear(): void;
    ClearRandomWriteTargets(): void;
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color): void;
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color, depth: number): void;
    ClearRenderTarget(clearDepth: boolean, clearColor: boolean, backgroundColor: Color, depth: number, stencil: number): void;
    ClearRenderTarget(clearFlags: RTClearFlags, backgroundColor: Color, depth: number, stencil: number): void;
    ClearRenderTarget(clearFlags: RTClearFlags, backgroundColors: CSArray<Color>, depth: number, stencil: number): void;
    ConfigureFoveatedRendering(platformData: unknown): void;
    ConvertTexture(src: RenderTargetIdentifier, dst: RenderTargetIdentifier): void;
    ConvertTexture(src: RenderTargetIdentifier, srcElement: number, dst: RenderTargetIdentifier, dstElement: number): void;
    CopyBuffer(source: GraphicsBuffer, dest: GraphicsBuffer): void;
    CopyCounterValue(src: ComputeBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: GraphicsBuffer, dst: ComputeBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: ComputeBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyCounterValue(src: GraphicsBuffer, dst: GraphicsBuffer, dstOffsetBytes: number): void;
    CopyTexture(src: RenderTargetIdentifier, dst: RenderTargetIdentifier): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, dst: RenderTargetIdentifier, dstElement: number): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, srcMip: number, dst: RenderTargetIdentifier, dstElement: number, dstMip: number): void;
    CopyTexture(src: RenderTargetIdentifier, srcElement: number, srcMip: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number, dst: RenderTargetIdentifier, dstElement: number, dstMip: number, dstX: number, dstY: number): void;
    CreateAsyncGraphicsFence(): GraphicsFence;
    CreateAsyncGraphicsFence(stage: SynchronisationStage): GraphicsFence;
    CreateGPUFence(stage: SynchronisationStage): GPUFence;
    CreateGPUFence(): GPUFence;
    CreateGraphicsFence(fenceType: GraphicsFenceType, stage: SynchronisationStageFlags): GraphicsFence;
    DisableKeyword(keyword: unknown): void;
    DisableKeyword(material: Material, keyword: unknown): void;
    DisableKeyword(computeShader: ComputeShader, keyword: unknown): void;
    DisableScissorRect(): void;
    DisableShaderKeyword(keyword: string): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, threadGroupsX: number, threadGroupsY: number, threadGroupsZ: number): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, indirectBuffer: ComputeBuffer, argsOffset: number): void;
    DispatchCompute(computeShader: ComputeShader, kernelIndex: number, indirectBuffer: GraphicsBuffer, argsOffset: number): void;
    DispatchRays(rayTracingShader: RayTracingShader, rayGenName: string, width: number, height: number, depth: number, camera: Camera): void;
    Dispose(): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, shaderPass: number, properties: MaterialPropertyBlock): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, shaderPass: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number): void;
    DrawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>, count: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>, count: number): void;
    DrawMeshInstanced(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, matrices: CSArray<Matrix4x4>): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: ComputeBuffer): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawMeshInstancedIndirect(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, bufferWithArgs: GraphicsBuffer): void;
    DrawMeshInstancedProcedural(mesh: Mesh, submeshIndex: number, material: Material, shaderPass: number, count: number, properties: MaterialPropertyBlock): void;
    DrawMultipleMeshes(matrices: CSArray<Matrix4x4>, meshes: CSArray<Mesh>, subsetIndices: CSArray<number>, count: number, material: Material, shaderPass: number, properties: MaterialPropertyBlock): void;
    DrawOcclusionMesh(normalizedCamViewport: RectInt): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number, instanceCount: number, properties: MaterialPropertyBlock): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number, instanceCount: number): void;
    DrawProcedural(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, vertexCount: number): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number, instanceCount: number, properties: MaterialPropertyBlock): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number, instanceCount: number): void;
    DrawProcedural(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, indexCount: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer, argsOffset: number): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: ComputeBuffer): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralIndirect(matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number, properties: MaterialPropertyBlock): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer, argsOffset: number): void;
    DrawProceduralIndirect(indexBuffer: GraphicsBuffer, matrix: Matrix4x4, material: Material, shaderPass: number, topology: MeshTopology, bufferWithArgs: GraphicsBuffer): void;
    DrawRenderer(renderer: Renderer, material: Material, submeshIndex: number, shaderPass: number): void;
    DrawRenderer(renderer: Renderer, material: Material, submeshIndex: number): void;
    DrawRenderer(renderer: Renderer, material: Material): void;
    DrawRendererList(rendererList: RendererList): void;
    EnableKeyword(keyword: unknown): void;
    EnableKeyword(material: Material, keyword: unknown): void;
    EnableKeyword(computeShader: ComputeShader, keyword: unknown): void;
    EnableScissorRect(scissor: Rect): void;
    EnableShaderKeyword(keyword: string): void;
    EndRenderPass(): void;
    EndSample(name: string): void;
    EndSample(sampler: CustomSampler): void;
    EndSample(marker: ProfilerMarker): void;
    GenerateMips(rt: RenderTargetIdentifier): void;
    GenerateMips(rt: RenderTexture): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless, useDynamicScale: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless, useDynamicScale: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean, memorylessMode: RenderTextureMemoryless): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number, filter: FilterMode): void;
    GetTemporaryRT(nameID: number, width: number, height: number, depthBuffer: number): void;
    GetTemporaryRT(nameID: number, width: number, height: number): void;
    GetTemporaryRT(nameID: number, desc: RenderTextureDescriptor, filter: FilterMode): void;
    GetTemporaryRT(nameID: number, desc: RenderTextureDescriptor): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean, useDynamicScale: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat, antiAliasing: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: GraphicsFormat): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number, enableRandomWrite: boolean): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite, antiAliasing: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat, readWrite: RenderTextureReadWrite): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode, format: RenderTextureFormat): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number, filter: FilterMode): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number, depthBuffer: number): void;
    GetTemporaryRTArray(nameID: number, width: number, height: number, slices: number): void;
    IncrementUpdateCount(dest: RenderTargetIdentifier): void;
    InvokeOnRenderObjectCallbacks(): void;
    IssuePluginCustomBlit(callback: unknown, command: number, source: RenderTargetIdentifier, dest: RenderTargetIdentifier, commandParam: number, commandFlags: number): void;
    IssuePluginCustomTextureUpdate(callback: unknown, targetTexture: Texture, userData: number): void;
    IssuePluginCustomTextureUpdateV1(callback: unknown, targetTexture: Texture, userData: number): void;
    IssuePluginCustomTextureUpdateV2(callback: unknown, targetTexture: Texture, userData: number): void;
    IssuePluginEvent(callback: unknown, eventID: number): void;
    IssuePluginEventAndData(callback: unknown, eventID: number, data: unknown): void;
    IssuePluginEventAndDataWithFlags(callback: unknown, eventID: number, flags: CustomMarkerCallbackFlags, data: unknown): void;
    MarkLateLatchMatrixShaderPropertyID(matrixPropertyType: CameraLateLatchMatrixType, shaderPropertyID: number): void;
    NextSubPass(): void;
    ProcessVTFeedback(rt: RenderTargetIdentifier, resolver: unknown, slice: number, x: number, width: number, y: number, height: number, mip: number): void;
    Release(): void;
    ReleaseTemporaryRT(nameID: number): void;
    RequestAsyncReadback(src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadback(src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadback(src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadback(src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadback(src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeArray<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: ComputeBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: ComputeBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: GraphicsBuffer, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: GraphicsBuffer, size: number, offset: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, dstFormat: GraphicsFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: TextureFormat, callback: unknown): void;
    RequestAsyncReadbackIntoNativeSlice<T>(output: CSArray<T>, src: Texture, mipIndex: number, x: number, width: number, y: number, height: number, z: number, depth: number, dstFormat: GraphicsFormat, callback: unknown): void;
    ResolveAntiAliasedSurface(rt: RenderTexture, target: RenderTexture): void;
    SetBufferCounterValue(buffer: ComputeBuffer, counterValue: number): void;
    SetBufferCounterValue(buffer: GraphicsBuffer, counterValue: number): void;
    SetBufferData(buffer: ComputeBuffer, data: unknown): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetBufferData(buffer: ComputeBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData(buffer: GraphicsBuffer, data: unknown): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>): void;
    SetBufferData(buffer: GraphicsBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetBufferData<T>(buffer: GraphicsBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferCounterValue(buffer: ComputeBuffer, counterValue: number): void;
    SetComputeBufferData(buffer: ComputeBuffer, data: unknown): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>): void;
    SetComputeBufferData(buffer: ComputeBuffer, data: unknown, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, managedBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferData<T>(buffer: ComputeBuffer, data: CSArray<T>, nativeBufferStartIndex: number, graphicsBufferStartIndex: number, count: number): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, buffer: ComputeBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, buffer: ComputeBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, bufferHandle: GraphicsBufferHandle): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, bufferHandle: GraphicsBufferHandle): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, buffer: GraphicsBuffer): void;
    SetComputeBufferParam(computeShader: ComputeShader, kernelIndex: number, name: string, buffer: GraphicsBuffer): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetComputeConstantBufferParam(computeShader: ComputeShader, name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetComputeFloatParam(computeShader: ComputeShader, nameID: number, val: number): void;
    SetComputeFloatParam(computeShader: ComputeShader, name: string, val: number): void;
    SetComputeFloatParams(computeShader: ComputeShader, name: string, values: CSArray<number>): void;
    SetComputeFloatParams(computeShader: ComputeShader, nameID: number, values: CSArray<number>): void;
    SetComputeIntParam(computeShader: ComputeShader, nameID: number, val: number): void;
    SetComputeIntParam(computeShader: ComputeShader, name: string, val: number): void;
    SetComputeIntParams(computeShader: ComputeShader, name: string, values: CSArray<number>): void;
    SetComputeIntParams(computeShader: ComputeShader, nameID: number, values: CSArray<number>): void;
    SetComputeMatrixArrayParam(computeShader: ComputeShader, nameID: number, values: CSArray<Matrix4x4>): void;
    SetComputeMatrixArrayParam(computeShader: ComputeShader, name: string, values: CSArray<Matrix4x4>): void;
    SetComputeMatrixParam(computeShader: ComputeShader, nameID: number, val: Matrix4x4): void;
    SetComputeMatrixParam(computeShader: ComputeShader, name: string, val: Matrix4x4): void;
    SetComputeParamsFromMaterial(computeShader: ComputeShader, kernelIndex: number, material: Material): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier, mipLevel: number): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier, mipLevel: number): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, name: string, rt: RenderTargetIdentifier, mipLevel: number, element: RenderTextureSubElement): void;
    SetComputeTextureParam(computeShader: ComputeShader, kernelIndex: number, nameID: number, rt: RenderTargetIdentifier, mipLevel: number, element: RenderTextureSubElement): void;
    SetComputeVectorArrayParam(computeShader: ComputeShader, nameID: number, values: CSArray<Vector4>): void;
    SetComputeVectorArrayParam(computeShader: ComputeShader, name: string, values: CSArray<Vector4>): void;
    SetComputeVectorParam(computeShader: ComputeShader, nameID: number, val: Vector4): void;
    SetComputeVectorParam(computeShader: ComputeShader, name: string, val: Vector4): void;
    SetExecutionFlags(flags: CommandBufferExecutionFlags): void;
    SetFoveatedRenderingMode(foveatedRenderingMode: FoveatedRenderingMode): void;
    SetGlobalBuffer(name: string, value: ComputeBuffer): void;
    SetGlobalBuffer(nameID: number, value: ComputeBuffer): void;
    SetGlobalBuffer(name: string, value: GraphicsBuffer): void;
    SetGlobalBuffer(nameID: number, value: GraphicsBuffer): void;
    SetGlobalColor(nameID: number, value: Color): void;
    SetGlobalColor(name: string, value: Color): void;
    SetGlobalConstantBuffer(buffer: ComputeBuffer, nameID: number, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: ComputeBuffer, name: string, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: GraphicsBuffer, nameID: number, offset: number, size: number): void;
    SetGlobalConstantBuffer(buffer: GraphicsBuffer, name: string, offset: number, size: number): void;
    SetGlobalDepthBias(bias: number, slopeBias: number): void;
    SetGlobalFloat(nameID: number, value: number): void;
    SetGlobalFloat(name: string, value: number): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(propertyName: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(propertyName: string, values: CSArray<number>): void;
    SetGlobalInt(nameID: number, value: number): void;
    SetGlobalInt(name: string, value: number): void;
    SetGlobalInteger(nameID: number, value: number): void;
    SetGlobalInteger(name: string, value: number): void;
    SetGlobalMatrix(nameID: number, value: Matrix4x4): void;
    SetGlobalMatrix(name: string, value: Matrix4x4): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(propertyName: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(propertyName: string, values: CSArray<Matrix4x4>): void;
    SetGlobalRayTracingAccelerationStructure(name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    SetGlobalRayTracingAccelerationStructure(nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    SetGlobalTexture(name: string, value: RenderTargetIdentifier): void;
    SetGlobalTexture(nameID: number, value: RenderTargetIdentifier): void;
    SetGlobalTexture(name: string, value: RenderTargetIdentifier, element: RenderTextureSubElement): void;
    SetGlobalTexture(nameID: number, value: RenderTargetIdentifier, element: RenderTextureSubElement): void;
    SetGlobalVector(nameID: number, value: Vector4): void;
    SetGlobalVector(name: string, value: Vector4): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(propertyName: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(propertyName: string, values: CSArray<Vector4>): void;
    SetInstanceMultiplier(multiplier: number): void;
    SetInvertCulling(invertCulling: boolean): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetKeyword(material: Material, keyword: unknown, value: boolean): void;
    SetKeyword(computeShader: ComputeShader, keyword: unknown, value: boolean): void;
    SetLateLatchProjectionMatrices(projectionMat: CSArray<Matrix4x4>): void;
    SetProjectionMatrix(proj: Matrix4x4): void;
    SetRandomWriteTarget(index: number, rt: RenderTargetIdentifier): void;
    SetRandomWriteTarget(index: number, buffer: ComputeBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, buffer: ComputeBuffer): void;
    SetRandomWriteTarget(index: number, buffer: GraphicsBuffer, preserveCounterValue: boolean): void;
    SetRandomWriteTarget(index: number, buffer: GraphicsBuffer): void;
    SetRayTracingAccelerationStructure(rayTracingShader: RayTracingShader, name: string, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(rayTracingShader: RayTracingShader, nameID: number, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(computeShader: ComputeShader, kernelIndex: number, name: string, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(computeShader: ComputeShader, kernelIndex: number, nameID: number, rayTracingAccelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: ComputeBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: ComputeBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: GraphicsBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: GraphicsBuffer): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, name: string, bufferHandle: GraphicsBufferHandle): void;
    SetRayTracingBufferParam(rayTracingShader: RayTracingShader, nameID: number, bufferHandle: GraphicsBufferHandle): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetRayTracingConstantBufferParam(rayTracingShader: RayTracingShader, name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetRayTracingFloatParam(rayTracingShader: RayTracingShader, name: string, val: number): void;
    SetRayTracingFloatParam(rayTracingShader: RayTracingShader, nameID: number, val: number): void;
    SetRayTracingFloatParams(rayTracingShader: RayTracingShader, name: string, values: CSArray<number>): void;
    SetRayTracingFloatParams(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<number>): void;
    SetRayTracingIntParam(rayTracingShader: RayTracingShader, name: string, val: number): void;
    SetRayTracingIntParam(rayTracingShader: RayTracingShader, nameID: number, val: number): void;
    SetRayTracingIntParams(rayTracingShader: RayTracingShader, name: string, values: CSArray<number>): void;
    SetRayTracingIntParams(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<number>): void;
    SetRayTracingMatrixArrayParam(rayTracingShader: RayTracingShader, name: string, values: CSArray<Matrix4x4>): void;
    SetRayTracingMatrixArrayParam(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<Matrix4x4>): void;
    SetRayTracingMatrixParam(rayTracingShader: RayTracingShader, name: string, val: Matrix4x4): void;
    SetRayTracingMatrixParam(rayTracingShader: RayTracingShader, nameID: number, val: Matrix4x4): void;
    SetRayTracingShaderPass(rayTracingShader: RayTracingShader, passName: string): void;
    SetRayTracingTextureParam(rayTracingShader: RayTracingShader, name: string, rt: RenderTargetIdentifier): void;
    SetRayTracingTextureParam(rayTracingShader: RayTracingShader, nameID: number, rt: RenderTargetIdentifier): void;
    SetRayTracingVectorArrayParam(rayTracingShader: RayTracingShader, name: string, values: CSArray<Vector4>): void;
    SetRayTracingVectorArrayParam(rayTracingShader: RayTracingShader, nameID: number, values: CSArray<Vector4>): void;
    SetRayTracingVectorParam(rayTracingShader: RayTracingShader, name: string, val: Vector4): void;
    SetRayTracingVectorParam(rayTracingShader: RayTracingShader, nameID: number, val: Vector4): void;
    SetRenderTarget(rt: RenderTargetIdentifier): void;
    SetRenderTarget(rt: RenderTargetIdentifier, loadAction: RenderBufferLoadAction, storeAction: RenderBufferStoreAction): void;
    SetRenderTarget(rt: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace): void;
    SetRenderTarget(rt: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace): void;
    SetRenderTarget(color: RenderTargetIdentifier, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(color: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depth: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): void;
    SetRenderTarget(colors: CSArray<RenderTargetIdentifier>, depth: RenderTargetIdentifier): void;
    SetRenderTarget(colors: CSArray<RenderTargetIdentifier>, depth: RenderTargetIdentifier, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(binding: RenderTargetBinding, mipLevel: number, cubemapFace: CubemapFace, depthSlice: number): void;
    SetRenderTarget(binding: RenderTargetBinding): void;
    SetShadowSamplingMode(shadowmap: RenderTargetIdentifier, mode: ShadowSamplingMode): void;
    SetSinglePassStereo(mode: SinglePassStereoMode): void;
    SetupCameraProperties(camera: Camera): void;
    SetViewMatrix(view: Matrix4x4): void;
    SetViewport(pixelRect: Rect): void;
    SetViewProjectionMatrices(view: Matrix4x4, proj: Matrix4x4): void;
    SetWireframe(enable: boolean): void;
    UnmarkLateLatchMatrix(matrixPropertyType: CameraLateLatchMatrixType): void;
    WaitAllAsyncReadbackRequests(): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStage): void;
    WaitOnAsyncGraphicsFence(fence: GraphicsFence, stage: SynchronisationStageFlags): void;
    WaitOnGPUFence(fence: GPUFence, stage: SynchronisationStage): void;
    WaitOnGPUFence(fence: GPUFence): void;
}
    
interface AttachmentDescriptor {
    loadAction: RenderBufferLoadAction;
    storeAction: RenderBufferStoreAction;
    graphicsFormat: GraphicsFormat;
    format: RenderTextureFormat;
    loadStoreTarget: RenderTargetIdentifier;
    resolveTarget: RenderTargetIdentifier;
    clearColor: Color;
    clearDepth: number;
    clearStencil: number;


    ConfigureClear(clearColor: Color, clearDepth: number, clearStencil: number): void;
    ConfigureResolveTarget(target: RenderTargetIdentifier): void;
    ConfigureTarget(target: RenderTargetIdentifier, loadExistingContents: boolean, storeResults: boolean): void;
    Equals(other: AttachmentDescriptor): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
}
    
interface RenderTargetIdentifier {


    Equals(rhs: RenderTargetIdentifier): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface RenderTargetIdentifierConstructor {
    AllDepthSlices: number;

    new(type: BuiltinRenderTextureType): RenderTargetIdentifier;
    new(type: BuiltinRenderTextureType, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(name: string): RenderTargetIdentifier;
    new(name: string, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(nameID: number): RenderTargetIdentifier;
    new(nameID: number, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(renderTargetIdentifier: RenderTargetIdentifier, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(tex: Texture): RenderTargetIdentifier;
    new(tex: Texture, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;
    new(buf: RenderBuffer, mipLevel: number, cubeFace: CubemapFace, depthSlice: number): RenderTargetIdentifier;

}
declare const RenderTargetIdentifier: RenderTargetIdentifierConstructor;
    
interface AttachmentDescriptorConstructor {

    new(format: GraphicsFormat): AttachmentDescriptor;
    new(format: RenderTextureFormat): AttachmentDescriptor;
    new(format: RenderTextureFormat, target: RenderTargetIdentifier, loadExistingContents: boolean, storeResults: boolean, resolve: boolean): AttachmentDescriptor;

}
declare const AttachmentDescriptor: AttachmentDescriptorConstructor;
    
interface SubPassDescriptor {
    inputs: AttachmentIndexArray;
    colorOutputs: AttachmentIndexArray;
    flags: SubPassFlags;


}
    
interface AttachmentIndexArray {
    Item: number;
    Length: number;


}
    
interface AttachmentIndexArrayConstructor {
    Emtpy: AttachmentIndexArray;
    MaxAttachments: number;

    new(numAttachments: number): AttachmentIndexArray;
    new(attachments: CSArray<number>): AttachmentIndexArray;
    new(attachments: CSArray<number>): AttachmentIndexArray;

}
declare const AttachmentIndexArray: AttachmentIndexArrayConstructor;
    
interface Sampler {
    isValid: boolean;
    name: string;


    GetRecorder(): Recorder;
}
    
interface Recorder {
    isValid: boolean;
    enabled: boolean;
    elapsedNanoseconds: number;
    gpuElapsedNanoseconds: number;
    sampleBlockCount: number;
    gpuSampleBlockCount: number;


    CollectFromAllThreads(): void;
    FilterToCurrentThread(): void;
}
    
interface RecorderConstructor {


    Get(samplerName: string): Recorder;
}
declare const Recorder: RecorderConstructor;
    
interface SamplerConstructor {


    Get(name: string): Sampler;
    GetNames(names: CSArray<string>): number;
}
declare const Sampler: SamplerConstructor;
    
interface CustomSampler extends Sampler {


    Begin(): void;
    Begin(targetObject: Object): void;
    End(): void;
}
    
interface CustomSamplerConstructor {


    Create(name: string, collectGpuData: boolean): CustomSampler;
}
declare const CustomSampler: CustomSamplerConstructor;
    
interface ProfilerMarker {
    Handle: unknown;


    Auto(): AutoScope;
    Begin(): void;
    Begin(contextUnityObject: Object): void;
    End(): void;
}
    
interface AutoScope {


    Dispose(): void;
}
    
interface ProfilerMarkerConstructor {

    new(name: string): ProfilerMarker;
    new(name: unknown, nameLen: number): ProfilerMarker;
    new(category: ProfilerCategory, name: string): ProfilerMarker;
    new(category: ProfilerCategory, name: unknown, nameLen: number): ProfilerMarker;
    new(category: ProfilerCategory, name: string, flags: MarkerFlags): ProfilerMarker;
    new(category: ProfilerCategory, name: unknown, nameLen: number, flags: MarkerFlags): ProfilerMarker;

}
declare const ProfilerMarker: ProfilerMarkerConstructor;
    
interface Material extends Object {
    shader: Shader;
    color: Color;
    mainTexture: Texture;
    mainTextureOffset: Vector2;
    mainTextureScale: Vector2;
    renderQueue: number;
    enabledKeywords: CSArray<LocalKeyword>;
    globalIlluminationFlags: MaterialGlobalIlluminationFlags;
    doubleSidedGI: boolean;
    enableInstancing: boolean;
    passCount: number;
    shaderKeywords: CSArray<string>;
    parent: Material;
    isVariant: boolean;


    ApplyPropertyOverride(destination: Material, nameID: number, recordUndo: boolean): void;
    ApplyPropertyOverride(destination: Material, name: string, recordUndo: boolean): void;
    ComputeCRC(): number;
    CopyMatchingPropertiesFromMaterial(mat: Material): void;
    CopyPropertiesFromMaterial(mat: Material): void;
    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    FindPass(passName: string): number;
    GetBuffer(name: string): GraphicsBufferHandle;
    GetColor(name: string): Color;
    GetColor(nameID: number): Color;
    GetColorArray(name: string): CSArray<Color>;
    GetColorArray(nameID: number): CSArray<Color>;
    GetColorArray(name: string, values: CSArray<Color>): void;
    GetColorArray(nameID: number, values: CSArray<Color>): void;
    GetConstantBuffer(name: string): GraphicsBufferHandle;
    GetFloat(name: string): number;
    GetFloat(nameID: number): number;
    GetFloatArray(name: string): CSArray<number>;
    GetFloatArray(nameID: number): CSArray<number>;
    GetFloatArray(name: string, values: CSArray<number>): void;
    GetFloatArray(nameID: number, values: CSArray<number>): void;
    GetInt(name: string): number;
    GetInt(nameID: number): number;
    GetInteger(name: string): number;
    GetInteger(nameID: number): number;
    GetMatrix(name: string): Matrix4x4;
    GetMatrix(nameID: number): Matrix4x4;
    GetMatrixArray(name: string): CSArray<Matrix4x4>;
    GetMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetPassName(pass: number): string;
    GetPropertyNames(type: MaterialPropertyType): CSArray<string>;
    GetShaderPassEnabled(passName: string): boolean;
    GetTag(tag: string, searchFallbacks: boolean, defaultValue: string): string;
    GetTag(tag: string, searchFallbacks: boolean): string;
    GetTexture(name: string): Texture;
    GetTexture(nameID: number): Texture;
    GetTextureOffset(name: string): Vector2;
    GetTextureOffset(nameID: number): Vector2;
    GetTexturePropertyNameIDs(): CSArray<number>;
    GetTexturePropertyNameIDs(outNames: CSArray<number>): void;
    GetTexturePropertyNames(): CSArray<string>;
    GetTexturePropertyNames(outNames: CSArray<string>): void;
    GetTextureScale(name: string): Vector2;
    GetTextureScale(nameID: number): Vector2;
    GetVector(name: string): Vector4;
    GetVector(nameID: number): Vector4;
    GetVectorArray(name: string): CSArray<Vector4>;
    GetVectorArray(nameID: number): CSArray<Vector4>;
    GetVectorArray(name: string, values: CSArray<Vector4>): void;
    GetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    HasBuffer(name: string): boolean;
    HasBuffer(nameID: number): boolean;
    HasColor(name: string): boolean;
    HasColor(nameID: number): boolean;
    HasConstantBuffer(name: string): boolean;
    HasConstantBuffer(nameID: number): boolean;
    HasFloat(name: string): boolean;
    HasFloat(nameID: number): boolean;
    HasInt(name: string): boolean;
    HasInt(nameID: number): boolean;
    HasInteger(name: string): boolean;
    HasInteger(nameID: number): boolean;
    HasMatrix(name: string): boolean;
    HasMatrix(nameID: number): boolean;
    HasProperty(nameID: number): boolean;
    HasProperty(name: string): boolean;
    HasTexture(name: string): boolean;
    HasTexture(nameID: number): boolean;
    HasVector(name: string): boolean;
    HasVector(nameID: number): boolean;
    IsChildOf(ancestor: Material): boolean;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    IsPropertyLocked(nameID: number): boolean;
    IsPropertyLocked(name: string): boolean;
    IsPropertyLockedByAncestor(nameID: number): boolean;
    IsPropertyLockedByAncestor(name: string): boolean;
    IsPropertyOverriden(nameID: number): boolean;
    IsPropertyOverriden(name: string): boolean;
    Lerp(start: Material, end: Material, t: number): void;
    RevertAllPropertyOverrides(): void;
    RevertPropertyOverride(nameID: number): void;
    RevertPropertyOverride(name: string): void;
    SetBuffer(name: string, value: ComputeBuffer): void;
    SetBuffer(nameID: number, value: ComputeBuffer): void;
    SetBuffer(name: string, value: GraphicsBuffer): void;
    SetBuffer(nameID: number, value: GraphicsBuffer): void;
    SetColor(name: string, value: Color): void;
    SetColor(nameID: number, value: Color): void;
    SetColorArray(name: string, values: CSArray<Color>): void;
    SetColorArray(nameID: number, values: CSArray<Color>): void;
    SetColorArray(name: string, values: CSArray<Color>): void;
    SetColorArray(nameID: number, values: CSArray<Color>): void;
    SetConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(name: string, value: number): void;
    SetFloat(nameID: number, value: number): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetInt(name: string, value: number): void;
    SetInt(nameID: number, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(nameID: number, value: number): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetMatrix(name: string, value: Matrix4x4): void;
    SetMatrix(nameID: number, value: Matrix4x4): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetOverrideTag(tag: string, val: string): void;
    SetPass(pass: number): boolean;
    SetPropertyLock(nameID: number, value: boolean): void;
    SetPropertyLock(name: string, value: boolean): void;
    SetShaderPassEnabled(passName: string, enabled: boolean): void;
    SetTexture(name: string, value: Texture): void;
    SetTexture(nameID: number, value: Texture): void;
    SetTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTextureOffset(name: string, value: Vector2): void;
    SetTextureOffset(nameID: number, value: Vector2): void;
    SetTextureScale(name: string, value: Vector2): void;
    SetTextureScale(nameID: number, value: Vector2): void;
    SetVector(name: string, value: Vector4): void;
    SetVector(nameID: number, value: Vector4): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
}
    
interface Shader extends Object {
    maximumLOD: number;
    isSupported: boolean;
    keywordSpace: LocalKeywordSpace;
    renderQueue: number;
    passCount: number;
    subshaderCount: number;


    FindPassTagValue(passIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindPassTagValue(subshaderIndex: number, passIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindPropertyIndex(propertyName: string): number;
    FindSubshaderTagValue(subshaderIndex: number, tagName: ShaderTagId): ShaderTagId;
    FindTextureStack(propertyIndex: number, stackName: CSArray<string>, layerIndex: unknown): boolean;
    GetDependency(name: string): Shader;
    GetPassCountInSubshader(subshaderIndex: number): number;
    GetPropertyAttributes(propertyIndex: number): CSArray<string>;
    GetPropertyCount(): number;
    GetPropertyDefaultFloatValue(propertyIndex: number): number;
    GetPropertyDefaultIntValue(propertyIndex: number): number;
    GetPropertyDefaultVectorValue(propertyIndex: number): Vector4;
    GetPropertyDescription(propertyIndex: number): string;
    GetPropertyFlags(propertyIndex: number): ShaderPropertyFlags;
    GetPropertyName(propertyIndex: number): string;
    GetPropertyNameId(propertyIndex: number): number;
    GetPropertyRangeLimits(propertyIndex: number): Vector2;
    GetPropertyTextureDefaultName(propertyIndex: number): string;
    GetPropertyTextureDimension(propertyIndex: number): TextureDimension;
    GetPropertyType(propertyIndex: number): ShaderPropertyType;
}
    
interface LocalKeywordSpace {
    keywords: CSArray<LocalKeyword>;
    keywordNames: CSArray<string>;
    keywordCount: number;


    Equals(o: unknown): boolean;
    Equals(rhs: LocalKeywordSpace): boolean;
    FindKeyword(name: string): LocalKeyword;
    GetHashCode(): number;
}
    
interface LocalKeyword {
    name: string;
    isDynamic: boolean;
    isOverridable: boolean;
    isValid: boolean;
    type: ShaderKeywordType;


    Equals(o: unknown): boolean;
    Equals(rhs: LocalKeyword): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface LocalKeywordConstructor {

    new(shader: Shader, name: string): LocalKeyword;
    new(shader: ComputeShader, name: string): LocalKeyword;

}
declare const LocalKeyword: LocalKeywordConstructor;
    
interface ShaderTagId {
    name: string;


    Equals(obj: unknown): boolean;
    Equals(other: ShaderTagId): boolean;
    GetHashCode(): number;
}
    
interface ShaderTagIdConstructor {
    none: ShaderTagId;

    new(name: string): ShaderTagId;

}
declare const ShaderTagId: ShaderTagIdConstructor;
    
interface GlobalKeyword {
    name: string;


    ToString(): string;
}
    
interface GlobalKeywordConstructor {

    new(name: string): GlobalKeyword;

    Create(name: string): GlobalKeyword;
}
declare const GlobalKeyword: GlobalKeywordConstructor;
    
interface RayTracingAccelerationStructure {


    AddInstance(targetRenderer: Renderer, subMeshFlags: CSArray<number>, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, id: number): number;
    AddInstance(config: RayTracingAABBsInstanceConfig, matrix: Matrix4x4, id: number): number;
    AddInstance(config: unknown, matrix: Matrix4x4, prevMatrix: unknown, id: number): number;
    AddInstance(config: unknown, matrix: Matrix4x4, prevMatrix: unknown, id: number): number;
    AddInstance(targetRenderer: Renderer, subMeshMask: CSArray<boolean>, subMeshTransparencyFlags: CSArray<boolean>, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, id: number): void;
    AddInstance(aabbBuffer: GraphicsBuffer, numElements: number, material: Material, isCutOff: boolean, enableTriangleCulling: boolean, frontTriangleCounterClockwise: boolean, mask: number, reuseBounds: boolean, id: number): void;
    AddInstance(aabbBuffer: GraphicsBuffer, aabbCount: number, dynamicData: boolean, matrix: Matrix4x4, material: Material, opaqueMaterial: boolean, properties: MaterialPropertyBlock, mask: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, instanceCount: number, startInstance: number, id: number): number;
    AddInstances<T>(config: unknown, instanceData: CSArray<T>, id: number): number;
    AddVFXInstances(targetRenderer: Renderer, vfxSystemMasks: CSArray<number>): void;
    Build(): void;
    Build(relativeOrigin: Vector3): void;
    Build(buildSettings: BuildSettings): void;
    ClearInstances(): void;
    CullInstances(cullingConfig: unknown): RayTracingInstanceCullingResults;
    Dispose(): void;
    GetInstanceCount(): number;
    GetSize(): number;
    Release(): void;
    RemoveInstance(targetRenderer: Renderer): void;
    RemoveInstance(handle: number): void;
    RemoveVFXInstances(targetRenderer: Renderer): void;
    Update(): void;
    Update(relativeOrigin: Vector3): void;
    UpdateInstanceID(renderer: Renderer, instanceID: number): void;
    UpdateInstanceID(handle: number, instanceID: number): void;
    UpdateInstanceMask(renderer: Renderer, mask: number): void;
    UpdateInstanceMask(handle: number, mask: number): void;
    UpdateInstancePropertyBlock(handle: number, properties: MaterialPropertyBlock): void;
    UpdateInstanceTransform(renderer: Renderer): void;
    UpdateInstanceTransform(handle: number, matrix: Matrix4x4): void;
}
    
interface Renderer extends Component {
    lightmapTilingOffset: Vector4;
    lightProbeAnchor: Transform;
    castShadows: boolean;
    motionVectors: boolean;
    useLightProbes: boolean;
    bounds: Bounds;
    localBounds: Bounds;
    enabled: boolean;
    isVisible: boolean;
    shadowCastingMode: ShadowCastingMode;
    receiveShadows: boolean;
    forceRenderingOff: boolean;
    staticShadowCaster: boolean;
    motionVectorGenerationMode: MotionVectorGenerationMode;
    lightProbeUsage: LightProbeUsage;
    reflectionProbeUsage: ReflectionProbeUsage;
    renderingLayerMask: number;
    rendererPriority: number;
    rayTracingMode: RayTracingMode;
    rayTracingAccelerationStructureBuildFlags: RayTracingAccelerationStructureBuildFlags;
    rayTracingAccelerationStructureBuildFlagsOverride: boolean;
    sortingLayerName: string;
    sortingLayerID: number;
    sortingOrder: number;
    allowOcclusionWhenDynamic: boolean;
    isPartOfStaticBatch: boolean;
    worldToLocalMatrix: Matrix4x4;
    localToWorldMatrix: Matrix4x4;
    lightProbeProxyVolumeOverride: GameObject;
    probeAnchor: Transform;
    lightmapIndex: number;
    realtimeLightmapIndex: number;
    lightmapScaleOffset: Vector4;
    realtimeLightmapScaleOffset: Vector4;
    materials: CSArray<Material>;
    material: Material;
    sharedMaterial: Material;
    sharedMaterials: CSArray<Material>;


    GetClosestReflectionProbes(result: CSArray<ReflectionProbeBlendInfo>): void;
    GetMaterials(m: CSArray<Material>): void;
    GetPropertyBlock(properties: MaterialPropertyBlock): void;
    GetPropertyBlock(properties: MaterialPropertyBlock, materialIndex: number): void;
    GetSharedMaterials(m: CSArray<Material>): void;
    HasPropertyBlock(): boolean;
    ResetBounds(): void;
    ResetLocalBounds(): void;
    SetMaterials(materials: CSArray<Material>): void;
    SetPropertyBlock(properties: MaterialPropertyBlock): void;
    SetPropertyBlock(properties: MaterialPropertyBlock, materialIndex: number): void;
    SetSharedMaterials(materials: CSArray<Material>): void;
}
    
interface ReflectionProbeBlendInfo {
    probe: ReflectionProbe;
    weight: number;


}
    
interface ReflectionProbe extends Behaviour {
    type: ReflectionProbeType;
    size: Vector3;
    center: Vector3;
    nearClipPlane: number;
    farClipPlane: number;
    intensity: number;
    bounds: Bounds;
    hdr: boolean;
    renderDynamicObjects: boolean;
    shadowDistance: number;
    resolution: number;
    cullingMask: number;
    clearFlags: ReflectionProbeClearFlags;
    backgroundColor: Color;
    blendDistance: number;
    boxProjection: boolean;
    mode: ReflectionProbeMode;
    importance: number;
    refreshMode: ReflectionProbeRefreshMode;
    timeSlicingMode: ReflectionProbeTimeSlicingMode;
    bakedTexture: Texture;
    customBakedTexture: Texture;
    realtimeTexture: RenderTexture;
    texture: Texture;
    textureHDRDecodeValues: Vector4;


    IsFinishedRendering(renderId: number): boolean;
    RenderProbe(): number;
    RenderProbe(targetTexture: RenderTexture): number;
    Reset(): void;
}
    
interface ReflectionProbeConstructor {
    minBakedCubemapResolution: number;
    maxBakedCubemapResolution: number;
    defaultTextureHDRDecodeValues: Vector4;
    defaultTexture: Texture;

    new(): ReflectionProbe;

    BlendCubemap(src: Texture, dst: Texture, blend: number, target: RenderTexture): boolean;
    UpdateCachedState(): void;
}
declare const ReflectionProbe: ReflectionProbeConstructor;
    
interface MaterialPropertyBlock {
    isEmpty: boolean;


    AddColor(name: string, value: Color): void;
    AddColor(nameID: number, value: Color): void;
    AddFloat(name: string, value: number): void;
    AddFloat(nameID: number, value: number): void;
    AddMatrix(name: string, value: Matrix4x4): void;
    AddMatrix(nameID: number, value: Matrix4x4): void;
    AddTexture(name: string, value: Texture): void;
    AddTexture(nameID: number, value: Texture): void;
    AddVector(name: string, value: Vector4): void;
    AddVector(nameID: number, value: Vector4): void;
    Clear(): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>, sourceStart: number, destStart: number, count: number): void;
    CopyProbeOcclusionArrayFrom(occlusionProbes: CSArray<Vector4>, sourceStart: number, destStart: number, count: number): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>, sourceStart: number, destStart: number, count: number): void;
    CopySHCoefficientArraysFrom(lightProbes: CSArray<SphericalHarmonicsL2>, sourceStart: number, destStart: number, count: number): void;
    GetColor(name: string): Color;
    GetColor(nameID: number): Color;
    GetFloat(name: string): number;
    GetFloat(nameID: number): number;
    GetFloatArray(name: string): CSArray<number>;
    GetFloatArray(nameID: number): CSArray<number>;
    GetFloatArray(name: string, values: CSArray<number>): void;
    GetFloatArray(nameID: number, values: CSArray<number>): void;
    GetInt(name: string): number;
    GetInt(nameID: number): number;
    GetInteger(name: string): number;
    GetInteger(nameID: number): number;
    GetMatrix(name: string): Matrix4x4;
    GetMatrix(nameID: number): Matrix4x4;
    GetMatrixArray(name: string): CSArray<Matrix4x4>;
    GetMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetTexture(name: string): Texture;
    GetTexture(nameID: number): Texture;
    GetVector(name: string): Vector4;
    GetVector(nameID: number): Vector4;
    GetVectorArray(name: string): CSArray<Vector4>;
    GetVectorArray(nameID: number): CSArray<Vector4>;
    GetVectorArray(name: string, values: CSArray<Vector4>): void;
    GetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    HasBuffer(name: string): boolean;
    HasBuffer(nameID: number): boolean;
    HasColor(name: string): boolean;
    HasColor(nameID: number): boolean;
    HasConstantBuffer(name: string): boolean;
    HasConstantBuffer(nameID: number): boolean;
    HasFloat(name: string): boolean;
    HasFloat(nameID: number): boolean;
    HasInt(name: string): boolean;
    HasInt(nameID: number): boolean;
    HasInteger(name: string): boolean;
    HasInteger(nameID: number): boolean;
    HasMatrix(name: string): boolean;
    HasMatrix(nameID: number): boolean;
    HasProperty(name: string): boolean;
    HasProperty(nameID: number): boolean;
    HasTexture(name: string): boolean;
    HasTexture(nameID: number): boolean;
    HasVector(name: string): boolean;
    HasVector(nameID: number): boolean;
    SetBuffer(name: string, value: ComputeBuffer): void;
    SetBuffer(nameID: number, value: ComputeBuffer): void;
    SetBuffer(name: string, value: GraphicsBuffer): void;
    SetBuffer(nameID: number, value: GraphicsBuffer): void;
    SetColor(name: string, value: Color): void;
    SetColor(nameID: number, value: Color): void;
    SetConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(name: string, value: number): void;
    SetFloat(nameID: number, value: number): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetFloatArray(name: string, values: CSArray<number>): void;
    SetFloatArray(nameID: number, values: CSArray<number>): void;
    SetInt(name: string, value: number): void;
    SetInt(nameID: number, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(nameID: number, value: number): void;
    SetMatrix(name: string, value: Matrix4x4): void;
    SetMatrix(nameID: number, value: Matrix4x4): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetTexture(name: string, value: Texture): void;
    SetTexture(nameID: number, value: Texture): void;
    SetTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetVector(name: string, value: Vector4): void;
    SetVector(nameID: number, value: Vector4): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
}
    
interface SphericalHarmonicsL2 {
    Item: number;


    AddAmbientLight(color: Color): void;
    AddDirectionalLight(direction: Vector3, color: Color, intensity: number): void;
    Clear(): void;
    Equals(other: unknown): boolean;
    Equals(other: SphericalHarmonicsL2): boolean;
    Evaluate(directions: CSArray<Vector3>, results: CSArray<Color>): void;
    GetHashCode(): number;
}
    
interface MaterialPropertyBlockConstructor {

    new(): MaterialPropertyBlock;

}
declare const MaterialPropertyBlock: MaterialPropertyBlockConstructor;
    
interface RendererConstructor {

    new(): Renderer;

}
declare const Renderer: RendererConstructor;
    
interface RayTracingAABBsInstanceConfig {
    aabbBuffer: GraphicsBuffer;
    aabbCount: number;
    aabbOffset: number;
    dynamicGeometry: boolean;
    opaqueMaterial: boolean;
    material: Material;
    materialProperties: MaterialPropertyBlock;
    layer: number;
    mask: number;
    accelerationStructureBuildFlags: RayTracingAccelerationStructureBuildFlags;
    accelerationStructureBuildFlagsOverride: boolean;


}
    
interface RayTracingAABBsInstanceConfigConstructor {

    new(): RayTracingAABBsInstanceConfig;
    new(aabbBuffer: GraphicsBuffer, aabbCount: number, dynamicGeometry: boolean, material: Material): RayTracingAABBsInstanceConfig;

}
declare const RayTracingAABBsInstanceConfig: RayTracingAABBsInstanceConfigConstructor;
    
interface BuildSettings {
    buildFlags: RayTracingAccelerationStructureBuildFlags;
    relativeOrigin: Vector3;


}
    
interface BuildSettingsConstructor {

    new(): BuildSettings;
    new(buildFlags: RayTracingAccelerationStructureBuildFlags, relativeOrigin: Vector3): BuildSettings;

}
declare const BuildSettings: BuildSettingsConstructor;
    
interface RayTracingInstanceCullingResults {
    materialsCRC: CSArray<RayTracingInstanceMaterialCRC>;
    transformsChanged: boolean;


}
    
interface RayTracingInstanceMaterialCRC {
    instanceID: number;
    crc: number;


}
    
interface RayTracingAccelerationStructureConstructor {

    new(settings: Settings): RayTracingAccelerationStructure;
    new(): RayTracingAccelerationStructure;

}
declare const RayTracingAccelerationStructure: RayTracingAccelerationStructureConstructor;
    
interface ShaderConstructor {
    globalShaderHardwareTier: ShaderHardwareTier;
    maximumChunksOverride: number;
    globalMaximumLOD: number;
    globalRenderPipeline: string;
    enabledGlobalKeywords: CSArray<GlobalKeyword>;
    globalKeywords: CSArray<GlobalKeyword>;


    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    Find(name: string): Shader;
    GetGlobalColor(name: string): Color;
    GetGlobalColor(nameID: number): Color;
    GetGlobalFloat(name: string): number;
    GetGlobalFloat(nameID: number): number;
    GetGlobalFloatArray(name: string): CSArray<number>;
    GetGlobalFloatArray(nameID: number): CSArray<number>;
    GetGlobalFloatArray(name: string, values: CSArray<number>): void;
    GetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    GetGlobalInt(name: string): number;
    GetGlobalInt(nameID: number): number;
    GetGlobalInteger(name: string): number;
    GetGlobalInteger(nameID: number): number;
    GetGlobalMatrix(name: string): Matrix4x4;
    GetGlobalMatrix(nameID: number): Matrix4x4;
    GetGlobalMatrixArray(name: string): CSArray<Matrix4x4>;
    GetGlobalMatrixArray(nameID: number): CSArray<Matrix4x4>;
    GetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    GetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    GetGlobalTexture(name: string): Texture;
    GetGlobalTexture(nameID: number): Texture;
    GetGlobalVector(name: string): Vector4;
    GetGlobalVector(nameID: number): Vector4;
    GetGlobalVectorArray(name: string): CSArray<Vector4>;
    GetGlobalVectorArray(nameID: number): CSArray<Vector4>;
    GetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    GetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    PropertyToID(name: string): number;
    SetGlobalBuffer(name: string, value: ComputeBuffer): void;
    SetGlobalBuffer(nameID: number, value: ComputeBuffer): void;
    SetGlobalBuffer(name: string, value: GraphicsBuffer): void;
    SetGlobalBuffer(nameID: number, value: GraphicsBuffer): void;
    SetGlobalColor(name: string, value: Color): void;
    SetGlobalColor(nameID: number, value: Color): void;
    SetGlobalConstantBuffer(name: string, value: ComputeBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(nameID: number, value: ComputeBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(name: string, value: GraphicsBuffer, offset: number, size: number): void;
    SetGlobalConstantBuffer(nameID: number, value: GraphicsBuffer, offset: number, size: number): void;
    SetGlobalFloat(name: string, value: number): void;
    SetGlobalFloat(nameID: number, value: number): void;
    SetGlobalFloatArray(name: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalFloatArray(name: string, values: CSArray<number>): void;
    SetGlobalFloatArray(nameID: number, values: CSArray<number>): void;
    SetGlobalInt(name: string, value: number): void;
    SetGlobalInt(nameID: number, value: number): void;
    SetGlobalInteger(name: string, value: number): void;
    SetGlobalInteger(nameID: number, value: number): void;
    SetGlobalMatrix(name: string, value: Matrix4x4): void;
    SetGlobalMatrix(nameID: number, value: Matrix4x4): void;
    SetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetGlobalMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetGlobalRayTracingAccelerationStructure(name: string, value: RayTracingAccelerationStructure): void;
    SetGlobalRayTracingAccelerationStructure(nameID: number, value: RayTracingAccelerationStructure): void;
    SetGlobalTexGenMode(propertyName: string, mode: TexGenMode): void;
    SetGlobalTexture(name: string, value: Texture): void;
    SetGlobalTexture(nameID: number, value: Texture): void;
    SetGlobalTexture(name: string, value: RenderTexture, element: RenderTextureSubElement): void;
    SetGlobalTexture(nameID: number, value: RenderTexture, element: RenderTextureSubElement): void;
    SetGlobalTextureMatrixName(propertyName: string, matrixName: string): void;
    SetGlobalVector(name: string, value: Vector4): void;
    SetGlobalVector(nameID: number, value: Vector4): void;
    SetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(name: string, values: CSArray<Vector4>): void;
    SetGlobalVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    WarmupAllShaders(): void;
}
declare const Shader: ShaderConstructor;
    
interface MaterialConstructor {

    new(shader: Shader): Material;
    new(source: Material): Material;
    new(contents: string): Material;

    Create(scriptContents: string): Material;
}
declare const Material: MaterialConstructor;
    
interface GraphicsFence {
    passed: boolean;


}
    
interface GPUFence {
    passed: boolean;


}
    
interface ComputeShader extends Object {
    keywordSpace: LocalKeywordSpace;
    shaderKeywords: CSArray<string>;
    enabledKeywords: CSArray<LocalKeyword>;


    DisableKeyword(keyword: string): void;
    DisableKeyword(keyword: unknown): void;
    Dispatch(kernelIndex: number, threadGroupsX: number, threadGroupsY: number, threadGroupsZ: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: ComputeBuffer, argsOffset: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: ComputeBuffer): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: GraphicsBuffer, argsOffset: number): void;
    DispatchIndirect(kernelIndex: number, argsBuffer: GraphicsBuffer): void;
    EnableKeyword(keyword: string): void;
    EnableKeyword(keyword: unknown): void;
    FindKernel(name: string): number;
    GetKernelThreadGroupSizes(kernelIndex: number, x: unknown, y: unknown, z: unknown): void;
    HasKernel(name: string): boolean;
    IsKeywordEnabled(keyword: string): boolean;
    IsKeywordEnabled(keyword: unknown): boolean;
    IsSupported(kernelIndex: number): boolean;
    SetBool(name: string, val: boolean): void;
    SetBool(nameID: number, val: boolean): void;
    SetBuffer(kernelIndex: number, nameID: number, buffer: ComputeBuffer): void;
    SetBuffer(kernelIndex: number, nameID: number, buffer: GraphicsBuffer): void;
    SetBuffer(kernelIndex: number, name: string, buffer: ComputeBuffer): void;
    SetBuffer(kernelIndex: number, name: string, buffer: GraphicsBuffer): void;
    SetConstantBuffer(nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(nameID: number, val: number): void;
    SetFloat(name: string, val: number): void;
    SetFloats(name: string, values: CSArray<number>): void;
    SetFloats(nameID: number, values: CSArray<number>): void;
    SetInt(nameID: number, val: number): void;
    SetInt(name: string, val: number): void;
    SetInts(name: string, values: CSArray<number>): void;
    SetInts(nameID: number, values: CSArray<number>): void;
    SetKeyword(keyword: unknown, value: boolean): void;
    SetMatrix(nameID: number, val: Matrix4x4): void;
    SetMatrix(name: string, val: Matrix4x4): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetRayTracingAccelerationStructure(kernelIndex: number, nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    SetRayTracingAccelerationStructure(kernelIndex: number, name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    SetTexture(kernelIndex: number, nameID: number, texture: Texture, mipLevel: number): void;
    SetTexture(kernelIndex: number, nameID: number, texture: Texture): void;
    SetTexture(kernelIndex: number, name: string, texture: Texture): void;
    SetTexture(kernelIndex: number, name: string, texture: Texture, mipLevel: number): void;
    SetTexture(kernelIndex: number, nameID: number, texture: RenderTexture, mipLevel: number, element: RenderTextureSubElement): void;
    SetTexture(kernelIndex: number, name: string, texture: RenderTexture, mipLevel: number, element: RenderTextureSubElement): void;
    SetTextureFromGlobal(kernelIndex: number, nameID: number, globalTextureNameID: number): void;
    SetTextureFromGlobal(kernelIndex: number, name: string, globalTextureName: string): void;
    SetVector(nameID: number, val: Vector4): void;
    SetVector(name: string, val: Vector4): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
}
    
interface RayTracingShader extends Object {
    maxRecursionDepth: number;


    Dispatch(rayGenFunctionName: string, width: number, height: number, depth: number, camera: Camera): void;
    SetAccelerationStructure(nameID: number, accelerationStructure: RayTracingAccelerationStructure): void;
    SetAccelerationStructure(name: string, accelerationStructure: RayTracingAccelerationStructure): void;
    SetBool(name: string, val: boolean): void;
    SetBool(nameID: number, val: boolean): void;
    SetBuffer(nameID: number, buffer: ComputeBuffer): void;
    SetBuffer(nameID: number, buffer: GraphicsBuffer): void;
    SetBuffer(nameID: number, bufferHandle: GraphicsBufferHandle): void;
    SetBuffer(name: string, buffer: ComputeBuffer): void;
    SetBuffer(name: string, buffer: GraphicsBuffer): void;
    SetBuffer(name: string, bufferHandle: GraphicsBufferHandle): void;
    SetConstantBuffer(nameID: number, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: ComputeBuffer, offset: number, size: number): void;
    SetConstantBuffer(nameID: number, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetConstantBuffer(name: string, buffer: GraphicsBuffer, offset: number, size: number): void;
    SetFloat(nameID: number, val: number): void;
    SetFloat(name: string, val: number): void;
    SetFloats(name: string, values: CSArray<number>): void;
    SetFloats(nameID: number, values: CSArray<number>): void;
    SetInt(nameID: number, val: number): void;
    SetInt(name: string, val: number): void;
    SetInts(name: string, values: CSArray<number>): void;
    SetInts(nameID: number, values: CSArray<number>): void;
    SetMatrix(nameID: number, val: Matrix4x4): void;
    SetMatrix(name: string, val: Matrix4x4): void;
    SetMatrixArray(nameID: number, values: CSArray<Matrix4x4>): void;
    SetMatrixArray(name: string, values: CSArray<Matrix4x4>): void;
    SetShaderPass(passName: string): void;
    SetTexture(nameID: number, texture: Texture): void;
    SetTexture(name: string, texture: Texture): void;
    SetTextureFromGlobal(nameID: number, globalTextureNameID: number): void;
    SetTextureFromGlobal(name: string, globalTextureName: string): void;
    SetVector(nameID: number, val: Vector4): void;
    SetVector(name: string, val: Vector4): void;
    SetVectorArray(nameID: number, values: CSArray<Vector4>): void;
    SetVectorArray(name: string, values: CSArray<Vector4>): void;
}
    
interface RectInt {
    x: number;
    y: number;
    center: Vector2;
    min: Vector2Int;
    max: Vector2Int;
    width: number;
    height: number;
    xMin: number;
    yMin: number;
    xMax: number;
    yMax: number;
    position: Vector2Int;
    size: Vector2Int;
    allPositionsWithin: PositionEnumerator;


    ClampToBounds(bounds: RectInt): void;
    Contains(position: Vector2Int): boolean;
    Equals(other: unknown): boolean;
    Equals(other: RectInt): boolean;
    GetHashCode(): number;
    Overlaps(other: RectInt): boolean;
    SetMinMax(minPosition: Vector2Int, maxPosition: Vector2Int): void;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface PositionEnumerator {
    Current: Vector2Int;


    GetEnumerator(): PositionEnumerator;
    MoveNext(): boolean;
    Reset(): void;
}
    
interface PositionEnumeratorConstructor {

    new(min: Vector2Int, max: Vector2Int): PositionEnumerator;

}
declare const PositionEnumerator: PositionEnumeratorConstructor;
    
interface RectIntConstructor {
    zero: RectInt;

    new(xMin: number, yMin: number, width: number, height: number): RectInt;
    new(position: Vector2Int, size: Vector2Int): RectInt;

}
declare const RectInt: RectIntConstructor;
    
interface RendererList {
    isValid: boolean;


}
    
interface RendererListConstructor {
    nullRendererList: RendererList;


}
declare const RendererList: RendererListConstructor;
    
interface RenderTargetBinding {
    colorRenderTargets: CSArray<RenderTargetIdentifier>;
    depthRenderTarget: RenderTargetIdentifier;
    colorLoadActions: CSArray<number>;
    colorStoreActions: CSArray<number>;
    depthLoadAction: RenderBufferLoadAction;
    depthStoreAction: RenderBufferStoreAction;
    flags: RenderTargetFlags;


}
    
interface RenderTargetBindingConstructor {

    new(colorRenderTargets: CSArray<RenderTargetIdentifier>, colorLoadActions: CSArray<number>, colorStoreActions: CSArray<number>, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): RenderTargetBinding;
    new(colorRenderTarget: RenderTargetIdentifier, colorLoadAction: RenderBufferLoadAction, colorStoreAction: RenderBufferStoreAction, depthRenderTarget: RenderTargetIdentifier, depthLoadAction: RenderBufferLoadAction, depthStoreAction: RenderBufferStoreAction): RenderTargetBinding;
    new(setup: RenderTargetSetup): RenderTargetBinding;

}
declare const RenderTargetBinding: RenderTargetBindingConstructor;
    
interface CommandBufferConstructor {
    ThrowOnSetRenderTarget: boolean;

    new(): CommandBuffer;

}
declare const CommandBuffer: CommandBufferConstructor;
    
interface Cubemap extends Texture {
    format: TextureFormat;
    isReadable: boolean;
    streamingMipmaps: boolean;
    streamingMipmapsPriority: number;
    requestedMipmapLevel: number;
    desiredMipmapLevel: number;
    loadingMipmapLevel: number;
    loadedMipmapLevel: number;


    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    ClearRequestedMipmapLevel(): void;
    GetPixel(face: CubemapFace, x: number, y: number): Color;
    GetPixel(face: CubemapFace, x: number, y: number, mip: number): Color;
    GetPixelData<T>(mipLevel: number, face: CubemapFace): CSArray<T>;
    GetPixels(face: CubemapFace, miplevel: number): CSArray<Color>;
    GetPixels(face: CubemapFace): CSArray<Color>;
    IsRequestedMipmapLevelLoaded(): boolean;
    SetPixel(face: CubemapFace, x: number, y: number, color: Color): void;
    SetPixel(face: CubemapFace, x: number, y: number, color: Color, mip: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, face: CubemapFace, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, face: CubemapFace, sourceDataStartIndex: number): void;
    SetPixels(colors: CSArray<Color>, face: CubemapFace, miplevel: number): void;
    SetPixels(colors: CSArray<Color>, face: CubemapFace): void;
    SmoothEdges(smoothRegionWidthInPixels: number): void;
    SmoothEdges(): void;
    UpdateExternalTexture(nativeTexture: unknown): void;
}
    
interface CubemapConstructor {

    new(width: number, format: DefaultFormat, flags: TextureCreationFlags): Cubemap;
    new(width: number, format: DefaultFormat, flags: TextureCreationFlags, mipCount: number): Cubemap;
    new(width: number, format: GraphicsFormat, flags: TextureCreationFlags): Cubemap;
    new(width: number, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: number): Cubemap;
    new(width: number, textureFormat: TextureFormat, mipChain: boolean): Cubemap;
    new(width: number, textureFormat: TextureFormat, mipChain: boolean, createUninitialized: boolean): Cubemap;
    new(width: number, format: TextureFormat, mipCount: number): Cubemap;
    new(width: number, format: TextureFormat, mipCount: number, createUninitialized: boolean): Cubemap;

    CreateExternalTexture(width: number, format: TextureFormat, mipmap: boolean, nativeTex: unknown): Cubemap;
}
declare const Cubemap: CubemapConstructor;
    
interface RenderRequest {
    isValid: boolean;
    mode: RenderRequestMode;
    result: RenderTexture;
    outputSpace: RenderRequestOutputSpace;


}
    
interface RenderRequestConstructor {

    new(mode: RenderRequestMode, rt: RenderTexture): RenderRequest;
    new(mode: RenderRequestMode, space: RenderRequestOutputSpace, rt: RenderTexture): RenderRequest;

}
declare const RenderRequest: RenderRequestConstructor;
    
interface CameraCallback {


    BeginInvoke(cam: Camera, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(cam: Camera): void;
}
    
interface CameraCallbackConstructor {

    new(object: unknown, method: unknown): CameraCallback;

}
declare const CameraCallback: CameraCallbackConstructor;
    
interface GateFitParameters {
    mode: GateFitMode;
    aspect: number;


}
    
interface GateFitParametersConstructor {

    new(mode: GateFitMode, aspect: number): GateFitParameters;

}
declare const GateFitParameters: GateFitParametersConstructor;
    
interface CameraConstructor {
    kMinAperture: number;
    kMaxAperture: number;
    kMinBladeCount: number;
    kMaxBladeCount: number;
    onPreCull: CameraCallback;
    onPreRender: CameraCallback;
    onPostRender: CameraCallback;
    main: Camera;
    current: Camera;
    allCamerasCount: number;
    allCameras: CSArray<Camera>;
    mainCamera: Camera;

    new(): Camera;

    CalculateProjectionMatrixFromPhysicalProperties(output: unknown, focalLength: number, sensorSize: Vector2, lensShift: Vector2, nearClip: number, farClip: number, gateFitParameters: GateFitParameters): void;
    FieldOfViewToFocalLength(fieldOfView: number, sensorSize: number): number;
    FocalLengthToFieldOfView(focalLength: number, sensorSize: number): number;
    GetAllCameras(cameras: CSArray<Camera>): number;
    HorizontalToVerticalFieldOfView(horizontalFieldOfView: number, aspectRatio: number): number;
    SetupCurrent(cur: Camera): void;
    VerticalToHorizontalFieldOfView(verticalFieldOfView: number, aspectRatio: number): number;
}
declare const Camera: CameraConstructor;
    
interface Input {


}
    
interface LocationService {
    isEnabledByUser: boolean;
    status: LocationServiceStatus;
    lastData: LocationInfo;


    Start(desiredAccuracyInMeters: number, updateDistanceInMeters: number): void;
    Start(desiredAccuracyInMeters: number): void;
    Start(): void;
    Stop(): void;
}
    
interface LocationInfo {
    latitude: number;
    longitude: number;
    altitude: number;
    horizontalAccuracy: number;
    verticalAccuracy: number;
    timestamp: number;


}
    
interface LocationServiceConstructor {

    new(): LocationService;

}
declare const LocationService: LocationServiceConstructor;
    
interface Compass {
    magneticHeading: number;
    trueHeading: number;
    headingAccuracy: number;
    rawVector: Vector3;
    timestamp: number;
    enabled: boolean;


}
    
interface CompassConstructor {

    new(): Compass;

}
declare const Compass: CompassConstructor;
    
interface Gyroscope {
    rotationRate: Vector3;
    rotationRateUnbiased: Vector3;
    gravity: Vector3;
    userAcceleration: Vector3;
    attitude: Quaternion;
    enabled: boolean;
    updateInterval: number;


}
    
interface Touch {
    fingerId: number;
    position: Vector2;
    rawPosition: Vector2;
    deltaPosition: Vector2;
    deltaTime: number;
    tapCount: number;
    phase: TouchPhase;
    pressure: number;
    maximumPossiblePressure: number;
    type: TouchType;
    altitudeAngle: number;
    azimuthAngle: number;
    radius: number;
    radiusVariance: number;


}
    
interface AccelerationEvent {
    acceleration: Vector3;
    deltaTime: number;


}
    
interface PenData {
    position: Vector2;
    tilt: Vector2;
    penStatus: PenStatus;
    twist: number;
    pressure: number;
    contactType: PenEventType;
    deltaPos: Vector2;


}
    
interface InputConstructor {
    simulateMouseWithTouches: boolean;
    anyKey: boolean;
    anyKeyDown: boolean;
    inputString: string;
    mousePosition: Vector3;
    mousePositionDelta: Vector3;
    mouseScrollDelta: Vector2;
    imeCompositionMode: IMECompositionMode;
    compositionString: string;
    imeIsSelected: boolean;
    compositionCursorPos: Vector2;
    eatKeyPressOnTextFieldFocus: boolean;
    mousePresent: boolean;
    penEventCount: number;
    touchCount: number;
    touchPressureSupported: boolean;
    stylusTouchSupported: boolean;
    touchSupported: boolean;
    multiTouchEnabled: boolean;
    isGyroAvailable: boolean;
    deviceOrientation: DeviceOrientation;
    acceleration: Vector3;
    compensateSensors: boolean;
    accelerationEventCount: number;
    backButtonLeavesApp: boolean;
    location: LocationService;
    compass: Compass;
    gyro: Gyroscope;
    touches: CSArray<Touch>;
    accelerationEvents: CSArray<AccelerationEvent>;

    new(): Input;

    ClearLastPenContactEvent(): void;
    GetAccelerationEvent(index: number): AccelerationEvent;
    GetAxis(axisName: string): number;
    GetAxisRaw(axisName: string): number;
    GetButton(buttonName: string): boolean;
    GetButtonDown(buttonName: string): boolean;
    GetButtonUp(buttonName: string): boolean;
    GetJoystickNames(): CSArray<string>;
    GetKey(key: KeyCode): boolean;
    GetKey(name: string): boolean;
    GetKeyDown(key: KeyCode): boolean;
    GetKeyDown(name: string): boolean;
    GetKeyUp(key: KeyCode): boolean;
    GetKeyUp(name: string): boolean;
    GetLastPenContactEvent(): PenData;
    GetMouseButton(button: number): boolean;
    GetMouseButtonDown(button: number): boolean;
    GetMouseButtonUp(button: number): boolean;
    GetPenEvent(index: number): PenData;
    GetTouch(index: number): Touch;
    IsJoystickPreconfigured(joystickName: string): boolean;
    ResetInputAxes(): void;
    ResetPenEvents(): void;
}
declare const Input: InputConstructor;
    
interface InstanceFinder {


}
    
interface InstanceFinderConstructor {
    NetworkManager: NetworkManager;
    ServerManager: ServerManager;
    ClientManager: ClientManager;
    TransportManager: TransportManager;
    TimeManager: TimeManager;
    SceneManager: SceneManager;
    RollbackManager: RollbackManager;
    PredictionManager: PredictionManager;
    StatisticsManager: StatisticsManager;
    IsServer: boolean;
    IsServerOnly: boolean;
    IsClient: boolean;
    IsClientOnly: boolean;
    IsHost: boolean;
    IsOffline: boolean;


    GetInstance<T>(): T;
    HasInstance<T>(): boolean;
    RegisterInstance<T>(component: T, replace: boolean): void;
    RegisterInvokeOnInstance<T>(handler: unknown): void;
    TryGetInstance<T>(component: unknown): boolean;
    TryRegisterInstance<T>(component: T): boolean;
    UnregisterInstance<T>(): void;
    UnregisterInvokeOnInstance<T>(handler: unknown): void;
}
declare const InstanceFinder: InstanceFinderConstructor;
    
interface IListItem {
    Key: Key;


}
    
interface Key extends IListItem {


}
    
interface KeyConstructor {
    NotInList: number;

    new(): Key;

    IndexOf(key: Key): number;
    IsInList(key: Key): boolean;
}
declare const Key: KeyConstructor;
    
interface Key extends IListItem {


}
    
interface KeyConstructor {
    NotInList: number;

    new(): Key;

    IndexOf(key: Key): number;
    IsInList(key: Key): boolean;
}
declare const Key: KeyConstructor;
    
interface IEventSystemHandler {


}
    
interface ISubmitHandler extends IEventSystemHandler {


    OnSubmit(eventData: BaseEventData): void;
}
    
interface AbstractEventData {
    used: boolean;


    Reset(): void;
    Use(): void;
}
    
interface BaseEventData extends AbstractEventData {
    currentInputModule: BaseInputModule;
    selectedObject: GameObject;


}
    
interface UIBehaviour extends MonoBehaviour {


    IsActive(): boolean;
    IsDestroyed(): boolean;
}
    
interface BaseInputModule extends UIBehaviour {
    input: BaseInput;
    inputOverride: BaseInput;


    ActivateModule(): void;
    ConvertUIToolkitPointerId(sourcePointerData: PointerEventData): number;
    DeactivateModule(): void;
    IsModuleSupported(): boolean;
    IsPointerOverGameObject(pointerId: number): boolean;
    Process(): void;
    ShouldActivateModule(): boolean;
    UpdateModule(): void;
}
    
interface BaseInput extends UIBehaviour {
    compositionString: string;
    imeCompositionMode: IMECompositionMode;
    compositionCursorPos: Vector2;
    mousePresent: boolean;
    mousePosition: Vector2;
    mouseScrollDelta: Vector2;
    touchSupported: boolean;
    touchCount: number;


    GetAxisRaw(axisName: string): number;
    GetButtonDown(buttonName: string): boolean;
    GetMouseButton(button: number): boolean;
    GetMouseButtonDown(button: number): boolean;
    GetMouseButtonUp(button: number): boolean;
    GetTouch(index: number): Touch;
}
    
interface BaseInputConstructor {

    new(): BaseInput;

}
declare const BaseInput: BaseInputConstructor;
    
interface PointerEventData extends BaseEventData {
    hovered: CSArray<GameObject>;
    pointerEnter: GameObject;
    lastPress: GameObject;
    rawPointerPress: GameObject;
    pointerDrag: GameObject;
    pointerClick: GameObject;
    pointerCurrentRaycast: RaycastResult;
    pointerPressRaycast: RaycastResult;
    eligibleForClick: boolean;
    displayIndex: number;
    pointerId: number;
    position: Vector2;
    delta: Vector2;
    pressPosition: Vector2;
    worldPosition: Vector3;
    worldNormal: Vector3;
    clickTime: number;
    clickCount: number;
    scrollDelta: Vector2;
    useDragThreshold: boolean;
    dragging: boolean;
    button: InputButton;
    pressure: number;
    tangentialPressure: number;
    altitudeAngle: number;
    azimuthAngle: number;
    twist: number;
    tilt: Vector2;
    penStatus: PenStatus;
    radius: Vector2;
    radiusVariance: Vector2;
    fullyExited: boolean;
    reentered: boolean;
    enterEventCamera: Camera;
    pressEventCamera: Camera;
    pointerPress: GameObject;


    IsPointerMoving(): boolean;
    IsScrolling(): boolean;
    ToString(): string;
}
    
interface RaycastResult {
    module: BaseRaycaster;
    distance: number;
    index: number;
    depth: number;
    sortingGroupID: number;
    sortingGroupOrder: number;
    sortingLayer: number;
    sortingOrder: number;
    worldPosition: Vector3;
    worldNormal: Vector3;
    screenPosition: Vector2;
    displayIndex: number;
    gameObject: GameObject;
    isValid: boolean;


    Clear(): void;
    ToString(): string;
}
    
interface BaseRaycaster extends UIBehaviour {
    eventCamera: Camera;
    priority: number;
    sortOrderPriority: number;
    renderOrderPriority: number;
    rootRaycaster: BaseRaycaster;


    Raycast(eventData: PointerEventData, resultAppendList: CSArray<RaycastResult>): void;
    ToString(): string;
}
    
interface PointerEventDataConstructor {

    new(eventSystem: EventSystem): PointerEventData;

}
declare const PointerEventData: PointerEventDataConstructor;
    
interface BaseEventDataConstructor {

    new(eventSystem: EventSystem): BaseEventData;

}
declare const BaseEventData: BaseEventDataConstructor;
    
interface IPointerClickHandler extends IEventSystemHandler {


    OnPointerClick(eventData: PointerEventData): void;
}
    
interface IPointerEnterHandler extends IEventSystemHandler {


    OnPointerEnter(eventData: PointerEventData): void;
}
    
interface ISelectHandler extends IEventSystemHandler {


    OnSelect(eventData: BaseEventData): void;
}
    
interface IPointerExitHandler extends IEventSystemHandler {


    OnPointerExit(eventData: PointerEventData): void;
}
    
interface IDeselectHandler extends IEventSystemHandler {


    OnDeselect(eventData: BaseEventData): void;
}
    
interface IPointerDownHandler extends IEventSystemHandler {


    OnPointerDown(eventData: PointerEventData): void;
}
    
interface IPointerUpHandler extends IEventSystemHandler {


    OnPointerUp(eventData: PointerEventData): void;
}
    
interface IMoveHandler extends IEventSystemHandler {


    OnMove(eventData: AxisEventData): void;
}
    
interface AxisEventData extends BaseEventData {
    moveVector: Vector2;
    moveDir: MoveDirection;


}
    
interface AxisEventDataConstructor {

    new(eventSystem: EventSystem): AxisEventData;

}
declare const AxisEventData: AxisEventDataConstructor;
    
interface Selectable extends UIBehaviour, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
    navigation: Navigation;
    transition: Transition;
    colors: ColorBlock;
    spriteState: SpriteState;
    animationTriggers: AnimationTriggers;
    targetGraphic: Graphic;
    interactable: boolean;
    image: Image;
    animator: Animator;


    FindSelectable(dir: Vector3): Selectable;
    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    IsInteractable(): boolean;
    OnDeselect(eventData: BaseEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    Select(): void;
}
    
interface Navigation {
    mode: Mode;
    wrapAround: boolean;
    selectOnUp: Selectable;
    selectOnDown: Selectable;
    selectOnLeft: Selectable;
    selectOnRight: Selectable;


    Equals(other: Navigation): boolean;
}
    
interface NavigationConstructor {
    defaultNavigation: Navigation;


}
declare const Navigation: NavigationConstructor;
    
interface ColorBlock {
    normalColor: Color;
    highlightedColor: Color;
    pressedColor: Color;
    selectedColor: Color;
    disabledColor: Color;
    colorMultiplier: number;
    fadeDuration: number;


    Equals(obj: unknown): boolean;
    Equals(other: ColorBlock): boolean;
    GetHashCode(): number;
}
    
interface ColorBlockConstructor {
    defaultColorBlock: ColorBlock;


}
declare const ColorBlock: ColorBlockConstructor;
    
interface SpriteState {
    highlightedSprite: Sprite;
    pressedSprite: Sprite;
    selectedSprite: Sprite;
    disabledSprite: Sprite;


    Equals(other: SpriteState): boolean;
}
    
interface AnimationTriggers {
    normalTrigger: string;
    highlightedTrigger: string;
    pressedTrigger: string;
    selectedTrigger: string;
    disabledTrigger: string;


}
    
interface AnimationTriggersConstructor {

    new(): AnimationTriggers;

}
declare const AnimationTriggers: AnimationTriggersConstructor;
    
interface ICanvasElement {
    transform: Transform;


    GraphicUpdateComplete(): void;
    IsDestroyed(): boolean;
    LayoutComplete(): void;
    Rebuild(executing: CanvasUpdate): void;
}
    
interface Graphic extends UIBehaviour, ICanvasElement {
    color: Color;
    raycastTarget: boolean;
    raycastPadding: Vector4;
    depth: number;
    rectTransform: RectTransform;
    canvas: Canvas;
    canvasRenderer: CanvasRenderer;
    defaultMaterial: Material;
    material: Material;
    materialForRendering: Material;
    mainTexture: Texture;


    CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean, useRGB: boolean): void;
    GetPixelAdjustedRect(): Rect;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnCullingChanged(): void;
    OnRebuildRequested(): void;
    PixelAdjustPoint(point: Vector2): Vector2;
    Raycast(sp: Vector2, eventCamera: Camera): boolean;
    Rebuild(update: CanvasUpdate): void;
    RegisterDirtyLayoutCallback(action: UnityAction): void;
    RegisterDirtyMaterialCallback(action: UnityAction): void;
    RegisterDirtyVerticesCallback(action: UnityAction): void;
    SetAllDirty(): void;
    SetLayoutDirty(): void;
    SetMaterialDirty(): void;
    SetNativeSize(): void;
    SetRaycastDirty(): void;
    SetVerticesDirty(): void;
    UnregisterDirtyLayoutCallback(action: UnityAction): void;
    UnregisterDirtyMaterialCallback(action: UnityAction): void;
    UnregisterDirtyVerticesCallback(action: UnityAction): void;
}
    
interface RectTransform extends Transform {
    rect: Rect;
    anchorMin: Vector2;
    anchorMax: Vector2;
    anchoredPosition: Vector2;
    sizeDelta: Vector2;
    pivot: Vector2;
    anchoredPosition3D: Vector3;
    offsetMin: Vector2;
    offsetMax: Vector2;
    drivenByObject: Object;


    ForceUpdateRectTransforms(): void;
    GetLocalCorners(fourCornersArray: CSArray<Vector3>): void;
    GetWorldCorners(fourCornersArray: CSArray<Vector3>): void;
    SetInsetAndSizeFromParentEdge(edge: Edge, inset: number, size: number): void;
    SetSizeWithCurrentAnchors(axis: Axis, size: number): void;
}
    
interface RectTransformConstructor {

    new(): RectTransform;

}
declare const RectTransform: RectTransformConstructor;
    
interface Canvas extends Behaviour {
    renderMode: RenderMode;
    isRootCanvas: boolean;
    pixelRect: Rect;
    scaleFactor: number;
    referencePixelsPerUnit: number;
    overridePixelPerfect: boolean;
    vertexColorAlwaysGammaSpace: boolean;
    pixelPerfect: boolean;
    planeDistance: number;
    renderOrder: number;
    overrideSorting: boolean;
    sortingOrder: number;
    targetDisplay: number;
    sortingLayerID: number;
    cachedSortingLayerValue: number;
    additionalShaderChannels: AdditionalCanvasShaderChannels;
    sortingLayerName: string;
    rootCanvas: Canvas;
    renderingDisplaySize: Vector2;
    updateRectTransformForStandalone: StandaloneRenderResize;
    worldCamera: Camera;
    normalizedSortingGridSize: number;
    sortingGridNormalizedSize: number;


}
    
interface CanvasConstructor {

    new(): Canvas;

    ForceUpdateCanvases(): void;
    GetDefaultCanvasMaterial(): Material;
    GetDefaultCanvasTextMaterial(): Material;
    GetETC1SupportedCanvasMaterial(): Material;
}
declare const Canvas: CanvasConstructor;
    
interface CanvasRenderer extends Component {
    hasPopInstruction: boolean;
    materialCount: number;
    popMaterialCount: number;
    absoluteDepth: number;
    hasMoved: boolean;
    cullTransparentMesh: boolean;
    hasRectClipping: boolean;
    relativeDepth: number;
    cull: boolean;
    isMask: boolean;
    clippingSoftness: Vector2;


    Clear(): void;
    DisableRectClipping(): void;
    EnableRectClipping(rect: Rect): void;
    GetAlpha(): number;
    GetColor(): Color;
    GetInheritedAlpha(): number;
    GetMaterial(index: number): Material;
    GetMaterial(): Material;
    GetMesh(): Mesh;
    GetPopMaterial(index: number): Material;
    SetAlpha(alpha: number): void;
    SetAlphaTexture(texture: Texture): void;
    SetColor(color: Color): void;
    SetMaterial(material: Material, index: number): void;
    SetMaterial(material: Material, texture: Texture): void;
    SetMesh(mesh: Mesh): void;
    SetPopMaterial(material: Material, index: number): void;
    SetTexture(texture: Texture): void;
    SetVertices(vertices: CSArray<UIVertex>): void;
    SetVertices(vertices: CSArray<UIVertex>, size: number): void;
}
    
interface UIVertex {
    position: Vector3;
    normal: Vector3;
    tangent: Vector4;
    color: Color32;
    uv0: Vector4;
    uv1: Vector4;
    uv2: Vector4;
    uv3: Vector4;


}
    
interface UIVertexConstructor {
    simpleVert: UIVertex;


}
declare const UIVertex: UIVertexConstructor;
    
interface CanvasRendererConstructor {

    new(): CanvasRenderer;

    AddUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>): void;
    AddUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>): void;
    CreateUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    CreateUIVertexStream(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    SplitUIVertexStreams(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
    SplitUIVertexStreams(verts: CSArray<UIVertex>, positions: CSArray<Vector3>, colors: CSArray<Color32>, uv0S: CSArray<Vector4>, uv1S: CSArray<Vector4>, uv2S: CSArray<Vector4>, uv3S: CSArray<Vector4>, normals: CSArray<Vector3>, tangents: CSArray<Vector4>, indices: CSArray<number>): void;
}
declare const CanvasRenderer: CanvasRendererConstructor;
    
interface UnityAction {


    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;
}
    
interface UnityActionConstructor {

    new(object: unknown, method: unknown): UnityAction;

}
declare const UnityAction: UnityActionConstructor;
    
interface GraphicConstructor {
    defaultGraphicMaterial: Material;


}
declare const Graphic: GraphicConstructor;
    
interface ISerializationCallbackReceiver {


    OnAfterDeserialize(): void;
    OnBeforeSerialize(): void;
}
    
interface ICanvasRaycastFilter {


    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;
}
    
interface ILayoutElement {
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
}
    
interface IClippable {
    gameObject: GameObject;
    rectTransform: RectTransform;


    Cull(clipRect: Rect, validRect: boolean): void;
    RecalculateClipping(): void;
    SetClipRect(value: Rect, validRect: boolean): void;
    SetClipSoftness(clipSoftness: Vector2): void;
}
    
interface IMaterialModifier {


    GetModifiedMaterial(baseMaterial: Material): Material;
}
    
interface IMaskable {


    RecalculateMasking(): void;
}
    
interface MaskableGraphic extends Graphic, IClippable, IMaterialModifier, IMaskable {
    onCullStateChanged: CullStateChangedEvent;
    maskable: boolean;
    isMaskingGraphic: boolean;


    Cull(clipRect: Rect, validRect: boolean): void;
    GetModifiedMaterial(baseMaterial: Material): Material;
    ParentMaskStateChanged(): void;
    RecalculateClipping(): void;
    RecalculateMasking(): void;
    SetClipRect(clipRect: Rect, validRect: boolean): void;
    SetClipSoftness(clipSoftness: Vector2): void;
}
    
interface CullStateChangedEvent {


}
    
interface CullStateChangedEventConstructor {

    new(): CullStateChangedEvent;

}
declare const CullStateChangedEvent: CullStateChangedEventConstructor;
    
interface Image extends MaskableGraphic, ISerializationCallbackReceiver, ICanvasRaycastFilter, ILayoutElement {
    sprite: Sprite;
    overrideSprite: Sprite;
    type: Type;
    preserveAspect: boolean;
    fillCenter: boolean;
    fillMethod: FillMethod;
    fillAmount: number;
    fillClockwise: boolean;
    fillOrigin: number;
    eventAlphaThreshold: number;
    alphaHitTestMinimumThreshold: number;
    useSpriteMesh: boolean;
    mainTexture: Texture;
    hasBorder: boolean;
    pixelsPerUnitMultiplier: number;
    pixelsPerUnit: number;
    material: Material;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    DisableSpriteOptimizations(): void;
    IsRaycastLocationValid(screenPoint: Vector2, eventCamera: Camera): boolean;
    OnAfterDeserialize(): void;
    OnBeforeSerialize(): void;
    SetNativeSize(): void;
}
    
interface ImageConstructor {
    defaultETC1GraphicMaterial: Material;


}
declare const Image: ImageConstructor;
    
interface Animator extends Behaviour {
    isOptimizable: boolean;
    isHuman: boolean;
    hasRootMotion: boolean;
    humanScale: number;
    isInitialized: boolean;
    deltaPosition: Vector3;
    deltaRotation: Quaternion;
    velocity: Vector3;
    angularVelocity: Vector3;
    rootPosition: Vector3;
    rootRotation: Quaternion;
    applyRootMotion: boolean;
    linearVelocityBlending: boolean;
    animatePhysics: boolean;
    updateMode: AnimatorUpdateMode;
    hasTransformHierarchy: boolean;
    gravityWeight: number;
    bodyPosition: Vector3;
    bodyRotation: Quaternion;
    stabilizeFeet: boolean;
    layerCount: number;
    parameters: CSArray<AnimatorControllerParameter>;
    parameterCount: number;
    feetPivotActive: number;
    pivotWeight: number;
    pivotPosition: Vector3;
    isMatchingTarget: boolean;
    speed: number;
    targetPosition: Vector3;
    targetRotation: Quaternion;
    avatarRoot: Transform;
    cullingMode: AnimatorCullingMode;
    playbackTime: number;
    recorderStartTime: number;
    recorderStopTime: number;
    recorderMode: AnimatorRecorderMode;
    runtimeAnimatorController: RuntimeAnimatorController;
    hasBoundPlayables: boolean;
    avatar: Avatar;
    playableGraph: PlayableGraph;
    layersAffectMassCenter: boolean;
    leftFeetBottomHeight: number;
    rightFeetBottomHeight: number;
    logWarnings: boolean;
    fireEvents: boolean;
    keepAnimatorControllerStateOnDisable: boolean;
    keepAnimatorStateOnDisable: boolean;
    writeDefaultValuesOnDisable: boolean;


    ApplyBuiltinRootMotion(): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number): void;
    CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number): void;
    CrossFade(stateHashName: number, normalizedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void;
    CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number): void;
    CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void;
    ForceStateNormalizedTime(normalizedTime: number): void;
    GetAnimatorTransitionInfo(layerIndex: number): AnimatorTransitionInfo;
    GetBehaviour<T>(): T;
    GetBehaviours<T>(): CSArray<T>;
    GetBehaviours(fullPathHash: number, layerIndex: number): CSArray<StateMachineBehaviour>;
    GetBoneTransform(humanBoneId: HumanBodyBones): Transform;
    GetBool(name: string): boolean;
    GetBool(id: number): boolean;
    GetCurrentAnimationClipState(layerIndex: number): CSArray<AnimationInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetCurrentAnimatorClipInfoCount(layerIndex: number): number;
    GetCurrentAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetFloat(name: string): number;
    GetFloat(id: number): number;
    GetIKHintPosition(hint: AvatarIKHint): Vector3;
    GetIKHintPositionWeight(hint: AvatarIKHint): number;
    GetIKPosition(goal: AvatarIKGoal): Vector3;
    GetIKPositionWeight(goal: AvatarIKGoal): number;
    GetIKRotation(goal: AvatarIKGoal): Quaternion;
    GetIKRotationWeight(goal: AvatarIKGoal): number;
    GetInteger(name: string): number;
    GetInteger(id: number): number;
    GetLayerIndex(layerName: string): number;
    GetLayerName(layerIndex: number): string;
    GetLayerWeight(layerIndex: number): number;
    GetNextAnimationClipState(layerIndex: number): CSArray<AnimationInfo>;
    GetNextAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetNextAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetNextAnimatorClipInfoCount(layerIndex: number): number;
    GetNextAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetParameter(index: number): AnimatorControllerParameter;
    GetQuaternion(name: string): Quaternion;
    GetQuaternion(id: number): Quaternion;
    GetVector(name: string): Vector3;
    GetVector(id: number): Vector3;
    HasState(layerIndex: number, stateID: number): boolean;
    InterruptMatchTarget(): void;
    InterruptMatchTarget(completeMatch: boolean): void;
    IsControlled(transform: Transform): boolean;
    IsInTransition(layerIndex: number): boolean;
    IsParameterControlledByCurve(name: string): boolean;
    IsParameterControlledByCurve(id: number): boolean;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number): void;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number, targetNormalizedTime: number): void;
    MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: AvatarTarget, weightMask: MatchTargetWeightMask, startNormalizedTime: number, targetNormalizedTime: number, completeMatch: boolean): void;
    Play(stateName: string, layer: number): void;
    Play(stateName: string): void;
    Play(stateName: string, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number, layer: number): void;
    Play(stateNameHash: number): void;
    PlayInFixedTime(stateName: string, layer: number): void;
    PlayInFixedTime(stateName: string): void;
    PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number): void;
    PlayInFixedTime(stateNameHash: number): void;
    Rebind(): void;
    ResetTrigger(name: string): void;
    ResetTrigger(id: number): void;
    SetBoneLocalRotation(humanBoneId: HumanBodyBones, rotation: Quaternion): void;
    SetBool(name: string, value: boolean): void;
    SetBool(id: number, value: boolean): void;
    SetFloat(name: string, value: number): void;
    SetFloat(name: string, value: number, dampTime: number, deltaTime: number): void;
    SetFloat(id: number, value: number): void;
    SetFloat(id: number, value: number, dampTime: number, deltaTime: number): void;
    SetIKHintPosition(hint: AvatarIKHint, hintPosition: Vector3): void;
    SetIKHintPositionWeight(hint: AvatarIKHint, value: number): void;
    SetIKPosition(goal: AvatarIKGoal, goalPosition: Vector3): void;
    SetIKPositionWeight(goal: AvatarIKGoal, value: number): void;
    SetIKRotation(goal: AvatarIKGoal, goalRotation: Quaternion): void;
    SetIKRotationWeight(goal: AvatarIKGoal, value: number): void;
    SetInteger(name: string, value: number): void;
    SetInteger(id: number, value: number): void;
    SetLayerWeight(layerIndex: number, weight: number): void;
    SetLookAtPosition(lookAtPosition: Vector3): void;
    SetLookAtWeight(weight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number): void;
    SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number, clampWeight: number): void;
    SetQuaternion(name: string, value: Quaternion): void;
    SetQuaternion(id: number, value: Quaternion): void;
    SetTarget(targetIndex: AvatarTarget, targetNormalizedTime: number): void;
    SetTrigger(name: string): void;
    SetTrigger(id: number): void;
    SetVector(name: string, value: Vector3): void;
    SetVector(id: number, value: Vector3): void;
    StartPlayback(): void;
    StartRecording(frameCount: number): void;
    Stop(): void;
    StopPlayback(): void;
    StopRecording(): void;
    Update(deltaTime: number): void;
    WriteDefaultValues(): void;
}
    
interface AnimatorControllerParameter {
    name: string;
    nameHash: number;
    type: AnimatorControllerParameterType;
    defaultFloat: number;
    defaultInt: number;
    defaultBool: boolean;


    Equals(o: unknown): boolean;
    GetHashCode(): number;
}
    
interface AnimatorControllerParameterConstructor {

    new(): AnimatorControllerParameter;

}
declare const AnimatorControllerParameter: AnimatorControllerParameterConstructor;
    
interface RuntimeAnimatorController extends Object {
    animationClips: CSArray<AnimationClip>;


}
    
interface Motion extends Object {
    averageDuration: number;
    averageAngularSpeed: number;
    averageSpeed: Vector3;
    apparentSpeed: number;
    isLooping: boolean;
    legacy: boolean;
    isHumanMotion: boolean;
    isAnimatorMotion: boolean;


    ValidateIfRetargetable(val: boolean): boolean;
}
    
interface AnimationClip extends Motion {
    length: number;
    frameRate: number;
    wrapMode: WrapMode;
    localBounds: Bounds;
    legacy: boolean;
    humanMotion: boolean;
    empty: boolean;
    hasGenericRootTransform: boolean;
    hasMotionFloatCurves: boolean;
    hasMotionCurves: boolean;
    hasRootCurves: boolean;
    events: CSArray<AnimationEvent>;


    AddEvent(evt: AnimationEvent): void;
    ClearCurves(): void;
    EnsureQuaternionContinuity(): void;
    SampleAnimation(go: GameObject, time: number): void;
    SetCurve(relativePath: string, type: unknown, propertyName: string, curve: AnimationCurve): void;
}
    
interface AnimationEvent {
    data: string;
    stringParameter: string;
    floatParameter: number;
    intParameter: number;
    objectReferenceParameter: Object;
    functionName: string;
    time: number;
    messageOptions: SendMessageOptions;
    isFiredByLegacy: boolean;
    isFiredByAnimator: boolean;
    animationState: AnimationState;
    animatorStateInfo: AnimatorStateInfo;
    animatorClipInfo: AnimatorClipInfo;


}
    
interface TrackedReference {


    Equals(o: unknown): boolean;
    GetHashCode(): number;
}
    
interface AnimationState extends TrackedReference {
    enabled: boolean;
    weight: number;
    wrapMode: WrapMode;
    time: number;
    normalizedTime: number;
    speed: number;
    normalizedSpeed: number;
    length: number;
    layer: number;
    clip: AnimationClip;
    name: string;
    blendMode: AnimationBlendMode;


    AddMixingTransform(mix: Transform): void;
    AddMixingTransform(mix: Transform, recursive: boolean): void;
    RemoveMixingTransform(mix: Transform): void;
}
    
interface AnimationStateConstructor {

    new(): AnimationState;

}
declare const AnimationState: AnimationStateConstructor;
    
interface AnimatorStateInfo {
    fullPathHash: number;
    nameHash: number;
    shortNameHash: number;
    normalizedTime: number;
    length: number;
    speed: number;
    speedMultiplier: number;
    tagHash: number;
    loop: boolean;


    IsName(name: string): boolean;
    IsTag(tag: string): boolean;
}
    
interface AnimatorClipInfo {
    clip: AnimationClip;
    weight: number;


}
    
interface AnimationEventConstructor {

    new(): AnimationEvent;

}
declare const AnimationEvent: AnimationEventConstructor;
    
interface AnimationCurve {
    keys: CSArray<Keyframe>;
    Item: Keyframe;
    length: number;
    preWrapMode: WrapMode;
    postWrapMode: WrapMode;


    AddKey(time: number, value: number): number;
    AddKey(key: Keyframe): number;
    ClearKeys(): void;
    CopyFrom(other: AnimationCurve): void;
    Equals(o: unknown): boolean;
    Equals(other: AnimationCurve): boolean;
    Evaluate(time: number): number;
    GetHashCode(): number;
    MoveKey(index: number, key: Keyframe): number;
    RemoveKey(index: number): void;
    SmoothTangents(index: number, weight: number): void;
}
    
interface Keyframe {
    time: number;
    value: number;
    inTangent: number;
    outTangent: number;
    inWeight: number;
    outWeight: number;
    weightedMode: WeightedMode;
    tangentMode: number;


}
    
interface KeyframeConstructor {

    new(time: number, value: number): Keyframe;
    new(time: number, value: number, inTangent: number, outTangent: number): Keyframe;
    new(time: number, value: number, inTangent: number, outTangent: number, inWeight: number, outWeight: number): Keyframe;

}
declare const Keyframe: KeyframeConstructor;
    
interface AnimationCurveConstructor {

    new(keys: CSArray<Keyframe>): AnimationCurve;
    new(): AnimationCurve;

    Constant(timeStart: number, timeEnd: number, value: number): AnimationCurve;
    EaseInOut(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve;
    Linear(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve;
}
declare const AnimationCurve: AnimationCurveConstructor;
    
interface AnimationClipConstructor {

    new(): AnimationClip;

}
declare const AnimationClip: AnimationClipConstructor;
    
interface Avatar extends Object {
    isValid: boolean;
    isHuman: boolean;
    humanDescription: HumanDescription;


}
    
interface HumanDescription {
    human: CSArray<HumanBone>;
    skeleton: CSArray<SkeletonBone>;
    upperArmTwist: number;
    lowerArmTwist: number;
    upperLegTwist: number;
    lowerLegTwist: number;
    armStretch: number;
    legStretch: number;
    feetSpacing: number;
    hasTranslationDoF: boolean;


}
    
interface HumanBone {
    limit: HumanLimit;
    boneName: string;
    humanName: string;


}
    
interface HumanLimit {
    useDefaultValues: boolean;
    min: Vector3;
    max: Vector3;
    center: Vector3;
    axisLength: number;


}
    
interface SkeletonBone {
    name: string;
    position: Vector3;
    rotation: Quaternion;
    scale: Vector3;
    transformModified: number;


}
    
interface PlayableGraph {


    Connect<U, V>(source: U, sourceOutputPort: number, destination: V, destinationInputPort: number): boolean;
    Destroy(): void;
    DestroyOutput<U>(output: U): void;
    DestroyPlayable<U>(playable: U): void;
    DestroySubgraph<U>(playable: U): void;
    Disconnect<U>(input: U, inputPort: number): void;
    Evaluate(): void;
    Evaluate(deltaTime: number): void;
    GetEditorName(): string;
    GetOutput(index: number): PlayableOutput;
    GetOutputByType<T>(index: number): PlayableOutput;
    GetOutputCount(): number;
    GetOutputCountByType<T>(): number;
    GetPlayableCount(): number;
    GetResolver(): IExposedPropertyTable;
    GetRootPlayable(index: number): Playable;
    GetRootPlayableCount(): number;
    GetTimeUpdateMode(): DirectorUpdateMode;
    IsDone(): boolean;
    IsPlaying(): boolean;
    IsValid(): boolean;
    Play(): void;
    SetResolver(value: IExposedPropertyTable): void;
    SetTimeUpdateMode(value: DirectorUpdateMode): void;
    Stop(): void;
}
    
interface IPlayableOutput {


    GetHandle(): PlayableOutputHandle;
}
    
interface PlayableOutputHandle {


    Equals(p: unknown): boolean;
    Equals(other: PlayableOutputHandle): boolean;
    GetHashCode(): number;
}
    
interface PlayableOutputHandleConstructor {
    Null: PlayableOutputHandle;


}
declare const PlayableOutputHandle: PlayableOutputHandleConstructor;
    
interface PlayableOutput extends IPlayableOutput {


    Equals(other: PlayableOutput): boolean;
    GetHandle(): PlayableOutputHandle;
    GetPlayableOutputType(): unknown;
    IsPlayableOutputOfType<T>(): boolean;
}
    
interface PlayableOutputConstructor {
    Null: PlayableOutput;


}
declare const PlayableOutput: PlayableOutputConstructor;
    
interface IExposedPropertyTable {


    ClearReferenceValue(id: PropertyName): void;
    GetReferenceValue(id: PropertyName, idValid: unknown): Object;
    SetReferenceValue(id: PropertyName, value: Object): void;
}
    
interface PropertyName {


    Equals(other: unknown): boolean;
    Equals(other: PropertyName): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface PropertyNameConstructor {

    new(name: string): PropertyName;
    new(other: PropertyName): PropertyName;
    new(id: number): PropertyName;

    IsNullOrEmpty(prop: PropertyName): boolean;
}
declare const PropertyName: PropertyNameConstructor;
    
interface IPlayable {


    GetHandle(): PlayableHandle;
}
    
interface PlayableHandle {


    Equals(p: unknown): boolean;
    Equals(other: PlayableHandle): boolean;
    GetHashCode(): number;
}
    
interface PlayableHandleConstructor {
    Null: PlayableHandle;


}
declare const PlayableHandle: PlayableHandleConstructor;
    
interface Playable extends IPlayable {


    Equals(other: Playable): boolean;
    GetHandle(): PlayableHandle;
    GetPlayableType(): unknown;
    IsPlayableOfType<T>(): boolean;
}
    
interface PlayableConstructor {
    Null: Playable;


    Create(graph: PlayableGraph, inputCount: number): Playable;
}
declare const Playable: PlayableConstructor;
    
interface PlayableGraphConstructor {


    Create(): PlayableGraph;
    Create(name: string): PlayableGraph;
}
declare const PlayableGraph: PlayableGraphConstructor;
    
interface AnimatorTransitionInfo {
    fullPathHash: number;
    nameHash: number;
    userNameHash: number;
    durationUnit: DurationUnit;
    duration: number;
    normalizedTime: number;
    anyState: boolean;


    IsName(name: string): boolean;
    IsUserName(name: string): boolean;
}
    
interface StateMachineBehaviour extends ScriptableObject {


    OnStateEnter(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateEnter(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateExit(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateExit(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateIK(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateIK(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateMachineEnter(animator: Animator, stateMachinePathHash: number): void;
    OnStateMachineEnter(animator: Animator, stateMachinePathHash: number, controller: AnimatorControllerPlayable): void;
    OnStateMachineExit(animator: Animator, stateMachinePathHash: number): void;
    OnStateMachineExit(animator: Animator, stateMachinePathHash: number, controller: AnimatorControllerPlayable): void;
    OnStateMove(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateMove(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
    OnStateUpdate(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number): void;
    OnStateUpdate(animator: Animator, stateInfo: AnimatorStateInfo, layerIndex: number, controller: AnimatorControllerPlayable): void;
}
    
interface AnimatorControllerPlayable extends IPlayable {


    CrossFade(stateName: string, transitionDuration: number): void;
    CrossFade(stateName: string, transitionDuration: number, layer: number): void;
    CrossFade(stateName: string, transitionDuration: number, layer: number, normalizedTime: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number, layer: number): void;
    CrossFade(stateNameHash: number, transitionDuration: number, layer: number, normalizedTime: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateName: string, transitionDuration: number, layer: number, fixedTime: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number, layer: number): void;
    CrossFadeInFixedTime(stateNameHash: number, transitionDuration: number, layer: number, fixedTime: number): void;
    Equals(other: AnimatorControllerPlayable): boolean;
    GetAnimatorTransitionInfo(layerIndex: number): AnimatorTransitionInfo;
    GetBool(name: string): boolean;
    GetBool(id: number): boolean;
    GetCurrentAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetCurrentAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetCurrentAnimatorClipInfoCount(layerIndex: number): number;
    GetCurrentAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetFloat(name: string): number;
    GetFloat(id: number): number;
    GetHandle(): PlayableHandle;
    GetInteger(name: string): number;
    GetInteger(id: number): number;
    GetLayerCount(): number;
    GetLayerIndex(layerName: string): number;
    GetLayerName(layerIndex: number): string;
    GetLayerWeight(layerIndex: number): number;
    GetNextAnimatorClipInfo(layerIndex: number, clips: CSArray<AnimatorClipInfo>): void;
    GetNextAnimatorClipInfo(layerIndex: number): CSArray<AnimatorClipInfo>;
    GetNextAnimatorClipInfoCount(layerIndex: number): number;
    GetNextAnimatorStateInfo(layerIndex: number): AnimatorStateInfo;
    GetParameter(index: number): AnimatorControllerParameter;
    GetParameterCount(): number;
    HasState(layerIndex: number, stateID: number): boolean;
    IsInTransition(layerIndex: number): boolean;
    IsParameterControlledByCurve(name: string): boolean;
    IsParameterControlledByCurve(id: number): boolean;
    Play(stateName: string): void;
    Play(stateName: string, layer: number): void;
    Play(stateName: string, layer: number, normalizedTime: number): void;
    Play(stateNameHash: number): void;
    Play(stateNameHash: number, layer: number): void;
    Play(stateNameHash: number, layer: number, normalizedTime: number): void;
    PlayInFixedTime(stateName: string): void;
    PlayInFixedTime(stateName: string, layer: number): void;
    PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void;
    PlayInFixedTime(stateNameHash: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number): void;
    PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void;
    ResetTrigger(name: string): void;
    ResetTrigger(id: number): void;
    SetBool(name: string, value: boolean): void;
    SetBool(id: number, value: boolean): void;
    SetFloat(name: string, value: number): void;
    SetFloat(id: number, value: number): void;
    SetHandle(handle: PlayableHandle): void;
    SetInteger(name: string, value: number): void;
    SetInteger(id: number, value: number): void;
    SetLayerWeight(layerIndex: number, weight: number): void;
    SetTrigger(name: string): void;
    SetTrigger(id: number): void;
}
    
interface AnimatorControllerPlayableConstructor {
    Null: AnimatorControllerPlayable;


    Create(graph: PlayableGraph, controller: RuntimeAnimatorController): AnimatorControllerPlayable;
}
declare const AnimatorControllerPlayable: AnimatorControllerPlayableConstructor;
    
interface AnimationInfo {
    clip: AnimationClip;
    weight: number;


}
    
interface MatchTargetWeightMask {
    positionXYZWeight: Vector3;
    rotationWeight: number;


}
    
interface MatchTargetWeightMaskConstructor {

    new(positionXYZWeight: Vector3, rotationWeight: number): MatchTargetWeightMask;

}
declare const MatchTargetWeightMask: MatchTargetWeightMaskConstructor;
    
interface AnimatorConstructor {

    new(): Animator;

    StringToHash(name: string): number;
}
declare const Animator: AnimatorConstructor;
    
interface SelectableConstructor {
    allSelectablesArray: CSArray<Selectable>;
    allSelectableCount: number;
    allSelectables: CSArray<Selectable>;


    AllSelectablesNoAlloc(selectables: CSArray<Selectable>): number;
}
declare const Selectable: SelectableConstructor;
    
interface Button extends Selectable, ISubmitHandler, IPointerClickHandler {
    onClick: ButtonClickedEvent;


    OnPointerClick(eventData: PointerEventData): void;
    OnSubmit(eventData: BaseEventData): void;
}
    
interface UnityEventBase extends ISerializationCallbackReceiver {


    GetPersistentEventCount(): number;
    GetPersistentListenerState(index: number): UnityEventCallState;
    GetPersistentMethodName(index: number): string;
    GetPersistentTarget(index: number): Object;
    RemoveAllListeners(): void;
    SetPersistentListenerState(index: number, state: UnityEventCallState): void;
    ToString(): string;
}
    
interface UnityEventBaseConstructor {


    GetValidMethodInfo(obj: unknown, functionName: string, argumentTypes: CSArray<unknown>): unknown;
    GetValidMethodInfo(objectType: unknown, functionName: string, argumentTypes: CSArray<unknown>): unknown;
}
declare const UnityEventBase: UnityEventBaseConstructor;
    
interface UnityEvent extends UnityEventBase {


    AddListener(call: UnityAction): void;
    Invoke(): void;
    RemoveListener(call: UnityAction): void;
}
    
interface UnityEventConstructor {

    new(): UnityEvent;

}
declare const UnityEvent: UnityEventConstructor;
    
interface ButtonClickedEvent extends UnityEvent {


}
    
interface ButtonClickedEventConstructor {

    new(): ButtonClickedEvent;

}
declare const ButtonClickedEvent: ButtonClickedEventConstructor;
    
interface MeshRenderer extends Renderer {
    additionalVertexStreams: Mesh;
    enlightenVertexStream: Mesh;
    subMeshStartIndex: number;
    scaleInLightmap: number;
    receiveGI: ReceiveGI;
    stitchLightmapSeams: boolean;


}
    
interface MeshRendererConstructor {

    new(): MeshRenderer;

}
declare const MeshRenderer: MeshRendererConstructor;
    
interface MeshFilter extends Component {
    sharedMesh: Mesh;
    mesh: Mesh;


}
    
interface MeshFilterConstructor {

    new(): MeshFilter;

}
declare const MeshFilter: MeshFilterConstructor;
    
interface TMP_Text extends MaskableGraphic {
    text: string;
    textPreprocessor: ITextPreprocessor;
    isRightToLeftText: boolean;
    font: TMP_FontAsset;
    fontSharedMaterial: Material;
    fontSharedMaterials: CSArray<Material>;
    fontMaterial: Material;
    fontMaterials: CSArray<Material>;
    color: Color;
    alpha: number;
    enableVertexGradient: boolean;
    colorGradient: VertexGradient;
    colorGradientPreset: TMP_ColorGradient;
    spriteAsset: TMP_SpriteAsset;
    tintAllSprites: boolean;
    styleSheet: TMP_StyleSheet;
    textStyle: TMP_Style;
    overrideColorTags: boolean;
    faceColor: Color32;
    outlineColor: Color32;
    outlineWidth: number;
    fontSize: number;
    fontWeight: FontWeight;
    pixelsPerUnit: number;
    enableAutoSizing: boolean;
    fontSizeMin: number;
    fontSizeMax: number;
    fontStyle: FontStyles;
    isUsingBold: boolean;
    horizontalAlignment: HorizontalAlignmentOptions;
    verticalAlignment: VerticalAlignmentOptions;
    alignment: TextAlignmentOptions;
    characterSpacing: number;
    wordSpacing: number;
    lineSpacing: number;
    lineSpacingAdjustment: number;
    paragraphSpacing: number;
    characterWidthAdjustment: number;
    textWrappingMode: TextWrappingModes;
    enableWordWrapping: boolean;
    wordWrappingRatios: number;
    overflowMode: TextOverflowModes;
    isTextOverflowing: boolean;
    firstOverflowCharacterIndex: number;
    linkedTextComponent: TMP_Text;
    isTextTruncated: boolean;
    enableKerning: boolean;
    fontFeatures: CSArray<OTL_FeatureTag>;
    extraPadding: boolean;
    richText: boolean;
    emojiFallbackSupport: boolean;
    parseCtrlCharacters: boolean;
    isOverlay: boolean;
    isOrthographic: boolean;
    enableCulling: boolean;
    ignoreVisibility: boolean;
    horizontalMapping: TextureMappingOptions;
    verticalMapping: TextureMappingOptions;
    mappingUvLineOffset: number;
    renderMode: TextRenderFlags;
    geometrySortingOrder: VertexSortingOrder;
    isTextObjectScaleStatic: boolean;
    vertexBufferAutoSizeReduction: boolean;
    firstVisibleCharacter: number;
    maxVisibleCharacters: number;
    maxVisibleWords: number;
    maxVisibleLines: number;
    useMaxVisibleDescender: boolean;
    pageToDisplay: number;
    margin: Vector4;
    textInfo: TMP_TextInfo;
    havePropertiesChanged: boolean;
    isUsingLegacyAnimationComponent: boolean;
    transform: Transform;
    rectTransform: RectTransform;
    autoSizeTextContainer: boolean;
    mesh: Mesh;
    isVolumetricText: boolean;
    bounds: Bounds;
    textBounds: Bounds;
    flexibleHeight: number;
    flexibleWidth: number;
    minWidth: number;
    minHeight: number;
    maxWidth: number;
    maxHeight: number;
    preferredWidth: number;
    preferredHeight: number;
    renderedWidth: number;
    renderedHeight: number;
    layoutPriority: number;


    ClearMesh(): void;
    ClearMesh(uploadGeometry: boolean): void;
    ComputeMarginSize(): void;
    CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void;
    CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void;
    ForceMeshUpdate(ignoreActiveState: boolean, forceTextReparsing: boolean): void;
    GetParsedText(): string;
    GetPreferredValues(): Vector2;
    GetPreferredValues(width: number, height: number): Vector2;
    GetPreferredValues(text: string): Vector2;
    GetPreferredValues(text: string, width: number, height: number): Vector2;
    GetRenderedValues(): Vector2;
    GetRenderedValues(onlyVisibleCharacters: boolean): Vector2;
    GetTextInfo(text: string): TMP_TextInfo;
    SetCharArray(sourceText: CSArray<string>): void;
    SetCharArray(sourceText: CSArray<string>, start: number, length: number): void;
    SetText(sourceText: string): void;
    SetText(sourceText: string, syncTextInputBox: boolean): void;
    SetText(sourceText: string, arg0: number): void;
    SetText(sourceText: string, arg0: number, arg1: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number): void;
    SetText(sourceText: string, arg0: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number): void;
    SetText(sourceText: unknown): void;
    SetText(sourceText: CSArray<string>): void;
    SetText(sourceText: CSArray<string>, start: number, length: number): void;
    SetVertices(vertices: CSArray<Vector3>): void;
    UpdateGeometry(mesh: Mesh, index: number): void;
    UpdateMeshPadding(): void;
    UpdateVertexData(flags: TMP_VertexDataUpdateFlags): void;
    UpdateVertexData(): void;
}
    
interface ITextPreprocessor {


    PreprocessText(text: string): string;
}
    
interface TMP_Asset extends ScriptableObject {
    version: string;
    instanceID: number;
    hashCode: number;
    faceInfo: FaceInfo;
    material: Material;
    materialHashCode: number;


}
    
interface FaceInfo {
    familyName: string;
    styleName: string;
    pointSize: number;
    scale: number;
    lineHeight: number;
    ascentLine: number;
    capLine: number;
    meanLine: number;
    baseline: number;
    descentLine: number;
    superscriptOffset: number;
    superscriptSize: number;
    subscriptOffset: number;
    subscriptSize: number;
    underlineOffset: number;
    underlineThickness: number;
    strikethroughOffset: number;
    strikethroughThickness: number;
    tabWidth: number;


    Compare(other: FaceInfo): boolean;
}
    
interface TMP_FontAsset extends TMP_Asset {
    normalStyle: number;
    normalSpacingOffset: number;
    boldStyle: number;
    boldSpacing: number;
    italicStyle: number;
    tabSize: number;
    atlas: Texture2D;
    creationSettings: FontAssetCreationSettings;
    sourceFontFile: Font;
    atlasPopulationMode: AtlasPopulationMode;
    glyphTable: CSArray<Glyph>;
    glyphLookupTable: CSDictionary<number, Glyph>;
    characterTable: CSArray<TMP_Character>;
    characterLookupTable: CSDictionary<number, TMP_Character>;
    atlasTexture: Texture2D;
    atlasTextures: CSArray<Texture2D>;
    atlasTextureCount: number;
    isMultiAtlasTexturesEnabled: boolean;
    getFontFeatures: boolean;
    atlasWidth: number;
    atlasHeight: number;
    atlasPadding: number;
    atlasRenderMode: GlyphRenderMode;
    fontFeatureTable: TMP_FontFeatureTable;
    fallbackFontAssetTable: CSArray<TMP_FontAsset>;
    fontWeightTable: CSArray<TMP_FontWeightPair>;
    fontInfo: FaceInfo_Legacy;


    ClearFontAssetData(setAtlasSizeToZero: boolean): void;
    HasCharacter(character: number): boolean;
    HasCharacter(character: string, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<string>): boolean;
    HasCharacters(text: string, missingCharacters: CSArray<number>, searchFallbacks: boolean, tryAddCharacter: boolean): boolean;
    HasCharacters(text: string): boolean;
    ReadFontAssetDefinition(): void;
    TryAddCharacters(unicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(unicodes: CSArray<number>, missingUnicodes: CSArray<number>, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, includeFontFeatures: boolean): boolean;
    TryAddCharacters(characters: string, missingCharacters: CSArray<string>, includeFontFeatures: boolean): boolean;
}
    
interface FontAssetCreationSettings {
    sourceFontFileName: string;
    sourceFontFileGUID: string;
    faceIndex: number;
    pointSizeSamplingMode: number;
    pointSize: number;
    padding: number;
    paddingMode: number;
    packingMode: number;
    atlasWidth: number;
    atlasHeight: number;
    characterSetSelectionMode: number;
    characterSequence: string;
    referencedFontAssetGUID: string;
    referencedTextAssetGUID: string;
    fontStyle: number;
    fontStyleModifier: number;
    renderMode: number;
    includeFontFeatures: boolean;


}
    
interface Font extends Object {
    material: Material;
    fontNames: CSArray<string>;
    dynamic: boolean;
    ascent: number;
    fontSize: number;
    characterInfo: CSArray<CharacterInfo>;
    lineHeight: number;
    textureRebuildCallback: FontTextureRebuildCallback;


    GetCharacterInfo(ch: string, info: unknown, size: number, style: FontStyle): boolean;
    GetCharacterInfo(ch: string, info: unknown, size: number): boolean;
    GetCharacterInfo(ch: string, info: unknown): boolean;
    HasCharacter(c: string): boolean;
    RequestCharactersInTexture(characters: string, size: number, style: FontStyle): void;
    RequestCharactersInTexture(characters: string, size: number): void;
    RequestCharactersInTexture(characters: string): void;
}
    
interface CharacterInfo {
    index: number;
    uv: Rect;
    vert: Rect;
    width: number;
    size: number;
    style: FontStyle;
    flipped: boolean;
    advance: number;
    glyphWidth: number;
    glyphHeight: number;
    bearing: number;
    minY: number;
    maxY: number;
    minX: number;
    maxX: number;
    uvBottomLeft: Vector2;
    uvBottomRight: Vector2;
    uvTopRight: Vector2;
    uvTopLeft: Vector2;


}
    
interface FontTextureRebuildCallback {


    BeginInvoke(callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(): void;
}
    
interface FontTextureRebuildCallbackConstructor {

    new(object: unknown, method: unknown): FontTextureRebuildCallback;

}
declare const FontTextureRebuildCallback: FontTextureRebuildCallbackConstructor;
    
interface FontConstructor {

    new(): Font;
    new(name: string): Font;

    CreateDynamicFontFromOSFont(fontname: string, size: number): Font;
    CreateDynamicFontFromOSFont(fontnames: CSArray<string>, size: number): Font;
    GetMaxVertsForString(str: string): number;
    GetOSInstalledFontNames(): CSArray<string>;
    GetPathsToOSFonts(): CSArray<string>;
}
declare const Font: FontConstructor;
    
interface Glyph {
    index: number;
    metrics: GlyphMetrics;
    glyphRect: GlyphRect;
    scale: number;
    atlasIndex: number;
    classDefinitionType: GlyphClassDefinitionType;


    Compare(other: Glyph): boolean;
}
    
interface GlyphMetrics {
    width: number;
    height: number;
    horizontalBearingX: number;
    horizontalBearingY: number;
    horizontalAdvance: number;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphMetrics): boolean;
    GetHashCode(): number;
}
    
interface GlyphMetricsConstructor {

    new(width: number, height: number, bearingX: number, bearingY: number, advance: number): GlyphMetrics;

}
declare const GlyphMetrics: GlyphMetricsConstructor;
    
interface GlyphRect {
    x: number;
    y: number;
    width: number;
    height: number;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphRect): boolean;
    GetHashCode(): number;
}
    
interface GlyphRectConstructor {
    zero: GlyphRect;

    new(x: number, y: number, width: number, height: number): GlyphRect;
    new(rect: Rect): GlyphRect;

}
declare const GlyphRect: GlyphRectConstructor;
    
interface GlyphConstructor {

    new(): Glyph;
    new(glyph: Glyph): Glyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect): Glyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number): Glyph;

}
declare const Glyph: GlyphConstructor;
    
interface TMP_TextElement {
    elementType: TextElementType;
    unicode: number;
    textAsset: TMP_Asset;
    glyph: Glyph;
    glyphIndex: number;
    scale: number;


}
    
interface TMP_TextElementConstructor {

    new(): TMP_TextElement;

}
declare const TMP_TextElement: TMP_TextElementConstructor;
    
interface TMP_Character extends TMP_TextElement {


}
    
interface TMP_CharacterConstructor {

    new(): TMP_Character;
    new(unicode: number, glyph: Glyph): TMP_Character;
    new(unicode: number, fontAsset: TMP_FontAsset, glyph: Glyph): TMP_Character;

}
declare const TMP_Character: TMP_CharacterConstructor;
    
interface TMP_FontFeatureTable {
    multipleSubstitutionRecords: CSArray<MultipleSubstitutionRecord>;
    ligatureRecords: CSArray<LigatureSubstitutionRecord>;
    glyphPairAdjustmentRecords: CSArray<GlyphPairAdjustmentRecord>;
    MarkToBaseAdjustmentRecords: CSArray<MarkToBaseAdjustmentRecord>;
    MarkToMarkAdjustmentRecords: CSArray<MarkToMarkAdjustmentRecord>;


    SortGlyphPairAdjustmentRecords(): void;
    SortMarkToBaseAdjustmentRecords(): void;
    SortMarkToMarkAdjustmentRecords(): void;
}
    
interface MultipleSubstitutionRecord {
    targetGlyphID: number;
    substituteGlyphIDs: CSArray<number>;


}
    
interface LigatureSubstitutionRecord {
    componentGlyphIDs: CSArray<number>;
    ligatureGlyphID: number;


}
    
interface GlyphPairAdjustmentRecord {
    firstAdjustmentRecord: GlyphAdjustmentRecord;
    secondAdjustmentRecord: GlyphAdjustmentRecord;
    featureLookupFlags: FontFeatureLookupFlags;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphPairAdjustmentRecord): boolean;
    GetHashCode(): number;
}
    
interface GlyphAdjustmentRecord {
    glyphIndex: number;
    glyphValueRecord: GlyphValueRecord;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphAdjustmentRecord): boolean;
    GetHashCode(): number;
}
    
interface GlyphValueRecord {
    xPlacement: number;
    yPlacement: number;
    xAdvance: number;
    yAdvance: number;


    Equals(obj: unknown): boolean;
    Equals(other: GlyphValueRecord): boolean;
    GetHashCode(): number;
}
    
interface GlyphValueRecordConstructor {

    new(xPlacement: number, yPlacement: number, xAdvance: number, yAdvance: number): GlyphValueRecord;

}
declare const GlyphValueRecord: GlyphValueRecordConstructor;
    
interface GlyphAdjustmentRecordConstructor {

    new(glyphIndex: number, glyphValueRecord: GlyphValueRecord): GlyphAdjustmentRecord;

}
declare const GlyphAdjustmentRecord: GlyphAdjustmentRecordConstructor;
    
interface GlyphPairAdjustmentRecordConstructor {

    new(firstAdjustmentRecord: GlyphAdjustmentRecord, secondAdjustmentRecord: GlyphAdjustmentRecord): GlyphPairAdjustmentRecord;

}
declare const GlyphPairAdjustmentRecord: GlyphPairAdjustmentRecordConstructor;
    
interface MarkToBaseAdjustmentRecord {
    baseGlyphID: number;
    baseGlyphAnchorPoint: GlyphAnchorPoint;
    markGlyphID: number;
    markPositionAdjustment: MarkPositionAdjustment;


}
    
interface GlyphAnchorPoint {
    xCoordinate: number;
    yCoordinate: number;


}
    
interface MarkPositionAdjustment {
    xPositionAdjustment: number;
    yPositionAdjustment: number;


}
    
interface MarkPositionAdjustmentConstructor {

    new(x: number, y: number): MarkPositionAdjustment;

}
declare const MarkPositionAdjustment: MarkPositionAdjustmentConstructor;
    
interface MarkToMarkAdjustmentRecord {
    baseMarkGlyphID: number;
    baseMarkGlyphAnchorPoint: GlyphAnchorPoint;
    combiningMarkGlyphID: number;
    combiningMarkPositionAdjustment: MarkPositionAdjustment;


}
    
interface TMP_FontFeatureTableConstructor {

    new(): TMP_FontFeatureTable;

}
declare const TMP_FontFeatureTable: TMP_FontFeatureTableConstructor;
    
interface TMP_FontWeightPair {
    regularTypeface: TMP_FontAsset;
    italicTypeface: TMP_FontAsset;


}
    
interface FaceInfo_Legacy {
    Name: string;
    PointSize: number;
    Scale: number;
    CharacterCount: number;
    LineHeight: number;
    Baseline: number;
    Ascender: number;
    CapHeight: number;
    Descender: number;
    CenterLine: number;
    SuperscriptOffset: number;
    SubscriptOffset: number;
    SubSize: number;
    Underline: number;
    UnderlineThickness: number;
    strikethrough: number;
    strikethroughThickness: number;
    TabWidth: number;
    Padding: number;
    AtlasWidth: number;
    AtlasHeight: number;


}
    
interface FaceInfo_LegacyConstructor {

    new(): FaceInfo_Legacy;

}
declare const FaceInfo_Legacy: FaceInfo_LegacyConstructor;
    
interface TMP_FontAssetConstructor {

    new(): TMP_FontAsset;

    CreateFontAsset(familyName: string, styleName: string, pointSize: number): TMP_FontAsset;
    CreateFontAsset(fontFilePath: string, faceIndex: number, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number): TMP_FontAsset;
    CreateFontAsset(font: Font): TMP_FontAsset;
    CreateFontAsset(font: Font, samplingPointSize: number, atlasPadding: number, renderMode: GlyphRenderMode, atlasWidth: number, atlasHeight: number, atlasPopulationMode: AtlasPopulationMode, enableMultiAtlasSupport: boolean): TMP_FontAsset;
    GetCharacters(fontAsset: TMP_FontAsset): string;
    GetCharactersArray(fontAsset: TMP_FontAsset): CSArray<number>;
}
declare const TMP_FontAsset: TMP_FontAssetConstructor;
    
interface VertexGradient {
    topLeft: Color;
    topRight: Color;
    bottomLeft: Color;
    bottomRight: Color;


}
    
interface VertexGradientConstructor {

    new(color: Color): VertexGradient;
    new(color0: Color, color1: Color, color2: Color, color3: Color): VertexGradient;

}
declare const VertexGradient: VertexGradientConstructor;
    
interface TMP_ColorGradient extends ScriptableObject {
    colorMode: ColorMode;
    topLeft: Color;
    topRight: Color;
    bottomLeft: Color;
    bottomRight: Color;


}
    
interface TMP_ColorGradientConstructor {

    new(): TMP_ColorGradient;
    new(color: Color): TMP_ColorGradient;
    new(color0: Color, color1: Color, color2: Color, color3: Color): TMP_ColorGradient;

}
declare const TMP_ColorGradient: TMP_ColorGradientConstructor;
    
interface TMP_SpriteAsset extends TMP_Asset {
    spriteSheet: Texture;
    spriteInfoList: CSArray<TMP_Sprite>;
    fallbackSpriteAssets: CSArray<TMP_SpriteAsset>;
    spriteCharacterTable: CSArray<TMP_SpriteCharacter>;
    spriteCharacterLookupTable: CSDictionary<number, TMP_SpriteCharacter>;
    spriteGlyphTable: CSArray<TMP_SpriteGlyph>;


    GetSpriteIndexFromHashcode(hashCode: number): number;
    GetSpriteIndexFromName(name: string): number;
    GetSpriteIndexFromUnicode(unicode: number): number;
    SortGlyphTable(): void;
    UpdateLookupTables(): void;
}
    
interface TMP_TextElement_Legacy {
    id: number;
    x: number;
    y: number;
    width: number;
    height: number;
    xOffset: number;
    yOffset: number;
    xAdvance: number;
    scale: number;


}
    
interface TMP_TextElement_LegacyConstructor {

    new(): TMP_TextElement_Legacy;

}
declare const TMP_TextElement_Legacy: TMP_TextElement_LegacyConstructor;
    
interface TMP_Sprite extends TMP_TextElement_Legacy {
    name: string;
    hashCode: number;
    unicode: number;
    pivot: Vector2;
    sprite: Sprite;


}
    
interface TMP_SpriteConstructor {

    new(): TMP_Sprite;

}
declare const TMP_Sprite: TMP_SpriteConstructor;
    
interface TMP_SpriteCharacter extends TMP_TextElement {
    name: string;


}
    
interface TMP_SpriteCharacterConstructor {

    new(): TMP_SpriteCharacter;
    new(unicode: number, glyph: TMP_SpriteGlyph): TMP_SpriteCharacter;
    new(unicode: number, spriteAsset: TMP_SpriteAsset, glyph: TMP_SpriteGlyph): TMP_SpriteCharacter;

}
declare const TMP_SpriteCharacter: TMP_SpriteCharacterConstructor;
    
interface TMP_SpriteGlyph extends Glyph {
    sprite: Sprite;


}
    
interface TMP_SpriteGlyphConstructor {

    new(): TMP_SpriteGlyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number): TMP_SpriteGlyph;
    new(index: number, metrics: GlyphMetrics, glyphRect: GlyphRect, scale: number, atlasIndex: number, sprite: Sprite): TMP_SpriteGlyph;

}
declare const TMP_SpriteGlyph: TMP_SpriteGlyphConstructor;
    
interface TMP_SpriteAssetConstructor {

    new(): TMP_SpriteAsset;

    SearchForSpriteByHashCode(spriteAsset: TMP_SpriteAsset, hashCode: number, includeFallbacks: boolean, spriteIndex: unknown): TMP_SpriteAsset;
    SearchForSpriteByUnicode(spriteAsset: TMP_SpriteAsset, unicode: number, includeFallbacks: boolean, spriteIndex: unknown): TMP_SpriteAsset;
}
declare const TMP_SpriteAsset: TMP_SpriteAssetConstructor;
    
interface TMP_StyleSheet extends ScriptableObject {


    GetStyle(hashCode: number): TMP_Style;
    GetStyle(name: string): TMP_Style;
    RefreshStyles(): void;
}
    
interface TMP_Style {
    name: string;
    hashCode: number;
    styleOpeningDefinition: string;
    styleClosingDefinition: string;
    styleOpeningTagArray: CSArray<number>;
    styleClosingTagArray: CSArray<number>;


    RefreshStyle(): void;
}
    
interface TMP_StyleConstructor {
    NormalStyle: TMP_Style;


}
declare const TMP_Style: TMP_StyleConstructor;
    
interface TMP_StyleSheetConstructor {

    new(): TMP_StyleSheet;

}
declare const TMP_StyleSheet: TMP_StyleSheetConstructor;
    
interface TMP_TextInfo {
    textComponent: TMP_Text;
    characterCount: number;
    spriteCount: number;
    spaceCount: number;
    wordCount: number;
    linkCount: number;
    lineCount: number;
    pageCount: number;
    materialCount: number;
    characterInfo: CSArray<TMP_CharacterInfo>;
    wordInfo: CSArray<TMP_WordInfo>;
    linkInfo: CSArray<TMP_LinkInfo>;
    lineInfo: CSArray<TMP_LineInfo>;
    pageInfo: CSArray<TMP_PageInfo>;
    meshInfo: CSArray<TMP_MeshInfo>;


    ClearAllMeshInfo(): void;
    ClearMeshInfo(updateMesh: boolean): void;
    ClearUnusedVertices(materials: CSArray<MaterialReference>): void;
    CopyMeshInfoVertexData(): CSArray<TMP_MeshInfo>;
    ResetVertexLayout(isVolumetric: boolean): void;
}
    
interface TMP_CharacterInfo {
    elementType: TMP_TextElementType;
    character: string;
    index: number;
    stringLength: number;
    textElement: TMP_TextElement;
    alternativeGlyph: Glyph;
    fontAsset: TMP_FontAsset;
    material: Material;
    materialReferenceIndex: number;
    isUsingAlternateTypeface: boolean;
    pointSize: number;
    lineNumber: number;
    pageNumber: number;
    vertexIndex: number;
    vertex_BL: TMP_Vertex;
    vertex_TL: TMP_Vertex;
    vertex_TR: TMP_Vertex;
    vertex_BR: TMP_Vertex;
    topLeft: Vector3;
    bottomLeft: Vector3;
    topRight: Vector3;
    bottomRight: Vector3;
    origin: number;
    xAdvance: number;
    ascender: number;
    baseLine: number;
    descender: number;
    aspectRatio: number;
    scale: number;
    color: Color32;
    underlineColor: Color32;
    underlineVertexIndex: number;
    strikethroughColor: Color32;
    strikethroughVertexIndex: number;
    highlightColor: Color32;
    highlightState: HighlightState;
    style: FontStyles;
    isVisible: boolean;


}
    
interface TMP_Vertex {
    position: Vector3;
    uv: Vector4;
    uv2: Vector2;
    color: Color32;


}
    
interface TMP_VertexConstructor {
    zero: TMP_Vertex;


}
declare const TMP_Vertex: TMP_VertexConstructor;
    
interface HighlightState {
    color: Color32;
    padding: TMP_Offset;


    Equals(obj: unknown): boolean;
    Equals(other: HighlightState): boolean;
    GetHashCode(): number;
}
    
interface TMP_Offset {
    left: number;
    right: number;
    top: number;
    bottom: number;
    horizontal: number;
    vertical: number;


    Equals(obj: unknown): boolean;
    Equals(other: TMP_Offset): boolean;
    GetHashCode(): number;
}
    
interface TMP_OffsetConstructor {
    zero: TMP_Offset;

    new(left: number, right: number, top: number, bottom: number): TMP_Offset;
    new(horizontal: number, vertical: number): TMP_Offset;

}
declare const TMP_Offset: TMP_OffsetConstructor;
    
interface HighlightStateConstructor {

    new(color: Color32, padding: TMP_Offset): HighlightState;

}
declare const HighlightState: HighlightStateConstructor;
    
interface TMP_WordInfo {
    textComponent: TMP_Text;
    firstCharacterIndex: number;
    lastCharacterIndex: number;
    characterCount: number;


    GetWord(): string;
}
    
interface TMP_LinkInfo {
    textComponent: TMP_Text;
    hashCode: number;
    linkIdFirstCharacterIndex: number;
    linkIdLength: number;
    linkTextfirstCharacterIndex: number;
    linkTextLength: number;


    GetLink(): string;
    GetLinkID(): string;
    GetLinkText(): string;
}
    
interface TMP_LineInfo {
    characterCount: number;
    visibleCharacterCount: number;
    spaceCount: number;
    visibleSpaceCount: number;
    wordCount: number;
    firstCharacterIndex: number;
    firstVisibleCharacterIndex: number;
    lastCharacterIndex: number;
    lastVisibleCharacterIndex: number;
    length: number;
    lineHeight: number;
    ascender: number;
    baseline: number;
    descender: number;
    maxAdvance: number;
    width: number;
    marginLeft: number;
    marginRight: number;
    alignment: HorizontalAlignmentOptions;
    lineExtents: Extents;


}
    
interface Extents {
    min: Vector2;
    max: Vector2;


    ToString(): string;
}
    
interface ExtentsConstructor {

    new(min: Vector2, max: Vector2): Extents;

}
declare const Extents: ExtentsConstructor;
    
interface TMP_PageInfo {
    firstCharacterIndex: number;
    lastCharacterIndex: number;
    ascender: number;
    baseLine: number;
    descender: number;


}
    
interface TMP_MeshInfo {
    mesh: Mesh;
    vertexCount: number;
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;
    tangents: CSArray<Vector4>;
    uvs0: CSArray<Vector4>;
    uvs2: CSArray<Vector2>;
    colors32: CSArray<Color32>;
    triangles: CSArray<number>;
    material: Material;


    Clear(): void;
    Clear(uploadChanges: boolean): void;
    ClearUnusedVertices(): void;
    ClearUnusedVertices(startIndex: number): void;
    ClearUnusedVertices(startIndex: number, updateMesh: boolean): void;
    ResizeMeshInfo(size: number): void;
    ResizeMeshInfo(size: number, isVolumetric: boolean): void;
    SortGeometry(order: VertexSortingOrder): void;
    SortGeometry(sortingOrder: CSArray<number>): void;
    SwapVertexData(src: number, dst: number): void;
}
    
interface TMP_MeshInfoConstructor {

    new(mesh: Mesh, size: number): TMP_MeshInfo;
    new(mesh: Mesh, size: number, isVolumetric: boolean): TMP_MeshInfo;

}
declare const TMP_MeshInfo: TMP_MeshInfoConstructor;
    
interface MaterialReference {
    index: number;
    fontAsset: TMP_FontAsset;
    spriteAsset: TMP_SpriteAsset;
    material: Material;
    isDefaultMaterial: boolean;
    isFallbackMaterial: boolean;
    fallbackMaterial: Material;
    padding: number;
    referenceCount: number;


}
    
interface MaterialReferenceConstructor {

    new(index: number, fontAsset: TMP_FontAsset, spriteAsset: TMP_SpriteAsset, material: Material, padding: number): MaterialReference;

    AddMaterialReference(material: Material, fontAsset: TMP_FontAsset, materialReferences: CSArray<MaterialReference>, materialReferenceIndexLookup: CSDictionary<number, number>): number;
    AddMaterialReference(material: Material, spriteAsset: TMP_SpriteAsset, materialReferences: CSArray<MaterialReference>, materialReferenceIndexLookup: CSDictionary<number, number>): number;
    Contains(materialReferences: CSArray<MaterialReference>, fontAsset: TMP_FontAsset): boolean;
}
declare const MaterialReference: MaterialReferenceConstructor;
    
interface TMP_TextInfoConstructor {

    new(): TMP_TextInfo;
    new(textComponent: TMP_Text): TMP_TextInfo;

    Resize<T>(array: CSArray<T>, size: number): void;
    Resize<T>(array: CSArray<T>, size: number, isBlockAllocated: boolean): void;
}
declare const TMP_TextInfo: TMP_TextInfoConstructor;
    
interface TextMeshProUGUI extends TMP_Text, ILayoutElement {
    materialForRendering: Material;
    autoSizeTextContainer: boolean;
    mesh: Mesh;
    canvasRenderer: CanvasRenderer;
    maskOffset: Vector4;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    ClearMesh(): void;
    ComputeMarginSize(): void;
    Cull(clipRect: Rect, validRect: boolean): void;
    ForceMeshUpdate(ignoreActiveState: boolean, forceTextReparsing: boolean): void;
    GetModifiedMaterial(baseMaterial: Material): Material;
    GetTextInfo(text: string): TMP_TextInfo;
    Rebuild(update: CanvasUpdate): void;
    RecalculateClipping(): void;
    SetAllDirty(): void;
    SetLayoutDirty(): void;
    SetMaterialDirty(): void;
    SetVerticesDirty(): void;
    UpdateFontAsset(): void;
    UpdateGeometry(mesh: Mesh, index: number): void;
    UpdateMeshPadding(): void;
    UpdateVertexData(flags: TMP_VertexDataUpdateFlags): void;
    UpdateVertexData(): void;
}
    
interface TextMeshProUGUIConstructor {

    new(): TextMeshProUGUI;

}
declare const TextMeshProUGUI: TextMeshProUGUIConstructor;
    
interface Animation extends Behaviour {
    clip: AnimationClip;
    playAutomatically: boolean;
    wrapMode: WrapMode;
    isPlaying: boolean;
    Item: AnimationState;
    animatePhysics: boolean;
    updateMode: AnimationUpdateMode;
    animateOnlyIfVisible: boolean;
    cullingType: AnimationCullingType;
    localBounds: Bounds;


    AddClip(clip: AnimationClip, newName: string): void;
    AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number): void;
    AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number, addLoopFrame: boolean): void;
    Blend(animation: string): void;
    Blend(animation: string, targetWeight: number): void;
    Blend(animation: string, targetWeight: number, fadeLength: number): void;
    CrossFade(animation: string): void;
    CrossFade(animation: string, fadeLength: number): void;
    CrossFade(animation: string, fadeLength: number, mode: PlayMode): void;
    CrossFadeQueued(animation: string): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number, queue: QueueMode): AnimationState;
    CrossFadeQueued(animation: string, fadeLength: number, queue: QueueMode, mode: PlayMode): AnimationState;
    GetClip(name: string): AnimationClip;
    GetClipCount(): number;
    GetEnumerator(): unknown;
    IsPlaying(name: string): boolean;
    Play(): boolean;
    Play(mode: PlayMode): boolean;
    Play(animation: string): boolean;
    Play(animation: string, mode: PlayMode): boolean;
    Play(mode: AnimationPlayMode): boolean;
    Play(animation: string, mode: AnimationPlayMode): boolean;
    PlayQueued(animation: string): AnimationState;
    PlayQueued(animation: string, queue: QueueMode): AnimationState;
    PlayQueued(animation: string, queue: QueueMode, mode: PlayMode): AnimationState;
    RemoveClip(clip: AnimationClip): void;
    RemoveClip(clipName: string): void;
    Rewind(): void;
    Rewind(name: string): void;
    Sample(): void;
    Stop(): void;
    Stop(name: string): void;
    SyncLayer(layer: number): void;
}
    
interface AnimationConstructor {

    new(): Animation;

}
declare const Animation: AnimationConstructor;
    
interface ClientSceneListener extends MonoBehaviour {
    IsGameSceneLoaded: boolean;
    SceneLoadPercent: number;


}
    
interface ClientSceneListenerConstructor {

    new(): ClientSceneListener;

}
declare const ClientSceneListener: ClientSceneListenerConstructor;
    
interface BundleLoadingScreen extends MonoBehaviour {


    SetProgress(text: string, percent: number): void;
}
    
interface CoreLoadingScreen extends BundleLoadingScreen {
    progressText: TMP_Text;
    disconnectButton: Button;


    Close(): void;
    SetProgress(text: string, percent: number): void;
}
    
interface CoreLoadingScreenConstructor {

    new(): CoreLoadingScreen;

}
declare const CoreLoadingScreen: CoreLoadingScreenConstructor;
    
interface TextField {
    multiline: boolean;
    value: string;


    SetValueWithoutNotify(newValue: string): void;
}
    
interface TextFieldConstructor {
    ussClassName: string;
    labelUssClassName: string;
    inputUssClassName: string;

    new(): TextField;
    new(maxLength: number, multiline: boolean, isPasswordField: boolean, maskChar: string): TextField;
    new(label: string): TextField;
    new(label: string, maxLength: number, multiline: boolean, isPasswordField: boolean, maskChar: string): TextField;

}
declare const TextField: TextFieldConstructor;
    
interface GameConfig extends ScriptableObject {
    gameId: string;
    startingSceneName: string;
    gameScenes: CSArray<Object>;
    packages: CSArray<AirshipPackageDocument>;
    tags: CSArray<string>;


    ToJson(): string;
}
    
interface AirshipPackageDocument {
    id: string;
    version: string;
    game: boolean;
    localSource: boolean;
    disabled: boolean;
    defaultPackage: boolean;
    forceLatestVersion: boolean;


}
    
interface AirshipPackageDocumentConstructor {

    new(): AirshipPackageDocument;

    FindPathFromDocument(document: AirshipPackageDocument): string;
}
declare const AirshipPackageDocument: AirshipPackageDocumentConstructor;
    
interface GameConfigConstructor {

    new(): GameConfig;

    Load(): GameConfig;
}
declare const GameConfig: GameConfigConstructor;
    
interface RenderSettings extends Object {


}
    
interface Light extends Behaviour {
    type: LightType;
    shape: LightShape;
    spotAngle: number;
    innerSpotAngle: number;
    color: Color;
    colorTemperature: number;
    useColorTemperature: boolean;
    intensity: number;
    bounceIntensity: number;
    useBoundingSphereOverride: boolean;
    boundingSphereOverride: Vector4;
    useViewFrustumForShadowCasterCull: boolean;
    shadowCustomResolution: number;
    shadowBias: number;
    shadowNormalBias: number;
    shadowNearPlane: number;
    useShadowMatrixOverride: boolean;
    shadowMatrixOverride: Matrix4x4;
    range: number;
    dilatedRange: number;
    flare: Flare;
    bakingOutput: LightBakingOutput;
    cullingMask: number;
    renderingLayerMask: number;
    lightShadowCasterMode: LightShadowCasterMode;
    shadowRadius: number;
    shadowAngle: number;
    shadows: LightShadows;
    shadowStrength: number;
    shadowResolution: LightShadowResolution;
    shadowSoftness: number;
    shadowSoftnessFade: number;
    layerShadowCullDistances: CSArray<number>;
    cookieSize: number;
    cookie: Texture;
    renderMode: LightRenderMode;
    bakedIndex: number;
    areaSize: Vector2;
    lightmapBakeType: LightmapBakeType;
    commandBufferCount: number;
    shadowConstantBias: number;
    shadowObjectSizeBias: number;
    attenuate: boolean;
    lightmappingMode: LightmappingMode;
    isBaked: boolean;
    alreadyLightmapped: boolean;


    AddCommandBuffer(evt: LightEvent, buffer: CommandBuffer): void;
    AddCommandBuffer(evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass): void;
    AddCommandBufferAsync(evt: LightEvent, buffer: CommandBuffer, queueType: ComputeQueueType): void;
    AddCommandBufferAsync(evt: LightEvent, buffer: CommandBuffer, shadowPassMask: ShadowMapPass, queueType: ComputeQueueType): void;
    GetCommandBuffers(evt: LightEvent): CSArray<CommandBuffer>;
    RemoveAllCommandBuffers(): void;
    RemoveCommandBuffer(evt: LightEvent, buffer: CommandBuffer): void;
    RemoveCommandBuffers(evt: LightEvent): void;
    Reset(): void;
    SetLightDirty(): void;
}
    
interface Flare extends Object {


}
    
interface FlareConstructor {

    new(): Flare;

}
declare const Flare: FlareConstructor;
    
interface LightBakingOutput {
    probeOcclusionLightIndex: number;
    occlusionMaskChannel: number;
    lightmapBakeType: LightmapBakeType;
    mixedLightingMode: MixedLightingMode;
    isBaked: boolean;


}
    
interface LightConstructor {
    pixelLightCount: number;

    new(): Light;

    GetLights(type: LightType, layer: number): CSArray<Light>;
}
declare const Light: LightConstructor;
    
interface RenderSettingsConstructor {
    ambientSkyboxAmount: number;
    fog: boolean;
    fogStartDistance: number;
    fogEndDistance: number;
    fogMode: FogMode;
    fogColor: Color;
    fogDensity: number;
    ambientMode: AmbientMode;
    ambientSkyColor: Color;
    ambientEquatorColor: Color;
    ambientGroundColor: Color;
    ambientIntensity: number;
    ambientLight: Color;
    subtractiveShadowColor: Color;
    skybox: Material;
    sun: Light;
    ambientProbe: SphericalHarmonicsL2;
    customReflection: Cubemap;
    customReflectionTexture: Texture;
    reflectionIntensity: number;
    reflectionBounces: number;
    defaultReflectionMode: DefaultReflectionMode;
    defaultReflectionResolution: number;
    haloStrength: number;
    flareStrength: number;
    flareFadeSpeed: number;


}
declare const RenderSettings: RenderSettingsConstructor;
    
interface ServerBootstrap extends MonoBehaviour {
    startupConfig: StartupConfig;
    overrideGameBundleId: string;
    overrideGameBundleVersion: string;
    overrideCoreBundleId: string;
    overrideCoreBundleVersion: string;
    overrideQueueType: string;
    airshipJWT: string;
    agones: AgonesSdk;
    gameId: string;
    serverId: string;
    organizationId: string;
    serverContext: ServerContext;
    editorConfig: AirshipEditorConfig;
    serverReady: boolean;
    isStartupConfigReady: boolean;


    FinishedSetup(): void;
    GetJoinCode(): string;
    GetQueueType(): string;
    IsAgonesEnvironment(): boolean;
    Shutdown(): void;
}
    
interface StartupConfig {
    GameBundleId: string;
    GameBundleVersion: string;
    StartingSceneName: string;
    CdnUrl: string;
    packages: CSArray<AirshipPackageDocument>;


}
    
interface AgonesSdk extends MonoBehaviour {
    healthIntervalSecond: number;
    healthEnabled: boolean;
    logEnabled: boolean;


    Allocate(): boolean;
    Connect(): boolean;
    GameServer(): GameServer;
    Ready(): boolean;
    Reserve(duration: unknown): boolean;
    SetAnnotation(key: string, value: string): boolean;
    SetLabel(key: string, value: string): boolean;
    Shutdown(): boolean;
    WatchGameServer(callback: WatchGameServerCallback): void;
}
    
interface GameServer {
    ObjectMeta: GameServerObjectMeta;
    Spec: GameServerSpec;
    Status: GameServerStatus;


    Equals(input: unknown): boolean;
    Equals(input: GameServer): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface GameServerObjectMeta {
    Name: string;
    Namespace: string;
    Uid: string;
    ResourceVersion: string;
    Generation: number;
    CreationTimestamp: string;
    DeletionTimestamp?: string;
    Annotations: CSDictionary<string, string>;
    Labels: CSDictionary<string, string>;


    Equals(input: unknown): boolean;
    Equals(input: GameServerObjectMeta): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface GameServerObjectMetaConstructor {

    new(data: CSDictionary<string, unknown>): GameServerObjectMeta;

}
declare const GameServerObjectMeta: GameServerObjectMetaConstructor;
    
interface GameServerSpec {
    Health: SpecHealth;


    Equals(input: unknown): boolean;
    Equals(input: GameServerSpec): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface SpecHealth {
    Disabled: boolean;
    PeriodSeconds: number;
    FailureThreshold: number;
    InitialDelaySeconds: number;


    Equals(input: unknown): boolean;
    Equals(input: SpecHealth): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface SpecHealthConstructor {

    new(data: CSDictionary<string, unknown>): SpecHealth;

}
declare const SpecHealth: SpecHealthConstructor;
    
interface GameServerSpecConstructor {

    new(data: CSDictionary<string, unknown>): GameServerSpec;

}
declare const GameServerSpec: GameServerSpecConstructor;
    
interface GameServerStatus {
    State: string;
    Address: string;
    Ports: CSArray<StatusPort>;


    Equals(input: unknown): boolean;
    Equals(input: GameServerStatus): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface StatusPort {
    Name: string;
    Port: number;


    Equals(input: unknown): boolean;
    Equals(input: StatusPort): boolean;
    GetHashCode(): number;
    ToString(): string;
}
    
interface StatusPortConstructor {

    new(data: CSDictionary<string, unknown>): StatusPort;

}
declare const StatusPort: StatusPortConstructor;
    
interface GameServerStatusConstructor {

    new(data: CSDictionary<string, unknown>): GameServerStatus;

}
declare const GameServerStatus: GameServerStatusConstructor;
    
interface GameServerConstructor {

    new(data: CSDictionary<string, unknown>): GameServer;

}
declare const GameServer: GameServerConstructor;
    
interface WatchGameServerCallback {


    BeginInvoke(gameServer: GameServer, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(gameServer: GameServer): void;
}
    
interface WatchGameServerCallbackConstructor {

    new(object: unknown, method: unknown): WatchGameServerCallback;

}
declare const WatchGameServerCallback: WatchGameServerCallbackConstructor;
    
interface AgonesSdkConstructor {

    new(): AgonesSdk;

}
declare const AgonesSdk: AgonesSdkConstructor;
    
interface ServerContext extends NetworkBehaviour {
    serverId: string;
    gameId: string;
    organizationId: string;
    syncVar___serverId: unknown;
    syncVar___gameId: unknown;
    syncVar___organizationId: unknown;
    SyncAccessor_serverId: string;
    SyncAccessor_gameId: string;
    SyncAccessor_organizationId: string;


    Awake(): void;
    Awake___UserLogic(): void;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    ReadSyncVar___ServerContext(PooledReader0: PooledReader, UInt321: number, Boolean2: boolean): boolean;
}
    
interface ServerContextConstructor {

    new(): ServerContext;

}
declare const ServerContext: ServerContextConstructor;
    
interface AirshipEditorConfig extends ScriptableObject {
    useBundlesInEditor: boolean;
    buildBundlesOnPlay: boolean;
    downloadPackages: boolean;


}
    
interface AirshipEditorConfigConstructor {

    new(): AirshipEditorConfig;

    Load(): AirshipEditorConfig;
}
declare const AirshipEditorConfig: AirshipEditorConfigConstructor;
    
interface ServerBootstrapConstructor {

    new(): ServerBootstrap;

}
declare const ServerBootstrap: ServerBootstrapConstructor;
    
interface SceneManager {


}
    
interface CreateSceneParameters {
    localPhysicsMode: LocalPhysicsMode;


}
    
interface CreateSceneParametersConstructor {

    new(physicsMode: LocalPhysicsMode): CreateSceneParameters;

}
declare const CreateSceneParameters: CreateSceneParametersConstructor;
    
interface SceneManagerConstructor {
    sceneCount: number;
    loadedSceneCount: number;
    sceneCountInBuildSettings: number;

    new(): SceneManager;

    CreateScene(sceneName: string, parameters: CreateSceneParameters): Scene;
    CreateScene(sceneName: string): Scene;
    GetActiveScene(): Scene;
    GetAllScenes(): CSArray<Scene>;
    GetSceneAt(index: number): Scene;
    GetSceneByBuildIndex(buildIndex: number): Scene;
    GetSceneByName(name: string): Scene;
    GetSceneByPath(scenePath: string): Scene;
    LoadScene(sceneName: string, mode: LoadSceneMode): void;
    LoadScene(sceneName: string): void;
    LoadScene(sceneName: string, parameters: LoadSceneParameters): Scene;
    LoadScene(sceneBuildIndex: number, mode: LoadSceneMode): void;
    LoadScene(sceneBuildIndex: number): void;
    LoadScene(sceneBuildIndex: number, parameters: LoadSceneParameters): Scene;
    LoadSceneAsync(sceneBuildIndex: number, mode: LoadSceneMode): AsyncOperation;
    LoadSceneAsync(sceneBuildIndex: number): AsyncOperation;
    LoadSceneAsync(sceneBuildIndex: number, parameters: LoadSceneParameters): AsyncOperation;
    LoadSceneAsync(sceneName: string, mode: LoadSceneMode): AsyncOperation;
    LoadSceneAsync(sceneName: string): AsyncOperation;
    LoadSceneAsync(sceneName: string, parameters: LoadSceneParameters): AsyncOperation;
    MergeScenes(sourceScene: Scene, destinationScene: Scene): void;
    MoveGameObjectsToScene(instanceIDs: CSArray<number>, scene: Scene): void;
    MoveGameObjectToScene(go: GameObject, scene: Scene): void;
    SetActiveScene(scene: Scene): boolean;
    UnloadScene(scene: Scene): boolean;
    UnloadScene(sceneBuildIndex: number): boolean;
    UnloadScene(sceneName: string): boolean;
    UnloadSceneAsync(sceneBuildIndex: number): AsyncOperation;
    UnloadSceneAsync(sceneName: string): AsyncOperation;
    UnloadSceneAsync(scene: Scene): AsyncOperation;
    UnloadSceneAsync(sceneBuildIndex: number, options: UnloadSceneOptions): AsyncOperation;
    UnloadSceneAsync(sceneName: string, options: UnloadSceneOptions): AsyncOperation;
    UnloadSceneAsync(scene: Scene, options: UnloadSceneOptions): AsyncOperation;
}
declare const SceneManager: SceneManagerConstructor;
    
interface AccessoryBuilder extends MonoBehaviour {
    rig: CharacterRig;
    firstPerson: boolean;
    firstPersonLayer: number;
    thirdPersonLayer: number;


    AddAccessories(accessoryTemplates: CSArray<AccessoryComponent>, addMode: AccessoryAddMode, rebuildMeshImmediately: boolean): CSArray<ActiveAccessory>;
    AddSingleAccessory(accessoryTemplate: AccessoryComponent, rebuildMeshImmediately: boolean): ActiveAccessory;
    AddSkinAccessory(skin: AccessorySkin, rebuildMeshImmediately: boolean): void;
    EquipAccessoryOutfit(outfit: AccessoryOutfit, rebuildMeshImmediately: boolean): CSArray<ActiveAccessory>;
    GetAccessoryMeshes(slot: AccessorySlot): CSArray<Renderer>;
    GetAccessoryParticles(slot: AccessorySlot): CSArray<ParticleSystem>;
    GetActiveAccessories(): CSArray<ActiveAccessory>;
    GetActiveAccessoriesBySlot(target: AccessorySlot): CSArray<ActiveAccessory>;
    GetAllAccessoryMeshes(): CSArray<Renderer>;
    GetCombinedSkinnedMesh(): SkinnedMeshRenderer;
    GetCombinedStaticMesh(): MeshRenderer;
    RemoveAccessories(): void;
    RemoveAccessorySlot(slot: AccessorySlot, rebuildMeshImmediately: boolean): void;
    SetAccessoryColor(slot: AccessorySlot, color: Color, rebuildMeshImmediately: boolean): void;
    SetSkinColor(color: Color, rebuildMeshImmediately: boolean): void;
    TryCombineMeshes(): void;
    UpdateAccessoryLayers(): void;
}
    
interface CharacterRig extends MonoBehaviour {
    bodyMesh: SkinnedMeshRenderer;
    headMesh: SkinnedMeshRenderer;
    faceMesh: SkinnedMeshRenderer;
    rigHolder: Transform;
    rootMotion: Transform;
    master: Transform;
    hips: Transform;
    spine: Transform;
    head: Transform;
    upperArmL: Transform;
    forearmL: Transform;
    handL: Transform;
    fingersL: Transform;
    thumbL: Transform;
    upperArmR: Transform;
    forearmR: Transform;
    handR: Transform;
    fingersR: Transform;
    thumbR: Transform;
    thighL: Transform;
    shinL: Transform;
    footL: Transform;
    thighR: Transform;
    shinR: Transform;
    footR: Transform;
    headTop: Transform;
    neck: Transform;
    spineChest: Transform;
    heldItemL: Transform;
    heldItemR: Transform;
    baseMeshes: CSArray<SkinnedMeshRenderer>;


    GetSlotTransform(slot: AccessorySlot): Transform;
}
    
interface SkinnedMeshRenderer extends Renderer {
    quality: SkinQuality;
    updateWhenOffscreen: boolean;
    forceMatrixRecalculationPerRender: boolean;
    rootBone: Transform;
    bones: CSArray<Transform>;
    sharedMesh: Mesh;
    skinnedMotionVectors: boolean;
    vertexBufferTarget: Target;


    BakeMesh(mesh: Mesh): void;
    BakeMesh(mesh: Mesh, useScale: boolean): void;
    GetBlendShapeWeight(index: number): number;
    GetPreviousVertexBuffer(): GraphicsBuffer;
    GetVertexBuffer(): GraphicsBuffer;
    SetBlendShapeWeight(index: number, value: number): void;
}
    
interface SkinnedMeshRendererConstructor {

    new(): SkinnedMeshRenderer;

}
declare const SkinnedMeshRenderer: SkinnedMeshRendererConstructor;
    
interface CharacterRigConstructor {

    new(): CharacterRig;

}
declare const CharacterRig: CharacterRigConstructor;
    
interface ActiveAccessory {
    AccessoryComponent: AccessoryComponent;
    rootTransform: Transform;
    gameObjects: CSArray<GameObject>;
    renderers: CSArray<Renderer>;


}
    
interface AccessoryComponent extends MonoBehaviour {
    serverClassId: string;
    serverInstanceId: string;
    accessorySlot: AccessorySlot;
    visibilityMode: VisibilityMode;
    skinnedToCharacter: boolean;
    localPosition: Vector3;
    localRotation: Quaternion;
    localScale: Vector3;


    Copy(other: AccessoryComponent): void;
    GetSlotNumber(): number;
    ToString(): string;
}
    
interface AccessoryComponentConstructor {

    new(): AccessoryComponent;

}
declare const AccessoryComponent: AccessoryComponentConstructor;
    
interface AccessorySkin extends ScriptableObject {
    skinTextureDiffuse: Texture2D;
    skinTextureNormal: Texture2D;
    skinTextureORM: Texture2D;
    faceTextureDiffuse: Texture2D;


    ToString(): string;
}
    
interface AccessorySkinConstructor {

    new(): AccessorySkin;

}
declare const AccessorySkin: AccessorySkinConstructor;
    
interface AccessoryOutfit extends ScriptableObject {
    accessories: CSArray<AccessoryComponent>;
    customSkin: AccessorySkin;
    forceSkinColor: boolean;
    skinColor: Color;


}
    
interface AccessoryOutfitConstructor {

    new(): AccessoryOutfit;

}
declare const AccessoryOutfit: AccessoryOutfitConstructor;
    
interface ParticleSystem extends Component {
    safeCollisionEventSize: number;
    startDelay: number;
    loop: boolean;
    playOnAwake: boolean;
    duration: number;
    playbackSpeed: number;
    enableEmission: boolean;
    emissionRate: number;
    startSpeed: number;
    startSize: number;
    startColor: Color;
    startRotation: number;
    startRotation3D: Vector3;
    startLifetime: number;
    gravityModifier: number;
    maxParticles: number;
    simulationSpace: ParticleSystemSimulationSpace;
    scalingMode: ParticleSystemScalingMode;
    automaticCullingEnabled: boolean;
    isPlaying: boolean;
    isEmitting: boolean;
    isStopped: boolean;
    isPaused: boolean;
    particleCount: number;
    time: number;
    totalTime: number;
    randomSeed: number;
    useAutoRandomSeed: boolean;
    proceduralSimulationSupported: boolean;
    has3DParticleRotations: boolean;
    hasNonUniformParticleSizes: boolean;
    main: MainModule;
    emission: EmissionModule;
    shape: ShapeModule;
    velocityOverLifetime: VelocityOverLifetimeModule;
    limitVelocityOverLifetime: LimitVelocityOverLifetimeModule;
    inheritVelocity: InheritVelocityModule;
    lifetimeByEmitterSpeed: LifetimeByEmitterSpeedModule;
    forceOverLifetime: ForceOverLifetimeModule;
    colorOverLifetime: ColorOverLifetimeModule;
    colorBySpeed: ColorBySpeedModule;
    sizeOverLifetime: SizeOverLifetimeModule;
    sizeBySpeed: SizeBySpeedModule;
    rotationOverLifetime: RotationOverLifetimeModule;
    rotationBySpeed: RotationBySpeedModule;
    externalForces: ExternalForcesModule;
    noise: NoiseModule;
    collision: CollisionModule;
    trigger: TriggerModule;
    subEmitters: SubEmittersModule;
    textureSheetAnimation: TextureSheetAnimationModule;
    lights: LightsModule;
    trails: TrailModule;
    customData: CustomDataModule;


    AllocateAxisOfRotationAttribute(): void;
    AllocateCustomDataAttribute(stream: ParticleSystemCustomData): void;
    AllocateMeshIndexAttribute(): void;
    Clear(withChildren: boolean): void;
    Clear(): void;
    Emit(position: Vector3, velocity: Vector3, size: number, lifetime: number, color: Color32): void;
    Emit(particle: Particle): void;
    Emit(count: number): void;
    Emit(emitParams: EmitParams, count: number): void;
    GetCustomParticleData(customData: CSArray<Vector4>, streamIndex: ParticleSystemCustomData): number;
    GetParticles(particles: CSArray<Particle>, size: number, offset: number): number;
    GetParticles(particles: CSArray<Particle>, size: number): number;
    GetParticles(particles: CSArray<Particle>): number;
    GetParticles(particles: CSArray<Particle>, size: number, offset: number): number;
    GetParticles(particles: CSArray<Particle>, size: number): number;
    GetParticles(particles: CSArray<Particle>): number;
    GetPlaybackState(): PlaybackState;
    GetTrails(): Trails;
    GetTrails(trailData: unknown): number;
    IsAlive(withChildren: boolean): boolean;
    IsAlive(): boolean;
    Pause(withChildren: boolean): void;
    Pause(): void;
    Play(withChildren: boolean): void;
    Play(): void;
    SetCustomParticleData(customData: CSArray<Vector4>, streamIndex: ParticleSystemCustomData): void;
    SetParticles(particles: CSArray<Particle>, size: number, offset: number): void;
    SetParticles(particles: CSArray<Particle>, size: number): void;
    SetParticles(particles: CSArray<Particle>): void;
    SetParticles(particles: CSArray<Particle>, size: number, offset: number): void;
    SetParticles(particles: CSArray<Particle>, size: number): void;
    SetParticles(particles: CSArray<Particle>): void;
    SetPlaybackState(playbackState: PlaybackState): void;
    SetTrails(trailData: Trails): void;
    Simulate(t: number, withChildren: boolean, restart: boolean, fixedTimeStep: boolean): void;
    Simulate(t: number, withChildren: boolean, restart: boolean): void;
    Simulate(t: number, withChildren: boolean): void;
    Simulate(t: number): void;
    Stop(withChildren: boolean, stopBehavior: ParticleSystemStopBehavior): void;
    Stop(withChildren: boolean): void;
    Stop(): void;
    TriggerSubEmitter(subEmitterIndex: number): void;
    TriggerSubEmitter(subEmitterIndex: number, particle: unknown): void;
    TriggerSubEmitter(subEmitterIndex: number, particles: CSArray<Particle>): void;
}
    
interface MainModule {
    randomizeRotationDirection: number;
    emitterVelocity: Vector3;
    duration: number;
    loop: boolean;
    prewarm: boolean;
    startDelay: MinMaxCurve;
    startDelayMultiplier: number;
    startLifetime: MinMaxCurve;
    startLifetimeMultiplier: number;
    startSpeed: MinMaxCurve;
    startSpeedMultiplier: number;
    startSize3D: boolean;
    startSize: MinMaxCurve;
    startSizeMultiplier: number;
    startSizeX: MinMaxCurve;
    startSizeXMultiplier: number;
    startSizeY: MinMaxCurve;
    startSizeYMultiplier: number;
    startSizeZ: MinMaxCurve;
    startSizeZMultiplier: number;
    startRotation3D: boolean;
    startRotation: MinMaxCurve;
    startRotationMultiplier: number;
    startRotationX: MinMaxCurve;
    startRotationXMultiplier: number;
    startRotationY: MinMaxCurve;
    startRotationYMultiplier: number;
    startRotationZ: MinMaxCurve;
    startRotationZMultiplier: number;
    flipRotation: number;
    startColor: MinMaxGradient;
    gravitySource: ParticleSystemGravitySource;
    gravityModifier: MinMaxCurve;
    gravityModifierMultiplier: number;
    simulationSpace: ParticleSystemSimulationSpace;
    customSimulationSpace: Transform;
    simulationSpeed: number;
    useUnscaledTime: boolean;
    scalingMode: ParticleSystemScalingMode;
    playOnAwake: boolean;
    maxParticles: number;
    emitterVelocityMode: ParticleSystemEmitterVelocityMode;
    stopAction: ParticleSystemStopAction;
    ringBufferMode: ParticleSystemRingBufferMode;
    ringBufferLoopRange: Vector2;
    cullingMode: ParticleSystemCullingMode;


}
    
interface MinMaxCurve {
    curveScalar: number;
    mode: ParticleSystemCurveMode;
    curveMultiplier: number;
    curveMax: AnimationCurve;
    curveMin: AnimationCurve;
    constantMax: number;
    constantMin: number;
    constant: number;
    curve: AnimationCurve;


    Evaluate(time: number): number;
    Evaluate(time: number, lerpFactor: number): number;
}
    
interface MinMaxCurveConstructor {

    new(constant: number): MinMaxCurve;
    new(multiplier: number, curve: AnimationCurve): MinMaxCurve;
    new(multiplier: number, min: AnimationCurve, max: AnimationCurve): MinMaxCurve;
    new(min: number, max: number): MinMaxCurve;

}
declare const MinMaxCurve: MinMaxCurveConstructor;
    
interface MinMaxGradient {
    mode: ParticleSystemGradientMode;
    gradientMax: Gradient;
    gradientMin: Gradient;
    colorMax: Color;
    colorMin: Color;
    color: Color;
    gradient: Gradient;


    Evaluate(time: number): Color;
    Evaluate(time: number, lerpFactor: number): Color;
}
    
interface Gradient {
    colorKeys: CSArray<GradientColorKey>;
    alphaKeys: CSArray<GradientAlphaKey>;
    mode: GradientMode;
    colorSpace: ColorSpace;


    Equals(o: unknown): boolean;
    Equals(other: Gradient): boolean;
    Evaluate(time: number): Color;
    GetHashCode(): number;
    SetKeys(colorKeys: CSArray<GradientColorKey>, alphaKeys: CSArray<GradientAlphaKey>): void;
}
    
interface GradientColorKey {
    color: Color;
    time: number;


}
    
interface GradientColorKeyConstructor {

    new(col: Color, time: number): GradientColorKey;

}
declare const GradientColorKey: GradientColorKeyConstructor;
    
interface GradientAlphaKey {
    alpha: number;
    time: number;


}
    
interface GradientAlphaKeyConstructor {

    new(alpha: number, time: number): GradientAlphaKey;

}
declare const GradientAlphaKey: GradientAlphaKeyConstructor;
    
interface GradientConstructor {

    new(): Gradient;

}
declare const Gradient: GradientConstructor;
    
interface MinMaxGradientConstructor {

    new(color: Color): MinMaxGradient;
    new(gradient: Gradient): MinMaxGradient;
    new(min: Color, max: Color): MinMaxGradient;
    new(min: Gradient, max: Gradient): MinMaxGradient;

}
declare const MinMaxGradient: MinMaxGradientConstructor;
    
interface EmissionModule {
    type: ParticleSystemEmissionType;
    rate: MinMaxCurve;
    rateMultiplier: number;
    enabled: boolean;
    rateOverTime: MinMaxCurve;
    rateOverTimeMultiplier: number;
    rateOverDistance: MinMaxCurve;
    rateOverDistanceMultiplier: number;
    burstCount: number;


    GetBurst(index: number): Burst;
    GetBursts(bursts: CSArray<Burst>): number;
    SetBurst(index: number, burst: Burst): void;
    SetBursts(bursts: CSArray<Burst>): void;
    SetBursts(bursts: CSArray<Burst>, size: number): void;
}
    
interface Burst {
    time: number;
    count: MinMaxCurve;
    minCount: number;
    maxCount: number;
    cycleCount: number;
    repeatInterval: number;
    probability: number;


}
    
interface BurstConstructor {

    new(_time: number, _count: number): Burst;
    new(_time: number, _minCount: number, _maxCount: number): Burst;
    new(_time: number, _minCount: number, _maxCount: number, _cycleCount: number, _repeatInterval: number): Burst;
    new(_time: number, _count: MinMaxCurve): Burst;
    new(_time: number, _count: MinMaxCurve, _cycleCount: number, _repeatInterval: number): Burst;

}
declare const Burst: BurstConstructor;
    
interface ShapeModule {
    box: Vector3;
    meshScale: number;
    randomDirection: boolean;
    enabled: boolean;
    shapeType: ParticleSystemShapeType;
    randomDirectionAmount: number;
    sphericalDirectionAmount: number;
    randomPositionAmount: number;
    alignToDirection: boolean;
    radius: number;
    radiusMode: ParticleSystemShapeMultiModeValue;
    radiusSpread: number;
    radiusSpeed: MinMaxCurve;
    radiusSpeedMultiplier: number;
    radiusThickness: number;
    angle: number;
    length: number;
    boxThickness: Vector3;
    meshShapeType: ParticleSystemMeshShapeType;
    mesh: Mesh;
    meshRenderer: MeshRenderer;
    skinnedMeshRenderer: SkinnedMeshRenderer;
    sprite: Sprite;
    spriteRenderer: SpriteRenderer;
    useMeshMaterialIndex: boolean;
    meshMaterialIndex: number;
    useMeshColors: boolean;
    normalOffset: number;
    meshSpawnMode: ParticleSystemShapeMultiModeValue;
    meshSpawnSpread: number;
    meshSpawnSpeed: MinMaxCurve;
    meshSpawnSpeedMultiplier: number;
    arc: number;
    arcMode: ParticleSystemShapeMultiModeValue;
    arcSpread: number;
    arcSpeed: MinMaxCurve;
    arcSpeedMultiplier: number;
    donutRadius: number;
    position: Vector3;
    rotation: Vector3;
    scale: Vector3;
    texture: Texture2D;
    textureClipChannel: ParticleSystemShapeTextureChannel;
    textureClipThreshold: number;
    textureColorAffectsParticles: boolean;
    textureAlphaAffectsParticles: boolean;
    textureBilinearFiltering: boolean;
    textureUVChannel: number;


}
    
interface SpriteRenderer extends Renderer {
    sprite: Sprite;
    drawMode: SpriteDrawMode;
    size: Vector2;
    adaptiveModeThreshold: number;
    tileMode: SpriteTileMode;
    color: Color;
    maskInteraction: SpriteMaskInteraction;
    flipX: boolean;
    flipY: boolean;
    spriteSortPoint: SpriteSortPoint;


    RegisterSpriteChangeCallback(callback: unknown): void;
    UnregisterSpriteChangeCallback(callback: unknown): void;
}
    
interface SpriteRendererConstructor {

    new(): SpriteRenderer;

}
declare const SpriteRenderer: SpriteRendererConstructor;
    
interface VelocityOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    y: MinMaxCurve;
    z: MinMaxCurve;
    xMultiplier: number;
    yMultiplier: number;
    zMultiplier: number;
    orbitalX: MinMaxCurve;
    orbitalY: MinMaxCurve;
    orbitalZ: MinMaxCurve;
    orbitalXMultiplier: number;
    orbitalYMultiplier: number;
    orbitalZMultiplier: number;
    orbitalOffsetX: MinMaxCurve;
    orbitalOffsetY: MinMaxCurve;
    orbitalOffsetZ: MinMaxCurve;
    orbitalOffsetXMultiplier: number;
    orbitalOffsetYMultiplier: number;
    orbitalOffsetZMultiplier: number;
    radial: MinMaxCurve;
    radialMultiplier: number;
    speedModifier: MinMaxCurve;
    speedModifierMultiplier: number;
    space: ParticleSystemSimulationSpace;


}
    
interface LimitVelocityOverLifetimeModule {
    enabled: boolean;
    limitX: MinMaxCurve;
    limitXMultiplier: number;
    limitY: MinMaxCurve;
    limitYMultiplier: number;
    limitZ: MinMaxCurve;
    limitZMultiplier: number;
    limit: MinMaxCurve;
    limitMultiplier: number;
    dampen: number;
    separateAxes: boolean;
    space: ParticleSystemSimulationSpace;
    drag: MinMaxCurve;
    dragMultiplier: number;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;


}
    
interface InheritVelocityModule {
    enabled: boolean;
    mode: ParticleSystemInheritVelocityMode;
    curve: MinMaxCurve;
    curveMultiplier: number;


}
    
interface LifetimeByEmitterSpeedModule {
    enabled: boolean;
    curve: MinMaxCurve;
    curveMultiplier: number;
    range: Vector2;


}
    
interface ForceOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    y: MinMaxCurve;
    z: MinMaxCurve;
    xMultiplier: number;
    yMultiplier: number;
    zMultiplier: number;
    space: ParticleSystemSimulationSpace;
    randomized: boolean;


}
    
interface ColorOverLifetimeModule {
    enabled: boolean;
    color: MinMaxGradient;


}
    
interface ColorBySpeedModule {
    enabled: boolean;
    color: MinMaxGradient;
    range: Vector2;


}
    
interface SizeOverLifetimeModule {
    enabled: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;


}
    
interface SizeBySpeedModule {
    enabled: boolean;
    size: MinMaxCurve;
    sizeMultiplier: number;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;
    range: Vector2;


}
    
interface RotationOverLifetimeModule {
    enabled: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;


}
    
interface RotationBySpeedModule {
    enabled: boolean;
    x: MinMaxCurve;
    xMultiplier: number;
    y: MinMaxCurve;
    yMultiplier: number;
    z: MinMaxCurve;
    zMultiplier: number;
    separateAxes: boolean;
    range: Vector2;


}
    
interface ExternalForcesModule {
    enabled: boolean;
    multiplier: number;
    multiplierCurve: MinMaxCurve;
    influenceFilter: ParticleSystemGameObjectFilter;
    influenceMask: LayerMask;
    influenceCount: number;


    AddInfluence(field: ParticleSystemForceField): void;
    GetInfluence(index: number): ParticleSystemForceField;
    IsAffectedBy(field: ParticleSystemForceField): boolean;
    RemoveAllInfluences(): void;
    RemoveInfluence(index: number): void;
    RemoveInfluence(field: ParticleSystemForceField): void;
    SetInfluence(index: number, field: ParticleSystemForceField): void;
}
    
interface ParticleSystemForceField extends Behaviour {
    shape: ParticleSystemForceFieldShape;
    startRange: number;
    endRange: number;
    length: number;
    gravityFocus: number;
    rotationRandomness: Vector2;
    multiplyDragByParticleSize: boolean;
    multiplyDragByParticleVelocity: boolean;
    vectorField: Texture3D;
    directionX: MinMaxCurve;
    directionY: MinMaxCurve;
    directionZ: MinMaxCurve;
    gravity: MinMaxCurve;
    rotationSpeed: MinMaxCurve;
    rotationAttraction: MinMaxCurve;
    drag: MinMaxCurve;
    vectorFieldSpeed: MinMaxCurve;
    vectorFieldAttraction: MinMaxCurve;


}
    
interface Texture3D extends Texture {
    depth: number;
    format: TextureFormat;
    isReadable: boolean;


    Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void;
    Apply(updateMipmaps: boolean): void;
    Apply(): void;
    GetPixel(x: number, y: number, z: number): Color;
    GetPixel(x: number, y: number, z: number, mipLevel: number): Color;
    GetPixelBilinear(u: number, v: number, w: number): Color;
    GetPixelBilinear(u: number, v: number, w: number, mipLevel: number): Color;
    GetPixelData<T>(mipLevel: number): CSArray<T>;
    GetPixels(miplevel: number): CSArray<Color>;
    GetPixels(): CSArray<Color>;
    GetPixels32(miplevel: number): CSArray<Color32>;
    GetPixels32(): CSArray<Color32>;
    SetPixel(x: number, y: number, z: number, color: Color): void;
    SetPixel(x: number, y: number, z: number, color: Color, mipLevel: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixelData<T>(data: CSArray<T>, mipLevel: number, sourceDataStartIndex: number): void;
    SetPixels(colors: CSArray<Color>, miplevel: number): void;
    SetPixels(colors: CSArray<Color>): void;
    SetPixels32(colors: CSArray<Color32>, miplevel: number): void;
    SetPixels32(colors: CSArray<Color32>): void;
    UpdateExternalTexture(nativeTex: unknown): void;
}
    
interface Texture3DConstructor {

    new(width: number, height: number, depth: number, format: DefaultFormat, flags: TextureCreationFlags): Texture3D;
    new(width: number, height: number, depth: number, format: DefaultFormat, flags: TextureCreationFlags, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, format: GraphicsFormat, flags: TextureCreationFlags): Texture3D;
    new(width: number, height: number, depth: number, format: GraphicsFormat, flags: TextureCreationFlags, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number, nativeTex: unknown): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipCount: number, nativeTex: unknown, createUninitialized: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean, createUninitialized: boolean): Texture3D;
    new(width: number, height: number, depth: number, textureFormat: TextureFormat, mipChain: boolean, nativeTex: unknown): Texture3D;

    CreateExternalTexture(width: number, height: number, depth: number, format: TextureFormat, mipChain: boolean, nativeTex: unknown): Texture3D;
}
declare const Texture3D: Texture3DConstructor;
    
interface ParticleSystemForceFieldConstructor {

    new(): ParticleSystemForceField;

    FindAll(): CSArray<ParticleSystemForceField>;
}
declare const ParticleSystemForceField: ParticleSystemForceFieldConstructor;
    
interface NoiseModule {
    enabled: boolean;
    separateAxes: boolean;
    strength: MinMaxCurve;
    strengthMultiplier: number;
    strengthX: MinMaxCurve;
    strengthXMultiplier: number;
    strengthY: MinMaxCurve;
    strengthYMultiplier: number;
    strengthZ: MinMaxCurve;
    strengthZMultiplier: number;
    frequency: number;
    damping: boolean;
    octaveCount: number;
    octaveMultiplier: number;
    octaveScale: number;
    quality: ParticleSystemNoiseQuality;
    scrollSpeed: MinMaxCurve;
    scrollSpeedMultiplier: number;
    remapEnabled: boolean;
    remap: MinMaxCurve;
    remapMultiplier: number;
    remapX: MinMaxCurve;
    remapXMultiplier: number;
    remapY: MinMaxCurve;
    remapYMultiplier: number;
    remapZ: MinMaxCurve;
    remapZMultiplier: number;
    positionAmount: MinMaxCurve;
    rotationAmount: MinMaxCurve;
    sizeAmount: MinMaxCurve;


}
    
interface CollisionModule {
    maxPlaneCount: number;
    enabled: boolean;
    type: ParticleSystemCollisionType;
    mode: ParticleSystemCollisionMode;
    dampen: MinMaxCurve;
    dampenMultiplier: number;
    bounce: MinMaxCurve;
    bounceMultiplier: number;
    lifetimeLoss: MinMaxCurve;
    lifetimeLossMultiplier: number;
    minKillSpeed: number;
    maxKillSpeed: number;
    collidesWith: LayerMask;
    enableDynamicColliders: boolean;
    maxCollisionShapes: number;
    quality: ParticleSystemCollisionQuality;
    voxelSize: number;
    radiusScale: number;
    sendCollisionMessages: boolean;
    colliderForce: number;
    multiplyColliderForceByCollisionAngle: boolean;
    multiplyColliderForceByParticleSpeed: boolean;
    multiplyColliderForceByParticleSize: boolean;
    planeCount: number;
    enableInteriorCollisions: boolean;


    AddPlane(transform: Transform): void;
    GetPlane(index: number): Transform;
    RemovePlane(index: number): void;
    RemovePlane(transform: Transform): void;
    SetPlane(index: number, transform: Transform): void;
}
    
interface TriggerModule {
    maxColliderCount: number;
    enabled: boolean;
    inside: ParticleSystemOverlapAction;
    outside: ParticleSystemOverlapAction;
    enter: ParticleSystemOverlapAction;
    exit: ParticleSystemOverlapAction;
    colliderQueryMode: ParticleSystemColliderQueryMode;
    radiusScale: number;
    colliderCount: number;


    AddCollider(collider: Component): void;
    GetCollider(index: number): Component;
    RemoveCollider(index: number): void;
    RemoveCollider(collider: Component): void;
    SetCollider(index: number, collider: Component): void;
}
    
interface SubEmittersModule {
    birth0: ParticleSystem;
    birth1: ParticleSystem;
    collision0: ParticleSystem;
    collision1: ParticleSystem;
    death0: ParticleSystem;
    death1: ParticleSystem;
    enabled: boolean;
    subEmittersCount: number;


    AddSubEmitter(subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties, emitProbability: number): void;
    AddSubEmitter(subEmitter: ParticleSystem, type: ParticleSystemSubEmitterType, properties: ParticleSystemSubEmitterProperties): void;
    GetSubEmitterEmitProbability(index: number): number;
    GetSubEmitterProperties(index: number): ParticleSystemSubEmitterProperties;
    GetSubEmitterSystem(index: number): ParticleSystem;
    GetSubEmitterType(index: number): ParticleSystemSubEmitterType;
    RemoveSubEmitter(index: number): void;
    RemoveSubEmitter(subEmitter: ParticleSystem): void;
    SetSubEmitterEmitProbability(index: number, emitProbability: number): void;
    SetSubEmitterProperties(index: number, properties: ParticleSystemSubEmitterProperties): void;
    SetSubEmitterSystem(index: number, subEmitter: ParticleSystem): void;
    SetSubEmitterType(index: number, type: ParticleSystemSubEmitterType): void;
}
    
interface TextureSheetAnimationModule {
    flipU: number;
    flipV: number;
    useRandomRow: boolean;
    enabled: boolean;
    mode: ParticleSystemAnimationMode;
    timeMode: ParticleSystemAnimationTimeMode;
    fps: number;
    numTilesX: number;
    numTilesY: number;
    animation: ParticleSystemAnimationType;
    rowMode: ParticleSystemAnimationRowMode;
    frameOverTime: MinMaxCurve;
    frameOverTimeMultiplier: number;
    startFrame: MinMaxCurve;
    startFrameMultiplier: number;
    cycleCount: number;
    rowIndex: number;
    uvChannelMask: UVChannelFlags;
    spriteCount: number;
    speedRange: Vector2;


    AddSprite(sprite: Sprite): void;
    GetSprite(index: number): Sprite;
    RemoveSprite(index: number): void;
    SetSprite(index: number, sprite: Sprite): void;
}
    
interface LightsModule {
    enabled: boolean;
    ratio: number;
    useRandomDistribution: boolean;
    light: Light;
    useParticleColor: boolean;
    sizeAffectsRange: boolean;
    alphaAffectsIntensity: boolean;
    range: MinMaxCurve;
    rangeMultiplier: number;
    intensity: MinMaxCurve;
    intensityMultiplier: number;
    maxLights: number;


}
    
interface TrailModule {
    enabled: boolean;
    mode: ParticleSystemTrailMode;
    ratio: number;
    lifetime: MinMaxCurve;
    lifetimeMultiplier: number;
    minVertexDistance: number;
    textureMode: ParticleSystemTrailTextureMode;
    textureScale: Vector2;
    worldSpace: boolean;
    dieWithParticles: boolean;
    sizeAffectsWidth: boolean;
    sizeAffectsLifetime: boolean;
    inheritParticleColor: boolean;
    colorOverLifetime: MinMaxGradient;
    widthOverTrail: MinMaxCurve;
    widthOverTrailMultiplier: number;
    colorOverTrail: MinMaxGradient;
    generateLightingData: boolean;
    ribbonCount: number;
    shadowBias: number;
    splitSubEmitterRibbons: boolean;
    attachRibbonsToTransform: boolean;


}
    
interface CustomDataModule {
    enabled: boolean;


    GetColor(stream: ParticleSystemCustomData): MinMaxGradient;
    GetMode(stream: ParticleSystemCustomData): ParticleSystemCustomDataMode;
    GetVector(stream: ParticleSystemCustomData, component: number): MinMaxCurve;
    GetVectorComponentCount(stream: ParticleSystemCustomData): number;
    SetColor(stream: ParticleSystemCustomData, gradient: MinMaxGradient): void;
    SetMode(stream: ParticleSystemCustomData, mode: ParticleSystemCustomDataMode): void;
    SetVector(stream: ParticleSystemCustomData, component: number, curve: MinMaxCurve): void;
    SetVectorComponentCount(stream: ParticleSystemCustomData, count: number): void;
}
    
interface Particle {
    lifetime: number;
    randomValue: number;
    size: number;
    color: Color32;
    position: Vector3;
    velocity: Vector3;
    animatedVelocity: Vector3;
    totalVelocity: Vector3;
    remainingLifetime: number;
    startLifetime: number;
    startColor: Color32;
    randomSeed: number;
    axisOfRotation: Vector3;
    startSize: number;
    startSize3D: Vector3;
    rotation: number;
    rotation3D: Vector3;
    angularVelocity: number;
    angularVelocity3D: Vector3;


    GetCurrentColor(system: ParticleSystem): Color32;
    GetCurrentSize(system: ParticleSystem): number;
    GetCurrentSize3D(system: ParticleSystem): Vector3;
    GetMeshIndex(system: ParticleSystem): number;
    SetMeshIndex(index: number): void;
}
    
interface EmitParams {
    particle: Particle;
    position: Vector3;
    applyShapeToPosition: boolean;
    velocity: Vector3;
    startLifetime: number;
    startSize: number;
    startSize3D: Vector3;
    axisOfRotation: Vector3;
    rotation: number;
    rotation3D: Vector3;
    angularVelocity: number;
    angularVelocity3D: Vector3;
    startColor: Color32;
    randomSeed: number;
    meshIndex: number;


    ResetAngularVelocity(): void;
    ResetAxisOfRotation(): void;
    ResetMeshIndex(): void;
    ResetPosition(): void;
    ResetRandomSeed(): void;
    ResetRotation(): void;
    ResetStartColor(): void;
    ResetStartLifetime(): void;
    ResetStartSize(): void;
    ResetVelocity(): void;
}
    
interface PlaybackState {


}
    
interface Trails {
    capacity: number;


}
    
interface ParticleSystemConstructor {

    new(): ParticleSystem;

    ResetPreMappedBufferMemory(): void;
    SetMaximumPreMappedBufferCounts(vertexBuffersCount: number, indexBuffersCount: number): void;
}
declare const ParticleSystem: ParticleSystemConstructor;
    
interface AccessoryBuilderConstructor {

    new(): AccessoryBuilder;

}
declare const AccessoryBuilder: AccessoryBuilderConstructor;
    
interface AvatarMask extends Object {
    humanoidBodyPartCount: number;
    transformCount: number;


    AddTransformPath(transform: Transform): void;
    AddTransformPath(transform: Transform, recursive: boolean): void;
    GetHumanoidBodyPartActive(index: AvatarMaskBodyPart): boolean;
    GetTransformActive(index: number): boolean;
    GetTransformPath(index: number): string;
    RemoveTransformPath(transform: Transform): void;
    RemoveTransformPath(transform: Transform, recursive: boolean): void;
    SetHumanoidBodyPartActive(index: AvatarMaskBodyPart, value: boolean): void;
    SetTransformActive(index: number, value: boolean): void;
    SetTransformPath(index: number, path: string): void;
}
    
interface AvatarMaskConstructor {

    new(): AvatarMask;

}
declare const AvatarMask: AvatarMaskConstructor;
    
interface DebugUtil extends Debug {


}
    
interface DebugUtilConstructor {

    new(): DebugUtil;

    DrawArc(startAngle: number, endAngle: number, position: Vector3, orientation: Quaternion, radius: number, color: Color, drawChord: boolean, drawSector: boolean, arcSegments: number, durationSec: number): void;
    DrawBox(position: Vector3, orientation: Quaternion, halfSize: Vector3, color: Color, durationSec: number): void;
    DrawCircle(position: Vector3, rotation: Quaternion, radius: number, segments: number, color: Color, durationSec: number): void;
    DrawQuad(pointA: Vector3, pointB: Vector3, pointC: Vector3, pointD: Vector3, color: Color, durationSec: number): void;
    DrawRect(origin: Vector3, orientation: Quaternion, extent: Vector2, color: Color, durationSec: number): void;
    DrawSingleLine(startPosition: Vector3, endPosition: Vector3, color: Color, durationSec: number): void;
    DrawSphere(position: Vector3, orientation: Quaternion, radius: number, color: Color, segments: number, durationSec: number): void;
    TogglePauseEngine(): void;
}
declare const DebugUtil: DebugUtilConstructor;
    
interface CollisionWatcher extends MonoBehaviour {


}
    
interface CollisionWatcherConstructor {

    new(): CollisionWatcher;

}
declare const CollisionWatcher: CollisionWatcherConstructor;
    
interface TriggerWatcher extends MonoBehaviour {


}
    
interface TriggerWatcherConstructor {

    new(): TriggerWatcher;

}
declare const TriggerWatcher: TriggerWatcherConstructor;
    
interface PhysicsExt {


}
    
interface SphereCastReturnData {
    HitCount: number;
    RaycastHits: CSArray<RaycastHit>;


}
    
interface SphereCastReturnDataConstructor {

    new(hitCount: number, raycastHits: CSArray<RaycastHit>): SphereCastReturnData;

}
declare const SphereCastReturnData: SphereCastReturnDataConstructor;
    
interface PhysicsExtConstructor {

    new(): PhysicsExt;

    EasySphereCast(start: Vector3, direction: Vector3, radius: number, distance: number, layerMask: number): SphereCastReturnData;
}
declare const PhysicsExt: PhysicsExtConstructor;
    
interface ServerConsole extends MonoBehaviour {
    RemoteLogging: boolean;


}
    
interface ServerConsoleConstructor {

    new(): ServerConsole;

}
declare const ServerConsole: ServerConsoleConstructor;
    
interface RawImage extends MaskableGraphic {
    mainTexture: Texture;
    texture: Texture;
    uvRect: Rect;


    SetNativeSize(): void;
}
    
interface Application {


}
    
interface LogCallback {


    BeginInvoke(condition: string, stackTrace: string, type: LogType, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(condition: string, stackTrace: string, type: LogType): void;
}
    
interface LogCallbackConstructor {

    new(object: unknown, method: unknown): LogCallback;

}
declare const LogCallback: LogCallbackConstructor;
    
interface AdvertisingIdentifierCallback {


    BeginInvoke(advertisingId: string, trackingEnabled: boolean, errorMsg: string, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(advertisingId: string, trackingEnabled: boolean, errorMsg: string): void;
}
    
interface AdvertisingIdentifierCallbackConstructor {

    new(object: unknown, method: unknown): AdvertisingIdentifierCallback;

}
declare const AdvertisingIdentifierCallback: AdvertisingIdentifierCallbackConstructor;
    
interface ApplicationConstructor {
    isLoadingLevel: boolean;
    streamedBytes: number;
    webSecurityEnabled: boolean;
    isPlaying: boolean;
    isFocused: boolean;
    buildGUID: string;
    runInBackground: boolean;
    isBatchMode: boolean;
    dataPath: string;
    streamingAssetsPath: string;
    persistentDataPath: string;
    temporaryCachePath: string;
    absoluteURL: string;
    unityVersion: string;
    version: string;
    installerName: string;
    identifier: string;
    installMode: ApplicationInstallMode;
    sandboxType: ApplicationSandboxType;
    productName: string;
    companyName: string;
    cloudProjectId: string;
    targetFrameRate: number;
    stackTraceLogType: StackTraceLogType;
    consoleLogPath: string;
    backgroundLoadingPriority: ThreadPriority;
    genuine: boolean;
    genuineCheckAvailable: boolean;
    isShowingSplashScreen: boolean;
    platform: RuntimePlatform;
    isMobilePlatform: boolean;
    isConsolePlatform: boolean;
    systemLanguage: SystemLanguage;
    internetReachability: NetworkReachability;
    isPlayer: boolean;
    exitCancellationToken: unknown;
    levelCount: number;
    loadedLevel: number;
    loadedLevelName: string;
    isEditor: boolean;

    new(): Application;

    CancelQuit(): void;
    CanStreamedLevelBeLoaded(levelIndex: number): boolean;
    CanStreamedLevelBeLoaded(levelName: string): boolean;
    CaptureScreenshot(filename: string, superSize: number): void;
    CaptureScreenshot(filename: string): void;
    DontDestroyOnLoad(o: Object): void;
    ExternalCall(functionName: string, args: CSArray<unknown>): void;
    ExternalEval(script: string): void;
    ForceCrash(mode: number): void;
    GetBuildTags(): CSArray<string>;
    GetStackTraceLogType(logType: LogType): StackTraceLogType;
    GetStreamProgressForLevel(levelIndex: number): number;
    GetStreamProgressForLevel(levelName: string): number;
    HasProLicense(): boolean;
    HasUserAuthorization(mode: UserAuthorization): boolean;
    IsPlaying(obj: Object): boolean;
    LoadLevel(index: number): void;
    LoadLevel(name: string): void;
    LoadLevelAdditive(index: number): void;
    LoadLevelAdditive(name: string): void;
    LoadLevelAdditiveAsync(index: number): AsyncOperation;
    LoadLevelAdditiveAsync(levelName: string): AsyncOperation;
    LoadLevelAsync(index: number): AsyncOperation;
    LoadLevelAsync(levelName: string): AsyncOperation;
    OpenURL(url: string): void;
    Quit(exitCode: number): void;
    Quit(): void;
    RegisterLogCallback(handler: LogCallback): void;
    RegisterLogCallbackThreaded(handler: LogCallback): void;
    RequestAdvertisingIdentifierAsync(delegateMethod: AdvertisingIdentifierCallback): boolean;
    RequestUserAuthorization(mode: UserAuthorization): AsyncOperation;
    SetBuildTags(buildTags: CSArray<string>): void;
    SetStackTraceLogType(logType: LogType, stackTraceType: StackTraceLogType): void;
    Unload(): void;
    UnloadLevel(index: number): boolean;
    UnloadLevel(scenePath: string): boolean;
}
declare const Application: ApplicationConstructor;
    
interface ClientNetworkConnector extends MonoBehaviour {
    expectingDisconnect: boolean;


}
    
interface ClientNetworkConnectorConstructor {

    new(): ClientNetworkConnector;

}
declare const ClientNetworkConnector: ClientNetworkConnectorConstructor;
    
interface ParticleSystemRenderer extends Renderer {
    alignment: ParticleSystemRenderSpace;
    renderMode: ParticleSystemRenderMode;
    meshDistribution: ParticleSystemMeshDistribution;
    sortMode: ParticleSystemSortMode;
    lengthScale: number;
    velocityScale: number;
    cameraVelocityScale: number;
    normalDirection: number;
    shadowBias: number;
    sortingFudge: number;
    minParticleSize: number;
    maxParticleSize: number;
    pivot: Vector3;
    flip: Vector3;
    maskInteraction: SpriteMaskInteraction;
    trailMaterial: Material;
    enableGPUInstancing: boolean;
    allowRoll: boolean;
    freeformStretching: boolean;
    rotateWithStretchDirection: boolean;
    mesh: Mesh;
    meshCount: number;
    activeVertexStreamsCount: number;
    activeTrailVertexStreamsCount: number;
    supportsMeshInstancing: boolean;


    AreVertexStreamsEnabled(streams: ParticleSystemVertexStreams): boolean;
    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    BakeMesh(mesh: Mesh, options: ParticleSystemBakeMeshOptions): void;
    BakeMesh(mesh: Mesh, camera: Camera, options: ParticleSystemBakeMeshOptions): void;
    BakeTexture(verticesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    BakeTexture(verticesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    BakeTexture(verticesTexture: unknown, indicesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    BakeTexture(verticesTexture: unknown, indicesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    BakeTrailsMesh(mesh: Mesh, useTransform: boolean): void;
    BakeTrailsMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    BakeTrailsMesh(mesh: Mesh, options: ParticleSystemBakeMeshOptions): void;
    BakeTrailsMesh(mesh: Mesh, camera: Camera, options: ParticleSystemBakeMeshOptions): void;
    BakeTrailsTexture(verticesTexture: unknown, indicesTexture: unknown, options: ParticleSystemBakeTextureOptions): number;
    BakeTrailsTexture(verticesTexture: unknown, indicesTexture: unknown, camera: Camera, options: ParticleSystemBakeTextureOptions): number;
    DisableVertexStreams(streams: ParticleSystemVertexStreams): void;
    EnableVertexStreams(streams: ParticleSystemVertexStreams): void;
    GetActiveTrailVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    GetActiveVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    GetEnabledVertexStreams(streams: ParticleSystemVertexStreams): ParticleSystemVertexStreams;
    GetMeshes(meshes: CSArray<Mesh>): number;
    GetMeshWeightings(weightings: CSArray<number>): number;
    SetActiveTrailVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    SetActiveVertexStreams(streams: CSArray<ParticleSystemVertexStream>): void;
    SetMeshes(meshes: CSArray<Mesh>, size: number): void;
    SetMeshes(meshes: CSArray<Mesh>): void;
    SetMeshWeightings(weightings: CSArray<number>, size: number): void;
    SetMeshWeightings(weightings: CSArray<number>): void;
}
    
interface ParticleSystemRendererConstructor {

    new(): ParticleSystemRenderer;

}
declare const ParticleSystemRenderer: ParticleSystemRendererConstructor;
    
interface Profiler {


}
    
interface ProfilerCategory {
    Name: string;
    Color: Color32;


    ToString(): string;
}
    
interface ProfilerCategoryConstructor {
    Render: ProfilerCategory;
    Scripts: ProfilerCategory;
    Gui: ProfilerCategory;
    Physics: ProfilerCategory;
    Physics2D: ProfilerCategory;
    Animation: ProfilerCategory;
    Ai: ProfilerCategory;
    Audio: ProfilerCategory;
    Video: ProfilerCategory;
    Particles: ProfilerCategory;
    Lighting: ProfilerCategory;
    Network: ProfilerCategory;
    Loading: ProfilerCategory;
    Vr: ProfilerCategory;
    Input: ProfilerCategory;
    Memory: ProfilerCategory;
    VirtualTexturing: ProfilerCategory;
    FileIO: ProfilerCategory;
    Internal: ProfilerCategory;

    new(categoryName: string): ProfilerCategory;
    new(categoryName: string, color: ProfilerCategoryColor): ProfilerCategory;

}
declare const ProfilerCategory: ProfilerCategoryConstructor;
    
interface ProfilerConstructor {
    supported: boolean;
    logFile: string;
    enableBinaryLog: boolean;
    maxUsedMemory: number;
    enabled: boolean;
    enableAllocationCallstacks: boolean;
    areaCount: number;
    maxNumberOfSamplesPerFrame: number;
    usedHeapSize: number;
    usedHeapSizeLong: number;


    AddFramesFromFile(file: string): void;
    BeginSample(name: string): void;
    BeginSample(name: string, targetObject: Object): void;
    BeginThreadProfiling(threadGroupName: string, threadName: string): void;
    EmitFrameMetaData(id: unknown, tag: number, data: unknown): void;
    EmitFrameMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitFrameMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitSessionMetaData(id: unknown, tag: number, data: unknown): void;
    EmitSessionMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EmitSessionMetaData<T>(id: unknown, tag: number, data: CSArray<T>): void;
    EndSample(): void;
    EndThreadProfiling(): void;
    GetAllCategories(categories: CSArray<ProfilerCategory>): void;
    GetAllCategories(categories: CSArray<ProfilerCategory>): void;
    GetAllocatedMemoryForGraphicsDriver(): number;
    GetAreaEnabled(area: ProfilerArea): boolean;
    GetCategoriesCount(): number;
    GetMonoHeapSize(): number;
    GetMonoHeapSizeLong(): number;
    GetMonoUsedSize(): number;
    GetMonoUsedSizeLong(): number;
    GetRuntimeMemorySize(o: Object): number;
    GetRuntimeMemorySizeLong(o: Object): number;
    GetTempAllocatorSize(): number;
    GetTotalAllocatedMemory(): number;
    GetTotalAllocatedMemoryLong(): number;
    GetTotalFragmentationInfo(stats: CSArray<number>): number;
    GetTotalReservedMemory(): number;
    GetTotalReservedMemoryLong(): number;
    GetTotalUnusedReservedMemory(): number;
    GetTotalUnusedReservedMemoryLong(): number;
    IsCategoryEnabled(category: ProfilerCategory): boolean;
    SetAreaEnabled(area: ProfilerArea, enabled: boolean): void;
    SetCategoryEnabled(category: ProfilerCategory, enabled: boolean): void;
    SetTempAllocatorRequestedSize(size: number): boolean;
}
declare const Profiler: ProfilerConstructor;
    
interface ICancelHandler extends IEventSystemHandler {


    OnCancel(eventData: BaseEventData): void;
}
    
interface IBeginDragHandler extends IEventSystemHandler {


    OnBeginDrag(eventData: PointerEventData): void;
}
    
interface IDragHandler extends IEventSystemHandler {


    OnDrag(eventData: PointerEventData): void;
}
    
interface IEndDragHandler extends IEventSystemHandler {


    OnEndDrag(eventData: PointerEventData): void;
}
    
interface IScrollHandler extends IEventSystemHandler {


    OnScroll(eventData: PointerEventData): void;
}
    
interface IUpdateSelectedHandler extends IEventSystemHandler {


    OnUpdateSelected(eventData: BaseEventData): void;
}
    
interface TMP_InputField extends Selectable, ISubmitHandler, IPointerClickHandler, ICancelHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, IUpdateSelectedHandler, ILayoutElement {
    isAlert: boolean;
    shouldActivateOnSelect: boolean;
    shouldHideMobileInput: boolean;
    shouldHideSoftKeyboard: boolean;
    text: string;
    isFocused: boolean;
    caretBlinkRate: number;
    caretWidth: number;
    textViewport: RectTransform;
    textComponent: TMP_Text;
    placeholder: Graphic;
    verticalScrollbar: Scrollbar;
    scrollSensitivity: number;
    caretColor: Color;
    customCaretColor: boolean;
    selectionColor: Color;
    onEndEdit: SubmitEvent;
    onSubmit: SubmitEvent;
    onSelect: SelectionEvent;
    onDeselect: SelectionEvent;
    onTextSelection: TextSelectionEvent;
    onEndTextSelection: TextSelectionEvent;
    onValueChanged: OnChangeEvent;
    onTouchScreenKeyboardStatusChanged: TouchScreenKeyboardEvent;
    onValidateInput: OnValidateInput;
    characterLimit: number;
    pointSize: number;
    fontAsset: TMP_FontAsset;
    onFocusSelectAll: boolean;
    resetOnDeActivation: boolean;
    keepTextSelectionVisible: boolean;
    restoreOriginalTextOnEscape: boolean;
    isRichTextEditingAllowed: boolean;
    contentType: ContentType;
    lineType: LineType;
    lineLimit: number;
    inputType: InputType;
    touchScreenKeyboard: TouchScreenKeyboard;
    keyboardType: TouchScreenKeyboardType;
    characterValidation: CharacterValidation;
    inputValidator: TMP_InputValidator;
    readOnly: boolean;
    richText: boolean;
    multiLine: boolean;
    asteriskChar: string;
    wasCanceled: boolean;
    caretPosition: number;
    selectionAnchorPosition: number;
    selectionFocusPosition: number;
    stringPosition: number;
    selectionStringAnchorPosition: number;
    selectionStringFocusPosition: number;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    ActivateInputField(): void;
    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    DeactivateInputField(clearSelection: boolean): void;
    ForceLabelUpdate(): void;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    MoveTextEnd(shift: boolean): void;
    MoveTextStart(shift: boolean): void;
    MoveToEndOfLine(shift: boolean, ctrl: boolean): void;
    MoveToStartOfLine(shift: boolean, ctrl: boolean): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnCancel(eventData: BaseEventData): void;
    OnControlClick(): void;
    OnDeselect(eventData: BaseEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnScroll(eventData: PointerEventData): void;
    OnSelect(eventData: BaseEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    OnUpdateSelected(eventData: BaseEventData): void;
    ProcessEvent(e: Event): void;
    Rebuild(update: CanvasUpdate): void;
    ReleaseSelection(): void;
    SetGlobalFontAsset(fontAsset: TMP_FontAsset): void;
    SetGlobalPointSize(pointSize: number): void;
    SetTextWithoutNotify(input: string): void;
}
    
interface IInitializePotentialDragHandler extends IEventSystemHandler {


    OnInitializePotentialDrag(eventData: PointerEventData): void;
}
    
interface Scrollbar extends Selectable, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, ICanvasElement {
    handleRect: RectTransform;
    direction: Direction;
    value: number;
    size: number;
    numberOfSteps: number;
    onValueChanged: ScrollEvent;


    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    OnPointerUp(eventData: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetDirection(direction: Direction, includeRectLayouts: boolean): void;
    SetValueWithoutNotify(input: number): void;
}
    
interface ScrollEvent {


}
    
interface ScrollEventConstructor {

    new(): ScrollEvent;

}
declare const ScrollEvent: ScrollEventConstructor;
    
interface SubmitEvent {


}
    
interface SubmitEventConstructor {

    new(): SubmitEvent;

}
declare const SubmitEvent: SubmitEventConstructor;
    
interface SelectionEvent {


}
    
interface SelectionEventConstructor {

    new(): SelectionEvent;

}
declare const SelectionEvent: SelectionEventConstructor;
    
interface TextSelectionEvent {


}
    
interface TextSelectionEventConstructor {

    new(): TextSelectionEvent;

}
declare const TextSelectionEvent: TextSelectionEventConstructor;
    
interface OnChangeEvent {


}
    
interface OnChangeEventConstructor {

    new(): OnChangeEvent;

}
declare const OnChangeEvent: OnChangeEventConstructor;
    
interface TouchScreenKeyboardEvent {


}
    
interface TouchScreenKeyboardEventConstructor {

    new(): TouchScreenKeyboardEvent;

}
declare const TouchScreenKeyboardEvent: TouchScreenKeyboardEventConstructor;
    
interface OnValidateInput {


    BeginInvoke(text: string, charIndex: number, addedChar: string, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): string;
    Invoke(text: string, charIndex: number, addedChar: string): string;
}
    
interface OnValidateInputConstructor {

    new(object: unknown, method: unknown): OnValidateInput;

}
declare const OnValidateInput: OnValidateInputConstructor;
    
interface TouchScreenKeyboard {
    text: string;
    active: boolean;
    done: boolean;
    wasCanceled: boolean;
    status: Status;
    characterLimit: number;
    canGetSelection: boolean;
    canSetSelection: boolean;
    selection: RangeInt;
    type: TouchScreenKeyboardType;
    targetDisplay: number;


}
    
interface RangeInt {
    start: number;
    length: number;
    end: number;


}
    
interface RangeIntConstructor {

    new(start: number, length: number): RangeInt;

}
declare const RangeInt: RangeIntConstructor;
    
interface TouchScreenKeyboardConstructor {
    isSupported: boolean;
    isInPlaceEditingAllowed: boolean;
    hideInput: boolean;
    area: Rect;
    visible: boolean;

    new(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string, characterLimit: number): TouchScreenKeyboard;

    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string, characterLimit: number): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean, textPlaceholder: string): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean, alert: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean, secure: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean, multiline: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType, autocorrection: boolean): TouchScreenKeyboard;
    Open(text: string, keyboardType: TouchScreenKeyboardType): TouchScreenKeyboard;
    Open(text: string): TouchScreenKeyboard;
}
declare const TouchScreenKeyboard: TouchScreenKeyboardConstructor;
    
interface TMP_InputValidator extends ScriptableObject {


    Validate(text: CSArray<string>, pos: unknown, ch: string): string;
}
    
interface Event {
    rawType: EventType;
    mousePosition: Vector2;
    delta: Vector2;
    pointerType: PointerType;
    button: number;
    modifiers: EventModifiers;
    pressure: number;
    twist: number;
    tilt: Vector2;
    penStatus: PenStatus;
    clickCount: number;
    character: string;
    keyCode: KeyCode;
    displayIndex: number;
    type: EventType;
    commandName: string;
    mouseRay: Ray;
    shift: boolean;
    control: boolean;
    alt: boolean;
    command: boolean;
    capsLock: boolean;
    numeric: boolean;
    functionKey: boolean;
    isKey: boolean;
    isMouse: boolean;
    isScrollWheel: boolean;


    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GetTypeForControl(controlID: number): EventType;
    ToString(): string;
    Use(): void;
}
    
interface EventConstructor {
    current: Event;

    new(): Event;
    new(displayIndex: number): Event;
    new(other: Event): Event;

    GetEventCount(): number;
    KeyboardEvent(key: string): Event;
    PopEvent(outEvent: Event): boolean;
}
declare const Event: EventConstructor;
    
interface Slider extends Selectable, IInitializePotentialDragHandler, IDragHandler, ICanvasElement {
    fillRect: RectTransform;
    handleRect: RectTransform;
    direction: Direction;
    minValue: number;
    maxValue: number;
    wholeNumbers: boolean;
    value: number;
    normalizedValue: number;
    onValueChanged: SliderEvent;


    FindSelectableOnDown(): Selectable;
    FindSelectableOnLeft(): Selectable;
    FindSelectableOnRight(): Selectable;
    FindSelectableOnUp(): Selectable;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnMove(eventData: AxisEventData): void;
    OnPointerDown(eventData: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetDirection(direction: Direction, includeRectLayouts: boolean): void;
    SetValueWithoutNotify(input: number): void;
}
    
interface SliderEvent {


}
    
interface SliderEventConstructor {

    new(): SliderEvent;

}
declare const SliderEvent: SliderEventConstructor;
    
interface CanvasHitDetector extends MonoBehaviour {


    IsPointerOverTarget(target: GameObject): boolean;
    IsPointerOverUI(): boolean;
}
    
interface CanvasHitDetectorConstructor {

    new(): CanvasHitDetector;

}
declare const CanvasHitDetector: CanvasHitDetectorConstructor;
    
interface AudioBehaviour extends Behaviour {


}
    
interface AudioBehaviourConstructor {

    new(): AudioBehaviour;

}
declare const AudioBehaviour: AudioBehaviourConstructor;
    
interface AudioSource extends AudioBehaviour {
    panLevel: number;
    pan: number;
    volume: number;
    pitch: number;
    time: number;
    timeSamples: number;
    clip: AudioClip;
    resource: AudioResource;
    outputAudioMixerGroup: AudioMixerGroup;
    gamepadSpeakerOutputType: GamepadSpeakerOutputType;
    isPlaying: boolean;
    isVirtual: boolean;
    loop: boolean;
    ignoreListenerVolume: boolean;
    playOnAwake: boolean;
    ignoreListenerPause: boolean;
    velocityUpdateMode: AudioVelocityUpdateMode;
    panStereo: number;
    spatialBlend: number;
    spatialize: boolean;
    spatializePostEffects: boolean;
    reverbZoneMix: number;
    bypassEffects: boolean;
    bypassListenerEffects: boolean;
    bypassReverbZones: boolean;
    dopplerLevel: number;
    spread: number;
    priority: number;
    mute: boolean;
    minDistance: number;
    maxDistance: number;
    rolloffMode: AudioRolloffMode;
    minVolume: number;
    maxVolume: number;
    rolloffFactor: number;


    DisableGamepadOutput(): boolean;
    GetAmbisonicDecoderFloat(index: number, value: unknown): boolean;
    GetCustomCurve(type: AudioSourceCurveType): AnimationCurve;
    GetOutputData(numSamples: number, channel: number): CSArray<number>;
    GetOutputData(samples: CSArray<number>, channel: number): void;
    GetSpatializerFloat(index: number, value: unknown): boolean;
    GetSpectrumData(numSamples: number, channel: number, window: FFTWindow): CSArray<number>;
    GetSpectrumData(samples: CSArray<number>, channel: number, window: FFTWindow): void;
    Pause(): void;
    Play(): void;
    Play(delay: number): void;
    PlayDelayed(delay: number): void;
    PlayOneShot(clip: AudioClip): void;
    PlayOneShot(clip: AudioClip, volumeScale: number): void;
    PlayOnGamepad(slot: number): boolean;
    PlayScheduled(time: number): void;
    SetAmbisonicDecoderFloat(index: number, value: number): boolean;
    SetCustomCurve(type: AudioSourceCurveType, curve: AnimationCurve): void;
    SetGamepadSpeakerMixLevel(slot: number, mixLevel: number): boolean;
    SetGamepadSpeakerMixLevelDefault(slot: number): boolean;
    SetGamepadSpeakerRestrictedAudio(slot: number, restricted: boolean): boolean;
    SetScheduledEndTime(time: number): void;
    SetScheduledStartTime(time: number): void;
    SetSpatializerFloat(index: number, value: number): boolean;
    Stop(): void;
    UnPause(): void;
}
    
interface AudioResource extends Object {


}
    
interface AudioClip extends AudioResource {
    length: number;
    samples: number;
    channels: number;
    frequency: number;
    isReadyToPlay: boolean;
    loadType: AudioClipLoadType;
    preloadAudioData: boolean;
    ambisonic: boolean;
    loadInBackground: boolean;
    loadState: AudioDataLoadState;


    GetData(data: unknown, offsetSamples: number): boolean;
    GetData(data: CSArray<number>, offsetSamples: number): boolean;
    LoadAudioData(): boolean;
    SetData(data: CSArray<number>, offsetSamples: number): boolean;
    SetData(data: unknown, offsetSamples: number): boolean;
    UnloadAudioData(): boolean;
}
    
interface PCMReaderCallback {


    BeginInvoke(data: CSArray<number>, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(data: CSArray<number>): void;
}
    
interface PCMReaderCallbackConstructor {

    new(object: unknown, method: unknown): PCMReaderCallback;

}
declare const PCMReaderCallback: PCMReaderCallbackConstructor;
    
interface PCMSetPositionCallback {


    BeginInvoke(position: number, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(position: number): void;
}
    
interface PCMSetPositionCallbackConstructor {

    new(object: unknown, method: unknown): PCMSetPositionCallback;

}
declare const PCMSetPositionCallback: PCMSetPositionCallbackConstructor;
    
interface AudioClipConstructor {


    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean, pcmreadercallback: PCMReaderCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, _3D: boolean, stream: boolean, pcmreadercallback: PCMReaderCallback, pcmsetpositioncallback: PCMSetPositionCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: PCMReaderCallback): AudioClip;
    Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: PCMReaderCallback, pcmsetpositioncallback: PCMSetPositionCallback): AudioClip;
}
declare const AudioClip: AudioClipConstructor;
    
interface ISubAssetNotDuplicatable {


}
    
interface AudioMixerGroup extends Object, ISubAssetNotDuplicatable {
    audioMixer: AudioMixer;


}
    
interface AudioMixer extends Object {
    outputAudioMixerGroup: AudioMixerGroup;
    updateMode: AudioMixerUpdateMode;


    ClearFloat(name: string): boolean;
    FindMatchingGroups(subPath: string): CSArray<AudioMixerGroup>;
    FindSnapshot(name: string): AudioMixerSnapshot;
    GetFloat(name: string, value: unknown): boolean;
    SetFloat(name: string, value: number): boolean;
    TransitionToSnapshots(snapshots: CSArray<AudioMixerSnapshot>, weights: CSArray<number>, timeToReach: number): void;
}
    
interface AudioMixerSnapshot extends Object, ISubAssetNotDuplicatable {
    audioMixer: AudioMixer;


    TransitionTo(timeToReach: number): void;
}
    
interface AudioSourceConstructor {

    new(): AudioSource;

    GamepadSpeakerSupportsOutputType(outputType: GamepadSpeakerOutputType): boolean;
    PlayClipAtPoint(clip: AudioClip, position: Vector3): void;
    PlayClipAtPoint(clip: AudioClip, position: Vector3, volume: number): void;
}
declare const AudioSource: AudioSourceConstructor;
    
interface ITween {


    Cancel(): void;
    GetTotalDuration(includeDelay: boolean): number;
}
    
interface Tween<DriverValueType> extends MonoBehaviour, ITween {


    Await(): void;
    Cancel(): void;
    GetTotalDuration(includeDelay: boolean): number;
    OnGetFrom(): DriverValueType;
    OnInitialize(): boolean;
    OnUpdate(easedTime: number): void;
    SetDelay(delay: number, goToFirstFrameImmediately: boolean): Tween<DriverValueType>;
    SetEase(ease: EaseType): Tween<DriverValueType>;
    SetEaseBackIn(): Tween<DriverValueType>;
    SetEaseBackInOut(): Tween<DriverValueType>;
    SetEaseBackOut(): Tween<DriverValueType>;
    SetEaseBounceIn(): Tween<DriverValueType>;
    SetEaseBounceInOut(): Tween<DriverValueType>;
    SetEaseBounceOut(): Tween<DriverValueType>;
    SetEaseCircIn(): Tween<DriverValueType>;
    SetEaseCircInOut(): Tween<DriverValueType>;
    SetEaseCircOut(): Tween<DriverValueType>;
    SetEaseCubicIn(): Tween<DriverValueType>;
    SetEaseCubicInOut(): Tween<DriverValueType>;
    SetEaseCubicOut(): Tween<DriverValueType>;
    SetEaseElasticIn(): Tween<DriverValueType>;
    SetEaseElasticInOut(): Tween<DriverValueType>;
    SetEaseElasticOut(): Tween<DriverValueType>;
    SetEaseExpoIn(): Tween<DriverValueType>;
    SetEaseExpoInOut(): Tween<DriverValueType>;
    SetEaseExpoOut(): Tween<DriverValueType>;
    SetEaseLinear(): Tween<DriverValueType>;
    SetEaseQuadIn(): Tween<DriverValueType>;
    SetEaseQuadInOut(): Tween<DriverValueType>;
    SetEaseQuadOut(): Tween<DriverValueType>;
    SetEaseQuartIn(): Tween<DriverValueType>;
    SetEaseQuartInOut(): Tween<DriverValueType>;
    SetEaseQuartOut(): Tween<DriverValueType>;
    SetEaseQuintIn(): Tween<DriverValueType>;
    SetEaseQuintInOut(): Tween<DriverValueType>;
    SetEaseQuintOut(): Tween<DriverValueType>;
    SetEaseSineIn(): Tween<DriverValueType>;
    SetEaseSineInOut(): Tween<DriverValueType>;
    SetEaseSineOut(): Tween<DriverValueType>;
    SetFrom(valueFrom: DriverValueType): Tween<DriverValueType>;
    SetInfinite(): Tween<DriverValueType>;
    SetLoopCount(loopCount: number): Tween<DriverValueType>;
    SetOnCancel(onCancel: unknown): Tween<DriverValueType>;
    SetOnComplete(onComplete: unknown): Tween<DriverValueType>;
    SetOnStart(onStart: unknown): Tween<DriverValueType>;
    SetOvershooting(overshooting: number): Tween<DriverValueType>;
    SetPaused(isPaused: boolean): Tween<DriverValueType>;
    SetPingPong(): Tween<DriverValueType>;
    SetRandomTime(): Tween<DriverValueType>;
    SetTime(time: number): Tween<DriverValueType>;
    SetUseUnscaledTime(useUnscaledTime: boolean): Tween<DriverValueType>;
    Yield(): unknown;
}
    
interface Bridge {


}
    
interface BridgeConstructor {


    CopyToClipboard(text: string): void;
    GetAllocatedRam(): number;
    GetAverageFPS(): number;
    GetCurrentFPS(): number;
    GetMonoRam(): number;
    GetReservedRam(): number;
    GetVolume(): number;
    IsFullScreen(): boolean;
    LoadScene(sceneName: string, restartLuau: boolean): void;
    MakeMaterialPropertyBlock(): MaterialPropertyBlock;
    MakeMesh(): Mesh;
    MakeSprite(texture2D: Texture2D): Sprite;
    MakeVector2(x: number, y: number): Vector2;
    RemoveRichText(input: string): string;
    ScreenPointToLocalPointInRectangle(rectTransform: RectTransform, screenPoint: Vector2): Vector2;
    SetFullScreen(value: boolean): void;
    SetParentToSceneRoot(transform: Transform): void;
    SetVolume(volume: number): void;
    UpdateLayout(xform: Transform, recursive: boolean): void;
}
declare const Bridge: BridgeConstructor;
    
interface CanvasGroup extends Behaviour, ICanvasRaycastFilter {
    alpha: number;
    interactable: boolean;
    blocksRaycasts: boolean;
    ignoreParentGroups: boolean;


    IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean;
}
    
interface CanvasGroupConstructor {

    new(): CanvasGroup;

}
declare const CanvasGroup: CanvasGroupConstructor;
    
interface AutoShutdownBridge extends MonoBehaviour {


    SetBundlesLoaded(assetBundlesLoaded: boolean): void;
}
    
interface AutoShutdownBridgeConstructor {

    new(): AutoShutdownBridge;

}
declare const AutoShutdownBridge: AutoShutdownBridgeConstructor;
    
interface ScreenCapture {


}
    
interface ScreenCaptureConstructor {


    CaptureScreenshot(filename: string): void;
    CaptureScreenshot(filename: string, superSize: number): void;
    CaptureScreenshot(filename: string, stereoCaptureMode: StereoScreenCaptureMode): void;
    CaptureScreenshotAsTexture(): Texture2D;
    CaptureScreenshotAsTexture(superSize: number): Texture2D;
    CaptureScreenshotAsTexture(stereoCaptureMode: StereoScreenCaptureMode): Texture2D;
    CaptureScreenshotIntoRenderTexture(renderTexture: RenderTexture): void;
}
declare const ScreenCapture: ScreenCaptureConstructor;
    
interface VoxelBlocks {
    maxResolution: number;
    atlasSize: number;
    pointFiltering: boolean;
    atlas: TexturePacker;
    materials: CSDictionary<string, Material>;
    loadedBlocks: CSDictionary<number, BlockDefinition>;
    rootAssetPath: string;
    m_bundlePaths: CSArray<string>;


    AddSolidMaskToVoxelValue(voxelValue: number): number;
    GetBlock(index: number): BlockDefinition;
    GetBlockDefinitionByStringId(blockTypeId: string): BlockDefinition;
    GetBlockDefinitionFromIndex(index: number): BlockDefinition;
    GetBlockIdFromStringId(stringId: string): number;
    GetStringIdFromBlockId(blockVoxelId: number): string;
    Load(contentsOfBlockDefines: CSArray<string>, loadTexturesDirectlyFromDisk: boolean): void;
    UpdateVoxelBlockId(voxelValue: number, blockId: number): number;
}
    
interface TexturePacker {
    diffuse: RenderTexture;
    normals: RenderTexture;


    Dispose(): void;
    GetColor(texture: string): Color;
    GetUVs(texture: string): Rect;
    PackTextures(textures: CSDictionary<string, TextureSet>, desiredPadding: number, width: number, height: number, numMips: number, normalizedSize: number): void;
}
    
interface TextureSet {
    diffuse: Texture2D;
    normals: Texture2D;
    roughTexture: Texture2D;
    metalTexture: Texture2D;
    emissiveTexture: Texture2D;
    roughness: number;
    metallic: number;
    normalScale: number;
    emissive: number;
    brightness: number;


}
    
interface TextureSetConstructor {

    new(diffuse: Texture2D, normals: Texture2D, roughTex: Texture2D, metalTex: Texture2D, emissiveTex: Texture2D, roughness: number, metallic: number, normalScale: number, emissive: number, brightness: number): TextureSet;

}
declare const TextureSet: TextureSetConstructor;
    
interface TexturePackerConstructor {

    new(): TexturePacker;

    CustomBlit(renderTarget: RenderTexture, sourceTexture: Texture, material: Material, destX: number, destY: number, destWidth: number, destHeight: number, srcX: number, srcY: number, srcWidth: number, srcHeight: number): void;
    DoPadding(target: RenderTexture, source: Texture2D, rect: Rect, pad: number, flipMaterial: Material): void;
}
declare const TexturePacker: TexturePackerConstructor;
    
interface BlockDefinition {
    prefab: boolean;
    metallic: number;
    roughness: number;
    normalScale: number;
    emissive: number;
    brightness: number;
    solid: boolean;
    collisionType: CollisionType;
    randomRotation: boolean;
    mesh: VoxelMeshCopy;
    meshLod: VoxelMeshCopy;
    meshTiles: CSDictionary<number, LodSet>;
    meshTileProcessingOrder: CSArray<number>;
    contextStyle: ContextStyle;
    meshContexts: CSDictionary<number, VoxelMeshCopy>;
    detail: boolean;
    meshTexturePath: string;
    topTexturePath: string;
    sideTexturePath: string;
    bottomTexturePath: string;
    editorTexture: Texture2D;
    topUvs: Rect;
    bottomUvs: Rect;
    sideUvs: Rect;
    doOcclusion: boolean;
    materials: CSArray<string>;
    meshMaterialName: string;
    averageColor: CSArray<Color>;
    minecraftConversions: CSArray<string>;
    blockId: number;
    blockTypeId: string;
    name: string;
    material: string;
    topMaterial: string;
    sideMaterial: string;
    bottomMaterial: string;
    topTexture: string;
    sideTexture: string;
    bottomTexture: string;
    meshTexture: string;
    meshPath: string;
    meshPathLod: string;


    GetUvsForFace(i: number): Rect;
}
    
interface VoxelMeshCopy {
    quaternions: CSArray<unknown>;
    rotation: CSDictionary<number, PrecalculatedRotation>;
    srcUvs: CSArray<Vector2>;
    srcColors: CSArray<Color32>;
    srcVertices: CSArray<Vector3>;
    srcNormals: CSArray<Vector3>;
    surfaces: CSArray<Surface>;


    AdjustUVs(uvs: Rect): void;
}
    
interface PrecalculatedRotation {
    vertices: CSArray<Vector3>;
    normals: CSArray<Vector3>;


}
    
interface PrecalculatedRotationConstructor {

    new(srcVertices: CSArray<Vector3>, srcNormals: CSArray<Vector3>, rot: Rotations, quat: Quaternion): PrecalculatedRotation;
    new(srcVertices: CSArray<Vector3>, srcNormals: CSArray<Vector3>, rot: Rotations, quat: Quaternion): PrecalculatedRotation;

}
declare const PrecalculatedRotation: PrecalculatedRotationConstructor;
    
interface Surface {
    triangles: CSArray<number>;
    meshMaterial: Material;
    meshMaterialName: string;


}
    
interface SurfaceConstructor {

    new(triangles: CSArray<number>, material: Material, materialName: string): Surface;
    new(): Surface;

}
declare const Surface: SurfaceConstructor;
    
interface VoxelMeshCopyConstructor {

    new(mesh: Mesh): VoxelMeshCopy;
    new(src: VoxelMeshCopy): VoxelMeshCopy;
    new(assetPath: string, showError: boolean): VoxelMeshCopy;

}
declare const VoxelMeshCopy: VoxelMeshCopyConstructor;
    
interface LodSet {
    lod0: VoxelMeshCopy;
    lod1: VoxelMeshCopy;
    lod2: VoxelMeshCopy;


}
    
interface LodSetConstructor {

    new(): LodSet;

}
declare const LodSet: LodSetConstructor;
    
interface BlockDefinitionConstructor {

    new(): BlockDefinition;

}
declare const BlockDefinition: BlockDefinitionConstructor;
    
interface VoxelBlocksConstructor {
    meshTileOffsets: CSDictionary<number, Vector3>;
    meshTileSizes: CSDictionary<number, unknown>;
    TileSizeNames: CSArray<string>;
    ContextBlockNames: CSArray<string>;
    QuarterBlockNames: CSArray<string>;
    QuarterBlockSubstitutions: CSArray<number>;

    new(): VoxelBlocks;

}
declare const VoxelBlocks: VoxelBlocksConstructor;
    
interface CharacterController extends Collider {
    velocity: Vector3;
    isGrounded: boolean;
    collisionFlags: CollisionFlags;
    radius: number;
    height: number;
    center: Vector3;
    slopeLimit: number;
    stepOffset: number;
    skinWidth: number;
    minMoveDistance: number;
    detectCollisions: boolean;
    enableOverlapRecovery: boolean;


    Move(motion: Vector3): CollisionFlags;
    SimpleMove(speed: Vector3): boolean;
}
    
interface CharacterControllerConstructor {

    new(): CharacterController;

}
declare const CharacterController: CharacterControllerConstructor;
    
interface ProjectileTrajectoryRenderer extends MonoBehaviour {
    maxIterations: number;
    maxSegmentCount: number;
    segmentStepModulo: number;


    SetDrawingEnabled(enabled: boolean): void;
    UpdateInfo(startingPoint: Vector3, velocity: Vector3, drag: number, gravity: number): void;
}
    
interface ProjectileTrajectoryRendererConstructor {

    new(): ProjectileTrajectoryRenderer;

}
declare const ProjectileTrajectoryRenderer: ProjectileTrajectoryRendererConstructor;
    
interface ProjectileLauncher extends NetworkBehaviour {


    Awake(): void;
    Awake___UserLogic(): void;
    ClientFire(projectilePath: string, launcherItemTypeId: number, itemTypeId: number, position: Vector3, velocity: Vector3, gravity: number, drag: number): AirshipProjectile;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
}
    
interface AirshipProjectile extends MonoBehaviour {
    gravity: number;
    drag: number;
    launcherItemTypeId: number;
    itemTypeId: number;


    Initialize(startingVelocity: Vector3, gravity: number, drag: number, passedTime: number, itemTypeId: number, launcherItemTypeId: number): void;
}
    
interface AirshipProjectileConstructor {

    new(): AirshipProjectile;

}
declare const AirshipProjectile: AirshipProjectileConstructor;
    
interface ProjectileLauncherConstructor {

    new(): ProjectileLauncher;

}
declare const ProjectileLauncher: ProjectileLauncherConstructor;
    
interface ProjectileValidateEvent {
    shooter: GameObject;
    validated: boolean;
    projectilePath: string;
    position: Vector3;
    velocity: Vector3;
    gravity: number;
    drag: number;
    itemTypeId: number;


}
    
interface TrailRenderer extends Renderer {
    numPositions: number;
    time: number;
    startWidth: number;
    endWidth: number;
    widthMultiplier: number;
    autodestruct: boolean;
    emitting: boolean;
    numCornerVertices: number;
    numCapVertices: number;
    minVertexDistance: number;
    startColor: Color;
    endColor: Color;
    positionCount: number;
    textureScale: Vector2;
    shadowBias: number;
    generateLightingData: boolean;
    textureMode: LineTextureMode;
    alignment: LineAlignment;
    maskInteraction: SpriteMaskInteraction;
    widthCurve: AnimationCurve;
    colorGradient: Gradient;


    AddPosition(position: Vector3): void;
    AddPositions(positions: CSArray<Vector3>): void;
    AddPositions(positions: CSArray<Vector3>): void;
    AddPositions(positions: CSArray<Vector3>): void;
    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    Clear(): void;
    GetPosition(index: number): Vector3;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    GetVisiblePositions(positions: CSArray<Vector3>): number;
    SetPosition(index: number, position: Vector3): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
}
    
interface TrailRendererConstructor {

    new(): TrailRenderer;

}
declare const TrailRenderer: TrailRendererConstructor;
    
interface WindowCore {


}
    
interface WindowProxy extends MonoBehaviour {


    HasFocus(): boolean;
}
    
interface WindowProxyConstructor {

    new(): WindowProxy;

}
declare const WindowProxy: WindowProxyConstructor;
    
interface WindowCoreConstructor {
    Window: WindowProxy;


    SetWindowProxy(window: WindowProxy): void;
}
declare const WindowCore: WindowCoreConstructor;
    
interface CharacterMoveModifier {
    speedMultiplier: number;
    blockSprint: boolean;
    blockJump: boolean;


}
    
interface CharacterMoveModifierConstructor {

    new(): CharacterMoveModifier;

}
declare const CharacterMoveModifier: CharacterMoveModifierConstructor;
    
interface DynamicVariables extends ScriptableObject {
    collectionId: string;
    strings: CSArray<unknown>;
    numbers: CSArray<unknown>;
    vectors: CSArray<unknown>;


    GetAsString(key: string): string;
    GetNumber(key: string): number;
    GetString(key: string): string;
    GetVector3(key: string): Vector3;
    Register(): void;
    ReplicateAll(): void;
    ReplicateNumber(key: string): void;
    ReplicateString(key: string): void;
    ReplicateVector3(key: string): void;
    SetNumber(key: string, val: number): void;
    SetString(key: string, val: string): void;
    SetVector3(key: string, val: Vector3): void;
}
    
interface DynamicVariablesConstructor {

    new(): DynamicVariables;

}
declare const DynamicVariables: DynamicVariablesConstructor;
    
interface ProjectileHitEvent {
    raycastHit: RaycastHit;
    velocity: Vector3;


}
    
interface MaterialColor extends MonoBehaviour {
    colorSettings: CSArray<ColorSetting>;
    addedByEditorScript: boolean;


    ConvertColor(color: Color): Color;
    DoUpdate(): void;
    EditorFirstTimeSetup(): void;
    GetColor(materialIndex: number): ColorSetting;
    SetAllColors(diffuseColor: Color, multiplyColor: boolean): void;
    SetAllEmissive(emissiveColor: Color, emissiveMix: number): void;
    SetColor(settings: ColorSetting, materialIndex: number): boolean;
    SetMaterialColor(index: number, color: Color): void;
}
    
interface ColorSetting {
    materialColor: Color;
    emissiveColor: Color;
    emissiveMix: number;
    reference: string;


    CopyFrom(otherSettings: ColorSetting): void;
}
    
interface ColorSettingConstructor {

    new(materialColor: Color, emissiveColor: Color, emissiveMix: number): ColorSetting;

}
declare const ColorSetting: ColorSettingConstructor;
    
interface MaterialColorConstructor {

    new(): MaterialColor;

}
declare const MaterialColor: MaterialColorConstructor;
    
interface DefaultObjectPool extends ObjectPool {
    Cache: CSArray<CSDictionary<number, CSArray<NetworkObject>>>;


    CacheObjects(prefab: NetworkObject, count: number, asServer: boolean): void;
    ClearPool(): void;
    ClearPool(collectionId: number): void;
    RetrieveObject(prefabId: number, asServer: boolean): NetworkObject;
    RetrieveObject(prefabId: number, collectionId: number, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    RetrieveObject(prefabId: number, collectionId: number, asServer: boolean): NetworkObject;
    StoreObject(instantiated: NetworkObject, asServer: boolean): void;
}
    
interface DefaultObjectPoolConstructor {

    new(): DefaultObjectPool;

}
declare const DefaultObjectPool: DefaultObjectPoolConstructor;
    
interface AirshipObjectPool extends DefaultObjectPool {
    maxSpawnPerFrame: number;


    RetrieveObject(prefabId: number, collectionId: number, position: Vector3, rotation: Quaternion, asServer: boolean): NetworkObject;
    SlowlyCacheObjects(prefab: NetworkObject, count: number): void;
}
    
interface AirshipObjectPoolConstructor {

    new(): AirshipObjectPool;

}
declare const AirshipObjectPool: AirshipObjectPoolConstructor;
    
interface MainMenuLoadingScreen extends BundleLoadingScreen {
    canvas: Canvas;
    progressText: TMP_Text;


    Close(): void;
    SetProgress(text: string, percent: number): void;
}
    
interface MainMenuLoadingScreenConstructor {

    new(): MainMenuLoadingScreen;

}
declare const MainMenuLoadingScreen: MainMenuLoadingScreenConstructor;
    
interface HttpManager {


}
    
interface HttpResponse {
    success: boolean;
    statusCode: number;
    data: string;
    error: string;


}
    
interface HttpManagerConstructor {
    loggingEnabled: boolean;

    new(): HttpManager;

    DeleteAsync(url: string): HttpResponse;
    DeleteAsync(url: string, headers: string): HttpResponse;
    GetAsync(url: string, headers: string): HttpResponse;
    GetAsync(url: string): HttpResponse;
    PatchAsync(url: string, data: string): HttpResponse;
    PatchAsync(url: string, data: string, headers: string): HttpResponse;
    PostAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string, data: string, headers: string): HttpResponse;
    PutAsync(url: string, data: string): HttpResponse;
    PutAsync(url: string, data: string, headers: string): HttpResponse;
}
declare const HttpManager: HttpManagerConstructor;
    
interface InternalHttpManager {


}
    
interface InternalHttpManagerConstructor {
    authToken: string;

    new(): InternalHttpManager;

    DeleteAsync(url: string): HttpResponse;
    GetAsync(url: string): HttpResponse;
    PatchAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string, data: string): HttpResponse;
    PostAsync(url: string): HttpResponse;
    PutAsync(url: string, data: string): HttpResponse;
    SetAuthToken(authToken: string): void;
}
declare const InternalHttpManager: InternalHttpManagerConstructor;
    
interface FriendsControllerBackend {


}
    
interface FriendsControllerBackendConstructor {

    new(): FriendsControllerBackend;

    GetFriends(): HttpResponse;
    IsFriendsWith(uid: string): HttpResponse;
}
declare const FriendsControllerBackend: FriendsControllerBackendConstructor;
    
interface MatchmakingControllerBackend {


}
    
interface MatchmakingControllerBackendConstructor {

    new(): MatchmakingControllerBackend;

    GetStatus(): HttpResponse;
}
declare const MatchmakingControllerBackend: MatchmakingControllerBackendConstructor;
    
interface PartyControllerBackend {


}
    
interface PartyControllerBackendConstructor {

    new(): PartyControllerBackend;

    GetParty(): HttpResponse;
}
declare const PartyControllerBackend: PartyControllerBackendConstructor;
    
interface AirshipInventoryControllerBackend {


}
    
interface AirshipInventoryControllerBackendConstructor {

    new(): AirshipInventoryControllerBackend;

    GetEquippedOutfitByUserId(uid: string): HttpResponse;
    GetEquippedProfilePictureByUserId(uid: string): HttpResponse;
}
declare const AirshipInventoryControllerBackend: AirshipInventoryControllerBackendConstructor;
    
interface TransferControllerBackend {


}
    
interface TransferControllerBackendConstructor {

    new(): TransferControllerBackend;

    TransferToGame(body: string): HttpResponse;
    TransferToPartyLeader(): HttpResponse;
}
declare const TransferControllerBackend: TransferControllerBackendConstructor;
    
interface UsersControllerBackend {


}
    
interface UsersControllerBackendConstructor {

    new(): UsersControllerBackend;

    GetUserById(userId: string): HttpResponse;
    GetUserByUsername(username: string): HttpResponse;
    GetUsersById(query: string): HttpResponse;
}
declare const UsersControllerBackend: UsersControllerBackendConstructor;
    
interface CacheStoreServiceBackend {


}
    
interface CacheStoreServiceBackendConstructor {

    new(): CacheStoreServiceBackend;

    GetKey(key: string, expireTimeSec: unknown): HttpResponse;
    SetKey(key: string, expireTimeSec: number, body: string): HttpResponse;
    SetKeyTTL(key: string, expireTimeSec: number): HttpResponse;
}
declare const CacheStoreServiceBackend: CacheStoreServiceBackendConstructor;
    
interface DataStoreServiceBackend {


}
    
interface DataStoreServiceBackendConstructor {

    new(): DataStoreServiceBackend;

    DeleteKey(key: string): HttpResponse;
    GetKey(key: string): HttpResponse;
    SetKey(key: string, body: string): HttpResponse;
}
declare const DataStoreServiceBackend: DataStoreServiceBackendConstructor;
    
interface LeaderboardServiceBackend {


}
    
interface LeaderboardServiceBackendConstructor {

    new(): LeaderboardServiceBackend;

    GetRank(leaderboardName: string, id: string): HttpResponse;
    GetRankRange(leaderboardName: string, skip: number, limit: number): HttpResponse;
    Update(leaderboardName: string, body: string): HttpResponse;
}
declare const LeaderboardServiceBackend: LeaderboardServiceBackendConstructor;
    
interface PartyServiceBackend {


}
    
interface PartyServiceBackendConstructor {

    new(): PartyServiceBackend;

    GetPartyById(partyId: string): HttpResponse;
    GetPartyForUserId(userId: string): HttpResponse;
}
declare const PartyServiceBackend: PartyServiceBackendConstructor;
    
interface MatchmakingServiceBackend {


}
    
interface MatchmakingServiceBackendConstructor {

    new(): MatchmakingServiceBackend;

    GetMatchmakingRegions(): HttpResponse;
    JoinPartyToQueue(partyId: string, body: string): HttpResponse;
    RemovePartyFromQueue(partyId: string): HttpResponse;
}
declare const MatchmakingServiceBackend: MatchmakingServiceBackendConstructor;
    
interface TransferServiceBackend {


}
    
interface TransferServiceBackendConstructor {

    new(): TransferServiceBackend;

    CreateServer(body: string): HttpResponse;
    Transfer(body: string): HttpResponse;
}
declare const TransferServiceBackend: TransferServiceBackendConstructor;
    
interface AirshipInventoryServiceBackend {


}
    
interface AirshipInventoryServiceBackendConstructor {

    new(): AirshipInventoryServiceBackend;

    DeleteAccessory(itemId: string): HttpResponse;
    DeleteItem(itemId: string): HttpResponse;
    DeleteProfilePicture(itemId: string): HttpResponse;
    GetAccessories(uid: string, query: string): HttpResponse;
    GetEquippedOutfitByUserId(userId: string): HttpResponse;
    GetEquippedProfilePictureByUserId(uid: string): HttpResponse;
    GetItems(uid: string, query: string): HttpResponse;
    GetProfilePictures(uid: string, query: string): HttpResponse;
    GrantAccessory(uid: string, classId: string): HttpResponse;
    GrantItem(uid: string, classId: string): HttpResponse;
    GrantProfilePicture(uid: string, classId: string): HttpResponse;
    PerformTrade(body: string): HttpResponse;
}
declare const AirshipInventoryServiceBackend: AirshipInventoryServiceBackendConstructor;
    
interface UsersServiceBackend {


}
    
interface UsersServiceBackendConstructor {

    new(): UsersServiceBackend;

    GetUserById(userId: string): HttpResponse;
    GetUserByUsername(username: string): HttpResponse;
    GetUsersById(query: string): HttpResponse;
}
declare const UsersServiceBackend: UsersServiceBackendConstructor;
    
interface CrossSceneState {


}
    
interface ServerTransferData {
    address: string;
    port: number;


}
    
interface ServerTransferDataConstructor {

    new(): ServerTransferData;

}
declare const ServerTransferData: ServerTransferDataConstructor;
    
interface CrossSceneStateConstructor {
    ServerTransferData: ServerTransferData;
    UseLocalBundles: boolean;


    IsLocalServer(): boolean;
}
declare const CrossSceneState: CrossSceneStateConstructor;
    
interface Toggle extends Selectable, ISubmitHandler, IPointerClickHandler, ICanvasElement {
    toggleTransition: ToggleTransition;
    graphic: Graphic;
    onValueChanged: ToggleEvent;
    group: ToggleGroup;
    isOn: boolean;


    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    OnPointerClick(eventData: PointerEventData): void;
    OnSubmit(eventData: BaseEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetIsOnWithoutNotify(value: boolean): void;
}
    
interface ToggleEvent {


}
    
interface ToggleEventConstructor {

    new(): ToggleEvent;

}
declare const ToggleEvent: ToggleEventConstructor;
    
interface ToggleGroup extends UIBehaviour {
    allowSwitchOff: boolean;


    ActiveToggles(): CSArray<Toggle>;
    AnyTogglesOn(): boolean;
    EnsureValidState(): void;
    GetFirstActiveToggle(): Toggle;
    NotifyToggleOn(toggle: Toggle, sendCallback: boolean): void;
    RegisterToggle(toggle: Toggle): void;
    SetAllTogglesOff(sendCallback: boolean): void;
    UnregisterToggle(toggle: Toggle): void;
}
    
interface ILayoutController {


    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;
}
    
interface ILayoutGroup extends ILayoutController {


}
    
interface LayoutGroup extends UIBehaviour, ILayoutGroup, ILayoutElement {
    padding: RectOffset;
    childAlignment: TextAnchor;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;
}
    
interface RectOffset {
    left: number;
    right: number;
    top: number;
    bottom: number;
    horizontal: number;
    vertical: number;


    Add(rect: Rect): Rect;
    Remove(rect: Rect): Rect;
    ToString(): string;
    ToString(format: string): string;
    ToString(format: string, formatProvider: unknown): string;
}
    
interface RectOffsetConstructor {

    new(): RectOffset;
    new(left: number, right: number, top: number, bottom: number): RectOffset;

}
declare const RectOffset: RectOffsetConstructor;
    
interface HorizontalOrVerticalLayoutGroup extends LayoutGroup {
    spacing: number;
    childForceExpandWidth: boolean;
    childForceExpandHeight: boolean;
    childControlWidth: boolean;
    childControlHeight: boolean;
    childScaleWidth: boolean;
    childScaleHeight: boolean;
    reverseArrangement: boolean;


}
    
interface HorizontalLayoutGroup extends HorizontalOrVerticalLayoutGroup {


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;
}
    
interface VerticalLayoutGroup extends HorizontalOrVerticalLayoutGroup {


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;
}
    
interface ILayoutSelfController extends ILayoutController {


}
    
interface ContentSizeFitter extends UIBehaviour, ILayoutSelfController {
    horizontalFit: FitMode;
    verticalFit: FitMode;


    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;
}
    
interface LayoutRebuilder extends ICanvasElement {
    transform: Transform;


    Equals(obj: unknown): boolean;
    GetHashCode(): number;
    GraphicUpdateComplete(): void;
    IsDestroyed(): boolean;
    LayoutComplete(): void;
    Rebuild(executing: CanvasUpdate): void;
    ToString(): string;
}
    
interface LayoutRebuilderConstructor {

    new(): LayoutRebuilder;

    ForceRebuildLayoutImmediate(layoutRoot: RectTransform): void;
    MarkLayoutForRebuild(rect: RectTransform): void;
}
declare const LayoutRebuilder: LayoutRebuilderConstructor;
    
interface RectTransformUtility {


}
    
interface RectTransformUtilityConstructor {


    CalculateRelativeRectTransformBounds(root: Transform, child: Transform): Bounds;
    CalculateRelativeRectTransformBounds(trans: Transform): Bounds;
    FlipLayoutAxes(rect: RectTransform, keepPositioning: boolean, recursive: boolean): void;
    FlipLayoutOnAxis(rect: RectTransform, axis: number, keepPositioning: boolean, recursive: boolean): void;
    PixelAdjustPoint(point: Vector2, elementTransform: Transform, canvas: Canvas): Vector2;
    PixelAdjustRect(rectTransform: RectTransform, canvas: Canvas): Rect;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2): boolean;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2, cam: Camera): boolean;
    RectangleContainsScreenPoint(rect: RectTransform, screenPoint: Vector2, cam: Camera, offset: Vector4): boolean;
    ScreenPointToLocalPointInRectangle(rect: RectTransform, screenPoint: Vector2, cam: Camera, localPoint: unknown): boolean;
    ScreenPointToRay(cam: Camera, screenPos: Vector2): Ray;
    ScreenPointToWorldPointInRectangle(rect: RectTransform, screenPoint: Vector2, cam: Camera, worldPoint: unknown): boolean;
    WorldToScreenPoint(cam: Camera, worldPoint: Vector3): Vector2;
}
declare const RectTransformUtility: RectTransformUtilityConstructor;
    
interface ScrollRect extends UIBehaviour, ILayoutGroup, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IScrollHandler, ILayoutElement {
    content: RectTransform;
    horizontal: boolean;
    vertical: boolean;
    movementType: MovementType;
    elasticity: number;
    inertia: boolean;
    decelerationRate: number;
    scrollSensitivity: number;
    viewport: RectTransform;
    horizontalScrollbar: Scrollbar;
    verticalScrollbar: Scrollbar;
    horizontalScrollbarVisibility: ScrollbarVisibility;
    verticalScrollbarVisibility: ScrollbarVisibility;
    horizontalScrollbarSpacing: number;
    verticalScrollbarSpacing: number;
    onValueChanged: ScrollRectEvent;
    velocity: Vector2;
    normalizedPosition: Vector2;
    horizontalNormalizedPosition: number;
    verticalNormalizedPosition: number;
    minWidth: number;
    preferredWidth: number;
    flexibleWidth: number;
    minHeight: number;
    preferredHeight: number;
    flexibleHeight: number;
    layoutPriority: number;


    CalculateLayoutInputHorizontal(): void;
    CalculateLayoutInputVertical(): void;
    GraphicUpdateComplete(): void;
    IsActive(): boolean;
    LayoutComplete(): void;
    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnInitializePotentialDrag(eventData: PointerEventData): void;
    OnScroll(data: PointerEventData): void;
    Rebuild(executing: CanvasUpdate): void;
    SetLayoutHorizontal(): void;
    SetLayoutVertical(): void;
    StopMovement(): void;
}
    
interface ScrollRectEvent {


}
    
interface ScrollRectEventConstructor {

    new(): ScrollRectEvent;

}
declare const ScrollRectEvent: ScrollRectEventConstructor;
    
interface NetworkTransform extends NetworkBehaviour {
    TakenOwnership: boolean;


    Awake(): void;
    Awake___UserLogic(): void;
    ForceSend(): void;
    GetSendToOwner(): boolean;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnOwnershipClient(prevOwner: NetworkConnection): void;
    OnOwnershipServer(prevOwner: NetworkConnection): void;
    OnSpawnServer(connection: NetworkConnection): void;
    OnStartClient(): void;
    OnStartNetwork(): void;
    OnStartServer(): void;
    OnStopNetwork(): void;
    SetInterval(value: number): void;
    SetPositionSnapping(axes: SnappedAxes): void;
    SetRotationSnapping(axes: SnappedAxes): void;
    SetScaleSnapping(axes: SnappedAxes): void;
    SetSendToOwner(value: boolean): void;
    SetSynchronizedProperties(value: SynchronizedProperty): void;
    SetSynchronizePosition(value: boolean): void;
    SetSynchronizeRotation(value: boolean): void;
    SetSynchronizeScale(value: boolean): void;
}
    
interface SnappedAxes {
    X: boolean;
    Y: boolean;
    Z: boolean;


}
    
interface NetworkTransformConstructor {
    MAX_INTERPOLATION: number;

    new(): NetworkTransform;

}
declare const NetworkTransform: NetworkTransformConstructor;
    
interface CameraScreenshotRecorder extends MonoBehaviour {
    saveFolder: SaveFolder;
    shouldSaveCaptures: boolean;
    resWidth: number;
    resHeight: number;
    FolderName: string;


    ScreenShotName(width: number, height: number): string;
    ScreenShotName(filename: string): string;
    TakeCameraScreenshot(camera: Camera, fileName: string, superSampleSize: number): void;
    TakeCameraScreenshotCo(camera: Camera, fileName: string, superSampleSize: number): unknown;
    TakeScreenshot(fileName: string, superSampleSize: number): void;
}
    
interface OnPictureTaken {


    BeginInvoke(screenshot: Texture2D, callback: unknown, object: unknown): unknown;
    EndInvoke(result: unknown): void;
    Invoke(screenshot: Texture2D): void;
}
    
interface OnPictureTakenConstructor {

    new(object: unknown, method: unknown): OnPictureTaken;

}
declare const OnPictureTaken: OnPictureTakenConstructor;
    
interface CameraScreenshotRecorderConstructor {
    onPictureTaken: OnPictureTaken;
    GetScreenshotTexture: Texture2D;

    new(): CameraScreenshotRecorder;

}
declare const CameraScreenshotRecorder: CameraScreenshotRecorderConstructor;
    
interface DevConsole {


}
    
interface Command {
    Name: string;
    HelpText: string;
    IsCustomCommand: boolean;


    GetAliases(): CSArray<string>;
    GetFormattedName(): string;
    GetFormattedParameter(parameterIndex: number): string;
    GetParameters(): CSArray<Parameter>;
    ToFormattedString(): string;
    ToString(): string;
}
    
interface Parameter {
    Type: unknown;
    FriendlyTypeName: string;
    Name: string;
    HelpText: string;


    ToFormattedString(): string;
    ToString(): string;
}
    
interface ParameterConstructor {


    Create(name: string, helpText: string): Parameter;
}
declare const Parameter: ParameterConstructor;
    
interface CommandConstructor {


    Create(name: string, aliases: string, helpText: string, callback: unknown): Command;
    Create<T1>(name: string, aliases: string, helpText: string, p1: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3, T4>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, p4: Parameter, callback: unknown, defaultCallback: unknown): Command;
    Create<T1, T2, T3, T4, T5>(name: string, aliases: string, helpText: string, p1: Parameter, p2: Parameter, p3: Parameter, p4: Parameter, p5: Parameter, callback: unknown, defaultCallback: unknown): Command;
}
declare const Command: CommandConstructor;
    
interface DevConsoleConstructor {
    IsEnabled: boolean;
    IsOpen: boolean;
    IsOpenAndFocused: boolean;
    IsKeyBindingsEnabled: boolean;
    ToggleKey?: KeyCode;
    AverageFps: number;
    AverageMs: number;


    AddCommand(command: Command, onlyInDevBuild: boolean): boolean;
    AddParameterType<T>(parseFunc: unknown): boolean;
    ClearActiveConsoleContext(): void;
    ClearConsole(): void;
    CloseConsole(): void;
    DisableConsole(): void;
    DisableToggleKey(): void;
    EnableConsole(): void;
    GetCommand(name: string): Command;
    GetCommand(name: string, command: unknown): boolean;
    InvokeCoroutine(enumerator: unknown): Coroutine;
    InvokeDelayed(action: unknown, delay: number): Coroutine;
    Log(message: unknown, context: LogContext): void;
    Log(message: unknown, colour: Color, context: LogContext): void;
    LogCollection<T>(collection: CSArray<T>, toString: unknown, prefix: string, suffix: string): void;
    LogCommand(): void;
    LogCommand(name: string): void;
    LogError(message: unknown, context: LogContext): void;
    LogException(exception: unknown, context: LogContext): void;
    LogSeperator(message: unknown): void;
    LogSuccess(message: unknown, context: LogContext): void;
    LogVariable(variableName: string, value: unknown, suffix: string): void;
    LogWarning(message: unknown, context: LogContext): void;
    OpenConsole(): void;
    RemoveCommand(name: string): boolean;
    RemoveTrackedStat(name: string): boolean;
    RunCommand(input: string): boolean;
    SetToggleKey(toggleKey: unknown): void;
    SetTrackedStat(name: string, func: unknown, startEnabled: boolean): void;
}
declare const DevConsole: DevConsoleConstructor;
    
interface EasyShake extends MonoBehaviour {
    duration: number;
    movementsPerSecond: number;
    lerpMod: number;
    maxRadius: Vector3;
    minRadius: Vector3;
    positionRadiusMod: number;
    rotationRadiusMod: number;
    minimizeShakeOverTime: boolean;
    infinite: boolean;
    destroyOnEnd: boolean;


}
    
interface EasyShakeConstructor {

    new(): EasyShake;

}
declare const EasyShake: EasyShakeConstructor;
    
interface EasyMotion extends MonoBehaviour {
    runInEditor: boolean;
    transformSpace: Space;
    translate: boolean;
    translationSpeed: Vector3;
    rotate: boolean;
    angularRotationSpeed: Vector3;
    scale: boolean;
    scaleSpeed: Vector3;


}
    
interface EasyMotionConstructor {

    new(): EasyMotion;

}
declare const EasyMotion: EasyMotionConstructor;
    
interface GroundItemDrop extends MonoBehaviour {
    boxCollider: BoxCollider;


    GetVelocity(): Vector3;
    IsGrounded(): boolean;
    SetGrounded(grounded: boolean): void;
    SetPosition(position: Vector3): void;
    SetSpinActive(active: boolean): void;
    SetVelocity(velocity: Vector3): void;
}
    
interface BoxCollider extends Collider {
    center: Vector3;
    size: Vector3;
    extents: Vector3;


}
    
interface BoxColliderConstructor {

    new(): BoxCollider;

}
declare const BoxCollider: BoxColliderConstructor;
    
interface GroundItemDropConstructor {

    new(): GroundItemDrop;

}
declare const GroundItemDrop: GroundItemDropConstructor;
    
interface CloudImage extends MonoBehaviour {
    url: string;
    image: Image;
    downloadOnStart: boolean;


    StartDownload(): void;
}
    
interface CloudImageConstructor {
    cachedTextures: CSDictionary<string, Texture2D>;

    new(): CloudImage;

    OnLoad(): void;
}
declare const CloudImage: CloudImageConstructor;
    
interface LineRenderer extends Renderer {
    numPositions: number;
    startWidth: number;
    endWidth: number;
    widthMultiplier: number;
    numCornerVertices: number;
    numCapVertices: number;
    useWorldSpace: boolean;
    loop: boolean;
    startColor: Color;
    endColor: Color;
    positionCount: number;
    textureScale: Vector2;
    shadowBias: number;
    generateLightingData: boolean;
    textureMode: LineTextureMode;
    alignment: LineAlignment;
    maskInteraction: SpriteMaskInteraction;
    widthCurve: AnimationCurve;
    colorGradient: Gradient;


    BakeMesh(mesh: Mesh, useTransform: boolean): void;
    BakeMesh(mesh: Mesh, camera: Camera, useTransform: boolean): void;
    GetPosition(index: number): Vector3;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    GetPositions(positions: CSArray<Vector3>): number;
    SetColors(start: Color, end: Color): void;
    SetPosition(index: number, position: Vector3): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetPositions(positions: CSArray<Vector3>): void;
    SetVertexCount(count: number): void;
    SetWidth(start: number, end: number): void;
    Simplify(tolerance: number): void;
}
    
interface LineRendererConstructor {

    new(): LineRenderer;

}
declare const LineRenderer: LineRendererConstructor;
    
interface AirshipRedirectDrag extends MonoBehaviour, IBeginDragHandler, IDragHandler, IEndDragHandler, IPointerEnterHandler, IPointerExitHandler {
    isDragging: boolean;
    redirectTarget: ScrollRect;


    OnBeginDrag(eventData: PointerEventData): void;
    OnDrag(eventData: PointerEventData): void;
    OnEndDrag(eventData: PointerEventData): void;
    OnPointerEnter(eventData: PointerEventData): void;
    OnPointerExit(eventData: PointerEventData): void;
}
    
interface AirshipRedirectDragConstructor {

    new(): AirshipRedirectDrag;

}
declare const AirshipRedirectDrag: AirshipRedirectDragConstructor;
    
interface IMeshModifier {


    ModifyMesh(mesh: Mesh): void;
    ModifyMesh(verts: VertexHelper): void;
}
    
interface VertexHelper {
    currentVertCount: number;
    currentIndexCount: number;


    AddTriangle(idx0: number, idx1: number, idx2: number): void;
    AddUIVertexQuad(verts: CSArray<UIVertex>): void;
    AddUIVertexStream(verts: CSArray<UIVertex>, indices: CSArray<number>): void;
    AddUIVertexTriangleStream(verts: CSArray<UIVertex>): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4, uv1: Vector4, uv2: Vector4, uv3: Vector4, normal: Vector3, tangent: Vector4): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4, uv1: Vector4, normal: Vector3, tangent: Vector4): void;
    AddVert(position: Vector3, color: Color32, uv0: Vector4): void;
    AddVert(v: UIVertex): void;
    Clear(): void;
    Dispose(): void;
    FillMesh(mesh: Mesh): void;
    GetUIVertexStream(stream: CSArray<UIVertex>): void;
    PopulateUIVertex(vertex: unknown, i: number): void;
    SetUIVertex(vertex: UIVertex, i: number): void;
}
    
interface VertexHelperConstructor {

    new(): VertexHelper;
    new(m: Mesh): VertexHelper;

}
declare const VertexHelper: VertexHelperConstructor;
    
interface TrueShadow extends UIBehaviour, IMeshModifier, ICanvasElement {
    Size: number;
    Spread: number;
    UseGlobalAngle: boolean;
    OffsetAngle: number;
    OffsetDistance: number;
    Color: Color;
    UseCasterAlpha: boolean;
    IgnoreCasterColor: boolean;
    Inset: boolean;
    BlendMode: BlendMode;
    ColorBleedMode: ColorBleedMode;
    DisableFitCompensation: boolean;
    ClearColor: Color;
    ShadowAsSibling: boolean;
    CustomHash: number;
    Offset: Vector2;
    Cutout: boolean;
    UsingRendererMaterialProvider: boolean;


    ApplySerializedData(): void;
    CopyTo(other: TrueShadow): void;
    CopyTo(other: GameObject): void;
    CopyToTMPSubMeshes(): void;
    GetShadowCastingMaterial(): Material;
    GetShadowRenderingMaterial(): Material;
    GraphicUpdateComplete(): void;
    LayoutComplete(): void;
    ModifyMesh(mesh: Mesh): void;
    ModifyMesh(verts: VertexHelper): void;
    ModifyShadowCastingMaterialProperties(propertyBlock: MaterialPropertyBlock): void;
    ModifyShadowCastingMesh(mesh: Mesh): void;
    ModifyShadowRendererMaterial(baseMaterial: Material): void;
    ModifyShadowRendererMesh(vertexHelper: VertexHelper): void;
    Rebuild(executing: CanvasUpdate): void;
    RefreshPlugins(): void;
    SetHierachyDirty(): void;
    SetLayoutDirty(): void;
    SetTextureDirty(): void;
}
    
interface TrueShadowConstructor {

    new(): TrueShadow;

}
declare const TrueShadow: TrueShadowConstructor;
    
interface ScalableBufferManager {


}
    
interface ScalableBufferManagerConstructor {
    widthScaleFactor: number;
    heightScaleFactor: number;


    ResizeBuffers(widthScale: number, heightScale: number): void;
}
declare const ScalableBufferManager: ScalableBufferManagerConstructor;
    
interface AirshipPlatformUtil {


}
    
interface AirshipPlatformUtilConstructor {
    livePlatforms: CSArray<number>;

    new(): AirshipPlatformUtil;

    FromBuildTarget(buildTarget: BuildTarget): AirshipPlatform;
    FromRuntimePlatform(runtimePlatform: RuntimePlatform): AirshipPlatform;
    GetLocalPlatform(): AirshipPlatform;
    ToBuildTarget(platform: AirshipPlatform): BuildTarget;
}
declare const AirshipPlatformUtil: AirshipPlatformUtilConstructor;
    
interface ColliderRollback extends NetworkBehaviour {


    Awake(): void;
    Awake___UserLogic(): void;
    NetworkInitialize___Early(): void;
    NetworkInitialize__Late(): void;
    NetworkInitializeIfDisabled(): void;
    OnStartServer(): void;
    OnStopServer(): void;
}
    
interface ColliderRollbackConstructor {

    new(): ColliderRollback;

}
declare const ColliderRollback: ColliderRollbackConstructor;

