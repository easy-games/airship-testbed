-- Compiled with unity-ts v2.1.0-62
local TS = require("Shared/include/RuntimeLib")
local Modding = require("./modding").Modding
local Reflect = require("./reflect").Reflect
local ArtificialDependency, Flamework
local Flamework = {}
do
	local _container = Flamework
	local flameworkConfig = {
		isDefault = true,
	}
	_container.flameworkConfig = flameworkConfig
	_container.isInitialized = false
	-- * @hidden
	local function resolveDependency(id)
		return Modding.resolveDependency(ArtificialDependency, id, 0, {})
	end
	_container.resolveDependency = resolveDependency
	-- * @hidden
	local function addPath(path, searchPattern)
		local preloadPaths = {}
		local files = EasyFileService:GetFilesInPath(path, searchPattern)
		do
			local i = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 1
				else
					_shouldIncrement = true
				end
				if not (i < files.Length) then
					break
				end
				local path = files:GetValue(i)
				path = string.split(path, "assets/game/bedwars/bundles/")[2]
				path = string.split(path, ".lua")[1]
				local _path = path
				table.insert(preloadPaths, _path)
			end
		end
		local preload = function(path)
			local start = os.clock()
			local success, value = pcall(require, path)
			local endTime = math.floor((os.clock() - start) * 1000)
			if not success then
				error(path .. (" failed to preload (" .. (tostring(endTime) .. ("ms): " .. tostring(value)))))
			end
		end
		for _, path in preloadPaths do
			preload(path)
		end
	end
	_container.addPath = addPath
	-- * @hidden
	local function _implements(object, id)
		local _exp = Reflect.getMetadatas(object, "flamework:implements")
		local _arg0 = function(impl)
			local _impl = impl
			local _id = id
			return table.find(_impl, _id) ~= nil
		end
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		for _k, _v in _exp do
			if _arg0(_v, _k - 1, _exp) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		return _result
	end
	_container._implements = _implements
	local function isService(ctor)
		return Modding.getDecorator(ctor, nil, "$:flamework@Service") ~= nil
	end
	local function isController(ctor)
		return Modding.getDecorator(ctor, nil, "$:flamework@Controller") ~= nil
	end
	local function isConstructor(obj)
		return obj.new ~= nil and obj.constructor ~= nil
	end
	local function getIdentifier(obj, suffix)
		if suffix == nil then
			suffix = ""
		end
		local _condition = Reflect.getMetadata(obj, "identifier")
		if _condition == nil then
			_condition = "UnidentifiedFlameworkListener" .. suffix
		end
		return _condition
	end
	local externalClasses = {}
	--[[
		*
		* Allow an external module to be bootstrapped by Flamework.ignite()
	]]
	local function registerExternalClass(ctor)
		local _ctor = ctor
		externalClasses[_ctor] = true
	end
	_container.registerExternalClass = registerExternalClass
	local hasFlameworkIgnited = false
	--[[
		*
		* Initialize Flamework.
		*
		* This will start up the lifecycle events on all currently registered
		* classes.
		*
		* You should preload all necessary directories before calling this
		* as newly registered classes will not run their lifecycle events.
		*
		* @returns All the dependencies that have been loaded.
	]]
	local function ignite(patchedConfig)
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		if patchedConfig then
			for key, value in pairs(patchedConfig) do
				flameworkConfig[key] = value
			end
		end
		for ctor in Reflect.objToId do
			if RunCore:IsServer() and not isService(ctor) then
				continue
			end
			if RunCore:IsClient() and not isController(ctor) then
				continue
			end
			if not isConstructor(ctor) then
				continue
			end
			local isPatched = Reflect.getOwnMetadata(ctor, "flamework:isPatched")
			if flameworkConfig.loadOverride and (not (table.find(flameworkConfig.loadOverride, ctor) ~= nil) and not isPatched) then
				continue
			end
			local isExternal = Reflect.getOwnMetadata(ctor, "flamework:isExternal")
			if isExternal and not (externalClasses[ctor] ~= nil) then
				continue
			end
			Modding.resolveSingleton(ctor)
		end
		local dependencies = {}
		local decoratorType = if RunCore:IsServer() then "$:flamework@Service" else "$:flamework@Controller"
		for ctor in Modding.getSingletons() do
			local decorator = Modding.getDecorator(ctor, nil, decoratorType)
			if not decorator then
				continue
			end
			local isExternal = Reflect.getOwnMetadata(ctor, "flamework:isExternal")
			if isExternal and not (externalClasses[ctor] ~= nil) then
				continue
			end
			local dependency = Modding.resolveSingleton(ctor)
			local _arg0 = { dependency, decorator.arguments[1] or {} }
			table.insert(dependencies, _arg0)
		end
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		local _arg0 = function(_param, _param_1)
			local a = _param[2]
			local b = _param_1[2]
			local _condition = a.loadOrder
			if _condition == nil then
				_condition = 1
			end
			local _condition_1 = b.loadOrder
			if _condition_1 == nil then
				_condition_1 = 1
			end
			return _condition < _condition_1
		end
		table.sort(dependencies, _arg0)
		-- Modding.onListenerAdded<OnTick>((object) => tick.set(object, getIdentifier(object, "/OnTick")));
		-- Modding.onListenerAdded<OnPhysics>((object) => physics.set(object, getIdentifier(object, "/OnPhysics")));
		-- Modding.onListenerAdded<OnRender>((object) => render.set(object, getIdentifier(object, "/OnRender")));
		-- Modding.onListenerRemoved<OnTick>((object) => tick.delete(object));
		-- Modding.onListenerRemoved<OnPhysics>((object) => physics.delete(object));
		-- Modding.onListenerRemoved<OnRender>((object) => render.delete(object));
		for _, _binding in dependencies do
			local dependency = _binding[1]
			if Flamework._implements(dependency, "$:flamework@OnInit") then
				local _arg1 = getIdentifier(dependency)
				init[dependency] = _arg1
			end
			if Flamework._implements(dependency, "$:flamework@OnStart") then
				local _arg1 = getIdentifier(dependency)
				start[dependency] = _arg1
			end
		end
		for dependency, identifier in init do
			-- debug.setmemorycategory(identifier);
			local initResult = dependency:OnInit()
			if TS.Promise.is(initResult) then
				local status, value = initResult:awaitStatus()
				if status == TS.Promise.Status.Rejected then
					error("OnInit failed for dependency '" .. (identifier .. ("'. " .. tostring(value))))
				end
			end
			-- debug.resetmemorycategory();
		end
		_container.isInitialized = true
		-- RunCore.Heartbeat.Connect((dt) => {
		-- for (const [dependency, identifier] of tick) {
		-- task.spawn(() => {
		-- // debug.setmemorycategory(identifier);
		-- dependency.onTick(dt);
		-- });
		-- }
		-- });
		-- RunCore.Stepped.Connect((time, dt) => {
		-- for (const [dependency, identifier] of physics) {
		-- task.spawn(() => {
		-- // debug.setmemorycategory(identifier);
		-- dependency.onPhysics(dt, time);
		-- });
		-- }
		-- });
		-- if (RunCore.IsClient()) {
		-- RunCore.RenderStepped.Connect((dt) => {
		-- for (const [dependency, identifier] of render) {
		-- task.spawn(() => {
		-- // debug.setmemorycategory(identifier);
		-- dependency.onRender(dt);
		-- });
		-- }
		-- });
		-- }
		for dependency, indentifier in start do
			coroutine.wrap(function()
				dependency:OnStart()
			end)()
			-- task.spawn(() => {
			-- debug.setmemorycategory(indentifier);
			-- dependency.OnStart();
			-- });
		end
		return dependencies
	end
	_container.ignite = ignite
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	-- export declare function addPaths(...args: string[]): void;
	--[[
		*
		* Retrieve the identifier for the specified type.
	]]
	--[[
		*
		* Check if the constructor implements the specified interface.
	]]
	--[[
		*
		* Check if object implements the specified interface.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Hash a function using the method used internally by Flamework.
		* If a context is provided, then Flamework will create a new hash
		* if the specified string does not have one in that context.
		* @param str The string to hash
		* @param context A scope for the hash
	]]
	--[[
		*
		* Utility for use in test suites, not recommended for anything else.
	]]
	local Testing = {}
	do
		local _container_1 = Testing
		local function patchDependency(patchedClass, id)
			if id == nil then
				error("Patching failed, no ID")
			end
			local _idToObj = Reflect.idToObj
			local _id = id
			local idCtor = _idToObj[_id]
			if idCtor == nil then
				error("Dependency " .. (id .. " was not found and cannot be patched."))
			end
			if Modding.getSingletons()[idCtor] ~= nil then
				error(id .. " has already been resolved, continuing is unsafe")
			end
			local objMetadata = Reflect.metadata[idCtor]
			if not objMetadata then
				error("Dependency " .. (id .. " has no existing metadata."))
			end
			Reflect.defineMetadata(idCtor, "flamework:isPatched", true)
			Reflect.metadata[idCtor] = nil
			local _metadata = Reflect.metadata
			local _patchedClass = patchedClass
			_metadata[_patchedClass] = objMetadata
			local _objToId = Reflect.objToId
			local _patchedClass_1 = patchedClass
			local _id_1 = id
			_objToId[_patchedClass_1] = _id_1
			local _idToObj_1 = Reflect.idToObj
			local _id_2 = id
			local _patchedClass_2 = patchedClass
			_idToObj_1[_id_2] = _patchedClass_2
		end
		_container_1.patchDependency = patchDependency
	end
	_container.Testing = Testing
end
--[[
	*
	* An internal class used for resolving the Dependency<T> macro.
]]
do
	ArtificialDependency = setmetatable({}, {
		__tostring = function()
			return "ArtificialDependency"
		end,
	})
	ArtificialDependency.__index = ArtificialDependency
	function ArtificialDependency.new(...)
		local self = setmetatable({}, ArtificialDependency)
		return self:constructor(...) or self
	end
	function ArtificialDependency:constructor()
	end
end
Reflect.defineMetadata(ArtificialDependency, "identifier", "$:flamework@ArtificialDependency")
Reflect.defineMetadata(ArtificialDependency, "flamework:isArtificial", true)
--[[
	*
	* Register a class as a Service.
	*
	* @server
	* @metadata flamework:implements flamework:parameters
]]
local Service = Modding.createMetaDecorator("Class")
--[[
	*
	* Register a class as a Controller.
	*
	* @client
	* @metadata flamework:implements flamework:parameters
]]
local Controller = Modding.createMetaDecorator("Class")
--[[
	*
	* Marks this class as an external class.
	*
	* External classes are designed for packages and won't be
	* bootstrapped unless explicitly specified. Excluding this
	* inside of a package will make the class load as long as
	* it has been loaded.
]]
local External = Modding.createDecorator("Class", function(descriptor)
	Reflect.defineMetadata(descriptor.object, "flamework:isExternal", true)
end)
--[[
	*
	* Hook into the OnInit lifecycle event.
]]
--[[
	*
	* Hook into the OnStart lifecycle event.
]]
--[[
	*
	* Hook into the OnTick lifecycle event.
	* Equivalent to: RunCore.Heartbeat
]]
--[[
	*
	* Hook into the OnPhysics lifecycle event.
	* Equivalent to: RunCore.Stepped
]]
--[[
	*
	* Hook into the OnRender lifecycle event.
	* Equivalent to: RunCore.RenderStepped
	*
	* @client
]]
return {
	Flamework = Flamework,
	Service = Service,
	Controller = Controller,
	External = External,
}
-- ----------------------------------
-- ----------------------------------
